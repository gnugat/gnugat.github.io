<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2025-10-23T07:37:26+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[SpecGen v0.3]]></title>
            <link href="/2015/05/28/spec-gen-0-3.html"/>
            <updated>2015-05-28T00:00:00+01:00</updated>
            <id>/2015/05/28/spec-gen-0-3.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> v0.3 inserts a property for each constructor argument.</p>
</blockquote>

<p>SpecGen is a <a href="http://phpspec.net">phpspec</a> extension which enhance its code generator.
With the latest release, v0.3, we get the following features:</p>

<ul>
<li>method generation:

<ul>
<li>it inserts method at the end of the class</li>
<li>it typehints object, array and callable arguments</li>
<li>it names object arguments after their type</li>
<li>it names scalar arguments after a generic name (<code>argument</code>)</li>
<li>it adds number on names that could collide (e.g. <code>$argument1, $argument2</code>)</li>
</ul></li>
<li>constructor generation, same as method except:

<ul>
<li>it inserts constructor at the begining of the class</li>
<li>it inserts properties with initialization for each constructor arguments</li>
</ul></li>
</ul>

<p>Here's a simple example to demonstrate how helpful it can be.</p>

<h2 id="example">Example</h2>

<p>First of all, we need to set up a project with <a href="https://getcomposer.org/download">Composer</a>.
Let's write the following <code>composer.json</code>:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>Then we can install phpspec with SpecGen by running those commands:</p>

<pre><code>composer require --dev phpspec/phpspec:~2.2
composer require --dev memio/spec-gen:~0.3
echo 'extensions:' &gt; phpspec.yml
echo '  - Memio\SpecGen\MemioSpecGenExtension' &gt;&gt; phpspec.yml
</code></pre>

<p>In our example, we'll specify a <code>TextEditor</code> service, it should be able to
create new files by relying on <code>Filesystem</code>, another service.</p>

<p>This can be done as follow:</p>

<pre><code>phpspec describe 'Vendor\Project\TextEditor'
````

&gt; **Tip**: make your vendor's binaries available by adding `vendor/bin` to your `$PATH`.
&gt; `export PATH="vendor/bin:$PATH"`.

This should generate a `spec\Vendor\Project\TextEditorSpec.php` file:

```php
&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class TextEditorSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\TextEditor');
    }
}
</code></pre>

<p>It needs to be edited to fit our needs:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_creates_new_files(File $file, Filesystem $filesystem)
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>The Test Driven Development cycle advises us to run the test suite now:</p>

<pre><code>phpspec run
</code></pre>

<p>This will bootstrap the following code:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open($argument1, $argument2)
    {
    }
}
</code></pre>

<p>It created a <code>filesystem</code> property to mirror the constructor arguments. Neat!</p>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>In our example phpspec also generated the collaborators (<code>File</code> and <code>Filesystem</code>).
These don't beneficiate from SpecGen help yet, so the next release (v0.4) will
probably be about using it for collaborators.</p>

<p>Other features that could be implemented would be PHPdoc generation, or avoiding the
<code>Interface</code> / <code>Abstract</code> suffix/prefix in interface and abstract object argument names.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[SpecGen v0.2]]></title>
            <link href="/2015/05/20/spec-gen-0-2.html"/>
            <updated>2015-05-20T00:00:00+01:00</updated>
            <id>/2015/05/20/spec-gen-0-2.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> v0.2 inserts use statements.</p>
</blockquote>

<p>SpecGen v0.2 has been released, it introduces a small change: use statement insertion.</p>

<h2 id="it-inserts-use-statements">It inserts use statements</h2>

<p>Let's go back to the sources of the example used in the <a href="/2015/05/13/memio-spec-gen.html">previous article</a>
and clean it a little bit:</p>

<pre><code>rm -rf src
</code></pre>

<p>Given the following specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Message\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Message\Response');
    }
}
</code></pre>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following file, with a use statement:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Message\Request;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="it-doesn%27t-insert-use-statements-twice">It doesn't insert use statements twice</h2>

<p>Given the following new step in our specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Message\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Message\Response');
    }

    function it_supports_request(Request $request)
    {
        $this-&gt;supports($request)-&gt;shouldBe(true);
    }
}
</code></pre>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following file, without new use statements:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Message\Request;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }

    public function supports(Request $request)
    {
    }
}
</code></pre>

<h2 id="it-doesn%27t-insert-use-statement-for-same-namespace">It doesn't insert use statement for same namespace</h2>

<p>Let's clear everything:</p>

<pre><code>rm -rf src
</code></pre>

<p>Given the following specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <code>Request</code> and <code>RequestHandler</code> are both in the same namespace.</p>
</blockquote>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following, without any use statements:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="behind-the-hood">Behind the hood</h2>

<p>This small feature was the occasion to refactor SpecGen a bit! This resulted in the
introduction of <code>CodeEditor</code>, a facade for a home made <code>CommandBus</code> and for
<a href="http://gnugat.github.io/redaktilo">Redaktilo</a>'s <code>Editor</code>.</p>

<p>With these, the code to generate a method and insert a use statement looks like this:</p>

<pre><code class="php">$file = $this-&gt;codeEditor-&gt;open($fileName);
$this-&gt;codeEditor-&gt;handle(new InsertUseStatements($file, $fullyQualifiedNames));
$this-&gt;codeEditor-&gt;handle(new InsertMethod($file, $method));
$this-&gt;codeEditor-&gt;save($file);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>While some improvements can still be done (use statements in alphabetical order,
typehint interfaces only), the version 0.3 will mainly be about the introduction
of a new generator: insertion of properties when the method is a constructor.</p>

<p>Stay tuned!</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio SpecGen v0.1]]></title>
            <link href="/2015/05/13/memio-spec-gen.html"/>
            <updated>2015-05-13T00:00:00+01:00</updated>
            <id>/2015/05/13/memio-spec-gen.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> is a <a href="http://phpspec.net">phpspec</a>
  extension that improves its code generator. Currently available: type hinted method arguments.</p>
</blockquote>

<p>With <a href="http://memio.github.io/memio">Memio v1.0 released</a>, it is now possible to
create powerful code generators without re-inventing the wheel.
<a href="http://github.com/memio/spec-gen">SpecGen</a> is the first project to use this library, let's
see what it can do for us.</p>

<h2 id="phpspec">phpspec</h2>

<p>First of all we'll talk about <a href="http://phpspec.net">phpspec</a>, which is an exciting
project that provides many benefits:</p>

<ul>
<li>a testing tool (allows to write specifications, which are kind of unit tests)</li>
<li>a "best practice" enforcer (for e.g. cannot test private methods to force us to split code into smaller public APIs)</li>
<li>a time saver (bootstraps tests and code)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: See <a href="http://techportal.inviqa.com/2014/09/11/my-top-ten-favourite-phpspec-limitations/">My top 10 favourite phpsepc limitations</a>.</p>
</blockquote>

<p>It makes Test Driven Development cycles even more meaningful:</p>

<ol>
<li>bootstrap test by thinking on a class name</li>
<li>write a test by thinking how the class should behave</li>
<li>bootstrap the corresponding code by running the whole test suite</li>
<li>write code as quick as possible without thinking about best practices or design patterns (be pragmatic)</li>
<li>run the test suite to check if the code fulfills the test's specifications</li>
<li>refactor the code (manage the technical debt)</li>
<li>run the test suite to check for regressions</li>
<li>repeat!</li>
</ol>

<p>phpspec's code generator is a big part of its value. Let's see if we can improve it.</p>

<h2 id="phpspec-example">phpspec example</h2>

<p>Let's have a look at how phpspec works. For this we'll need to have a project configured with
<a href="https://getcomposer.org/download">Composer</a>:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>We can install phpspec with the following:</p>

<pre><code>composer require --dev phpspec/phpspec:~2.2
</code></pre>

<p>Let's say we want to create a class that handles requests, conforming to the HTTP protocol
(take a <code>Request</code>, return a <code>Response</code>). We can call this class <code>RequestHandler</code>:</p>

<pre><code>phpspec describe 'Vendor\Project\RequestHandler'
</code></pre>

<blockquote>
  <p><strong>Tip</strong>: make your vendor's binaries available by adding <code>vendor/bin</code> to your <code>$PATH</code>.
  <code>export PATH="vendor/bin:$PATH"</code>.</p>
</blockquote>

<p>We should now have the <code>spec/Vendor/Project/RequestHandlerSpec.php</code> file, bootstraped
for us by phpspec:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\RequestHandler');
    }
}
</code></pre>

<p>We can directly start by writing our first specification (test method) in it:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response(Request $request)
    {
        $this-&gt;handle($request)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We tried to make the test method as descriptive as possible (e.g. not <code>testHandler()</code>).
  This is the whole point of specBDD (specification Behavior Driven Development).</p>
</blockquote>

<p>With this we can start to boostrap the code by simply running the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>It will ask the following 3 questions:</p>

<ol>
<li>Would you like me to generate an interface <code>Vendor\Project\Request</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\RequestHandler</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\RequestHandler::handle()</code> for you?</li>
</ol>

<p>By accepting everytime, phpspec will bootstrap the following
<code>src/Vendor/Project/Vendor/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{

    public function handle($argument1)
    {
        // TODO: write logic here
    }
}
</code></pre>

<p>In our specification, we make use of a non existing <code>Request</code> class, and phpspec
also bootstraped it for us in <code>src/Vendor/Project/Vendor/Request.php</code>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

interface Request
{
}
</code></pre>

<p>This is extremely usefull to kickstart our TDD cycle!</p>

<h2 id="memio-specgen">Memio SpecGen</h2>

<p>SpecGen is a phpspec extension, it makes use of Memio (the PHP code generator library)
to make the above bootstraping even more awesome.</p>

<p>Here's how to install it:</p>

<pre><code>composer require --dev memio/spec-gen:~0.1
</code></pre>

<p>We also need to register it as a phpspec extension by writing the following <code>phpspec.yml</code> file:</p>

<pre><code>extensions:
  - Memio\SpecGen\MemioSpecGenExtension
</code></pre>

<p>Its first release, v0.1 (unstable for now), improves the method generation with:</p>

<ul>
<li>type hinted arguments</li>
<li>object arguments named after their type</li>
<li>putting each arguments on their own lines if the inline alternative would have been longer than 120 characters</li>
</ul>

<p>To be fair, this is exactly what already <a href="https://ciaranmcnulty.com/">Ciaran McNulty</a>'s
<a href="https://github.com/ciaranmcnulty/phpspec-typehintedmethods">Typehinted Methods extension</a>
provides, so why would we choose SpecGen? Well simply because it intends to do much more:</p>

<ul>
<li>insertion of <code>use</code> statements</li>
<li>constructor generation (each argument will have a corresponding property and a property initialization)</li>
<li>PHPdoc</li>
<li>???</li>
<li>profit!</li>
</ul>

<h2 id="memio-specgen-example">Memio SpecGen example</h2>

<p>Let's give it a try by first removing the code we boostrapped until now:</p>

<pre><code>rm -rf src
</code></pre>

<p>In order to demonstrate more type hints, we'll add more arguments:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<p>We can now run the test suite to bootstrap the code:</p>

<pre><code>phpspec run
</code></pre>

<p>This should create the following <code>src/Vendor/Project/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: for now <code>use</code> statements aren't generated. In our example it doesn't
  matter since <code>Request</code> is in the same namespace as <code>RequestHandler</code>.</p>
</blockquote>

<p>Let's remove again the generated code:</p>

<pre><code>rm -rf src
</code></pre>

<p>Now we'd like to see this multiline feature by adding many arguments to our specifiction:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response()
    {
        $this-&gt;myMethod(1, 2, 3, 4, 5, 6, 7, 8);
    }
}
</code></pre>

<p>Again, we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>This should bootstrap the following <code>src/Vendor/Project/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function myMethod(
        $argument1,
        $argument2,
        $argument3,
        $argument4,
        $argument5,
        $argument6,
        $argument7,
        $argument8
    )
    {
    }
}
</code></pre>

<p>And that's it!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio SpecGen improves phpspec's generator by adding better named, type hinted
and PSR-2 compliant method arguments.</p>

<p>Note that this kind of improvement has to be done in extension. They cannot be
done directly in phpspec because it tries to enforce best practices, and one of
them is to type hint only against interfaces. As it happens, the current extensions
can also type hint against implementations, depending on how the developers write
their specifications.</p>

<p>The next versions will bring even more exciting features, such as constructor and PHPdoc
generation.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio v1.0]]></title>
            <link href="/2015/05/06/memio.html"/>
            <updated>2015-05-06T00:00:00+01:00</updated>
            <id>/2015/05/06/memio.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://memio.github.io/memio">Memio</a> is a PHP code generator library,
  the main repository provides integration with Twig templates, but by using the
  smaller package <code>pretty-printer</code> on its own it is possible to be decoupled from any template engines.</p>
</blockquote>

<p><a href="http://memio.github.io/memio">Memio</a> has finally be released in version 1.0 (stable).
In this article, we'll see how the different packages are assembled in the main repository.</p>

<h2 id="standard-edition">Standard Edition</h2>

<p>Memio is composed of small packages (<code>linter</code>, <code>model</code>, <code>pretty-printer</code>, <code>twig-template-engine</code>, <code>validator</code>),
the main repository (<a href="http://gituhb.com/memio/memio">memio/memio</a>) is a standard selection of those
to make their usage easier:</p>

<p><img src="http://yuml.me/8686d889" alt="Package diagram" /></p>

<p>It can be installed using <a href="http://getcomposer.com/">Composer</a>:</p>

<pre><code>composer require memio/memio:~1.0
</code></pre>

<p>It provides two services, which can be instanciated as follow:</p>

<pre><code class="php">&lt;?php
// File: memio.php

require __DIR__.'/vendor/autoload.php';

use Memio\Memio\Config\Build;

$linter = Build::linter();
$prettyPrinter = Build::prettyPrinter();
</code></pre>

<p>To see how to use them, let's describe a request handler method:</p>

<pre><code class="php">// ...

use Memio\Model\Method;
use Memio\Model\Argument;

$handle = Method::make('handle')
    -&gt;addArgument(Argument::make('Request', 'request'))
    -&gt;addArgument(Argument::make('int', 'type')
        -&gt;setDefaultValue('self::MASTER_REQUEST')
    )
    -&gt;addArgument(Argument::make('bool', 'catch')
        -&gt;setDefaultValue('true')
    )
;
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Each Model can be constructed using <code>new</code> or the static constructor <code>make</code>.
  The last one has the advantage to allow method chaining (e.g. <code>Method::make('doHandle')-&gt;makePrivate()</code>).</p>
</blockquote>

<p>We can lint this model:</p>

<pre><code class="php">// ...

$linter-&gt;validate($handler); // @throws Memio\Validator\Exception\InvalidModelException if the model contains syntax errors.
</code></pre>

<p>And we can generate the corresponding PHP code:</p>

<pre><code class="php">// ...

$generatedCode = $prettyPrinter-&gt;generateCode($handle);
</code></pre>

<p>We can check in our console's output the result:</p>

<pre><code class="php">// ...

echo $generatedCode;
</code></pre>

<p>This should print:</p>

<pre><code class="php">    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
    {
    }
</code></pre>

<h2 id="limitations">Limitations</h2>

<p>Currently it is possible to describe:</p>

<ul>
<li>a File (License header, use statements)</li>
<li>a Class (abstract, final, with parents, PHPdoc) or an Interface (with parents, PHPdoc)</li>
<li>a class Constant</li>
<li>a class Property (static, default value, PHPdoc)</li>
<li>a class Method (static, abstract, final, visibility, PHPdoc)</li>
<li>a method Argument (typehint, default value)</li>
</ul>

<p>It is possible to describe a method Body, but only with a string:</p>

<pre><code class="php">// ...

$handle-&gt;setBody(&lt;&lt;&lt;BODY
        try {
            $this-&gt;requestHandler-&gt;handle($request);
        } catch (\Exception $e) {
            if (!$catch) {
                throw $e;
            }
        }
BODY
);
</code></pre>

<h2 id="use-cases">Use cases</h2>

<p>In real life, models wouldn't be built manually as in the above examples. They would
be built dynamically:</p>

<pre><code class="php">// ...

array_shift($argv); // remove binary name (php)
array_shift($argv); // remove script name (memio.php)
$methodName = array_shift($argv); // first argument = method name
$arguments = $argv; // all other arguments = argument types (e.g. `int`, `bool`, `DateTime`, etc)

$method = new Method($methodName);
$index = 1;
foreach ($arguments as $argumentType) {
    $argumentName = 'argument'.$index++;
    $method-&gt;addArgument(new Argument($argumentType, $argumentName));
}

echo $prettyPrinter-&gt;generatedCode($method);
</code></pre>

<p>Have a try by running <code>php memio.php handle Request int bool</code>, it should print the following:</p>

<pre><code class="php">    public function handle(Request $argument1, $argument2, $argument3)
    {
    }
</code></pre>

<p>With this we can already improve <a href="http://phpspec.net">phpspec</a> generator (generate typehinted arguments, PHPdoc, etc).
This is going to be the next Memio package, a phpspec extension.</p>

<h2 id="extension-points">Extension points</h2>

<p>The coding style can be changed by creating our custom templates. Those can be loaded as follow:</p>

<pre><code class="php">// ...

$prettyPrinter-&gt;addTemplatePath(__DIR__.'/our-custom-templates-dir');
</code></pre>

<p>Custom constraints can be written to check more things, for example we can ensure
that arguments are always object.</p>

<p>Those steps, just like the rest, are heavily described in the official <a href="http://memio.github.io/memio">documentation</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio is a library that provides a PHP Code Generator:</p>

<ol>
<li>First we describe what we want by building <code>Models</code> (e.g. <code>new Method('__construct')</code>)</li>
<li>Optionally we can <code>Lint</code> them to check if we introduced syntax errors (e.g. <code>Method cannot be both abstract and final</code>)</li>
<li>Then we use a <code>PrettyPrinter</code> to get the generated code (returns a string, can be displayed on the output or saved in a file, etc)</li>
</ol>

<p>You can read more about it with the following articles:</p>

<ul>
<li><a href="/2015/04/08/introducing-memio-code-generator.html">Introducing Memio</a></li>
<li><a href="/2015/04/15/memio-models.html">Memio Models</a></li>
<li><a href="/2015/04/22/memio-validator-linter.html">Memio Validator and Linter</a></li>
<li><a href="/2015/04/29/memio-pretty-printer.html">Memio PrettyPrinter and TwigTemplateEngine</a></li>
</ul>

<p>It also has an <a href="http://memio.github.io/memio">official documentation</a>.</p>

<p>The next step is to create a <a href="http://phpspec.net">phpspec</a> extension to improve its
code generator.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio Pretty Printer]]></title>
            <link href="/2015/04/29/memio-pretty-printer.html"/>
            <updated>2015-04-29T00:00:00+01:00</updated>
            <id>/2015/04/29/memio-pretty-printer.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/pretty-printer">PrettyPrinter</a> converts a
  <a href="http://github.com/memio/model">Model</a> into its PHP code (returns a string),
  using <a href="http://twig.sensiolabs.org/">Twig templates</a>.</p>
</blockquote>

<p>Until now we've seen how to build Memio <a href="http://github.com/memio/model">Models</a>
to describe PHP code and how to <a href="http://github.com/memio/validator">validate</a>
the <a href="http://github.com/memio/linter">syntax</a>.</p>

<p>It's now time to take things seriously with the newly released package:
<a href="http://github.com/memio/pretty-printer">PrettyPrinter</a>, the actual code generator.</p>

<h2 id="what-is-a-pretty-printer%3F">What is a pretty printer?</h2>

<p>As opposed to "fidelity printers" which are supposed to generate code according to
the developer's coding style, "pretty printer" rely on their own.</p>

<p>If we were to open an existing PHP file with Memio and then to generate it again immediately,
chances are that the code would look slightly different.</p>

<blockquote>
  <p><strong>Note</strong>: Memio actually complies to <a href="http://www.php-fig.org/psr/">PHP standards</a>,
  with some extra rules.</p>
</blockquote>

<p>The name "printer" is a bit misleading: one could think that the service would
print the generated code in the console's output or a web page, but all it really
does is to return a simple string.</p>

<blockquote>
  <p><strong>Note</strong>: The terminology used is inspired by this <a href="http://stackoverflow.com/a/5834775/3437428">StackOverflow answer</a>.</p>
</blockquote>

<h2 id="template-engine-agnostic">Template engine agnostic</h2>

<p>Memio makes use of templates, making it easy to change the style. It defines a
<code>TemplateEngine</code> interface that has to be implemented, in order to comply with
<a href="http://webmozarts.com/">webmozart</a>'s <a href="https://github.com/memio/memio/issues/51">request</a>.</p>

<p>For now the only package available is <a href="http://github.com/memio/twig-template-engine">TwigTemplateEngine</a>,
it provides <a href="http://twig.sensiolabs.org/">Twig templates</a>.</p>

<h2 id="code-generation-example">Code generation example</h2>

<p>Enough talk, let's code! First of all we have to create our <code>PrettyPrinter</code>:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

$loader = new \Twig_Loader_Filesystem(\Memio\TwigTemplateEngine\Config\Locate::templates());
$twig = new \Twig_Environment($loader);

$line = new \Memio\TwigTemplateEngine\TwigExtension\Line\Line();
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\ContractLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\FileLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\MethodPhpdocLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\ObjectLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\StructurePhpdocLineStrategy());

$twig-&gt;addExtension(new \Memio\TwigTemplateEngine\TwigExtension\Type());
$twig-&gt;addExtension(new \Memio\TwigTemplateEngine\TwigExtension\Whitespace($line));

$templateEngine = new \Memio\TwigTemplateEngine\TwigTemplateEngine($twig);
$prettyPrinter = new \Memio\PrettyPrinter\PrettyPrinter($templateEngine);
</code></pre>

<p>Wow! That was quite painful to write! Thankfully the next package to be released
will make life really easier (spoiler alert: <code>Build::prettyPrinter()</code>).</p>

<p>Now let's build some models:</p>

<pre><code class="php">// ...

$myMethod = new \Memio\Model\Method('myMethod');
for ($i = 1; $i &lt; 10; $i++) {
    $myMethod-&gt;addArgument(new \Memio\Model\Argument('mixed', 'argument'.$i));
}
</code></pre>

<p>All it takes to generate the code is this:</p>

<pre><code class="php">// ...

$generatedCode = $prettyPrinter-&gt;generateCode($myMethod);
</code></pre>

<p>Let's see in the console output what it did:</p>

<pre><code class="php">// ...

echo $generatedCode;
</code></pre>

<p>We should get the following:</p>

<pre><code class="php">    public function myMethod(
        $argument1,
        $argument2,
        $argument3,
        $argument4,
        $argument5,
        $argument6,
        $argument7,
        $argument8,
        $argument9
    )
    {
    }
</code></pre>

<p>Each arguments are displayed on their own line, because the inline equivalent
would have been longer than 120 characters.</p>

<h2 id="custom-templates">Custom templates</h2>

<p>Memio has extra rules regarding coding standards, for example it adds an empty
line between the PHP opening tag and the namespace statement.</p>

<p>We can get rid of this by creating our own custom template: first we copy the <code>file.twig</code>
template in our project:</p>

<pre><code>
{#- File: my_templates/file.twig -#}
&lt;?php
{% if file.licensePhpdoc is not empty %}

{% include 'phpdoc/license_phpdoc.twig' with { 'license_phpdoc': file.licensePhpdoc } only %}
{% endif %}
namespace {{ file.namespace }};

{% include 'collection/fully_qualified_name_collection.twig' with {
    'fully_qualified_name_collection': file.allFullyQualifiedNames
} only %}
{% if needs_line_after(file, 'fully_qualified_names') %}

{% endif %}
{% if file.structure is contract %}
{% include 'contract.twig' with { 'contract': file.structure } only %}
{% else %}
{% include 'object.twig' with { 'object': file.structure } only %}
{% endif %}

</code></pre>

<p>We've removed the line between <code>{% endif %}</code> and <code>namespace {{ file.namespace }};</code>.</p>

<p>In order for our custom template to be used, we'll need to add its directory path to <code>PrettyPrinter</code>:</p>

<pre><code class="php">// ...

$prettyPrinter-&gt;addTemplatePath(__DIR__.'/my_templates');
</code></pre>

<p>And we're done!</p>

<p>Let's check the result:</p>

<pre><code class="php">// ...

$file = \Memio\Model\File::make('src/Vendor/Project/MyClass.php')
    -&gt;setStructure(new \Memio\Model\Object('Vendor\Project\MyClass'))
;

echo $prettyPrinter-&gt;generateCode($file);
</code></pre>

<p>This will output:</p>

<pre><code class="php">&lt;?php
namespace Vendor\Project;

class MyClass
{
}
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>PrettyPrinter can convert Models into PHP code, it uses templates behind the scene
so we can tweak the coding style our way. It isn't tied to any Template Engine,
but we can install Memio's TwigTemplateEngine package .</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio validator and linter]]></title>
            <link href="/2015/04/22/memio-validator-linter.html"/>
            <updated>2015-04-22T00:00:00+01:00</updated>
            <id>/2015/04/22/memio-validator-linter.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Write <a href="http://github.com/memio/validator">constraints</a> to check
  <a href="http://github.com/memio/model">models</a> integrity.
  <a href="http://github.com/memio/linter">Linter</a> constraints (e.g. syntax error) are already available.</p>
</blockquote>

<p>Everyday Memio, the higly opinionated PHP code generation library, progresses
toward its stable release.</p>

<p>In this article, we'll have a look at two packages that have been freshly extracted:
<code>memio/validator</code> and <code>memio/linter</code>.</p>

<h2 id="writing-constraints">Writing constraints</h2>

<p>The <a href="http://github.com/memio/validator">validator</a> packages provides an easy way
to write constraints. Let's write one to check that method arguments are never scalar.</p>

<blockquote>
  <p><strong>Note</strong>: This is one of the principle in <a href="http://williamdurand.fr/2013/06/03/object-calisthenics">object calisthenics</a>:
  <a href="http://williamdurand.fr/2013/06/03/object-calisthenics/#3-wrap-all-primitives-and-strings">wrap all primitives and string</a>.</p>
</blockquote>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Memio\Validator\Constraint;
use Memio\Validator\Violation\NoneViolation;
use Memio\Validator\Violation\SomeViolation;

class ArgumentCannotBeScalar implements Constraint
{
    public function validate($model)
    {
        $type = $model-&gt;getType();
        if (in_array($type, array('array', 'bool', 'callable', 'double', 'int', 'mixed', 'null', 'resource', 'string'), true)) {
            return new SomeViolation(sprintf('Argument "%s" cannot be scalar', $model-&gt;getName()));
        }

        return new NoneViolation();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Naming constraints after their error message allow for better reability.</p>
</blockquote>

<p>The next step is to register our constraint in a validator. Since our constraint
aims <code>Argument</code> models, we'll register it in an <code>ArgumentValidator</code>:</p>

<pre><code class="php">// ...

use Memio\Validator\ModelValidator\ArgumentValidator;

$argumentValidator = new ArgumentValidator();
$argumentValidator-&gt;add(new ArgumentCannotBeScalar());
</code></pre>

<p>When building models, <code>Arguments</code> are burried in <code>Methods</code>, which themselves are burried in
<code>Contracts</code> or <code>Objects</code> which in turn are burried in <code>File</code>.</p>

<p>To make things easy, we'd like to simply give the top most model (e.g. <code>File</code>) to
a generic <code>Validator</code>. Its responsibility would be to go through each models and execute
the appropriate <code>ModelValidator</code>.</p>

<p>In order to do so, we have to create all <code>ModelValidators</code> and assemble them as follow:</p>

<pre><code class="php">// ...

use Memio\Validator\ModelValidator\CollectionValidator;
use Memio\Validator\ModelValidator\ContractValidator;
use Memio\Validator\ModelValidator\FileValidator;
use Memio\Validator\ModelValidator\MethodValidator;
use Memio\Validator\ModelValidator\ObjectValidator;

$collectionValidator = new CollectionValidator();
$methodValidator = new MethodValidator($argumentValidator, $collectionValidator);
$contractValidator = new ContractValidator($collectionValidator, $methodValidator);
$objectValidator = new ObjectValidator($collectionValidator, $methodValidator);
$fileValidator = new FileValidator($contractValidator, $objectValidator);
</code></pre>

<p>Finally, we need to create a validator and register our <code>ModelValidators</code> in it:</p>

<pre><code class="php">// ...

use Memio\Validator\Validator;

$calisthenicValidator = new Validator();
$calisthenicValidator-&gt;add($argumentValidator);
$calisthenicValidator-&gt;add($collectionValidator);
$calisthenicValidator-&gt;add($methodValidator);
$calisthenicValidator-&gt;add($contractValidator);
$calisthenicValidator-&gt;add($objectValidator);
$calisthenicValidator-&gt;add($fileValidator);
</code></pre>

<p>We can now validate our Models:</p>

<pre><code class="php">// ...

$calisthenicValidator-&gt;validate($file); // @throws Memio\Validator\InvalidModelException if one or more constraint fail
</code></pre>

<p>The <code>InvalidModelException</code>'s message has one line per violation.</p>

<h2 id="linter">Linter</h2>

<p>Out of the box, Memio provides a <a href="http://github.com/memio/linter">Linter</a> which
provides the following constraints:</p>

<ul>
<li>Collection cannot have name duplicates</li>
<li>Concrete Object Methods cannot be abstract</li>
<li>Contract Methods can only be public</li>
<li>Contract Methods cannot be final</li>
<li>Contract Methods cannot be static</li>
<li>Contract Methods cannot have a body</li>
<li>Method cannot be abstract and have a body</li>
<li>Method cannot be both abstract and final</li>
<li>Method cannot be both abstract and private</li>
<li>Method cannot be both abstract and static</li>
<li>Object Argument can only default to null</li>
</ul>

<p>As we've seen above, constructing and assembling constraints and validators can be quite
tiresome.</p>

<p>That's where <code>memio/memio</code>, the main central repository, starts to be useful by
providing a simple way to get a ready to use linter:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Memio\Memio\Config\Build;

$linter = Build::linter();

$linter-&gt;validate($file); // @throws Memio\Validator\InvalidModelException if one or more constraint fail
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Validator allows the creation of custom constraint to ensure that the build Models
are valid. Linter is a set of constraints ready to use, allowing to prevent syntax errors
(e.g. a method cannot be both final and abstract).</p>

<p>If you'd like to find out more about Memio Validator, have a look at the documentation:</p>

<ul>
<li><a href="http://memio.github.io/memio/doc/03-validation-tutorial.html">Validator Tutorial</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio models]]></title>
            <link href="/2015/04/15/memio-models.html"/>
            <updated>2015-04-15T00:00:00+01:00</updated>
            <id>/2015/04/15/memio-models.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Describe code by building <a href="http://github.com/memio/model">models</a>.</p>
</blockquote>

<p>Memio is a highly opinionated PHP code generation library, its version 1.0.0 (stable)
is going to be released soon: currently the main package <code>memio/memio</code> is being
split into smaller packages.</p>

<p>In this article, we'll have a look at the very first package to be ready: <code>memio/model</code>.</p>

<h2 id="describing-code">Describing code</h2>

<p>Let's have a look at the following method:</p>

<pre><code class="php">    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
    {
    }
</code></pre>

<p>We have many things here:</p>

<ul>
<li>a method named <code>handle</code> which is:

<ul>
<li>public</li>
<li>non static</li>
<li>non final</li>
<li>non abstract</li>
</ul></li>
</ul>

<p>It has the following arguments:</p>

<ul>
<li>a <code>Request</code> object named <code>request</code></li>
<li>an integer named <code>type</code> which defaults to <code>self::MASTER_REQUEST</code></li>
<li>a boolean named <code>catch</code> which defaults to <code>true</code></li>
</ul>

<p>Memio provides models that allow us to describe this method by constructing objects:</p>

<pre><code class="php">&lt;?php

use Memio\Model\Argument;
use Memio\Model\Method;

require __DIR__.'/vendor/autoload.php';

$method = Method::make('handle')
    -&gt;addArgument(Argument::make('Request', 'request'))
    -&gt;addArgument(Argument::make('int', 'type')
        -&gt;setDefaultValue('self::MASTER_REQUEST')
    )
    -&gt;addArgument(Argument::make('bool', 'catch')
        -&gt;setDefaultValue('true')
    )
;
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Static constructors are used to allow fluent interface (chaining calls).
  From PHP 5.6 it is possible to do the following:
  <code>(new Method('handle'))-&gt;addArgument(new Argument('Request', 'request'));</code></p>
</blockquote>

<h2 id="building-models-dynamically">Building models dynamically</h2>

<p>Usually models aren't built manually, they could be constructed using:</p>

<ul>
<li>a configuration (a PHP array, a YAML file, etc)</li>
<li>parameters (from CLI input, a web request, etc)</li>
<li>existing code (using <a href="http://nikic.github.io/aboutMe.html">nikic</a>'s <a href="https://github.com/nikic/PHP-Parser">PHP-Parser</a> for instance)</li>
</ul>

<p>Here's a usage example. When running the test suite, <a href="http://phpspec.net">phpspec</a>
generates missing methods in our code (amongst many other nice things).</p>

<p>If the following call is found in a test:</p>

<pre><code class="php">        $this-&gt;handle($request);
</code></pre>

<p>And if the <code>handle</code> method isn't defined in the class currently tested, then phpspec
gathers the following parameters:</p>

<ul>
<li><code>$methodName</code>, which here is set to <code>'handle'</code></li>
<li><code>$arguments</code>, which here is set to <code>array($request)</code></li>
</ul>

<p>Let's re-write its generator using Memio:</p>

<pre><code class="php">&lt;?php

use Memio\Model\Argument;
use Memio\Model\Method;

require __DIR__.'/vendor/autoload.php';

function phpspec_generator($methodName, array $arguments) {
    $method = new Method($methodName);
    $index = 1;
    foreach ($arguments as $argument) {
        $type = is_object($argument) ? get_class($argument) : gettype($argument);
        $argumentName = 'argument'.$index++;
        $method-&gt;addArgument(new Argument($type, $argumentName));
    }

    return $method
}
</code></pre>

<p>Pretty straightforward!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Models are Memio's core, almost every memio packages will rely on them:</p>

<ul>
<li><code>memio/linter</code> will scan models to detect errors (e.g. abstract methods in a final class)</li>
<li><code>memio/twig-template</code> will use them to actually generate the corresponding code</li>
</ul>

<p>For now they can describe:</p>

<ul>
<li>a method argument (typehint when needed, default value)</li>
<li>a method (with PHPdoc, visibility, staticness, abstracness and if it's final)</li>
<li>a property (with PHPdoc, visibility, staticness, default value)</li>
<li>a constant</li>
<li>a class (with PHPdoc, parents, interfaces, abstractness and if it's final)</li>
<li>an interface (with PHPdoc, parent interfaces)</li>
<li>a file (with license header, namespace, use statements)</li>
</ul>

<p>There are some limitations:</p>

<ul>
<li>it can only describe a method's body using a string (e.g. <code>$toto = 42;\necho $toto;</code>)</li>
<li>a file must have a class or an interface</li>
</ul>

<p>For now, it will be sufficient to start working on exciting projects!</p>

<p>If you'd like to find out more about Memio Models, have a look at the documentation:</p>

<ul>
<li><a href="http://memio.github.io/memio/doc/01-model-tutorial.html">regular Models</a></li>
<li><a href="http://memio.github.io/memio/doc/02-phpdoc-tutorial.html">PHPdoc Models</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Introducing Memio, code generator]]></title>
            <link href="/2015/04/08/introducing-memio-code-generator.html"/>
            <updated>2015-04-08T00:00:00+01:00</updated>
            <id>/2015/04/08/introducing-memio-code-generator.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Work in Progress: Memio, a library for PHP code generation.</p>
</blockquote>

<p>Code generators write code for you, so you don't have to! There's many kinds out there:</p>

<ul>
<li>the ones that bootstrap code but can't add anything to it later</li>
<li>the ones that create code but you can't add anything to it later</li>
<li>the ones that can add new things to existing files</li>
<li>the ones that will completly change the style of existing file if they add anything to it</li>
</ul>

<p>Many frameworks provide code generators, because they can be a real time saver by
automating repetitive boring tasks (e.g. bootstraping a CRUD controller). The only
issue is that usually we can't customize them.</p>

<p>For example with <a href="https://github.com/sensiolabs/SensioGeneratorBundle">GeneratorBundle</a>,
it's impossible to create REST controllers.</p>

<p>Some of them provide templates but don't template engines, like <a href="http://phpspec.net/">phpspec</a>
for example: this is a step forward but that's not enough.</p>

<p>Now let's have a look at code generator libraries: the main ones don't allow an easy
way to customize the coding style of generated code:</p>

<ul>
<li><a href="http://framework.zend.com/manual/current/en/modules/zend.code.generator.examples.html">Zend Code Generator</a></li>
<li><a href="https://github.com/nikic/PHP-Parser">PHP Parser</a></li>
</ul>

<p>Some of them do use a template engine, but you need to write a lot of code in order to use
them:</p>

<ul>
<li><a href="https://github.com/cedriclombardot/TwigGenerator">TwigGenerator</a></li>
</ul>

<p>Don't panic! Memio is a code generator library that uses a template engine and provide
out of the box templates, generators and even validation!</p>

<p>Started in september 2014 under the name "Medio", it has now matured enough to be soon
released in stable version (1.0.0).</p>

<p>Let's have a look at what's going to be achieved with it.</p>

<h2 id="improving-phpspec">Improving phpspec</h2>

<p>The <a href="https://github.com/ciaranmcnulty/phpspec-typehintedmethods">phpspec typehint extension</a> was
a good playground for Memio: it allowed to test generation of a method argument by:</p>

<ul>
<li>adding typehints when needed</li>
<li>naming object arguments after their types</li>
</ul>

<p>Once Memio is stable, it will provide its own phpspec extension that aims at:</p>

<ul>
<li>generating argument's PHPdoc</li>
<li>generating use statements for object arguments (no more fully qualified classnames)</li>
<li>generating dependency injection</li>
</ul>

<p>Curious about this last bullet point? Then read on.</p>

<h2 id="automating-dependency-injection">Automating Dependency Injection</h2>

<p>There are many ways to use constructors, and one of them is dependency injection:
each argument is stored in a property and the class can then use them.</p>

<blockquote>
  <p><strong>Note</strong>: Remember, Dependency Injection is a fancy word for passing arguments.</p>
</blockquote>

<p>When doing so, we need to write a lot of boilerplate code:</p>

<ul>
<li>add argument to constructor (with PHPdoc, typehint, name after the type)</li>
<li>add property initialization in constructor body</li>
<li>add property (with PHPdoc)</li>
<li>add use statement, if necessary</li>
</ul>

<p>Memio will automate this in its phpspec extension.</p>

<h2 id="possibly-more%3F">Possibly more?</h2>

<p>We talked about GeneratorBundle: the issue is that we can't define our own templates.
Well Memio could solve this issue in a reusable way!</p>

<p>Usually each applications have its own style, its own requirements, etc. In short:
we can't use the same code generator between projects. But if we focus on a single
project, then we can start using the same code generator to boostrap many classes:
endpoint/page controllers, entities, etc. The possibilities are endless!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio, once stable, will provide a powerful and reusable way of generating code.</p>

<p>What's left to do before the release of v1.0? Mainly splitting the main package
(<code>memio/memio</code>) into small ones (<code>model</code>, <code>template-engine</code>, <code>validator</code>, etc).
The main package would become a "standard edition", allowing developers to select
the features they want, for example the template engine (as <a href="https://github.com/memio/memio/issues/51">requested</a>
by <a href="https://github.com/webmozart">webmozart</a>).</p>

<p>Stay tuned!</p>

<h3 id="thanks">Thanks</h3>

<p>I'd like to thank the following early contributors:</p>

<ul>
<li><a href="https://github.com/funivan">funivan</a></li>
<li><a href="https://github.com/pyrech">pyrech</a></li>
<li><a href="https://github.com/tigitz">tigitz</a></li>
<li><a href="https://github.com/TomasVotruba">TomasVotruba</a></li>
</ul>

<p>Keep up the good work!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Lightweight console library]]></title>
            <link href="/2014/12/03/lightweight-console-lib.html"/>
            <updated>2014-12-03T00:00:00+00:00</updated>
            <id>/2014/12/03/lightweight-console-lib.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been deprecated.</p>
  
  <p><strong>TL;DR</strong>: <a href="https://github.com/gnugat/konzolo">Konzolo</a> can be used to create
  minimalistic CLI applications, or to implement the command design pattern.</p>
</blockquote>

<p>After implementing a same feature in many projects, I usually have the reflex to
create a library out of it. <a href="https://github.com/gnugat/konzolo">Konzolo</a> is one
of them :) .</p>

<p>In this article we'll see its features:</p>

<ul>
<li><a href="#create-a-command">Create a command</a></li>
<li><a href="#binding-up-an-application">Binding up an application</a></li>
<li><a href="#input-constraint">Input constraint</a></li>
<li><a href="#input-validator">Input validator</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="create-a-command">Create a command</h2>

<p>Let's create a "hello world" command:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Command;

use Gnugat\Konzolo\Command;
use Gnugat\Konzolo\Input;

class HelloWorldCommand implements Command
{
    public function execute(Input $input)
    {
        $name = $input-&gt;getArgument('name');
        echo "Hello $name\n";

        return Command::EXIT_SUCCESS;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: If the name argument is missing, an exception will be thrown.
  Keep reading to know more about those exceptions.</p>
</blockquote>

<p>We only have to implement the <code>execute</code> method, which receives a convenient
<code>Input</code> class and returns 0 on success (actually this is optional).</p>

<h2 id="binding-up-an-application">Binding up an application</h2>

<p>Now that we have a command, let's put it in an application:</p>

<pre><code class="php">&lt;?php
// File: console.php

use Acme\Demo\Command\HelloWorldCommand;
use Gnugat\Konzolo\Application;
use Gnugat\Konzolo\Input;

require __DIR__.'/vendor/autoload.php';

$input = new Input($argv[1]); // command name (acme:hello-world)
if (isset($argv[2])) {
    $input-&gt;setArgument('name', $argv[2]);
}

$application = new Application();
$application-&gt;addCommand('acme:hello-world', new HelloWorldCommand());

$application-&gt;run($input);
</code></pre>

<p>You can then run it:</p>

<pre><code>php console.php acme:hello-world Igor
</code></pre>

<h2 id="input-constraint">Input constraint</h2>

<p>If you need to validate the input, you can create a constraint:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Validation;

use Gnugat\Konzolo\Exception\InvalidInputException;
use Gnugat\Konzolo\Input;
use Gnugat\Konzolo\Validation\InputConstraint;

class NoWorldNameConstraint implements InputConstraint
{
    public function throwIfInvalid(Input $input)
    {
        $name = $input-&gt;getArgument('name');
        if ('World' === $name) {
            throw new InvalidInputException($input, 'The "name" parameter must not be set to "World"');
        }
    }
}
</code></pre>

<p>This constraint can be used directly in the command, as a dependency:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Command;

use Acme\Demo\Validation\NoWorldNameConstraint;
use Gnugat\Konzolo\Command;
use Gnugat\Konzolo\Input;

class HelloWorldCommand implements Command
{
    private $noWorldNameConstraint;

    public function __construct(NoWorldNameConstraint $noWorldNameConstraint)
    {
        $this-&gt;noWorldNameConstraint = $noWorldNameConstraint;
    }

    public function execute(Input $input)
    {
        $this-&gt;noWorldNameConstraint-&gt;throwIfInvalid($input);
        $name = $input-&gt;getArgument('name');
        echo "Hello $name\n";

        return Command::EXIT_SUCCESS;
    }
}
</code></pre>

<p>And then inject it:</p>

<pre><code class="php">&lt;?php
// File: console.php

use Acme\Demo\Command\HelloWorldCommand;
use Acme\Demo\Validation\NoWorldNameConstraint;
use Gnugat\Konzolo\Application;
use Gnugat\Konzolo\Input;

require __DIR__.'/vendor/autoload.php';

$input = new Input($argv[1]); // command name (acme:hello-world)
if (isset($argv[2])) {
    $input-&gt;setArgument('name', $argv[2]);
}

$application = new Application();
$application-&gt;addCommand('acme:hello-world', new HelloWorldCommand(new NoWorldNameConstraint()));

$application-&gt;run($input);
</code></pre>

<h2 id="input-validator">Input validator</h2>

<p>More conveniently, the command can depend on a validator:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Command;

use Gnugat\Konzolo\Command;
use Gnugat\Konzolo\Input;
use Gnugat\Konzolo\Validation\InputValidator;

class HelloWorldCommand implements Command
{
    private $validator;

    public function __construct(InputValidator $validator)
    {
        $this-&gt;validator = $validator;
    }

    public function execute(Input $input)
    {
        $this-&gt;validator-&gt;throwIfInvalid($input);
        $name = $input-&gt;getArgument('name');
        echo "Hello $name\n";

        return Command::EXIT_SUCCESS;
    }
}
</code></pre>

<p>You can add many constraint in a validator, and set priorities:</p>

<pre><code class="php">&lt;?php
// File: console.php

use Acme\Demo\Command\HelloWorldCommand;
use Acme\Demo\Validation\NoWorldNameConstraint;
use Gnugat\Konzolo\Application;
use Gnugat\Konzolo\Input;
use Gnugat\Konzolo\Validation\InputValidator;

require __DIR__.'/vendor/autoload.php';

$input = new Input($argv[1]); // command name (acme:hello-world)
if (isset($argv[2])) {
    $input-&gt;setArgument('name', $argv[2]);
}

$helloWorldValidator = new InputValidator();
$helloWorldValidator-&gt;addConstraint(new NoWorldNameConstraint(), 42);

$application = new Application();
$application-&gt;addCommand('acme:hello-world', new HelloWorldCommand($helloWorldValidator));

$application-&gt;run($input);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: The highest the priority, the soonest the constraint will be executed.
  For example, a constraint with priority 1337 will be executed before another
  one with priority 23 (even if this second one has been added first in the validator).</p>
</blockquote>

<h2 id="exceptions">Exceptions</h2>

<p>Konzolo's exceptions all implement the <code>Gnugat\Konzolo\Exception\Exception</code> interface.
This means you can catch every single one of them using this type. They also
extend at the standard <code>\Exception</code> class, so if you don't care about Konzolo
specific exceptions, you can catch them all!</p>

<p>This is usefull for example in <a href="https://symfony.com">Symfony2</a>: you can create
a Konzolo exception listener.</p>

<p>You can find more about the different kind of exceptions and their specific
methods in <a href="http://github.com/gnugat/konzolo/tree/master/doc/exception.md">its dedicated documentation</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We have seen how to create commands and validate their inputs.</p>

<p>Our examples showed how to create a CLI application, but Konzolo is mainly aimed at being used <strong>in</strong>
applications (not only CLI ones).
For example, <a href="https://github.com/gnugat/redaktilo">Redaktilo</a> uses internally
a system of Command/CommandInvoker, using an array as input and sanitizer as a
validation mechanism. All this logic can now be externalized, thanks to Konzolo!</p>

<p>I'd like to keep Konzolo as small as possible, but here's a list of possible
features it could see in the future:</p>

<h3 id="command-finder">Command finder</h3>

<p>Currently we can find commands by their exact names. But wouldn't it be nice if
we could just provide part of a name? Or an alias?</p>

<h3 id="input-factories">Input Factories</h3>

<p>Creating input manually isn't always what we need. A factory that creates one
from an array could improve the situation.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Find all available Fully Qualified ClassNames]]></title>
            <link href="/2014/11/26/find-all-available-fqcn.html"/>
            <updated>2014-11-26T00:00:00+00:00</updated>
            <id>/2014/11/26/find-all-available-fqcn.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="https://github.com/gnugat/nomo-spaco">Nomo Spaco</a> finds a given
  project's PHP files, and read them to give you the available Fully Qualified
  ClassNames.</p>
</blockquote>

<p>PHP provides the following function to find the declared classes of a project:
<a href="http://php.net/get_declared_classes">get_declared_classes</a>.</p>

<p>However this function only lists the classes which have been loaded
(included/required) before its call: the usage of an autoloader breaks it
(<a href="http://getcomposer.org">Composer</a> for example).</p>

<p>In this article, we'll see how to solve this problem.</p>

<h2 id="for-a-single-class">For a single class</h2>

<p>The first step is to find a way to get the Fully Qualified ClassName (fqcn) of
a single class.</p>

<p>A solution would be to read in its source file: if the project follows the
<a href="http://php-fig.org/psr/psr-0">PSR-0</a> or <a href="http://php-fig.org/psr/psr-4">PSR-4</a>
standards, the file should only contain one class and its filename should be the
same as the classname.</p>

<p>Let's create a function that retrieves the namespace declaration:</p>

<pre><code class="php">&lt;?php

function _get_full_namespace($filename) {
    $lines = file($filename);
    $namespaceLine = array_shift(preg_grep('/^namespace /', $lines));
    $match = array();
    preg_match('/^namespace (.*);$/', $namespaceLine, $match);
    $fullNamespace = array_pop($match);

    return $fullNamespace;
}
</code></pre>

<p>Now let's create a function that chops down the filename to get the classname:</p>

<pre><code class="php">&lt;?php

function _get_classname($filename) {
    $directoriesAndFilename = explode('/', $filename);
    $filename = array_pop($directoriesAndFilename);
    $nameAndExtension = explode('.', $filename);
    $className = array_shift($nameAndExtension);

    return $className;
}
</code></pre>

<p>That was easy! To get the Fully Qualified ClassName from a filename we can simply
call those two functions:</p>

<pre><code class="php">&lt;?php

$fqcn = _get_full_namespace($filename).'\\'._get_class_name($filename);
</code></pre>

<h2 id="for-a-project">For a project</h2>

<p>The second step is to find the filenames of all the project's classes. Let's use
the <a href="http://symfony.com/doc/current/components/finder/index.html">Symfony2 Finder Component</a>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Finder\Finder;

require __DIR__.'/vendor/autoload.php';

function _get_filenames($path) {
    $finderFiles = Finder::create()-&gt;files()-&gt;in($path)-&gt;name('*.php');
    $filenames = array();
    foreach ($finderFiles as $finderFile) {
        $filenames[] $finderFiles-&gt;getRealpath();
    }

    return $filenames;
}
</code></pre>

<p>And that's it! We can now create a function which calls those three:</p>

<pre><code class="php">&lt;?php

function get_all_fcqns($path) {
    $filenames = _get_filenames($projectRoot);
    $fcqns = array();
    foreach ($filenames as $filename) {
        $fcqns[] = _get_full_namespace($filename).'\\'._get_class_name($filename);
    }

    return $fcqns
}
</code></pre>

<p>It can simply be used like this:</p>

<pre><code class="php">&lt;?php

$allFcqns = get_all_fcqns(__DIR__);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>By finding all the PHP filenames in a project, and reading them to extract their
namespace and classname, we can easily find all the all available Fully
Qualified ClassNames.</p>

<p>The given functions are not meant to be used in production:</p>

<ol>
<li>they won't include standard and loaded extensions classes
(we could merge the result with <code>get_declared_classes()</code>)</li>
<li>they don't check if the files comply to PSR-0 or PSR-1</li>
<li>they will include test and fixture PHP files</li>
</ol>

<p>I've started a proof of concept: <a href="https://github.com/gnugat/nomo-spaco">Nomo Spaco</a>.
Hopefully it will grow to be more efficient, safer and tested. But for now it
provides you with a package, so you don't have to copy paste anything :) .</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Redaktilo 1.3]]></title>
            <link href="/2014/11/06/redaktilo-1-3.html"/>
            <updated>2014-11-06T00:00:00+00:00</updated>
            <id>/2014/11/06/redaktilo-1-3.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="https://github.com/gnugat/redaktilo">Redaktilo</a> is a library
  which wraps array manipulation to make it feel like using a text editor.</p>
</blockquote>

<p><a href="/2014/05/09/redaktilo.html">Six months ago</a>, I talked about a
<a href="https://github.com/gnugat/redaktilo">silly library</a> I was working on.</p>

<p>I've just released it's version 1.3, so I figured that maybe it's time to talk
about it as the mature and usefull project it has become.</p>

<h2 id="statistics">Statistics</h2>

<p>First, here's some meaningless figures:</p>

<ul>
<li>fisrt commit: at 08:06:46, on the 24th thursday of April 2014</li>
<li>number of releases: 36 (including 11 stable ones)</li>
<li>number of contributors: 3 (<a href="http://loickpiera.com/">Loick Piera</a>, <a href="http://wouterj.nl/">WouterJ</a> and myself)</li>
<li>lines of code (according to <a href="https://insight.sensiolabs.com/projects/fbe2d89f-f64d-45c2-a680-bbafac4b0d08/analyses/36">Insight, for version 1.3.0</a>): 1 183</li>
</ul>

<h2 id="history">History</h2>

<p>In my two previous pet projects (GnugatWizardBundle and Fossil), as well as in
professional projects, I've encountered the need to manipulate lines (from a
file or a static string).</p>

<p>I've done 3 different implementations, each less reusable than the other, so I
started to think that there was something to do here.</p>

<p>That's how <a href="https://github.com/gnugat/redaktilo">Redaktilo</a> is born!</p>

<h2 id="public-api">Public API</h2>

<p>My purpose was to create a single service which would be used as a text editor
("redaktilo" means "editor", in esperanto):</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class Editor
{
    // Filesystem operations:
    public function open($filename, $force = false);
    public function save(File $file);

    // Line selection
    public function jumpAbove(Text $text, $pattern, $location = null);
    public function jumpBelow(Text $text, $pattern, $location = null);

    // Line detection
    public function hasAbove(Text $text, $pattern, $location = null);
    public function hasBelow(Text $text, $pattern, $location = null);

    // Line manipulations
    public function insertAbove(Text $text, $addition, $location = null);
    public function insertBelow(Text $text, $addition, $location = null);
    public function replace(Text $text, $replacement, $location = null);
    public function replaceAll(Text $text, $pattern, $replacement);
    public function remove(Text $text, $location = null);

    // You can execute custom commands!
    public function run($name, array $input);
}
</code></pre>

<p>This service is <strong>stateless</strong>, it manipulates the following model:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class Text
{
    public function getLines();
    public function setLines(array $lines);
    public function getLength();

    public function getLineBreak();
    public function setLineBreak($lineBreak);

    public function getCurrentLineNumber();
    public function setCurrentLineNumber($lineNumber);
    public function getLine($lineNumber = null);
    public function setLine($line, $lineNumber = null);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: The <code>File</code> model extends <code>Text</code> and adds <code>filename</code> getter and
  setter.</p>
</blockquote>

<p>As you can see, everything is centered around a current line, but specifying
directly a line number is possible (that's the meaning of the <code>$location</code>
argument).</p>

<h2 id="facade-and-extension-points">Facade and extension points</h2>

<p>To be honest, <code>Editor</code> doesn't do anything, it just wraps some low level
services. Amongst those, we have:</p>

<ul>
<li><code>SearchEngine</code>: decides which <code>SearchStrategy</code> will be used</li>
<li><code>CommandInvoker</code>: executes a <code>Command</code></li>
</ul>

<p>Those two are actually here to provide extension points: if you need to look for
a line with something else than a regular expression, you can create your own
<code>SearchStrategy</code>, register it in <code>SearchEngine</code> and it will be available
directly from the <code>Editor</code>!</p>

<p>If the manipulations provided out of the box aren't sufficient, you can create
your own <code>Command</code>, register it in <code>CommandInvoker</code> and it will be available
directly from the <code>Editor</code>!</p>

<p>Commands rely on user input, which is why Loïck worked on <code>InputSanitizer</code> to
validate it. If the ones provided aren't enough, you can still create your own
implementations.</p>

<p>Finally, I'd like to highlight Wouter's work on the <code>EditorFatory</code> helper: it is
really cumbersome to instantiate manually <code>Editor</code>... But thanks to this
factory, you'll never have to do it by yourself!</p>

<blockquote>
  <p><strong>Note</strong>: Working on a <a href="http://symfony.com">Symfony2</a> project? You can use
  <a href="https://github.com/gnugat/redaktilo-bundle">RedaktiloBundle</a>, which also
  provides tags to register custom search strategies and commands.</p>
</blockquote>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>Loïck is currently improving the library's exceptions for the version 1.4.</p>

<p>For version 1.5, two new methods will be added to <code>Text</code>:
<code>incrementCurrentLineNumber</code> and <code>decrementCurrentLineNumber</code>, to avoid the
following:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\EditorFactory;

$editor = EditorFactory::createEditor();
$file = $editor-&gt;open('/tmp/monty-python.txt');

// Currently
$currentLineNumber = $file-&gt;getCurrentLineNumber();
$file-&gt;setCurrentLineNumber($currentLineNumber + 2);

// Soon...
$file-&gt;incrementCurrentLineNumber(2);
</code></pre>

<p>For the final version 1.6, a strong documentation of the deprecations will be
done, leading the way to version 2.0 where those will be removed (50% of the code
base will vanish!).</p>

<blockquote>
  <p><strong>Note</strong>: As I'm using Redaktilo everyday, I might discover new improvements
  to be done, leading the given version numbers above to change.</p>
</blockquote>

<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>

<h3 id="is-it-a-gui-%2F-cli-tool%3F">Is it a GUI / CLI tool?</h3>

<p>A question I've been often asked, because describing Redaktilo as a text editor
might be a bit misleading. It is a library which <strong>feels like</strong> an editor, but
it is in no way an actual editor you might run.</p>

<p>Here's an example of what you might be doing currently without Redaktilo:</p>

<pre><code class="php">&lt;?php

$lines = file('/tmp/monty-python.txt');
$currentLineNumber = 42;
$section = array_slice($lines, 0, $current, true); // Lines from 0 to 42
$reversedSection = array_reverse($section, true);
$found = preg_grep('/a knewt/', $reversedSection); // finding the first occurence, above line 42
$currentLineNumber = key($found);

array_splice($lines, $currentLineNumber + 1, 0, 'new line below "a knewt"');
$content = implode("\n", $lines); // Let's hope it wasn't a file created on Windows.
file_put_contents($content, '/tmp/monty-python');
</code></pre>

<p>With redaktilo:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\EditorFactory;

$editor = EditorFactory::createEditor();
$file = $editor-&gt;open('/tmp/monty-python');
$editor-&gt;jumpAbove($file, '/a knewt/', 42);
$editor-&gt;insertBelow($file, 'new line below "a knewt"');
$editor-&gt;save($file);
</code></pre>

<h3 id="is-it-a-code-editor%3F">Is it a code editor?</h3>

<p>Because the code example on the README is about inserting a new line in the
<code>AppKernel</code> file of a Symfony2 application, I also get this question.</p>

<p>Redaktilo can edit any text file, so it includes source files. But keep in mind
that it only manipulates lines, when you might want to manipulate an AST to edit
code.</p>

<p>I'm working on a new silly project: <a href="https://github.com/gnugat/medio">Medio</a>.
It heavily relies on Redaktilo to actually edit code: so you can make a code
editor with it, but again before you start ask yourself if an AST wouldn't be
better.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Redaktilo is a library which makes line manipulation dead easy! It provides
extension points and will soon reach version 2 which will mark its final
maturity point.</p>

<p>Until then, you can still use it safely, it's been stable for 11 releases now.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHP array manipulation]]></title>
            <link href="/2014/10/15/php-array-manipulation.html"/>
            <updated>2014-10-15T00:00:00+01:00</updated>
            <id>/2014/10/15/php-array-manipulation.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="https://github.com/gnugat/redaktilo">Redaktilo</a> provides a nice
  API to manipulate array of lines (insert, replace, go to line, etc).</p>
</blockquote>

<p>Arrays are surely one of the most used PHP functionality: they're simple,
convenient and benefit from a large set of standard functions to manipulate them.</p>

<p>Let's see the different possibilities:</p>

<ul>
<li><a href="#finding-an-element">Finding an element</a></li>
<li><a href="#finding-an-element-relatively-to-a-given-index">Finding an element relatively to a given index</a></li>
<li><a href="#inserting-a-new-element">Inserting a new element</a></li>
<li><a href="#removing-an-element">Removing an element</a></li>
<li><a href="#retrieving-elements-from-a-file">Retrieving elements from a file</a></li>
<li><a href="#saving-changes-in-a-file">Saving changes in a file</a></li>
<li><a href="#there-is-a-better-way">There is a better way</a>

<ul>
<li><a href="#retrieving-a-line">Retrieving a line</a></li>
<li><a href="#finding-an-element-relatively-to-a-given-line-number">Finding an element relatively to a given line number</a></li>
<li><a href="#inserting-a-new-line">Inserting a new line</a></li>
<li><a href="#using-text">Using Text</a></li>
<li><a href="#cheat-sheet">Cheat Sheet</a>

<ul>
<li><a href="#editor">Editor</a></li>
<li><a href="#text">Text</a></li>
<li><a href="#file">File</a></li>
</ul></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="finding-an-element">Finding an element</h2>

<p>In order to find the index of a string in an array, we can use one of the
following functions:</p>

<pre><code class="php">&lt;?php

$montyPython = array(
    'This is a dead parrot',
    'No, no, it\'s not dead, it\'s resting!',
);

$exactSentence = 'This is a dead parrot';
array_search($exactSentence, $montyPython, true); // Returns 0
$regex = '/resting!$/';
$found = preg_grep($regex, $montyPython);
key($found); // Returns 1
</code></pre>

<blockquote>
  <p><strong>Note</strong>: The third parameter of <a href="http://php.net/array_search"><code>array_search</code></a>
  enables the strict comparison (it makes sure the types are also the same).</p>
</blockquote>

<p>We can find the matching elements of a pattern using
<a href="http://php.net/preg_grep"><code>preg_grep</code></a>. To get the index of the first result
found, we can use <a href="http://php.net/key"><code>key</code></a>.</p>

<h2 id="finding-an-element-relatively-to-a-given-index">Finding an element relatively to a given index</h2>

<p>It's great! Now what if we want to remember the index and then make a search
relatively to it? For example we want to find the index of the element
<code>/a knewt/</code>, but only in the elements above <code>... I got better...</code>:</p>

<pre><code class="php">&lt;?php

$holyGrail = array(
    'She turned me into a knewt!',
    'A knewt?',
    '... I got better...',
    'A WITCH!',
);

$index = array_search('... I got better...', $holyGrail, true);
$section = array_slice($holyGrail, 0, $index, true);
$reversedSection = array_reverse($section, true);
$found = preg_grep('/a knewt/', $reversedSection);
key($found); // Returns 0
</code></pre>

<p>In this code snippet, we get a subset of the array
(from the first element to <code>... I got better</code>) using
<a href="http://php.net/array_slice"><code>array_slice</code></a> (the last argument allows to keep
the indexes unchanged). This also excludes <code>... I got better...</code>.</p>

<p>Then we change the order of the elements using
<a href="http://php.net/array_reverse"><code>array_reverse</code></a> (the second argument allows to
keep the index unchanged) so the element above <code>... I got better...</code> would be
the first result.</p>

<p>Finally we look for <code>/a knewt/</code> as we did previously.</p>

<h2 id="inserting-a-new-element">Inserting a new element</h2>

<p>If we want to insert a new element after a given index in the array, we need to
use <a href="http://php.net/array_splice"><code>array_splice</code></a>:</p>

<pre><code class="php">&lt;?php

$grandPiano = array(
    'I would like to learn how to fly an aeroplane',
    'A what?',
    'An aeroplane',
    'OH! An aeroplane, oh I say we are grand aren\'t we?',
    'Pardon me while I\'m flying me aeroplane... NOW GET ON THE TABLE!',
);

$found = preg_grep('/grand/', $grandPiano);
$index = key($found);
array_splice($grandPiano, $index + 1, 0, 'No more cluttered cream for me, butler, I\'m off to play the grand piano');
</code></pre>

<p>Actually <code>array_splice</code> allows to replace a subsection of an array, here's the
explanation of its arguments:</p>

<ol>
<li>the array to manipulate</li>
<li>the starting index</li>
<li>the ending index (<code>0</code> means replacing nothing, therefore just inserting)</li>
<li>the replacement (in our case the element to insert)</li>
</ol>

<p>It's not very explicit, but we have a solution for this (keep reading to find
out).</p>

<h2 id="removing-an-element">Removing an element</h2>

<p>Here's an easy one:</p>

<pre><code class="php">&lt;?php

$parrot = array(
    'Hello, I would like to make a complain. Hello, miss?',
    'What do you mean miss?',
    'Sorry, I have a cold',
);

$index = array_search('Sorry, I have a cold', $parrot, true);
unset($parrot[$index]);
</code></pre>

<p>You might want to reorder the indexes, to avoid gaps:</p>

<pre><code class="php">&lt;?php

$parrot = array(
    'Hello, I would like to make a complain. Hello, miss?',
    'What do you mean miss?',
    'Sorry, I have a cold',
);

$index = array_search('What do you mean miss?', $parrot, true);
unset($parrot[$index]);
// Current value:
// $parrot = array(
//     0 =&gt; 'Hello, I would like to make a complain. Hello, miss?',
//     2 =&gt; 'Sorry, I have a cold',
// );

$parrot = array_values($parrot);
// Current value:
// $parrot = array(
//     0 =&gt; 'Hello, I would like to make a complain. Hello, miss?',
//     1 =&gt; 'Sorry, I have a cold',
// );
</code></pre>

<p>The <a href="http://php.net/array_values"><code>array_values</code></a> function is equivalent to:</p>

<pre><code class="php">$newArray = array();
foreach ($oldArray as $element) {
    $newArray[] = $element;
}
</code></pre>

<h2 id="retrieving-elements-from-a-file">Retrieving elements from a file</h2>

<p>Until now, we've been using a hard coded array, but this is rarely what we
encounter in real life project. The data could for example come from a file,
which can be transformed into an array of lines:</p>

<pre><code class="php">&lt;?php

$file = file('/tmp/holy-grail.text', FILE_IGNORE_NEW_LINES);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: the second argument will remove the trailing line breaks.</p>
</blockquote>

<p>The only problem with <a href="http://php.net/file"><code>file</code></a> is that it will remove the
last line if it's empty. Let's use another function:</p>

<pre><code class="php">&lt;?php

$content = file_get_contents('/tmp/holy-grail.txt');
$lines = explode("\n", $content);
</code></pre>

<p>The <a href="http://php.net/file_get_contents"><code>file_get_contents</code></a> function returns the
content as a string.</p>

<p>We used <a href="http://php.net/explode"><code>explode</code></a> to split it into an array of lines.</p>

<p>This assumes that the file hasn't been created on Windows (where the line
separator is <code>\r\n</code>)... We need to detect the line break:</p>

<pre><code class="php">&lt;?php

$content = @file_get_contents('/tmp/holy-grail.txt');
$lineBreak = "\n"; // Used by every systems (except Windows), so used as default
if (false === strpos($content, "\n")) { // No line break detected at all
    $lineBreak = PHP_EOL; // Using the system's one
}
if (false !== strpos($content, "\r\n")) { // Windows line break detected
    $lineBreak = "\r\n";
}
$lines = explode($lineBreak, $content);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: There's many check to be done before actually reading the file
  (does the file actually exists? Do we have the permission to read it?).
  We have a solution for this (keep reading to find out).</p>
</blockquote>

<h2 id="saving-changes-in-a-file">Saving changes in a file</h2>

<p>If we do any changes to those lines, we might want to save them on the
filesystem:</p>

<pre><code class="php">&lt;?php

$lines = array(
    'Morning, morning, morning',
    'Morning Jim, Morning Jack',
    'Can\'t complain, keep coming back',
    'Boring, boring, boring',
);
$lineBreak = "\n"; // Or whatever has been detected
$content = implode($lineBreak, $lines);
file_put_contents('/tmp/silly-walk-song.txt', $content);
</code></pre>

<p>To convert back the array of lines to a string content, we use
<a href="http://php.net/implode"><code>implode</code></a>.</p>

<p>To write the content in the file, we use
<a href="http://php.net/file_put_contents"><code>file_put_contents</code></a>.</p>

<blockquote>
  <p><strong>Note</strong>: There's many check to be done before actually writing in a file
  (does the path actually exists? Do we have the permissions? What happens if
  the writing process fails during the execution?). To solve this, use the
  Symfony2 Filesystem Component (<code>Filesystem#dumpFile()</code>).</p>
</blockquote>

<h2 id="there-is-a-better-way">There is a better way</h2>

<p>You don't find <code>array_splice</code> very explicit for element insertion (or can't find
a way to remember its argument order/meaning)?</p>

<p>Keeping the elements, the index, the line break in separates variables looks too
procedural for you?</p>

<p>And what about error management?</p>

<p>Don't panic! There is a better way: <a href="https://github.com/gnugat/redaktilo">Redaktilo</a>
(it means "Editor" in esperanto).</p>

<p>This small library makes array manipulation easier by providing:</p>

<ul>
<li>an <code>Editor</code> object (open, save, find, insert, etc)</li>
<li>a <code>Text</code> object (line break, elements, current index, etc)</li>
<li>a <code>File</code> object (same as <code>Text</code>, but with filename)</li>
</ul>

<p>Use it in your projects, thanks to <a href="http://getcomposer.org">Composer</a>:</p>

<pre><code>composer require 'gnugat/redaktilo:~1.1'
</code></pre>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\EditorFactory;

$editor = EditorFactory::createEditor();
</code></pre>

<blockquote>
  <p><strong>Note</strong>: In order to make operations more explicit, Redaktilo has adopted the
  vocabulary of file edition (more specifically manipulation of lines). But in
  the end it's still array manipulation.</p>
</blockquote>

<h3 id="retrieving-a-line">Retrieving a line</h3>

<p>You don't have to worry about file checking and line break detection anymore:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\EditorFactory;

$editor = EditorFactory::createEditor();
$file = $editor-&gt;open('/tmp/silly-walk-song.txt');
$file-&gt;getLineBreak(); // Returns "\n" if the file hasn't been created on Windows
</code></pre>

<h3 id="finding-an-element-relatively-to-a-given-line-number">Finding an element relatively to a given line number</h3>

<p>Redaktilo takes care of the search strategy for you (it uses <code>preg_grep</code> when
you give a valid regular expression, and <code>array_search</code> when you give a string).</p>

<p>It supports search relative to the current line number stored in the given
<code>Text</code> and <code>File</code> (it uses <code>array_slice</code>, <code>array_reverse</code> and <code>key</code> internally).</p>

<p>The <code>hasAbove</code> and <code>hasBelow</code> methods just return a boolean, while the
<code>jumpAbove</code> and <code>jumpBelow</code> methods rather store the found line number in the
given <code>Text</code> and <code>File</code> (and raise an exception if nothing is found):</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\EditorFactory;

$editor = EditorFactory::createEditor();
$file = $editor-&gt;open('/tmp/silly-walk-song.txt');

$editor-&gt;jumpBelow($file, 'Boring, boring, boring');
$file-&gt;getCurrentLineNumber(); // Returns 3

$editor-&gt;hasAbove($file, '/morning,/'); // Returns true
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <code>hasAbove</code>, <code>hasBelow</code>, <code>jumpAbove</code> and <code>jumpBelow</code> all have a third
  argument which is a line number. If provided, the search will be done
  relatively to this line number, rather than to the current one.</p>
  
  <p>For example, checking the presence of a pattern in the whole file can be done
  as: <code>$editor-&gt;hasBelow($file, $pattern, 0); // starts the search from the top of the file</code>.</p>
</blockquote>

<h3 id="inserting-a-new-line">Inserting a new line</h3>

<p>No more <code>array_splice</code> nonsense!</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\EditorFactory;

$editor = EditorFactory::createEditor();
$file = $editor-&gt;open('/tmp/silly-walk-song.txt');

$editor-&gt;insertAbove($file, 'The silly walk song');
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <code>insertAbove</code>, <code>insertBelow</code>, <code>replace</code> and <code>remove</code> all have a
  third argument which is a line number. If provided, the anipulation will be
  done relatively to it, instead of relatively to the current one.</p>
</blockquote>

<h3 id="using-text">Using Text</h3>

<p>If you're not manipulating a file, you can use <code>Text</code> just like we used
<code>File</code>:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\EditorFactory;
use Gnugat\Redaktilo\Service\LineBreak;
use Gnugat\Redaktilo\Service\TextFactory;

$lineBreak = new LineBreak();
$textFactory = new TextFactory($lineBreak);

$text = $textFactory-&gt;make(&lt;&lt;&lt;EOF
Some raw text you would have got from somewhere,
for example a database.
EOF
);

$editor = EditorFactory::createEditor();
$editor-&gt;hasBelow($text, '/a database/'); // Returns true
</code></pre>

<h3 id="cheat-sheet">Cheat Sheet</h3>

<p>There's many more operations available, as you can discover in
<a href="https://github.com/gnugat/redaktilo/tree/master/doc">the documentation</a>.</p>

<p>To make it easier, here's some cheat sheet.</p>

<h4 id="editor">Editor</h4>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

use Gnugat\Redaktilo\Search\PatternNotFoundException;
use Gnugat\Redaktilo\Search\SearchEngine;
use Gnugat\Redaktilo\Service\Filesystem;
use Symfony\Component\Filesystem\Exception\FileNotFoundException;
use Symfony\Component\Filesystem\Exception\IOException;

class Editor
{
    public function open($filename, $force = false); // @throws FileNotFoundException
    public function save(File $file); // @throws IOException If cannot write

    // @throw PatternNotFoundException
    public function jumpAbove(Text $text, $pattern, $location = null);
    public function jumpBelow(Text $text, $pattern, $location = null);

    // @return bool
    public function hasAbove(Text $text, $pattern, $location = null);
    public function hasBelow(Text $text, $pattern, $location = null);

    public function insertAbove(Text $text, $addition, $location = null);
    public function insertBelow(Text $text, $addition, $location = null);
    public function replace(Text $text, $replacement, $location = null);
    public function remove(Text $text, $location = null);
}
</code></pre>

<h4 id="text">Text</h4>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class Text
{
    public function getLines();
    public function setLines(array $lines);
    public function getLength();
    public function getLineBreak();
    public function setLineBreak($lineBreak);
    public function getCurrentLineNumber();

    // @throw InvalidLineNumberException
    public function setCurrentLineNumber($lineNumber);
    public function getLine($lineNumber = null);
    public function setLine($line, $lineNumber = null);
}
</code></pre>

<h4 id="file">File</h4>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class File extends Text
{
    public function getFilename();
    public function setFilename($filename);
}
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>PHP provides plenty of built-in functions to manipulate arrays, but those are
not enough. <a href="https://github.com/gnugat/redaktilo">Redaktilo</a> is a small library
which provides a nicer API.</p>

<p>It allows you to select a line relatively to the current one and then do CRUD
operations on it.</p>

<p>I hope you'll find it as usefull as I do and if you find any bug or have any
proposals feel free to do so on <a href="https://github.com/gnugat/redaktilo/issues">Github</a>
where <a href="http://loickpiera.com/">Loïck Piera</a> and myself will both be glad to help
you.</p>

<blockquote>
  <p><strong>Note</strong>: As for the 15/10/2014, the current version of Redaktilo is 1.1.6
  (stable). Future updates are already planned!</p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Redaktilo v0.7]]></title>
            <link href="/2014/05/27/redaktilo-0-7.html"/>
            <updated>2014-05-27T00:00:00+01:00</updated>
            <id>/2014/05/27/redaktilo-0-7.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>Since the announcement of <a href="https://github.com/gnugat/redaktilo">Redaktilo</a> on
this blog, this silly library has jumped from 164 lines of code in v0.3 to 571
in v0.7.</p>

<p>In this article:</p>

<ol>
<li>we'll quickly oversee <a href="#changes-done">the changes done</a></li>
<li>then we'll have some insight on <a href="#upcoming-changes">the upcoming changes</a></li>
<li>finally I'll list <a href="#remaining-unresolved-questions">the remaining unresolved questions</a></li>
</ol>

<h2 id="changes-done">Changes done</h2>

<p>Thanks to <a href="https://github.com/gnugat/redaktilo/commits?author=WouterJ">WouterJ</a>
you can now:</p>

<ul>
<li>remove the current line: <code>$editor-&gt;remove($file);</code></li>
<li>replace the current line: <code>$editor-&gt;changeTo($file, $replacement);</code></li>
<li>replace all occurences: <code>$editor-&gt;replaceWith($file, $regex, $callback);</code></li>
<li>check line presence: <code>$editor-&gt;has($file, $pattern);</code></li>
</ul>

<p>I've updated to documentation to make the library easier to learn with:</p>

<ul>
<li>a <a href="https://github.com/gnugat/redaktilo/blob/master/doc/01-tutorial.md">tutorial</a></li>
<li>a <a href="https://github.com/gnugat/redaktilo/blob/master/doc/03-reference.md">code reference</a></li>
</ul>

<p><strong>Redaktilo</strong> has been created to fulfill actual needs. To make sure it keeps
this promise, I've added executable
<a href="https://github.com/gnugat/redaktilo/tree/master/tests/example">examples using PHPUnit tests</a>.</p>

<p>The major changes have been massive refactorings to allow the library to be
extended:</p>

<ul>
<li><a href="https://github.com/gnugat/redaktilo/tree/master/src/Gnugat/Redaktilo/Search">you can add search strategies</a></li>
<li><a href="https://github.com/gnugat/redaktilo/tree/master/src/Gnugat/Redaktilo/Converter">you can convert the file's content</a></li>
</ul>

<p>As highlited by <a href="https://twitter.com/clemherreman/status/466497340824911872">Clément Herreman</a>,
those refactorings have introduced a more complex construction schema.
To make things easier, a
<a href="https://github.com/gnugat/redaktilo/blob/master/src/Gnugat/Redaktilo/DependencyInjection/StaticContainer.php">static Dependency Injection Container</a>
has been created.</p>

<h2 id="upcoming-changes">Upcoming changes</h2>

<p><a href="http://www.sublimetext.com/">Sublime Text's go to anything</a> feature is
really awesome, which is why I'd like to implement something similar:</p>

<ul>
<li>go to the previous/next line (<code>array_search</code>)</li>
<li>go to x lines above/under</li>
<li>go to the previous/next substring match (<code>strpos</code>)</li>
<li>go to the previous/next regex match (<code>preg_grep</code>)</li>
<li>go to the previous/next PHP class/method/function (<code>token_get_all</code>)</li>
</ul>

<p>The two first ones are already available, so the other one still have to be
implemented (the last one might be done by
<a href="https://github.com/gnugat/redaktilo/issues/6#issuecomment-44005931">Loick Piera</a>).</p>

<p>The methods allowing this throw exception when nothing is found. Adding a
relative check (<code>hasBefore</code> and <code>hasAfter</code>) might make things easier.</p>

<p>Moving relatively isn't always sufficient. To go to an absolute line number
you have to use directly <code>File</code>, maybe it would be nicer to add a new method
to <code>Editor</code> (<code>jumpToFirst</code>).</p>

<p>Finally, the editor should allow insertion, replacement and removal in any
locations, not just on the current line.</p>

<p>Once these features added, more refactoring should take place: since the
creation of <strong>Redaktilo</strong>, <a href="https://github.com/jfsimon">Jean-François Simon</a>
advised me to use the command and memento patterns, which would allow the
undo/redo feature.
While I now think that <code>Command</code> is indeed more suitable than <code>ReplaceStrategy</code>
for insertion, replacement and removal, I'm not sure the versioning feature
is actually needed... For now.</p>

<p>And that should bring us near an alpha version :) .</p>

<p>A lot of renaming should happen at this stage:</p>

<ul>
<li><code>changeTo</code> to <code>replace</code></li>
<li><code>replaceWith</code> to <code>replaceAll</code></li>
<li><code>NotSupportedException</code> to <code>NotFoundEsception</code></li>
</ul>

<p>And perhaps some other methods or class names.</p>

<p>Once the heavy renaming done, beta versions can begin, with a main focus on
making every thing safer (argument checking, exception handling).</p>

<h2 id="remaining-unresolved-questions">Remaining unresolved questions</h2>

<p>I'm still not fully sure of what Redaktilo v1.0 will look like. Mainly because
I still haven't anwsered this by question (which have been in my mind since the
begining):</p>

<p>Should <strong>Redaktilo</strong> handle different kinds of files?</p>

<p>Sometimes I think it should, which is why the project has seen:</p>

<ul>
<li><a href="https://github.com/gnugat/redaktilo/tree/v0.1.0/src/Gnugat/Redaktilo/Editor">Editor interface</a></li>
<li><a href="https://github.com/gnugat/redaktilo/tree/v0.1.0/src/Gnugat/Redaktilo/File">File interface</a></li>
<li><a href="https://github.com/gnugat/redaktilo/tree/v0.6.1/src/Gnugat/Redaktilo">a premature ReplaceEngine/ReploaceStrategy</a></li>
<li><a href="https://github.com/gnugat/redaktilo/tree/v0.7.0/src/Gnugat/Redaktilo/Converter">ContentConverter interface</a></li>
</ul>

<p>The motives behind this is the JSON use case: you can currently edit JSON
files, but it's tedious.</p>

<p>Let's take the <code>composer.json</code> example. What if you need to
<a href="https://getcomposer.org/doc/articles/scripts.md">add a script</a> when:</p>

<ul>
<li>there's no <code>scripts</code> section yet?</li>
<li>there's no subsection in <code>script</code> yet?</li>
<li>there's already a script, but not in an array</li>
<li>there's already some scripts</li>
</ul>

<p>Another example would be the addition of a new element in an array: you
currently have to manually a trailing comma to the previous entry...</p>

<h2 id="conclusion">Conclusion</h2>

<p><strong>Redaktilo</strong> fulfills 98% of my use cases (inserting new lines in a YAML
configuration file, editing PHP files and replacing bits in a documentation
file) and is now extensible.</p>

<p>Some search strategies will be added to make it similar to the
<a href="http://www.sublimetext.com/">Sublime Text's go to anything</a>, and some
refactoring are still necessary before an alpha version.</p>

<p>There's still some unresolved questions (JSON edition is the 2% use case left),
but I'm sure they'll be answered during the development.</p>

<p>In the end <code>Editor</code> should have the following methods (no guaranty on the
names):</p>

<ul>
<li>filesystem operations: open/save</li>
<li>checking line presence: has/hasBefore/hasAfter</li>
<li>content navigation: jumpTo/jumpUpTo/jumpDownTo</li>
<li>content manipulation: insert/remove/replace (on the current line or at the
given location)</li>
<li>global manipulation: replaceAll</li>
</ul>

<p>I'd like to thank the early contributors:</p>

<ul>
<li><a href="https://github.com/jfsimon">Jean-François Simon</a></li>
<li><a href="https://github.com/gnugat/redaktilo/commits?author=WouterJ">WouterJ</a></li>
<li><a href="https://github.com/gnugat/redaktilo/commit/7c8da2d94e1d659318e9bb1745c8cc19435cb3af#commitcomment-6279956">Clément Debiaune</a></li>
<li><a href="https://twitter.com/clemherreman/status/466497340824911872">Clément Herreman</a></li>
<li><a href="https://github.com/gnugat/redaktilo/issues/6#issuecomment-44005931">Loick Piera</a></li>
</ul>

<p>Any help is appreciated, whether it's some code review, typo fixing or
code/documentation contribution. But the biggest help you could give me:
provide me with some feedback on Redaktilo's usage :) .</p>

<p>If you have any questions, remarks, please feel free to
<a href="https://github.com/gnugat/redaktilo/issues?state=open">open an issue</a> and
start a discussion here.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Facade design pattern, by example]]></title>
            <link href="/2014/05/21/facade-design-pattern-by-example.html"/>
            <updated>2014-05-21T00:00:00+01:00</updated>
            <id>/2014/05/21/facade-design-pattern-by-example.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>Sometimes, you just want to hide low level complexity behind a unique interface
which communicates a high level policy. The Facade design pattern is all about
this.</p>

<p>In this article, we'll see a real world example with
<a href="https://github.com/gnugat/redaktilo">Redaktilo</a>.</p>

<h2 id="low-level-file-manipulation">Low level file manipulation</h2>

<p><strong>Redaktilo</strong> provides an object oriented way to manipulate files. For example
you can open existing ones, or create new ones:</p>

<pre><code class="php">&lt;?php
require_once __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\DependencyInjection\StaticContainer;

$filesystem = StaticContainer::makeFilesystem();

$filename = '/tmp/monthy.py';
if ($filesystem-&gt;exists($filename)) {
    $file = $filesystem-&gt;open('/tmp/existing.txt');
} else {
    $file = $filesystem-&gt;create('/tmp/new.txt');
}

// ...
</code></pre>

<p>The main interest in this library lies in manipulations you can do, for example
jumping to a line and adding a new one under it:</p>

<pre><code class="php">&lt;?php
// ...

$lineSearchStrategy = StaticContainer::makeLineSearchStrategy();
$lineReplaceStrategy = StaticContainer::makeLineReplaceStrategy();

$lineNumber = $lineSearchStrategy-&gt;findNext('if Knight.saysNi():');
$lineReplaceStrategy-&gt;insertAt($file, $lineNumber, '    print "Ni!"');

// ...
</code></pre>

<p>Finally, you need to actually save the changes (they were only done in memory
until now) :</p>

<pre><code class="php">// ...

$filesystem-&gt;write($file);
</code></pre>

<h2 id="a-higher-level-api%3F">A higher level API?</h2>

<p>The Filesystem and Search/Replace strategies are low level APIs and require a
lot of boilerplate code to do every day tasks.</p>

<p>What if we provided a unique interface in front of those services? One that
would be in a higher level, say a text editor metaphor for instance?</p>

<pre><code class="php">&lt;?php
require_once __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\DependencyInjection\StaticContainer;

$editor = StaticContainer::makeEditor();

$filename = '/tmp/monthy.py';
$file = $editor-&gt;open($filename, true); // Force file creation.

$editor-&gt;jumpDownTo($file, 'if Knight.saysNi():');
$editor-&gt;addAfter($file, '    print "Ni!"');

$editor-&gt;save($file);
</code></pre>

<p>You don't need to take care of every service creation, and now you only have to
learn a small set of methods. The text editor metaphor also provides you with a
neat way to easily remember these methods!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Facades hide low level implementation by providing a unique high level API.</p>

<p>Here's another blog post about this pattern, by
<a href="http://mikeebert.tumblr.com/post/25342991856/design-pattern-facade-pattern">Mike Ebert</a>.</p>

<p>I hope you found this article interesting, if you have any questions or
feedback please feel free to do so on <a href="https://twitter.com/epiloic">Twitter</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Open/Closed principle, by example]]></title>
            <link href="/2014/05/14/open-closed-principle-by-example.html"/>
            <updated>2014-05-14T00:00:00+01:00</updated>
            <id>/2014/05/14/open-closed-principle-by-example.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>This week I've read two articles, which just have been published, on the
Open/Closed principle:</p>

<ul>
<li>one by <a href="http://blog.8thlight.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html">Uncle Bob</a></li>
<li>another one by <a href="http://verraes.net/2014/05/final-classes-in-php/">Mathias Verraes</a></li>
</ul>

<p>I'd like to add my small contribution to their explanation by providing a real
world example: <a href="https://github.com/gnugat/redaktilo">Redaktilo</a>.</p>

<h2 id="problem-statement">Problem statement</h2>

<p>Let's say you have the following file:</p>

<pre><code>Egg
Sausage
Bacon
Spam
</code></pre>

<p>Redaktilo provides an <code>Editor</code> class which allows you to jump to the line you
want, provided that you know exactly its content:</p>

<pre><code class="php">$editor-&gt;has($file, 'Bacon'); // true!
$editor-&gt;jumpDownTo($file, 'Bacon'); // Current line: Bacon
$editor-&gt;jumpUpTo($file, 'Sausage'); // Current line: Sausage
</code></pre>

<p>But what if you want to jump two lines under <code>Sausage</code>? You'd have to create
a new method:</p>

<pre><code class="php">$editor-&gt;moveDown($file, 2); // Current line: Spam
</code></pre>

<p>You have extended <code>Editor</code> by modifying it.</p>

<h2 id="complying-to-the-open%2Fclosed-principle">Complying to the Open/Closed principle</h2>

<p>Having to fork a library to extend it doesn't feel natural. What does the
Open/Closed principle say?</p>

<blockquote>
  <p>Software entities (classes, modules, functions, etc.) should be open for
  extension, but closed for modification.</p>
</blockquote>

<p>Our <code>Editor</code> class is open to extension, but also to modification.</p>

<p>To fix this, we can transfer the responsibility of finding a pattern in the file
to a <code>SearchStrategy</code>:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo\Search;

use Gnugat\Redaktilo\File;

interface SearchStrategy
{
    public function has(File $file, $pattern);

    public function findNext(File $file, $pattern);
    public function findPrevious(File $file, $pattern);

    public function supports($pattern);
}

</code></pre>

<p>Here's some implementation ideas:</p>

<ul>
<li><code>LineSearchStrategy</code>: looking for the exact line in the file</li>
<li><code>LineNumberSearchStrategy</code>: jumping to a line relatively to the current one</li>
<li><code>RegexpSearchStrategy</code>: looking for a pattern in the file using regular expressions</li>
<li><code>PhpTokenSearchStrategy</code>: parsing PHP tokens</li>
</ul>

<p>The <code>supports</code> method tells you that <code>LineSearchStrategy</code> needs <code>$pattern</code> to be
a string, but that <code>RegexpSearchStrategy</code> needs an <code>Expression</code> value object.</p>

<p>The responsibility to find a <code>SearchStrategy</code> which supports the given pattern
should be delegated to <code>SearchEngine</code>:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo\Search;

class SearchEngine
{
    private $searchStrategies = array();

    public function registerStrategy(SearchStrategy $searchStrategy)
    {
        $this-&gt;searchStrategies[] = $searchStrategy;
    }

    public function resolve($pattern)
    {
        foreach ($this-&gt;searchStrategies as $searchStrategy) {
            if ($searchStrategy-&gt;supports($pattern)) {
                return $searchStrategy;
            }
        }

        throw new PatternNotSupportedException($pattern);
    }
}
</code></pre>

<p>You no longer need to fork Redaktilo to add new search related behavior, you can
now just create a new implementation of <code>SearchStrategy</code>, register it into
<code>SearchEngine</code> and then inject it into the <code>Editor</code>:</p>

<pre><code class="php">use Gnugat\Redaktilo\Editor;
use Gnugat\Redaktilo\Filesystem;
use Gnugat\Redaktilo\Search\SearchEngine;
use Gnugat\Redaktilo\Search\LineNumberSearchStrategy;
use Gnugat\Redaktilo\Search\LineSearchStrategy;
use Symfony\Component\Filesystem\Filesystem as SymfonyFilesystem;

$searchEngine = new SearchEngine();

$lineSearchStrategy = new LineSearchStrategy();
$searchEngine-&gt;registerStrategy($lineSearchStrategy);

$lineNumberSearchStrategy = new LineNumberSearchStrategy();
$searchEngine-&gt;registerStrategy($lineNumberSearchStrategy);

$symfonyFilesystem = new SymfonyFilesystem();
$filesystem = new Filesystem($symfonyFilesystem);
$editor = new Editor($filesystem, $searchEngine);
</code></pre>

<p>We just made Redaktilo open to extension (still) and closed to modifications,
hooray!</p>

<h2 id="editor%27s-diff">Editor's diff</h2>

<p>Here's what <code>Editor</code> looked like after adding <code>moveDown</code>:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class Editor
{
    public function jumpDownTo(File $file, $pattern)
    {
        $lines = $file-&gt;readlines();
        $filename = $file-&gt;getFilename();
        $currentLineNumber = $file-&gt;getCurrentLineNumber() + 1;
        $length = count($lines);
        while ($currentLineNumber &lt; $length) {
            if ($lines[$currentLineNumber] === $pattern) {
                $file-&gt;setCurrentLineNumber($currentLineNumber);

                return;
            }
            $currentLineNumber++;
        }

        throw new \Exception("Couldn't find line $pattern in $filename");
    }

    public function jumpUpTo(File $file, $pattern)
    {
        $lines = $file-&gt;readlines();
        $filename = $file-&gt;getFilename();
        $currentLineNumber = $file-&gt;getCurrentLineNumber() - 1;
        while (0 &lt;= $currentLineNumber) {
            if ($lines[$currentLineNumber] === $pattern) {
                $file-&gt;setCurrentLineNumber($currentLineNumber);

                return;
            }
            $currentLineNumber--;
        }

        throw new \Exception("Couldn't find line $pattern in $filename");
    }

    public function moveUp(File $file, $lines = 1)
    {
        $newLineNumber = $file-&gt;getCurrentLineNumber() - $lines;

        if ($newLineNumber &lt; 0) {
            $newLineNumber = 0;
        }

        $file-&gt;setCurrentLineNumber($newLineNumber);
    }

    public function has(File $file, $pattern)
    {
        return $file-&gt;hasLine($pattern);
    }
}
</code></pre>

<p>And now, here's what it looks like:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

use Gnugat\Redaktilo\Search\SearchEngine;

class Editor
{
    private $searchEngine;

    public function __construct(SearchEngine $searchEngine)
    {
        $this-&gt;searchEngine = $searchEngine;
    }

    public function jumpDownTo(File $file, $pattern)
    {
        $searchStrategy = $this-&gt;searchEngine-&gt;resolve($pattern);
        $foundLineNumber = $searchStrategy-&gt;findNext($file, $pattern);

        $file-&gt;setCurrentLineNumber($foundLineNumber);
    }

    public function jumpUpTo(File $file, $pattern)
    {
        $searchStrategy = $this-&gt;searchEngine-&gt;resolve($pattern);
        $foundLineNumber = $searchStrategy-&gt;findPrevious($file, $pattern);

        $file-&gt;setCurrentLineNumber($foundLineNumber);
    }

    public function has(File $file, $pattern)
    {
        $searchStrategy = $this-&gt;searchEngine-&gt;resolve($pattern);

        return $searchStrategy-&gt;has($file, $pattern);
    }
}
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>You should be able to add new features without modifying existing code.</p>

<p>I hope you found this article interesting, if you have any questions or
feedback please feel free to do so on <a href="https://twitter.com/epiloic">Twitter</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Redaktilo: because your code too needs an editor]]></title>
            <link href="/2014/05/09/redaktilo.html"/>
            <updated>2014-05-09T00:00:00+01:00</updated>
            <id>/2014/05/09/redaktilo.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>I've been working on a silly library lately:
<a href="https://github.com/gnugat/redaktilo">Redaktilo</a> (it means editor in esperanto).</p>

<p>Redaktilo has been created to fulfill actual needs. In this article we'll see
what it is all about, and why it won't stay silly for long.</p>

<h2 id="use-case-1%3A-yaml-configuration-edition">Use case 1: YAML configuration edition</h2>

<p><a href="https://github.com/Incenteev/ParameterHandler">Incenteev\ParameterHandler</a>
is a good example: it updates a YAML configuration after each update of the
dependencies using <a href="https://getcomposer.org/">Composer</a>.</p>

<p>It uses the
<a href="http://symfony.com/doc/current/components/yaml/introduction.html">Symfony2 Yaml component</a>
which converts a YAML string into a PHP array, and then converts it back.
The problem with it is that it strips empty lines, custom formatting and
comments...</p>

<p>Redaktilo only inserts a new line in the file, leaving it as it is.</p>

<h2 id="use-case-2%3A-json-file-edition">Use case 2: JSON file edition</h2>

<p>The <code>composer.json</code> file is really usefull and can be almost completly edited
using the <code>composer.phar</code> CLI application.</p>

<p>Some part still need manual edition, like the script section. To automate this
you could use <code>json_decode</code> and <code>json_encode</code>, but similarly to the previous use
case you would lose empty lines and custom formatting...</p>

<p>Redaktilo aims at solving this problem, but isn't ready yet: inserting a line
in JSON often means adding a comma at the end of the previous one.</p>

<h2 id="use-case-3%3A-php-source-code-edition">Use case 3: PHP source code edition</h2>

<p>To be fair this use case isn't limited to PHP source code: it can be useful for
any plain text files (text, XML, java, python, anything).</p>

<p><a href="https://github.com/gnugat/GnugatWizardBundle">GnugatWizardBundle</a> automatically
registers new bundles installed using Composer in your Symfony2 application.</p>

<p>To do so it uses
<a href="https://github.com/sensiolabs/SensioGeneratorBundle">SensioGeneratorBundle</a>'s
<a href="https://github.com/sensiolabs/SensioGeneratorBundle/blob/8b7a33aa3d22388443b6de0b0cf184122e9f60d2/Manipulator/KernelManipulator.php">KernelManipulator</a>
to insert a line in the <code>app/AppKernel.php</code>. However this class registers bundles for every
environments, and doesn't take into account bundle which depend on the kernel.</p>

<p>If you take a look at the <a href="https://github.com/sensiolabs/SensioGeneratorBundle/blob/8b7a33aa3d22388443b6de0b0cf184122e9f60d2/Manipulator/KernelManipulator.php">KernelManipulator source code</a>
you'll realise it has been a bit over engineered as it parses PHP tokens.</p>

<p>A new <code>KernelManipulator</code> could be written using Redaktilo as follow:</p>

<pre><code class="php">&lt;?php

namespace Sensio\Bundle\GeneratorBundle\Manipulator;

use Gnugat\Redaktilo\Editor;

class KernelManipulator extends Manipulator
{
    protected $editor;
    protected $appKernelFilename;

    public function __construct(Editor $editor, $appKernelFilename)
    {
        $this-&gt;editor = $editor;
        $this-&gt;appKernelFilename = $appKernelFilename;
    }

    public function addBundle($bundle)
    {
        $file = $this-&gt;editor-&gt;open($this-&gt;appKernelFilename);
        $newLine = sprintf('            new %s(),', $bundle);

        $this-&gt;editor-&gt;jumpDownTo('    public function registerBundles()');
        $this-&gt;editor-&gt;jumpDownTo('        $bundles = array(');
        $this-&gt;editor-&gt;jumpDownTo('        );');

        $this-&gt;editor-&gt;addBefore($file, $newLine);

        $this-&gt;editor-&gt;save($file);

        return true;
    }
}
</code></pre>

<h2 id="usage">Usage</h2>

<p>A great effort has been put to document the project, as you can see in the
<a href="https://github.com/gnugat/redaktilo/#redaktilo">README</a>.</p>

<p>Here's an overview!</p>

<p>You can install Redaktilo using <a href="https://getcomposer.org/">Composer</a>:</p>

<pre><code>composer require "gnugat/redaktilo:~0.3@dev"
</code></pre>

<p>Then you need to create an instance of the <code>Editor</code> class:</p>

<pre><code class="php">&lt;?php
require_once __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\Filesystem;
use Gnugat\Redaktilo\Editor;
use Symfony\Component\Filesystem\Filesystem as SymfonyFilesystem;

$symfonyFilesystem = new SymfonyFilesystem();
$filesystem = new Filesystem($symfonyFilesystem);
$editor = new Editor($filesystem);
</code></pre>

<p><code>Editor</code> is completly stateless, which means you can use the same instance
everywhere in your scripts/applications/libraries.</p>

<p>Let's now have a look at the available classes and their responsibility.</p>

<h2 id="file">File</h2>

<p>The basic idea behind Redaktilo is to provide an object oriented way to
represent files:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class File
{
    public function getFilename();

    public function read();
    public function write($newContent);

    // ...
}
</code></pre>

<p>Once this domain model available, you can build services to manipulate it.</p>

<h2 id="filesystem">Filesystem</h2>

<p>This is the first service available:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class Filesystem
{
    public function open($filename); // Cannot open new files
    public function create($filename); // Cannot create existing files

    public function exists($filename);

    public function write(File $file);
}
</code></pre>

<p>It creates instances of <code>File</code> and write their content in the actual file.</p>

<h2 id="editor">Editor</h2>

<p>Developers should only use the <code>Editor</code> class: it's a facade which provides the
text edition metaphor:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class Editor
{
    // Filesystem operations.
    public function open($filename, $force = false);
    public function save(File $file);

    // Line insertion.
    public function addBefore(File $file, $add);
    public function addAfter(File $file, $add);

    // Content navigation.
    public function jumpDownTo(File $file, $line);
    public function jumpUpTo(File $file, $line);
}
</code></pre>

<p>And that's it.It told you it was a small and simple library ;) . Now let's see
what's planned for the next releases.</p>

<h2 id="version-0.4-should-bring-searchengine">Version 0.4 should bring SearchEngine</h2>

<p>There's still some search logic left in <code>Editor</code>.</p>

<p>To remove it, a whole system will be put in place: <code>SearchEngineCollection</code> will
be called by <code>Editor</code> and will ask its <code>SearchEngine</code>s if they support the
pattern.</p>

<p>This should allow many search strategies:</p>

<ul>
<li>find by line (what's currently done, an exact matching)</li>
<li>find by line number</li>
<li>find by regexp</li>
<li>find by symbol (similar to <a href="http://www.sublimetext.com/">SublimeText</a>'s <code>@</code>)</li>
</ul>

<p>You could then have an extending point!</p>

<h2 id="version-0.5-should-bring-contentconverter">Version 0.5 should bring ContentConverter</h2>

<p>Some extra logic are also left in <code>File</code>, regarding the conversion of the
content into an array of lines.</p>

<p><code>ContentConverter</code> could take a file, and convert its content into anything:</p>

<ul>
<li>an array of lines</li>
<li>an array of <code>IndentedLine</code></li>
<li>PHP tokens</li>
</ul>

<p>This would allow new types of <code>SearchEngine</code>, and maybe the creation of
<code>ContentEditor</code> which would bear the single responsibility of inserting,
replacing or removing bits of it.</p>

<h2 id="i-need-your-humble-opinion-%2F-help">I need your humble opinion / help</h2>

<p>I'd like to hear about more use cases: what would you do with Redaktilo? What
would you like to do with it?</p>

<p>You can <a href="https://github.com/gnugat/redaktilo/issues/new">open issues to start discussions</a>,
just make sure to provide a real life use case ;) .</p>

<h2 id="conclusion">Conclusion</h2>

<p><a href="https://github.com/gnugat/redaktilo">Redaktilo</a> provides an Object Oriented way
to manipulate files, through the editor metaphor:</p>

<ul>
<li>your scripts can open a file</li>
<li>they can then navigate in the file to select a line</li>
<li>next, they can insert a new line above/under the current one</li>
<li>finally they can save the changes on the filesystem</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Bootstrap the markdown files of your FOSS project]]></title>
            <link href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html"/>
            <updated>2014-01-15T00:00:00+00:00</updated>
            <id>/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: Fossil is currently unmaintained.</p>
</blockquote>

<p>The one thing that will make developers use your Free or Open Source Software
(FOSS) project is its documentation. Without it, how can they know what it does,
or how to install it?</p>

<p>Last summer <a href="http://williamdurand.fr/2013/07/04/on-open-sourcing-libraries/">William Durand wrote an article about it</a>,
describing the minimum files your FOSS project should have, and what they should
contain.</p>

<p>After reading his article, maybe you did the same thing as me: you took your
courage with both hands and wrote thoroughly a decent documentation for the
project you were working on at the time.</p>

<p>Because it was tedious, you decided to copy those markdown files into your new
projects and adapt them.</p>

<p>But this too was tedious...</p>

<p>To solve this problem once for all I created <strong><a href="https://github.com/gnugat/fossil">fossil</a></strong>:
it will bootstrap the markdown files of your FOSS projects, and it will even
create an installer for you!</p>

<p>It generates the following files out of skeletons:</p>

<ul>
<li><code>CHANGELOG.md</code></li>
<li><code>CONTRIBUTING.md</code></li>
<li><code>LICENSE</code></li>
<li><code>README.md</code></li>
<li><code>VERSIONING.md</code></li>
<li><code>bin/installer.sh</code></li>
<li><code>doc</code> (or <code>Resources/doc</code> if the project is a bundle) directory:

<ul>
<li><code>01-introduction.md</code></li>
<li><code>02-installation.md</code></li>
<li><code>03-usage.md</code></li>
<li><code>04-tests.md</code></li>
</ul></li>
</ul>

<p>The best thing about it: you can run it on your new FOSS projects as well as
with your existing ones! By default it does not replace existing files (if you
want to, simply use the <code>-f</code> option).</p>

<p><strong>Fossil</strong> supports different kind of projects: applications, libraries and
Symfony2 bundles. Here's a quick usage guide.</p>

<h2 id="applications">Applications</h2>

<p>The <code>doc</code> command allows you to generate the markdown files of your
applications, which can be a web application or a CLI tool just like <strong>fossil</strong>.</p>

<p>As you can see in the following example, it only requires 2 arguments:</p>

<pre><code>fossil doc 'acme/application' 'The ACME company'
</code></pre>

<h3 id="the-github-repository-argument">The <a href="https://github.com/">Github</a> repository argument</h3>

<p>Applications are installed by cloning the github repository, which makes it as
easy to update as to run <code>git pull</code>.</p>

<p>This argument is used in the installer script as well as in the installation
instructions.</p>

<p>You don't need to write the whole github URL, simply give the username and the
project name in the following format: <code>username/project-name</code></p>

<h3 id="the-license-author-argument">The license author argument</h3>

<p>While the copyright's date can be computed, you need to provide the author's
name to generate the <code>LICENSE</code> file.</p>

<p>For now it only generates MIT licenses, but pull requests are welcomed :) .</p>

<h3 id="the-path-option">The path option</h3>

<p>By default the files are created in the current directory, but you can target a
specific path:</p>

<pre><code>fossil doc 'acme/application' 'The ACME company' -p '/tmp/application'
</code></pre>

<h3 id="the-force-overwrite-option">The force overwrite option</h3>

<p>As mentioned earlier, <strong>fossil</strong> won't replace existing files by default: for
instance if your project already has a <code>README.md</code> and a <code>LICENSE</code> file it will
only generate the other ones.</p>

<p>But if you want to throw them away, you can use this option:</p>

<pre><code>fossil doc 'acme/project' 'The ACME company' -f
</code></pre>

<h2 id="libraries">Libraries</h2>

<p>The <code>doc:library</code> command has the exact same arguments and options as the <code>doc</code>
one:</p>

<pre><code>fossil doc:library 'acme/library' 'The ACME company'
</code></pre>

<p>You can use the shortcut <code>d:l</code>:</p>

<pre><code>fossil d:l 'acme/library' 'The ACME company'
</code></pre>

<p>The difference between an application and a library lies in its installation:
the library is installed using <a href="http://getcomposer.org/">composer</a>.</p>

<h3 id="the-composer-package-option">The composer package option</h3>

<p>By default <strong>fossil</strong> assumes the composer package's name is the same as the
Github repository name (in the example it would be <code>acme/library</code>).
If it's not your case, use the following option:</p>

<pre><code>fossil d:l 'acme/library' 'The ACME company' -c 'acme/composer-package'
</code></pre>

<h2 id="symfony2-bundles">Symfony2 Bundles</h2>

<p>The <code>doc:bundle</code> command has almost the same arguments and options as the
<code>doc:library</code> one. It has an additional argument:</p>

<pre><code>fossil doc:bundle 'acme/demo-bundle' 'The ACME company' 'Acme\DemoBundle\AcmeDemoBundle'
</code></pre>

<p>You can use the shortcut <code>d:b</code>:</p>

<pre><code>fossil d:b 'acme/demo-bundle' 'The ACME company' 'Acme\DemoBundle\AcmeDemoBundle'
</code></pre>

<p>The difference between a library and a bundle is the documentation directory,
which is in <code>Resources/doc</code> instead of <code>doc</code>.</p>

<h3 id="the-fully-qualified-classname-argument">The fully qualified classname argument</h3>

<p>Another difference is the installation: the bundle needs to be added in the
application's kernel.</p>

<p>This will be detailed in the documentation, but it will also be taken care of
by the installer.</p>

<p>That's right, you read it right: when developers will run the installer, not
only will it download the bundle using composer, but it will also add its fully
qualified classname in the <code>app/AppKernel.php</code> file! Hooray!</p>

<p>The application's kernel will look like this afterwards:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            // Other bundles...
            new Acme\DemoBundle\AcmeDemoBundle(),
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            // Other bundles...
        }

        return $bundles;
    }
}
</code></pre>

<p><em>Note</em>: because of the backslashes you should escape this argument using
quotes, just like in the example.</p>

<h3 id="the-development-tool-option">The development tool option</h3>

<p>By using this option, the bundle will be registered in the application only if
it runs in development or test environment:</p>

<pre><code>fossil d:b 'acme/demo-bundle' 'The ACME company' 'Acme\DemoBundle\AcmeDemoBundle' -d
</code></pre>

<p>The application's kernel will look like this afterwards:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            // Other bundles...
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            // Other bundles...
            $bundles[] = new Acme\DemoBundle\AcmeDemoBundle();
        }

        return $bundles;
    }
}
</code></pre>

<h2 id="you-still-need-to-write-the-documentation">You still need to write the documentation</h2>

<p>After running <strong>fossil</strong> you still need to provide some information (for
instance the elevator pitch in <code>README.md</code>) by editing those files:</p>

<ul>
<li><code>README.md</code></li>
<li><code>doc/01-introduction.md</code></li>
<li><code>doc/03-usage.md</code></li>
<li><code>doc/04-tests.md</code></li>
</ul>

<p>But is that enough? While I think <strong>fossil</strong> automates as much things as
possible, there's still some part of your project that needs specific
documentation.</p>

<p>For example you could add recipes which describe common tasks, or a glossary
defining technical or business terms used in your project.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Bootstrap the markdown files of your new and your old FOSS projects using
<strong><a href="https://github.com/gnugat/fossil">fossil</a></strong>, and then complete the
documentation so everyone can see how awesome your work is!</p>

<p>Happy hacking!</p>
]]></content>
        </entry>
    </feed>