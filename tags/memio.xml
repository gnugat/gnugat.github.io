<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2023-04-19T12:49:38+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[SpecGen v0.3]]></title>
            <link href="/2015/05/28/spec-gen-0-3.html"/>
            <updated>2015-05-28T00:00:00+01:00</updated>
            <id>/2015/05/28/spec-gen-0-3.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> v0.3 inserts a property for each constructor argument.</p>
</blockquote>

<p>SpecGen is a <a href="http://phpspec.net">phpspec</a> extension which enhance its code generator.
With the latest release, v0.3, we get the following features:</p>

<ul>
<li>method generation:

<ul>
<li>it inserts method at the end of the class</li>
<li>it typehints object, array and callable arguments</li>
<li>it names object arguments after their type</li>
<li>it names scalar arguments after a generic name (<code>argument</code>)</li>
<li>it adds number on names that could collide (e.g. <code>$argument1, $argument2</code>)</li>
</ul></li>
<li>constructor generation, same as method except:

<ul>
<li>it inserts constructor at the begining of the class</li>
<li>it inserts properties with initialization for each constructor arguments</li>
</ul></li>
</ul>

<p>Here's a simple example to demonstrate how helpful it can be.</p>

<h2 id="example">Example</h2>

<p>First of all, we need to set up a project with <a href="https://getcomposer.org/download">Composer</a>.
Let's write the following <code>composer.json</code>:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>Then we can install phpspec with SpecGen by running those commands:</p>

<pre><code>composer require --dev phpspec/phpspec:~2.2
composer require --dev memio/spec-gen:~0.3
echo 'extensions:' &gt; phpspec.yml
echo '  - Memio\SpecGen\MemioSpecGenExtension' &gt;&gt; phpspec.yml
</code></pre>

<p>In our example, we'll specify a <code>TextEditor</code> service, it should be able to
create new files by relying on <code>Filesystem</code>, another service.</p>

<p>This can be done as follow:</p>

<pre><code>phpspec describe 'Vendor\Project\TextEditor'
````

&gt; **Tip**: make your vendor's binaries available by adding `vendor/bin` to your `$PATH`.
&gt; `export PATH="vendor/bin:$PATH"`.

This should generate a `spec\Vendor\Project\TextEditorSpec.php` file:

```php
&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class TextEditorSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\TextEditor');
    }
}
</code></pre>

<p>It needs to be edited to fit our needs:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_creates_new_files(File $file, Filesystem $filesystem)
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>The Test Driven Development cycle advises us to run the test suite now:</p>

<pre><code>phpspec run
</code></pre>

<p>This will bootstrap the following code:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open($argument1, $argument2)
    {
    }
}
</code></pre>

<p>It created a <code>filesystem</code> property to mirror the constructor arguments. Neat!</p>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>In our example phpspec also generated the collaborators (<code>File</code> and <code>Filesystem</code>).
These don't beneficiate from SpecGen help yet, so the next release (v0.4) will
probably be about using it for collaborators.</p>

<p>Other features that could be implemented would be PHPdoc generation, or avoiding the
<code>Interface</code> / <code>Abstract</code> suffix/prefix in interface and abstract object argument names.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[SpecGen v0.2]]></title>
            <link href="/2015/05/20/spec-gen-0-2.html"/>
            <updated>2015-05-20T00:00:00+01:00</updated>
            <id>/2015/05/20/spec-gen-0-2.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> v0.2 inserts use statements.</p>
</blockquote>

<p>SpecGen v0.2 has been released, it introduces a small change: use statement insertion.</p>

<h2 id="it-inserts-use-statements">It inserts use statements</h2>

<p>Let's go back to the sources of the example used in the <a href="/2015/05/13/memio-spec-gen.html">previous article</a>
and clean it a little bit:</p>

<pre><code>rm -rf src
</code></pre>

<p>Given the following specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Message\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Message\Response');
    }
}
</code></pre>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following file, with a use statement:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Message\Request;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="it-doesn%27t-insert-use-statements-twice">It doesn't insert use statements twice</h2>

<p>Given the following new step in our specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Message\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Message\Response');
    }

    function it_supports_request(Request $request)
    {
        $this-&gt;supports($request)-&gt;shouldBe(true);
    }
}
</code></pre>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following file, without new use statements:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Message\Request;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }

    public function supports(Request $request)
    {
    }
}
</code></pre>

<h2 id="it-doesn%27t-insert-use-statement-for-same-namespace">It doesn't insert use statement for same namespace</h2>

<p>Let's clear everything:</p>

<pre><code>rm -rf src
</code></pre>

<p>Given the following specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <code>Request</code> and <code>RequestHandler</code> are both in the same namespace.</p>
</blockquote>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following, without any use statements:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="behind-the-hood">Behind the hood</h2>

<p>This small feature was the occasion to refactor SpecGen a bit! This resulted in the
introduction of <code>CodeEditor</code>, a facade for a home made <code>CommandBus</code> and for
<a href="http://gnugat.github.io/redaktilo">Redaktilo</a>'s <code>Editor</code>.</p>

<p>With these, the code to generate a method and insert a use statement looks like this:</p>

<pre><code class="php">$file = $this-&gt;codeEditor-&gt;open($fileName);
$this-&gt;codeEditor-&gt;handle(new InsertUseStatements($file, $fullyQualifiedNames));
$this-&gt;codeEditor-&gt;handle(new InsertMethod($file, $method));
$this-&gt;codeEditor-&gt;save($file);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>While some improvements can still be done (use statements in alphabetical order,
typehint interfaces only), the version 0.3 will mainly be about the introduction
of a new generator: insertion of properties when the method is a constructor.</p>

<p>Stay tuned!</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio SpecGen v0.1]]></title>
            <link href="/2015/05/13/memio-spec-gen.html"/>
            <updated>2015-05-13T00:00:00+01:00</updated>
            <id>/2015/05/13/memio-spec-gen.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> is a <a href="http://phpspec.net">phpspec</a>
  extension that improves its code generator. Currently available: type hinted method arguments.</p>
</blockquote>

<p>With <a href="http://memio.github.io/memio">Memio v1.0 released</a>, it is now possible to
create powerful code generators without re-inventing the wheel.
<a href="http://github.com/memio/spec-gen">SpecGen</a> is the first project to use this library, let's
see what it can do for us.</p>

<h2 id="phpspec">phpspec</h2>

<p>First of all we'll talk about <a href="http://phpspec.net">phpspec</a>, which is an exciting
project that provides many benefits:</p>

<ul>
<li>a testing tool (allows to write specifications, which are kind of unit tests)</li>
<li>a "best practice" enforcer (for e.g. cannot test private methods to force us to split code into smaller public APIs)</li>
<li>a time saver (bootstraps tests and code)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: See <a href="http://techportal.inviqa.com/2014/09/11/my-top-ten-favourite-phpspec-limitations/">My top 10 favourite phpsepc limitations</a>.</p>
</blockquote>

<p>It makes Test Driven Development cycles even more meaningful:</p>

<ol>
<li>bootstrap test by thinking on a class name</li>
<li>write a test by thinking how the class should behave</li>
<li>bootstrap the corresponding code by running the whole test suite</li>
<li>write code as quick as possible without thinking about best practices or design patterns (be pragmatic)</li>
<li>run the test suite to check if the code fulfills the test's specifications</li>
<li>refactor the code (manage the technical debt)</li>
<li>run the test suite to check for regressions</li>
<li>repeat!</li>
</ol>

<p>phpspec's code generator is a big part of its value. Let's see if we can improve it.</p>

<h2 id="phpspec-example">phpspec example</h2>

<p>Let's have a look at how phpspec works. For this we'll need to have a project configured with
<a href="https://getcomposer.org/download">Composer</a>:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>We can install phpspec with the following:</p>

<pre><code>composer require --dev phpspec/phpspec:~2.2
</code></pre>

<p>Let's say we want to create a class that handles requests, conforming to the HTTP protocol
(take a <code>Request</code>, return a <code>Response</code>). We can call this class <code>RequestHandler</code>:</p>

<pre><code>phpspec describe 'Vendor\Project\RequestHandler'
</code></pre>

<blockquote>
  <p><strong>Tip</strong>: make your vendor's binaries available by adding <code>vendor/bin</code> to your <code>$PATH</code>.
  <code>export PATH="vendor/bin:$PATH"</code>.</p>
</blockquote>

<p>We should now have the <code>spec/Vendor/Project/RequestHandlerSpec.php</code> file, bootstraped
for us by phpspec:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\RequestHandler');
    }
}
</code></pre>

<p>We can directly start by writing our first specification (test method) in it:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response(Request $request)
    {
        $this-&gt;handle($request)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We tried to make the test method as descriptive as possible (e.g. not <code>testHandler()</code>).
  This is the whole point of specBDD (specification Behavior Driven Development).</p>
</blockquote>

<p>With this we can start to boostrap the code by simply running the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>It will ask the following 3 questions:</p>

<ol>
<li>Would you like me to generate an interface <code>Vendor\Project\Request</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\RequestHandler</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\RequestHandler::handle()</code> for you?</li>
</ol>

<p>By accepting everytime, phpspec will bootstrap the following
<code>src/Vendor/Project/Vendor/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{

    public function handle($argument1)
    {
        // TODO: write logic here
    }
}
</code></pre>

<p>In our specification, we make use of a non existing <code>Request</code> class, and phpspec
also bootstraped it for us in <code>src/Vendor/Project/Vendor/Request.php</code>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

interface Request
{
}
</code></pre>

<p>This is extremely usefull to kickstart our TDD cycle!</p>

<h2 id="memio-specgen">Memio SpecGen</h2>

<p>SpecGen is a phpspec extension, it makes use of Memio (the PHP code generator library)
to make the above bootstraping even more awesome.</p>

<p>Here's how to install it:</p>

<pre><code>composer require --dev memio/spec-gen:~0.1
</code></pre>

<p>We also need to register it as a phpspec extension by writing the following <code>phpspec.yml</code> file:</p>

<pre><code>extensions:
  - Memio\SpecGen\MemioSpecGenExtension
</code></pre>

<p>Its first release, v0.1 (unstable for now), improves the method generation with:</p>

<ul>
<li>type hinted arguments</li>
<li>object arguments named after their type</li>
<li>putting each arguments on their own lines if the inline alternative would have been longer than 120 characters</li>
</ul>

<p>To be fair, this is exactly what already <a href="https://ciaranmcnulty.com/">Ciaran McNulty</a>'s
<a href="https://github.com/ciaranmcnulty/phpspec-typehintedmethods">Typehinted Methods extension</a>
provides, so why would we choose SpecGen? Well simply because it intends to do much more:</p>

<ul>
<li>insertion of <code>use</code> statements</li>
<li>constructor generation (each argument will have a corresponding property and a property initialization)</li>
<li>PHPdoc</li>
<li>???</li>
<li>profit!</li>
</ul>

<h2 id="memio-specgen-example">Memio SpecGen example</h2>

<p>Let's give it a try by first removing the code we boostrapped until now:</p>

<pre><code>rm -rf src
</code></pre>

<p>In order to demonstrate more type hints, we'll add more arguments:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<p>We can now run the test suite to bootstrap the code:</p>

<pre><code>phpspec run
</code></pre>

<p>This should create the following <code>src/Vendor/Project/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: for now <code>use</code> statements aren't generated. In our example it doesn't
  matter since <code>Request</code> is in the same namespace as <code>RequestHandler</code>.</p>
</blockquote>

<p>Let's remove again the generated code:</p>

<pre><code>rm -rf src
</code></pre>

<p>Now we'd like to see this multiline feature by adding many arguments to our specifiction:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response()
    {
        $this-&gt;myMethod(1, 2, 3, 4, 5, 6, 7, 8);
    }
}
</code></pre>

<p>Again, we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>This should bootstrap the following <code>src/Vendor/Project/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function myMethod(
        $argument1,
        $argument2,
        $argument3,
        $argument4,
        $argument5,
        $argument6,
        $argument7,
        $argument8
    )
    {
    }
}
</code></pre>

<p>And that's it!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio SpecGen improves phpspec's generator by adding better named, type hinted
and PSR-2 compliant method arguments.</p>

<p>Note that this kind of improvement has to be done in extension. They cannot be
done directly in phpspec because it tries to enforce best practices, and one of
them is to type hint only against interfaces. As it happens, the current extensions
can also type hint against implementations, depending on how the developers write
their specifications.</p>

<p>The next versions will bring even more exciting features, such as constructor and PHPdoc
generation.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio v1.0]]></title>
            <link href="/2015/05/06/memio.html"/>
            <updated>2015-05-06T00:00:00+01:00</updated>
            <id>/2015/05/06/memio.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://memio.github.io/memio">Memio</a> is a PHP code generator library,
  the main repository provides integration with Twig templates, but by using the
  smaller package <code>pretty-printer</code> on its own it is possible to be decoupled from any template engines.</p>
</blockquote>

<p><a href="http://memio.github.io/memio">Memio</a> has finally be released in version 1.0 (stable).
In this article, we'll see how the different packages are assembled in the main repository.</p>

<h2 id="standard-edition">Standard Edition</h2>

<p>Memio is composed of small packages (<code>linter</code>, <code>model</code>, <code>pretty-printer</code>, <code>twig-template-engine</code>, <code>validator</code>),
the main repository (<a href="http://gituhb.com/memio/memio">memio/memio</a>) is a standard selection of those
to make their usage easier:</p>

<p><img src="http://yuml.me/8686d889" alt="Package diagram" /></p>

<p>It can be installed using <a href="http://getcomposer.com/">Composer</a>:</p>

<pre><code>composer require memio/memio:~1.0
</code></pre>

<p>It provides two services, which can be instanciated as follow:</p>

<pre><code class="php">&lt;?php
// File: memio.php

require __DIR__.'/vendor/autoload.php';

use Memio\Memio\Config\Build;

$linter = Build::linter();
$prettyPrinter = Build::prettyPrinter();
</code></pre>

<p>To see how to use them, let's describe a request handler method:</p>

<pre><code class="php">// ...

use Memio\Model\Method;
use Memio\Model\Argument;

$handle = Method::make('handle')
    -&gt;addArgument(Argument::make('Request', 'request'))
    -&gt;addArgument(Argument::make('int', 'type')
        -&gt;setDefaultValue('self::MASTER_REQUEST')
    )
    -&gt;addArgument(Argument::make('bool', 'catch')
        -&gt;setDefaultValue('true')
    )
;
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Each Model can be constructed using <code>new</code> or the static constructor <code>make</code>.
  The last one has the advantage to allow method chaining (e.g. <code>Method::make('doHandle')-&gt;makePrivate()</code>).</p>
</blockquote>

<p>We can lint this model:</p>

<pre><code class="php">// ...

$linter-&gt;validate($handler); // @throws Memio\Validator\Exception\InvalidModelException if the model contains syntax errors.
</code></pre>

<p>And we can generate the corresponding PHP code:</p>

<pre><code class="php">// ...

$generatedCode = $prettyPrinter-&gt;generateCode($handle);
</code></pre>

<p>We can check in our console's output the result:</p>

<pre><code class="php">// ...

echo $generatedCode;
</code></pre>

<p>This should print:</p>

<pre><code class="php">    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
    {
    }
</code></pre>

<h2 id="limitations">Limitations</h2>

<p>Currently it is possible to describe:</p>

<ul>
<li>a File (License header, use statements)</li>
<li>a Class (abstract, final, with parents, PHPdoc) or an Interface (with parents, PHPdoc)</li>
<li>a class Constant</li>
<li>a class Property (static, default value, PHPdoc)</li>
<li>a class Method (static, abstract, final, visibility, PHPdoc)</li>
<li>a method Argument (typehint, default value)</li>
</ul>

<p>It is possible to describe a method Body, but only with a string:</p>

<pre><code class="php">// ...

$handle-&gt;setBody(&lt;&lt;&lt;BODY
        try {
            $this-&gt;requestHandler-&gt;handle($request);
        } catch (\Exception $e) {
            if (!$catch) {
                throw $e;
            }
        }
BODY
);
</code></pre>

<h2 id="use-cases">Use cases</h2>

<p>In real life, models wouldn't be built manually as in the above examples. They would
be built dynamically:</p>

<pre><code class="php">// ...

array_shift($argv); // remove binary name (php)
array_shift($argv); // remove script name (memio.php)
$methodName = array_shift($argv); // first argument = method name
$arguments = $argv; // all other arguments = argument types (e.g. `int`, `bool`, `DateTime`, etc)

$method = new Method($methodName);
$index = 1;
foreach ($arguments as $argumentType) {
    $argumentName = 'argument'.$index++;
    $method-&gt;addArgument(new Argument($argumentType, $argumentName));
}

echo $prettyPrinter-&gt;generatedCode($method);
</code></pre>

<p>Have a try by running <code>php memio.php handle Request int bool</code>, it should print the following:</p>

<pre><code class="php">    public function handle(Request $argument1, $argument2, $argument3)
    {
    }
</code></pre>

<p>With this we can already improve <a href="http://phpspec.net">phpspec</a> generator (generate typehinted arguments, PHPdoc, etc).
This is going to be the next Memio package, a phpspec extension.</p>

<h2 id="extension-points">Extension points</h2>

<p>The coding style can be changed by creating our custom templates. Those can be loaded as follow:</p>

<pre><code class="php">// ...

$prettyPrinter-&gt;addTemplatePath(__DIR__.'/our-custom-templates-dir');
</code></pre>

<p>Custom constraints can be written to check more things, for example we can ensure
that arguments are always object.</p>

<p>Those steps, just like the rest, are heavily described in the official <a href="http://memio.github.io/memio">documentation</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio is a library that provides a PHP Code Generator:</p>

<ol>
<li>First we describe what we want by building <code>Models</code> (e.g. <code>new Method('__construct')</code>)</li>
<li>Optionally we can <code>Lint</code> them to check if we introduced syntax errors (e.g. <code>Method cannot be both abstract and final</code>)</li>
<li>Then we use a <code>PrettyPrinter</code> to get the generated code (returns a string, can be displayed on the output or saved in a file, etc)</li>
</ol>

<p>You can read more about it with the following articles:</p>

<ul>
<li><a href="/2015/04/08/introducing-memio-code-generator.html">Introducing Memio</a></li>
<li><a href="/2015/04/15/memio-models.html">Memio Models</a></li>
<li><a href="/2015/04/22/memio-validator-linter.html">Memio Validator and Linter</a></li>
<li><a href="/2015/04/29/memio-pretty-printer.html">Memio PrettyPrinter and TwigTemplateEngine</a></li>
</ul>

<p>It also has an <a href="http://memio.github.io/memio">official documentation</a>.</p>

<p>The next step is to create a <a href="http://phpspec.net">phpspec</a> extension to improve its
code generator.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio Pretty Printer]]></title>
            <link href="/2015/04/29/memio-pretty-printer.html"/>
            <updated>2015-04-29T00:00:00+01:00</updated>
            <id>/2015/04/29/memio-pretty-printer.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/pretty-printer">PrettyPrinter</a> converts a
  <a href="http://github.com/memio/model">Model</a> into its PHP code (returns a string),
  using <a href="http://twig.sensiolabs.org/">Twig templates</a>.</p>
</blockquote>

<p>Until now we've seen how to build Memio <a href="http://github.com/memio/model">Models</a>
to describe PHP code and how to <a href="http://github.com/memio/validator">validate</a>
the <a href="http://github.com/memio/linter">syntax</a>.</p>

<p>It's now time to take things seriously with the newly released package:
<a href="http://github.com/memio/pretty-printer">PrettyPrinter</a>, the actual code generator.</p>

<h2 id="what-is-a-pretty-printer%3F">What is a pretty printer?</h2>

<p>As opposed to "fidelity printers" which are supposed to generate code according to
the developer's coding style, "pretty printer" rely on their own.</p>

<p>If we were to open an existing PHP file with Memio and then to generate it again immediately,
chances are that the code would look slightly different.</p>

<blockquote>
  <p><strong>Note</strong>: Memio actually complies to <a href="http://www.php-fig.org/psr/">PHP standards</a>,
  with some extra rules.</p>
</blockquote>

<p>The name "printer" is a bit misleading: one could think that the service would
print the generated code in the console's output or a web page, but all it really
does is to return a simple string.</p>

<blockquote>
  <p><strong>Note</strong>: The terminology used is inspired by this <a href="http://stackoverflow.com/a/5834775/3437428">StackOverflow answer</a>.</p>
</blockquote>

<h2 id="template-engine-agnostic">Template engine agnostic</h2>

<p>Memio makes use of templates, making it easy to change the style. It defines a
<code>TemplateEngine</code> interface that has to be implemented, in order to comply with
<a href="http://webmozarts.com/">webmozart</a>'s <a href="https://github.com/memio/memio/issues/51">request</a>.</p>

<p>For now the only package available is <a href="http://github.com/memio/twig-template-engine">TwigTemplateEngine</a>,
it provides <a href="http://twig.sensiolabs.org/">Twig templates</a>.</p>

<h2 id="code-generation-example">Code generation example</h2>

<p>Enough talk, let's code! First of all we have to create our <code>PrettyPrinter</code>:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

$loader = new \Twig_Loader_Filesystem(\Memio\TwigTemplateEngine\Config\Locate::templates());
$twig = new \Twig_Environment($loader);

$line = new \Memio\TwigTemplateEngine\TwigExtension\Line\Line();
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\ContractLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\FileLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\MethodPhpdocLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\ObjectLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\StructurePhpdocLineStrategy());

$twig-&gt;addExtension(new \Memio\TwigTemplateEngine\TwigExtension\Type());
$twig-&gt;addExtension(new \Memio\TwigTemplateEngine\TwigExtension\Whitespace($line));

$templateEngine = new \Memio\TwigTemplateEngine\TwigTemplateEngine($twig);
$prettyPrinter = new \Memio\PrettyPrinter\PrettyPrinter($templateEngine);
</code></pre>

<p>Wow! That was quite painful to write! Thankfully the next package to be released
will make life really easier (spoiler alert: <code>Build::prettyPrinter()</code>).</p>

<p>Now let's build some models:</p>

<pre><code class="php">// ...

$myMethod = new \Memio\Model\Method('myMethod');
for ($i = 1; $i &lt; 10; $i++) {
    $myMethod-&gt;addArgument(new \Memio\Model\Argument('mixed', 'argument'.$i));
}
</code></pre>

<p>All it takes to generate the code is this:</p>

<pre><code class="php">// ...

$generatedCode = $prettyPrinter-&gt;generateCode($myMethod);
</code></pre>

<p>Let's see in the console output what it did:</p>

<pre><code class="php">// ...

echo $generatedCode;
</code></pre>

<p>We should get the following:</p>

<pre><code class="php">    public function myMethod(
        $argument1,
        $argument2,
        $argument3,
        $argument4,
        $argument5,
        $argument6,
        $argument7,
        $argument8,
        $argument9
    )
    {
    }
</code></pre>

<p>Each arguments are displayed on their own line, because the inline equivalent
would have been longer than 120 characters.</p>

<h2 id="custom-templates">Custom templates</h2>

<p>Memio has extra rules regarding coding standards, for example it adds an empty
line between the PHP opening tag and the namespace statement.</p>

<p>We can get rid of this by creating our own custom template: first we copy the <code>file.twig</code>
template in our project:</p>

<pre><code>
{#- File: my_templates/file.twig -#}
&lt;?php
{% if file.licensePhpdoc is not empty %}

{% include 'phpdoc/license_phpdoc.twig' with { 'license_phpdoc': file.licensePhpdoc } only %}
{% endif %}
namespace {{ file.namespace }};

{% include 'collection/fully_qualified_name_collection.twig' with {
    'fully_qualified_name_collection': file.allFullyQualifiedNames
} only %}
{% if needs_line_after(file, 'fully_qualified_names') %}

{% endif %}
{% if file.structure is contract %}
{% include 'contract.twig' with { 'contract': file.structure } only %}
{% else %}
{% include 'object.twig' with { 'object': file.structure } only %}
{% endif %}

</code></pre>

<p>We've removed the line between <code>{% endif %}</code> and <code>namespace {{ file.namespace }};</code>.</p>

<p>In order for our custom template to be used, we'll need to add its directory path to <code>PrettyPrinter</code>:</p>

<pre><code class="php">// ...

$prettyPrinter-&gt;addTemplatePath(__DIR__.'/my_templates');
</code></pre>

<p>And we're done!</p>

<p>Let's check the result:</p>

<pre><code class="php">// ...

$file = \Memio\Model\File::make('src/Vendor/Project/MyClass.php')
    -&gt;setStructure(new \Memio\Model\Object('Vendor\Project\MyClass'))
;

echo $prettyPrinter-&gt;generateCode($file);
</code></pre>

<p>This will output:</p>

<pre><code class="php">&lt;?php
namespace Vendor\Project;

class MyClass
{
}
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>PrettyPrinter can convert Models into PHP code, it uses templates behind the scene
so we can tweak the coding style our way. It isn't tied to any Template Engine,
but we can install Memio's TwigTemplateEngine package .</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio validator and linter]]></title>
            <link href="/2015/04/22/memio-validator-linter.html"/>
            <updated>2015-04-22T00:00:00+01:00</updated>
            <id>/2015/04/22/memio-validator-linter.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Write <a href="http://github.com/memio/validator">constraints</a> to check
  <a href="http://github.com/memio/model">models</a> integrity.
  <a href="http://github.com/memio/linter">Linter</a> constraints (e.g. syntax error) are already available.</p>
</blockquote>

<p>Everyday Memio, the higly opinionated PHP code generation library, progresses
toward its stable release.</p>

<p>In this article, we'll have a look at two packages that have been freshly extracted:
<code>memio/validator</code> and <code>memio/linter</code>.</p>

<h2 id="writing-constraints">Writing constraints</h2>

<p>The <a href="http://github.com/memio/validator">validator</a> packages provides an easy way
to write constraints. Let's write one to check that method arguments are never scalar.</p>

<blockquote>
  <p><strong>Note</strong>: This is one of the principle in <a href="http://williamdurand.fr/2013/06/03/object-calisthenics">object calisthenics</a>:
  <a href="http://williamdurand.fr/2013/06/03/object-calisthenics/#3-wrap-all-primitives-and-strings">wrap all primitives and string</a>.</p>
</blockquote>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Memio\Validator\Constraint;
use Memio\Validator\Violation\NoneViolation;
use Memio\Validator\Violation\SomeViolation;

class ArgumentCannotBeScalar implements Constraint
{
    public function validate($model)
    {
        $type = $model-&gt;getType();
        if (in_array($type, array('array', 'bool', 'callable', 'double', 'int', 'mixed', 'null', 'resource', 'string'), true)) {
            return new SomeViolation(sprintf('Argument "%s" cannot be scalar', $model-&gt;getName()));
        }

        return new NoneViolation();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Naming constraints after their error message allow for better reability.</p>
</blockquote>

<p>The next step is to register our constraint in a validator. Since our constraint
aims <code>Argument</code> models, we'll register it in an <code>ArgumentValidator</code>:</p>

<pre><code class="php">// ...

use Memio\Validator\ModelValidator\ArgumentValidator;

$argumentValidator = new ArgumentValidator();
$argumentValidator-&gt;add(new ArgumentCannotBeScalar());
</code></pre>

<p>When building models, <code>Arguments</code> are burried in <code>Methods</code>, which themselves are burried in
<code>Contracts</code> or <code>Objects</code> which in turn are burried in <code>File</code>.</p>

<p>To make things easy, we'd like to simply give the top most model (e.g. <code>File</code>) to
a generic <code>Validator</code>. Its responsibility would be to go through each models and execute
the appropriate <code>ModelValidator</code>.</p>

<p>In order to do so, we have to create all <code>ModelValidators</code> and assemble them as follow:</p>

<pre><code class="php">// ...

use Memio\Validator\ModelValidator\CollectionValidator;
use Memio\Validator\ModelValidator\ContractValidator;
use Memio\Validator\ModelValidator\FileValidator;
use Memio\Validator\ModelValidator\MethodValidator;
use Memio\Validator\ModelValidator\ObjectValidator;

$collectionValidator = new CollectionValidator();
$methodValidator = new MethodValidator($argumentValidator, $collectionValidator);
$contractValidator = new ContractValidator($collectionValidator, $methodValidator);
$objectValidator = new ObjectValidator($collectionValidator, $methodValidator);
$fileValidator = new FileValidator($contractValidator, $objectValidator);
</code></pre>

<p>Finally, we need to create a validator and register our <code>ModelValidators</code> in it:</p>

<pre><code class="php">// ...

use Memio\Validator\Validator;

$calisthenicValidator = new Validator();
$calisthenicValidator-&gt;add($argumentValidator);
$calisthenicValidator-&gt;add($collectionValidator);
$calisthenicValidator-&gt;add($methodValidator);
$calisthenicValidator-&gt;add($contractValidator);
$calisthenicValidator-&gt;add($objectValidator);
$calisthenicValidator-&gt;add($fileValidator);
</code></pre>

<p>We can now validate our Models:</p>

<pre><code class="php">// ...

$calisthenicValidator-&gt;validate($file); // @throws Memio\Validator\InvalidModelException if one or more constraint fail
</code></pre>

<p>The <code>InvalidModelException</code>'s message has one line per violation.</p>

<h2 id="linter">Linter</h2>

<p>Out of the box, Memio provides a <a href="http://github.com/memio/linter">Linter</a> which
provides the following constraints:</p>

<ul>
<li>Collection cannot have name duplicates</li>
<li>Concrete Object Methods cannot be abstract</li>
<li>Contract Methods can only be public</li>
<li>Contract Methods cannot be final</li>
<li>Contract Methods cannot be static</li>
<li>Contract Methods cannot have a body</li>
<li>Method cannot be abstract and have a body</li>
<li>Method cannot be both abstract and final</li>
<li>Method cannot be both abstract and private</li>
<li>Method cannot be both abstract and static</li>
<li>Object Argument can only default to null</li>
</ul>

<p>As we've seen above, constructing and assembling constraints and validators can be quite
tiresome.</p>

<p>That's where <code>memio/memio</code>, the main central repository, starts to be useful by
providing a simple way to get a ready to use linter:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Memio\Memio\Config\Build;

$linter = Build::linter();

$linter-&gt;validate($file); // @throws Memio\Validator\InvalidModelException if one or more constraint fail
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Validator allows the creation of custom constraint to ensure that the build Models
are valid. Linter is a set of constraints ready to use, allowing to prevent syntax errors
(e.g. a method cannot be both final and abstract).</p>

<p>If you'd like to find out more about Memio Validator, have a look at the documentation:</p>

<ul>
<li><a href="http://memio.github.io/memio/doc/03-validation-tutorial.html">Validator Tutorial</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio models]]></title>
            <link href="/2015/04/15/memio-models.html"/>
            <updated>2015-04-15T00:00:00+01:00</updated>
            <id>/2015/04/15/memio-models.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Describe code by building <a href="http://github.com/memio/model">models</a>.</p>
</blockquote>

<p>Memio is a highly opinionated PHP code generation library, its version 1.0.0 (stable)
is going to be released soon: currently the main package <code>memio/memio</code> is being
split into smaller packages.</p>

<p>In this article, we'll have a look at the very first package to be ready: <code>memio/model</code>.</p>

<h2 id="describing-code">Describing code</h2>

<p>Let's have a look at the following method:</p>

<pre><code class="php">    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
    {
    }
</code></pre>

<p>We have many things here:</p>

<ul>
<li>a method named <code>handle</code> which is:

<ul>
<li>public</li>
<li>non static</li>
<li>non final</li>
<li>non abstract</li>
</ul></li>
</ul>

<p>It has the following arguments:</p>

<ul>
<li>a <code>Request</code> object named <code>request</code></li>
<li>an integer named <code>type</code> which defaults to <code>self::MASTER_REQUEST</code></li>
<li>a boolean named <code>catch</code> which defaults to <code>true</code></li>
</ul>

<p>Memio provides models that allow us to describe this method by constructing objects:</p>

<pre><code class="php">&lt;?php

use Memio\Model\Argument;
use Memio\Model\Method;

require __DIR__.'/vendor/autoload.php';

$method = Method::make('handle')
    -&gt;addArgument(Argument::make('Request', 'request'))
    -&gt;addArgument(Argument::make('int', 'type')
        -&gt;setDefaultValue('self::MASTER_REQUEST')
    )
    -&gt;addArgument(Argument::make('bool', 'catch')
        -&gt;setDefaultValue('true')
    )
;
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Static constructors are used to allow fluent interface (chaining calls).
  From PHP 5.6 it is possible to do the following:
  <code>(new Method('handle'))-&gt;addArgument(new Argument('Request', 'request'));</code></p>
</blockquote>

<h2 id="building-models-dynamically">Building models dynamically</h2>

<p>Usually models aren't built manually, they could be constructed using:</p>

<ul>
<li>a configuration (a PHP array, a YAML file, etc)</li>
<li>parameters (from CLI input, a web request, etc)</li>
<li>existing code (using <a href="http://nikic.github.io/aboutMe.html">nikic</a>'s <a href="https://github.com/nikic/PHP-Parser">PHP-Parser</a> for instance)</li>
</ul>

<p>Here's a usage example. When running the test suite, <a href="http://phpspec.net">phpspec</a>
generates missing methods in our code (amongst many other nice things).</p>

<p>If the following call is found in a test:</p>

<pre><code class="php">        $this-&gt;handle($request);
</code></pre>

<p>And if the <code>handle</code> method isn't defined in the class currently tested, then phpspec
gathers the following parameters:</p>

<ul>
<li><code>$methodName</code>, which here is set to <code>'handle'</code></li>
<li><code>$arguments</code>, which here is set to <code>array($request)</code></li>
</ul>

<p>Let's re-write its generator using Memio:</p>

<pre><code class="php">&lt;?php

use Memio\Model\Argument;
use Memio\Model\Method;

require __DIR__.'/vendor/autoload.php';

function phpspec_generator($methodName, array $arguments) {
    $method = new Method($methodName);
    $index = 1;
    foreach ($arguments as $argument) {
        $type = is_object($argument) ? get_class($argument) : gettype($argument);
        $argumentName = 'argument'.$index++;
        $method-&gt;addArgument(new Argument($type, $argumentName));
    }

    return $method
}
</code></pre>

<p>Pretty straightforward!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Models are Memio's core, almost every memio packages will rely on them:</p>

<ul>
<li><code>memio/linter</code> will scan models to detect errors (e.g. abstract methods in a final class)</li>
<li><code>memio/twig-template</code> will use them to actually generate the corresponding code</li>
</ul>

<p>For now they can describe:</p>

<ul>
<li>a method argument (typehint when needed, default value)</li>
<li>a method (with PHPdoc, visibility, staticness, abstracness and if it's final)</li>
<li>a property (with PHPdoc, visibility, staticness, default value)</li>
<li>a constant</li>
<li>a class (with PHPdoc, parents, interfaces, abstractness and if it's final)</li>
<li>an interface (with PHPdoc, parent interfaces)</li>
<li>a file (with license header, namespace, use statements)</li>
</ul>

<p>There are some limitations:</p>

<ul>
<li>it can only describe a method's body using a string (e.g. <code>$toto = 42;\necho $toto;</code>)</li>
<li>a file must have a class or an interface</li>
</ul>

<p>For now, it will be sufficient to start working on exciting projects!</p>

<p>If you'd like to find out more about Memio Models, have a look at the documentation:</p>

<ul>
<li><a href="http://memio.github.io/memio/doc/01-model-tutorial.html">regular Models</a></li>
<li><a href="http://memio.github.io/memio/doc/02-phpdoc-tutorial.html">PHPdoc Models</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Introducing Memio, code generator]]></title>
            <link href="/2015/04/08/introducing-memio-code-generator.html"/>
            <updated>2015-04-08T00:00:00+01:00</updated>
            <id>/2015/04/08/introducing-memio-code-generator.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Work in Progress: Memio, a library for PHP code generation.</p>
</blockquote>

<p>Code generators write code for you, so you don't have to! There's many kinds out there:</p>

<ul>
<li>the ones that bootstrap code but can't add anything to it later</li>
<li>the ones that create code but you can't add anything to it later</li>
<li>the ones that can add new things to existing files</li>
<li>the ones that will completly change the style of existing file if they add anything to it</li>
</ul>

<p>Many frameworks provide code generators, because they can be a real time saver by
automating repetitive boring tasks (e.g. bootstraping a CRUD controller). The only
issue is that usually we can't customize them.</p>

<p>For example with <a href="https://github.com/sensiolabs/SensioGeneratorBundle">GeneratorBundle</a>,
it's impossible to create REST controllers.</p>

<p>Some of them provide templates but don't template engines, like <a href="http://phpspec.net/">phpspec</a>
for example: this is a step forward but that's not enough.</p>

<p>Now let's have a look at code generator libraries: the main ones don't allow an easy
way to customize the coding style of generated code:</p>

<ul>
<li><a href="http://framework.zend.com/manual/current/en/modules/zend.code.generator.examples.html">Zend Code Generator</a></li>
<li><a href="https://github.com/nikic/PHP-Parser">PHP Parser</a></li>
</ul>

<p>Some of them do use a template engine, but you need to write a lot of code in order to use
them:</p>

<ul>
<li><a href="https://github.com/cedriclombardot/TwigGenerator">TwigGenerator</a></li>
</ul>

<p>Don't panic! Memio is a code generator library that uses a template engine and provide
out of the box templates, generators and even validation!</p>

<p>Started in september 2014 under the name "Medio", it has now matured enough to be soon
released in stable version (1.0.0).</p>

<p>Let's have a look at what's going to be achieved with it.</p>

<h2 id="improving-phpspec">Improving phpspec</h2>

<p>The <a href="https://github.com/ciaranmcnulty/phpspec-typehintedmethods">phpspec typehint extension</a> was
a good playground for Memio: it allowed to test generation of a method argument by:</p>

<ul>
<li>adding typehints when needed</li>
<li>naming object arguments after their types</li>
</ul>

<p>Once Memio is stable, it will provide its own phpspec extension that aims at:</p>

<ul>
<li>generating argument's PHPdoc</li>
<li>generating use statements for object arguments (no more fully qualified classnames)</li>
<li>generating dependency injection</li>
</ul>

<p>Curious about this last bullet point? Then read on.</p>

<h2 id="automating-dependency-injection">Automating Dependency Injection</h2>

<p>There are many ways to use constructors, and one of them is dependency injection:
each argument is stored in a property and the class can then use them.</p>

<blockquote>
  <p><strong>Note</strong>: Remember, Dependency Injection is a fancy word for passing arguments.</p>
</blockquote>

<p>When doing so, we need to write a lot of boilerplate code:</p>

<ul>
<li>add argument to constructor (with PHPdoc, typehint, name after the type)</li>
<li>add property initialization in constructor body</li>
<li>add property (with PHPdoc)</li>
<li>add use statement, if necessary</li>
</ul>

<p>Memio will automate this in its phpspec extension.</p>

<h2 id="possibly-more%3F">Possibly more?</h2>

<p>We talked about GeneratorBundle: the issue is that we can't define our own templates.
Well Memio could solve this issue in a reusable way!</p>

<p>Usually each applications have its own style, its own requirements, etc. In short:
we can't use the same code generator between projects. But if we focus on a single
project, then we can start using the same code generator to boostrap many classes:
endpoint/page controllers, entities, etc. The possibilities are endless!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio, once stable, will provide a powerful and reusable way of generating code.</p>

<p>What's left to do before the release of v1.0? Mainly splitting the main package
(<code>memio/memio</code>) into small ones (<code>model</code>, <code>template-engine</code>, <code>validator</code>, etc).
The main package would become a "standard edition", allowing developers to select
the features they want, for example the template engine (as <a href="https://github.com/memio/memio/issues/51">requested</a>
by <a href="https://github.com/webmozart">webmozart</a>).</p>

<p>Stay tuned!</p>

<h3 id="thanks">Thanks</h3>

<p>I'd like to thank the following early contributors:</p>

<ul>
<li><a href="https://github.com/funivan">funivan</a></li>
<li><a href="https://github.com/pyrech">pyrech</a></li>
<li><a href="https://github.com/tigitz">tigitz</a></li>
<li><a href="https://github.com/TomasVotruba">TomasVotruba</a></li>
</ul>

<p>Keep up the good work!</p>
]]></content>
        </entry>
    </feed>