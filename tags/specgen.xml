<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2026-01-21T07:08:18+00:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[ChatGPT: fluff or not? SpecBDD]]></title>
            <link href="/2023/04/19/chat-gpt-spec-bdd.html"/>
            <updated>2023-04-19T00:00:00+01:00</updated>
            <id>/2023/04/19/chat-gpt-spec-bdd.html</id>
            <content type="html"><![CDATA[<p>Now that a couple of months have passed since its over hyped launch,
surely <a href="https://openai.com/blog/chatgpt/">ChatGPT</a> has found some
use cases where it could be of any actual use. Or is it all fluff? Let's find out.</p>

<p>In my quest to find a use for ChatGPT in my day to day developer activity,
I've finally found a helpful scenario!</p>

<p>Let me walk you through my findings about ChatGPT and its "Spec Gen" capacity,
so we can learn a thing or two.</p>

<h2 id="spec-gen">Spec Gen</h2>

<p>When tasked to write a feature, I first write a unit test that specifies the
behaviour, for example:</p>

<pre><code>&lt;?php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    private const FILENAME = '/tmp/file.txt';
    private const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem): void
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_creates_new_files(File $file, Filesystem $filesystem): void
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>When using <a href="https://phpspec.net/en/stable/">phpspec</a>,
especially with the extension <a href="https://github.com/memio/spec-gen">spec-gen</a>,
running the test will bootstrap for me the corresponding class:</p>

<pre><code>&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesytem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open(string $argument1, bool $argument2)
    {
    }
}
</code></pre>

<p>That's pretty good, but it could be better: what if it was able to generate the complete code?</p>

<h2 id="gpt-gen">GPT Gen</h2>

<p>Let's forget about phpspec and use instead <a href="https://phpunit.de/">PHPUnit</a>,
but still with the <a href="https://github.com/phpspec/prophecy">Prophecy</a>
Mocking framework.</p>

<p>Let's ask ChatGPT. Here's the priming prompt:</p>

<blockquote>
  <p><strong>USER</strong>:
  Act as an expert PHP developer,
    who's been writing high quality API code for 20 years.
  Acknowledge with "ok".</p>
</blockquote>

<p>Because ChatGPT's Large Language Model (LLM) is able to generate a wide range
of text (conversation, essays, movie script, poetry, etc), assigning it a role
helps it narrow down its context, hence improving its accuracy for the task we
want it to complete: writing PHP code, on a professional level
(persona/role prompt engineering technique).</p>

<p>We also need to consider the Goldfish Memory issue of ChatGPT: it only takes
into account the last ~4000 tokens to generate its response, so asking it to
give us a short reply helps us save some space.</p>

<blockquote>
  <p><strong>ChatGPT</strong>: ok</p>
</blockquote>

<p>LLMs perform better when given some examples, and indeed before asking it to
generate code we might want to give ChatGPT some of our code samples
(X-Shot prompt engineering technique).</p>

<p>Since coding also requires some level of logic, it is also helpful to include
reasoning steps (Chain of Thought prompt engineering technique).</p>

<p>Similarly, asking the LLM to first generate some topic related knowledge,
and then reuse that in the further prompts will also increase our success rate
(Generated Knowledge prompt engineering technique).</p>

<p>With this in mind, here's the second prompt that provides a test class example:</p>

<blockquote>
  <p><strong>USER</strong>: Here's an example of test class from the project you're working on:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace tests\Ssc\Btlr\Cht\Message\Templates\Prompts;

use Ssc\Btlr\App\Filesystem\ReadFile;
use Ssc\Btlr\App\Template\Replace;
use Ssc\Btlr\Cht\Message\Logs\Type;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;
use Ssc\Btlr\Cht\Message\Templates\Prompts\Template;
use tests\Ssc\Btlr\AppTest\BtlrServiceTestCase;

class TemplateTest extends BtlrServiceTestCase
{
    /**
     * @test
     */
    public function it_creates_prompt_from_template(): void
    {
        // Fixtures
        $thoseParameters = [
            'last_messages' =&gt; 'USER (1968-04-02T18:40:23+00:00): Write code for me, please',
        ];
        $forType = Type::AUGMENTED_PROMPT;
        $withConfig = [
            'chunk_memory_size' =&gt; 15,
            'llm_engine' =&gt; 'chatgpt-gpt-3.5-turbo',
            'logs_filename' =&gt; './var/cht/logs',
            'prompt_templates_filename' =&gt; './templates/cht/prompts',
        ];

        $template = "LAST MESSAGES:\n%last_messages%\nBTLR:\n";
        $prompt = "LAST MESSAGES:\n{$thoseParameters['last_messages']}\nBTLR:\n";
        $data = [
            'entry' =&gt; $prompt,
        ];

        // Dummies
        $readFile = $this-&gt;prophesize(ReadFile::class);
        $replace = $this-&gt;prophesize(Replace::class);
        $writeLog = $this-&gt;prophesize(WriteLog::class);

        // Stubs &amp; Mocks
        $readFile-&gt;in("{$withConfig['prompt_templates_filename']}/{$forType['name']}.txt")
            -&gt;willReturn($template);
        $replace-&gt;in($template, $thoseParameters)
            -&gt;willReturn($prompt);
        $writeLog-&gt;for($data, $forType, $withConfig)
            -&gt;shouldBeCalled();

        // Assertion
        $template = new Template(
            $readFile-&gt;reveal(),
            $replace-&gt;reveal(),
            $writeLog-&gt;reveal(),
        );
        self::assertSame($prompt, $template-&gt;replace(
            $thoseParameters,
            $forType,
            $withConfig,
        ));
    }
}
</code></pre>

<blockquote>
  <p><strong>USER</strong>:
  Acknowledge by describing how the use of fixtures, dummies, stubs, mocks
  and assertions allow to make sure the tested code is behaving as expected.
  And note the use of the special BtlrServiceTestCase parent class for <code>TemplateTest</code>.</p>
</blockquote>

<p>By the way, the code is from my Super Secret Code project
<a href="https://github.com/gnugat/ssc-btlr">Btlr</a>.</p>

<p>Here's ChatGPT's response:</p>

<blockquote>
  <p><strong>ChatGPT</strong>:
  In this test class, fixtures are used to provide the necessary data for
  testing the <code>Template</code> class. The parameters and configuration are defined in
  <code>$thoseParameters</code> and <code>$withConfig</code> respectively, and the template and prompt
  strings are defined in <code>$template</code> and <code>$prompt</code>.</p>
  
  <p>Dummies are used to provide the interface of the <code>ReadFile</code>, <code>Replace</code>, and
  <code>WriteLog</code> classes, without providing any actual implementation, since these
  classes are not the focus of the test.</p>
  
  <p>Stubs are used to replace the implementation of <code>ReadFile</code> and <code>Replace</code>
  classes, by returning a fixed value when their respective methods are called.
  This ensures that the expected values are used for testing the <code>Template</code> class.</p>
  
  <p>Mocks are used to verify that the <code>WriteLog</code> class is called with the expected
  parameters. The <code>shouldBeCalled()</code> method ensures that the <code>for()</code> method of
  <code>WriteLog</code> class is actually called during the test.</p>
  
  <p>Finally, the assertion compares the result returned by the <code>replace()</code> method
  of the <code>Template</code> class with the expected prompt string.</p>
  
  <p>The <code>BtlrServiceTestCase</code> class is a special parent class that sets up a test
  environment for the Btlr service, which can include initializing dependencies,
  connecting to databases, and setting up configurations. This helps to ensure
  that tests are run in a consistent and isolated environment, and makes it easier
  to write tests for the Btlr service.</p>
</blockquote>

<p>ChatGPT doesn't have access to the project and its code, it only knows what we've
provided in the conversation so far.</p>

<p>So for example it took a wild guess at what <code>BtlrServiceTestCase</code> does and got
it wrong, but for our purpose this is good enough.</p>

<p>The third prompt is an example of the corresponding class:</p>

<blockquote>
  <p><strong>USER</strong>:
  When tasked with generating the corresponding <code>Template</code> class, from the above
  <code>TemplateTest</code> test class, here's the code you wrote:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace Ssc\Btlr\Cht\Message\Templates\Prompts;

use Ssc\Btlr\App\Filesystem\ReadFile;
use Ssc\Btlr\App\Template\Replace;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;

class Template
{
    public function __construct(
        private ReadFile $readFile,
        private Replace $replace,
        private WriteLog $writeLog,
    ) {
    }

    public function replace(
        array $thoseParameters,
        array $forType,
        array $withConfig,
    ): string {
        $template = $this-&gt;readFile-&gt;in(
            "{$withConfig['prompt_templates_filename']}/{$forType['name']}.txt",
        );
        $prompt = $this-&gt;replace-&gt;in($template, $thoseParameters);
        $this-&gt;writeLog-&gt;for([
            'entry' =&gt; $prompt,
        ], $forType, $withConfig);

        return $prompt;
    }
}
</code></pre>

<blockquote>
  <p><strong>USER</strong>: Acknowledge by describing how the test class got translated into its
  corresponding class.</p>
</blockquote>

<p>To which ChatGPT replies:</p>

<blockquote>
  <p><strong>ChatGPT</strong>:
  The <code>TemplateTest</code> test class served as a guide for implementing the
  <code>Template</code> class.</p>
  
  <p>First, the constructor of <code>Template</code> class takes three dependencies, which
  are also injected in the <code>TemplateTest</code> class as dummies or mocks.</p>
  
  <p>Next, the <code>replace()</code> method of <code>Template</code> class has the same signature as
  the test method <code>it_creates_prompt_from_template()</code>, with the addition of a
  return type declaration for the prompt string.</p>
  
  <p>The implementation of <code>replace()</code> method in <code>Template</code> class uses the
  injected <code>ReadFile</code> instance to read the template string from the filesystem,
  using the <code>$forType['name']</code> parameter to construct the file path.
  It then uses the injected <code>Replace</code> instance to replace placeholders in the
  template with values provided in the <code>$thoseParameters</code> array, resulting in
  a <code>$prompt</code> string.</p>
  
  <p>Finally, the method calls the injected <code>WriteLog</code> instance with the <code>$prompt</code>,
  <code>$forType</code>, and <code>$withConfig</code> parameters, which logs the prompt for the given
  type and configuration.</p>
  
  <p>Overall, the implementation of the <code>Template</code> class closely follows the
  structure of the <code>TemplateTest</code> class, and the use of dependency injection
  ensures that the class can be easily tested in isolation from its
  dependencies.</p>
</blockquote>

<p>With ChatGPT noting that the corresponding class closely follows the structure
of its test, it should be now ready.</p>

<p>Let's give it a new test class, and ask it to generate the corresponding code:</p>

<blockquote>
  <p><strong>USER</strong>: Brilliant. Now, in the same coding style as <code>TemplateTest</code> and
  <code>Template</code>, you are tasked to write a the corresponding code for the
  following <code>ReplyTest</code> test class:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace tests\Ssc\Btlr\Cht\Message;

use Ssc\Btlr\Cht\Message\Logs\Type;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;
use Ssc\Btlr\Cht\Message\Memory\Consolidate;
use Ssc\Btlr\Cht\Message\Reply;
use Ssc\Btlr\Cht\Message\Reply\Augment;
use Ssc\Btlr\Cht\Message\Reply\UsingLlm;
use tests\Ssc\Btlr\AppTest\BtlrServiceTestCase;

class ReplyTest extends BtlrServiceTestCase
{
    /**
     * @test
     */
    public function it_replies_to_user_prompt_using_llm(): void
    {
        // Fixtures
        $userPrompt = 'Write code for me, please';
        $withConfig = [
            'chunk_memory_size' =&gt; 15,
            'llm_engine' =&gt; 'chatgpt-gpt-3.5-turbo',
            'logs_filename' =&gt; './var/cht/logs',
            'prompt_templates_filename' =&gt; './templates/cht/prompts',
        ];

        $userPromptData = [
            'entry' =&gt; $userPrompt,
        ];
        $augmentedPrompt = "USER: {$userPrompt}\nBLTR:";
        $modelCompletion = "I'm sorry, dev. I'm afraid I can't do that.";
        $modelCompletionData = [
            'entry' =&gt; $modelCompletion,
            'llm_engine' =&gt; $withConfig['llm_engine'],
        ];

        // Dummies
        $augment = $this-&gt;prophesize(Augment::class);
        $consolidate = $this-&gt;prophesize(Consolidate::class);
        $usingLlm = $this-&gt;prophesize(UsingLlm::class);
        $writeLog = $this-&gt;prophesize(WriteLog::class);

        // Stubs &amp; Mocks
        $writeLog-&gt;for($userPromptData, Type::USER_PROMPT, $withConfig)
            -&gt;shouldBeCalled();
        $augment-&gt;the($userPrompt, $withConfig)
            -&gt;willReturn($augmentedPrompt);
        $usingLlm-&gt;complete($augmentedPrompt)
            -&gt;willReturn($modelCompletion);
        $writeLog-&gt;for($modelCompletionData, Type::MODEL_COMPLETION, $withConfig)
            -&gt;shouldBeCalled();
        $consolidate-&gt;memories($withConfig)
            -&gt;shouldBeCalled();

        // Assertion
        $reply = new Reply(
            $augment-&gt;reveal(),
            $consolidate-&gt;reveal(),
            $usingLlm-&gt;reveal(),
            $writeLog-&gt;reveal(),
        );
        self::assertSame($modelCompletion, $reply-&gt;to(
            $userPrompt,
            $withConfig,
        ));
    }
}
</code></pre>

<blockquote>
  <p><strong>USER</strong>: Acknowledge by generating the code for the <code>Reply</code> class.</p>
</blockquote>

<p>And here's what ChatGPT came up with:</p>

<blockquote>
  <p><strong>ChatGPT</strong>: Sure thing! Here's the code for the <code>Reply</code> class based on the
  <code>ReplyTest</code> test class:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace Ssc\Btlr\Cht\Message;

use Ssc\Btlr\Cht\Message\Logs\Type;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;
use Ssc\Btlr\Cht\Message\Memory\Consolidate;
use Ssc\Btlr\Cht\Message\Reply\Augment;
use Ssc\Btlr\Cht\Message\Reply\UsingLlm;

class Reply
{
    public function __construct(
        private Augment $augment,
        private Consolidate $consolidate,
        private UsingLlm $usingLlm,
        private WriteLog $writeLog,
    ) {
    }

    public function to(string $userPrompt, array $withConfig): string
    {
        $userPromptData = [
            'entry' =&gt; $userPrompt,
        ];

        // Augment the user prompt
        $augmentedPrompt = $this-&gt;augment-&gt;the($userPrompt, $withConfig);

        // Use LLM to generate a model completion
        $modelCompletion = $this-&gt;usingLlm-&gt;complete($augmentedPrompt);

        // Log the user prompt and model completion
        $this-&gt;writeLog-&gt;for($userPromptData, Type::USER_PROMPT, $withConfig);
        $modelCompletionData = [
            'entry' =&gt; $modelCompletion,
            'llm_engine' =&gt; $withConfig['llm_engine'],
        ];
        $this-&gt;writeLog-&gt;for($modelCompletionData, Type::MODEL_COMPLETION, $withConfig);

        // Consolidate the memories
        $this-&gt;consolidate-&gt;memories($withConfig);

        return $modelCompletion;
    }
}
</code></pre>

<blockquote>
  <p><strong>ChatGPT</strong>: This <code>Reply</code> class has a <code>to</code> method that takes a user prompt
  and a configuration array as input, and returns the model completion
  generated by LLM.
  The <code>Reply</code> class constructor takes in four dependencies: <code>Augment</code>,
  <code>Consolidate</code>, <code>UsingLlm</code>, and <code>WriteLog</code>, and stores them as private
  properties.
  The <code>to</code> method then uses these dependencies to augment the user prompt,
  generate the model completion, log both the user prompt and the model
  completion, and consolidate the memories.</p>
</blockquote>

<p>Which is pretty much spot on.</p>

<p>I'd personnally have written something slightly different (no comments, have
 <code>writeLog</code> for the user prompt at the begining of the method, and possibly
not have any intermediate variables).</p>

<p>But I can easily apply those changes!</p>

<h2 id="takeways">Takeways</h2>

<p>Thanks to Prompt Engineering (with techniques such as Role / Persona priming
prompt, X-Shot, Chain of Thought and Generated Knowledge), it is possible
to ask ChatGPT to generate code.</p>

<p>I'm personally using the following prompts to generate the corresponding code
for a given Test Class.</p>

<p>Priming Prompt:</p>

<blockquote>
  <p>Act as an expert PHP developer, who's been writing high quality API code for 20 years.
  Acknowledge with "ok".</p>
</blockquote>

<p>Test Class example prompt:</p>

<blockquote>
  <p>Here's an example of test class from the project you're working on:</p>
  
  <p><code>%example_test_class_code%</code></p>
  
  <p>Acknowledge by describing how the use of fixtures, dummies, stubs, mocks
  and assertions allow to make sure the tested code is behaving as expected.
  And note the use of the special BtlrServiceTestCase parent class for
  <code>%example_test_class_name%</code>.</p>
</blockquote>

<p>Corresponding class example prompt:</p>

<blockquote>
  <p>When tasked with generating the corresponding <code>%example_class_name%</code> class,
  from the above <code>%%example_test_class_name</code> test class, here's the code you wrote:</p>
  
  <p><code>%example_class_code%</code></p>
  
  <p>Acknowledge by describing how the test class got translated into its
  corresponding class.</p>
</blockquote>

<p>Code generation request from Test Class prompt:</p>

<blockquote>
  <p>Brilliant. Now, in the same coding style as <code>%example_test_class_name%</code> and
  <code>%example_class_name%</code>, you are tasked to write a the corresponding code for
  the following <code>%test_class_name%</code> test class:</p>
  
  <p><code>%test_class_code%</code></p>
  
  <p>Acknowledge by generating the code for the <code>%class_name%</code> class.</p>
</blockquote>

<p>Now, what if you're not practicing Test Driven Development?</p>

<p>I suppose you can tweek it to get ChatGPT to generate tests for you:</p>

<ul>
<li>Use the same priming prompt</li>
<li>Then use the class example prompt</li>
<li>Next use the "corresponding" test example prompt</li>
<li>Finally provide a class and ask ChatGPT to generate its corresponding test</li>
</ul>

<p>All in all, the exploration of ChatGPT's text generation potential turned out
to be quite worthwhile, as I ended up finding a practical use case for it in my
day to day developer activity.</p>

<p>Yet I suspect there's plenty more scenarions where ChatGPT can help, so I guess
the quest continues.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[SpecGen v0.3]]></title>
            <link href="/2015/05/28/spec-gen-0-3.html"/>
            <updated>2015-05-28T00:00:00+01:00</updated>
            <id>/2015/05/28/spec-gen-0-3.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> v0.3 inserts a property for each constructor argument.</p>
</blockquote>

<p>SpecGen is a <a href="http://phpspec.net">phpspec</a> extension which enhance its code generator.
With the latest release, v0.3, we get the following features:</p>

<ul>
<li>method generation:

<ul>
<li>it inserts method at the end of the class</li>
<li>it typehints object, array and callable arguments</li>
<li>it names object arguments after their type</li>
<li>it names scalar arguments after a generic name (<code>argument</code>)</li>
<li>it adds number on names that could collide (e.g. <code>$argument1, $argument2</code>)</li>
</ul></li>
<li>constructor generation, same as method except:

<ul>
<li>it inserts constructor at the begining of the class</li>
<li>it inserts properties with initialization for each constructor arguments</li>
</ul></li>
</ul>

<p>Here's a simple example to demonstrate how helpful it can be.</p>

<h2 id="example">Example</h2>

<p>First of all, we need to set up a project with <a href="https://getcomposer.org/download">Composer</a>.
Let's write the following <code>composer.json</code>:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>Then we can install phpspec with SpecGen by running those commands:</p>

<pre><code>composer require --dev phpspec/phpspec:~2.2
composer require --dev memio/spec-gen:~0.3
echo 'extensions:' &gt; phpspec.yml
echo '  - Memio\SpecGen\MemioSpecGenExtension' &gt;&gt; phpspec.yml
</code></pre>

<p>In our example, we'll specify a <code>TextEditor</code> service, it should be able to
create new files by relying on <code>Filesystem</code>, another service.</p>

<p>This can be done as follow:</p>

<pre><code>phpspec describe 'Vendor\Project\TextEditor'
````

&gt; **Tip**: make your vendor's binaries available by adding `vendor/bin` to your `$PATH`.
&gt; `export PATH="vendor/bin:$PATH"`.

This should generate a `spec\Vendor\Project\TextEditorSpec.php` file:

```php
&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class TextEditorSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\TextEditor');
    }
}
</code></pre>

<p>It needs to be edited to fit our needs:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_creates_new_files(File $file, Filesystem $filesystem)
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>The Test Driven Development cycle advises us to run the test suite now:</p>

<pre><code>phpspec run
</code></pre>

<p>This will bootstrap the following code:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open($argument1, $argument2)
    {
    }
}
</code></pre>

<p>It created a <code>filesystem</code> property to mirror the constructor arguments. Neat!</p>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>In our example phpspec also generated the collaborators (<code>File</code> and <code>Filesystem</code>).
These don't beneficiate from SpecGen help yet, so the next release (v0.4) will
probably be about using it for collaborators.</p>

<p>Other features that could be implemented would be PHPdoc generation, or avoiding the
<code>Interface</code> / <code>Abstract</code> suffix/prefix in interface and abstract object argument names.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[SpecGen v0.2]]></title>
            <link href="/2015/05/20/spec-gen-0-2.html"/>
            <updated>2015-05-20T00:00:00+01:00</updated>
            <id>/2015/05/20/spec-gen-0-2.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> v0.2 inserts use statements.</p>
</blockquote>

<p>SpecGen v0.2 has been released, it introduces a small change: use statement insertion.</p>

<h2 id="it-inserts-use-statements">It inserts use statements</h2>

<p>Let's go back to the sources of the example used in the <a href="/2015/05/13/memio-spec-gen.html">previous article</a>
and clean it a little bit:</p>

<pre><code>rm -rf src
</code></pre>

<p>Given the following specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Message\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Message\Response');
    }
}
</code></pre>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following file, with a use statement:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Message\Request;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="it-doesn%27t-insert-use-statements-twice">It doesn't insert use statements twice</h2>

<p>Given the following new step in our specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Message\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Message\Response');
    }

    function it_supports_request(Request $request)
    {
        $this-&gt;supports($request)-&gt;shouldBe(true);
    }
}
</code></pre>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following file, without new use statements:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Message\Request;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }

    public function supports(Request $request)
    {
    }
}
</code></pre>

<h2 id="it-doesn%27t-insert-use-statement-for-same-namespace">It doesn't insert use statement for same namespace</h2>

<p>Let's clear everything:</p>

<pre><code>rm -rf src
</code></pre>

<p>Given the following specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <code>Request</code> and <code>RequestHandler</code> are both in the same namespace.</p>
</blockquote>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following, without any use statements:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="behind-the-hood">Behind the hood</h2>

<p>This small feature was the occasion to refactor SpecGen a bit! This resulted in the
introduction of <code>CodeEditor</code>, a facade for a home made <code>CommandBus</code> and for
<a href="http://gnugat.github.io/redaktilo">Redaktilo</a>'s <code>Editor</code>.</p>

<p>With these, the code to generate a method and insert a use statement looks like this:</p>

<pre><code class="php">$file = $this-&gt;codeEditor-&gt;open($fileName);
$this-&gt;codeEditor-&gt;handle(new InsertUseStatements($file, $fullyQualifiedNames));
$this-&gt;codeEditor-&gt;handle(new InsertMethod($file, $method));
$this-&gt;codeEditor-&gt;save($file);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>While some improvements can still be done (use statements in alphabetical order,
typehint interfaces only), the version 0.3 will mainly be about the introduction
of a new generator: insertion of properties when the method is a constructor.</p>

<p>Stay tuned!</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio SpecGen v0.1]]></title>
            <link href="/2015/05/13/memio-spec-gen.html"/>
            <updated>2015-05-13T00:00:00+01:00</updated>
            <id>/2015/05/13/memio-spec-gen.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> is a <a href="http://phpspec.net">phpspec</a>
  extension that improves its code generator. Currently available: type hinted method arguments.</p>
</blockquote>

<p>With <a href="http://memio.github.io/memio">Memio v1.0 released</a>, it is now possible to
create powerful code generators without re-inventing the wheel.
<a href="http://github.com/memio/spec-gen">SpecGen</a> is the first project to use this library, let's
see what it can do for us.</p>

<h2 id="phpspec">phpspec</h2>

<p>First of all we'll talk about <a href="http://phpspec.net">phpspec</a>, which is an exciting
project that provides many benefits:</p>

<ul>
<li>a testing tool (allows to write specifications, which are kind of unit tests)</li>
<li>a "best practice" enforcer (for e.g. cannot test private methods to force us to split code into smaller public APIs)</li>
<li>a time saver (bootstraps tests and code)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: See <a href="http://techportal.inviqa.com/2014/09/11/my-top-ten-favourite-phpspec-limitations/">My top 10 favourite phpsepc limitations</a>.</p>
</blockquote>

<p>It makes Test Driven Development cycles even more meaningful:</p>

<ol>
<li>bootstrap test by thinking on a class name</li>
<li>write a test by thinking how the class should behave</li>
<li>bootstrap the corresponding code by running the whole test suite</li>
<li>write code as quick as possible without thinking about best practices or design patterns (be pragmatic)</li>
<li>run the test suite to check if the code fulfills the test's specifications</li>
<li>refactor the code (manage the technical debt)</li>
<li>run the test suite to check for regressions</li>
<li>repeat!</li>
</ol>

<p>phpspec's code generator is a big part of its value. Let's see if we can improve it.</p>

<h2 id="phpspec-example">phpspec example</h2>

<p>Let's have a look at how phpspec works. For this we'll need to have a project configured with
<a href="https://getcomposer.org/download">Composer</a>:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>We can install phpspec with the following:</p>

<pre><code>composer require --dev phpspec/phpspec:~2.2
</code></pre>

<p>Let's say we want to create a class that handles requests, conforming to the HTTP protocol
(take a <code>Request</code>, return a <code>Response</code>). We can call this class <code>RequestHandler</code>:</p>

<pre><code>phpspec describe 'Vendor\Project\RequestHandler'
</code></pre>

<blockquote>
  <p><strong>Tip</strong>: make your vendor's binaries available by adding <code>vendor/bin</code> to your <code>$PATH</code>.
  <code>export PATH="vendor/bin:$PATH"</code>.</p>
</blockquote>

<p>We should now have the <code>spec/Vendor/Project/RequestHandlerSpec.php</code> file, bootstraped
for us by phpspec:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\RequestHandler');
    }
}
</code></pre>

<p>We can directly start by writing our first specification (test method) in it:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response(Request $request)
    {
        $this-&gt;handle($request)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We tried to make the test method as descriptive as possible (e.g. not <code>testHandler()</code>).
  This is the whole point of specBDD (specification Behavior Driven Development).</p>
</blockquote>

<p>With this we can start to boostrap the code by simply running the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>It will ask the following 3 questions:</p>

<ol>
<li>Would you like me to generate an interface <code>Vendor\Project\Request</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\RequestHandler</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\RequestHandler::handle()</code> for you?</li>
</ol>

<p>By accepting everytime, phpspec will bootstrap the following
<code>src/Vendor/Project/Vendor/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{

    public function handle($argument1)
    {
        // TODO: write logic here
    }
}
</code></pre>

<p>In our specification, we make use of a non existing <code>Request</code> class, and phpspec
also bootstraped it for us in <code>src/Vendor/Project/Vendor/Request.php</code>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

interface Request
{
}
</code></pre>

<p>This is extremely usefull to kickstart our TDD cycle!</p>

<h2 id="memio-specgen">Memio SpecGen</h2>

<p>SpecGen is a phpspec extension, it makes use of Memio (the PHP code generator library)
to make the above bootstraping even more awesome.</p>

<p>Here's how to install it:</p>

<pre><code>composer require --dev memio/spec-gen:~0.1
</code></pre>

<p>We also need to register it as a phpspec extension by writing the following <code>phpspec.yml</code> file:</p>

<pre><code>extensions:
  - Memio\SpecGen\MemioSpecGenExtension
</code></pre>

<p>Its first release, v0.1 (unstable for now), improves the method generation with:</p>

<ul>
<li>type hinted arguments</li>
<li>object arguments named after their type</li>
<li>putting each arguments on their own lines if the inline alternative would have been longer than 120 characters</li>
</ul>

<p>To be fair, this is exactly what already <a href="https://ciaranmcnulty.com/">Ciaran McNulty</a>'s
<a href="https://github.com/ciaranmcnulty/phpspec-typehintedmethods">Typehinted Methods extension</a>
provides, so why would we choose SpecGen? Well simply because it intends to do much more:</p>

<ul>
<li>insertion of <code>use</code> statements</li>
<li>constructor generation (each argument will have a corresponding property and a property initialization)</li>
<li>PHPdoc</li>
<li>???</li>
<li>profit!</li>
</ul>

<h2 id="memio-specgen-example">Memio SpecGen example</h2>

<p>Let's give it a try by first removing the code we boostrapped until now:</p>

<pre><code>rm -rf src
</code></pre>

<p>In order to demonstrate more type hints, we'll add more arguments:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<p>We can now run the test suite to bootstrap the code:</p>

<pre><code>phpspec run
</code></pre>

<p>This should create the following <code>src/Vendor/Project/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: for now <code>use</code> statements aren't generated. In our example it doesn't
  matter since <code>Request</code> is in the same namespace as <code>RequestHandler</code>.</p>
</blockquote>

<p>Let's remove again the generated code:</p>

<pre><code>rm -rf src
</code></pre>

<p>Now we'd like to see this multiline feature by adding many arguments to our specifiction:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response()
    {
        $this-&gt;myMethod(1, 2, 3, 4, 5, 6, 7, 8);
    }
}
</code></pre>

<p>Again, we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>This should bootstrap the following <code>src/Vendor/Project/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function myMethod(
        $argument1,
        $argument2,
        $argument3,
        $argument4,
        $argument5,
        $argument6,
        $argument7,
        $argument8
    )
    {
    }
}
</code></pre>

<p>And that's it!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio SpecGen improves phpspec's generator by adding better named, type hinted
and PSR-2 compliant method arguments.</p>

<p>Note that this kind of improvement has to be done in extension. They cannot be
done directly in phpspec because it tries to enforce best practices, and one of
them is to type hint only against interfaces. As it happens, the current extensions
can also type hint against implementations, depending on how the developers write
their specifications.</p>

<p>The next versions will bring even more exciting features, such as constructor and PHPdoc
generation.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
    </feed>