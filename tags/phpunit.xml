<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Lo√Øc Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2025-10-01T13:55:52+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Lo√Øc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[eXtreme Legacy 3: End to End Tests]]></title>
            <link href="/2025/09/24/xl-3-end-to-end-tests.html"/>
            <updated>2025-09-24T00:00:00+01:00</updated>
            <id>/2025/09/24/xl-3-end-to-end-tests.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p>ü§ò The Beta Destroyer breaks free from the crypts of Manual Testing,
  forging unbreakable chains of End to End test scenarios,
  binding every component in the unholy covenant of automations! üî•</p>
</blockquote>

<p>In this series, we're dealing with BisouLand, an eXtreme Legacy application
(2005 LAMP spaghetti code base). So far, we have:</p>

<ol>
<li><a href="/2025/09/10/xl-1-dockerizing-2005-lamp-app.html">üêã got it to run in a local container</a></li>
<li><a href="/2025/09/17/xl-2-smoke-tests.html">üí® written Smoke Tests</a></li>
</ol>

<p>This means we can run it locally (http://localhost:8080/),
and have some level of automated tests.</p>

<p>But currently the tests are failing!</p>

<p>So, we'll inspect the issue, identify it,
write End to End tests which will be today's third article focus,
and finally we'll fix the bug.</p>

<p><img
    alt="The plan: we find the bug. We fix the bug. Now there are two bugs. Now there are three bugs"
    src="/images/xl-3-the-plan.jpg"
    width="100%" /></p>

<ul>
<li><a href="#identifying-the-issue">Identifying the issue</a></li>
<li><a href="#writing-the-test">Writing the test</a></li>
<li><a href="#test-data-cleanup">Test data cleanup</a></li>
<li><a href="#custom-assertion">Custom Assertion</a></li>
<li><a href="#fixing-the-bug">Fixing the bug</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="identifying-the-issue">Identifying the issue</h2>

<p>Let's run the tests to see the failure messages:</p>

<pre><code class="console">make test arg='--testdox --filter PlayerPages'
PHPUnit 12.3.2 by Sebastian Bergmann and contributors.

Runtime:       PHP 8.4.12
Configuration: /apps/qa/phpunit.xml.dist

FFFFFFFFFFFF............                                          24 / 24 (100%)

Time: 00:00.081, Memory: 18.00 MB

Player Pages (Bl\Qa\Tests\Smoke\PlayerPages)
 ‚úò it loads account page (`/connected.html`) for logged in players
   ‚îê
   ‚îú Failed asserting that Page loads for logged in players
   ‚îÇ
   ‚îÇ /apps/qa/tests/Smoke/Assertion/Assert.php:41
   ‚îÇ /apps/qa/tests/Smoke/PlayerPagesTest.php:45
   ‚î¥
[...]
FAILURES!
Tests: 24, Assertions: 24, Failures: 12.
</code></pre>

<p>The player cannot log in... Let's try manually,
first we need to sign-up a new player:</p>

<p><img alt="BisouLand signup attempt screenshot" src="/images/xl-3-signup-attempt-screenshot.png" width="100%" /></p>

<p>It worked:</p>

<p><img alt="BisouLand signup errot screenshot" src="/images/xl-3-signup-success-screenshot.png" width="100%" /></p>

<p>Now let's log in:</p>

<p><img alt="BisouLand signup attempt screenshot" src="/images/xl-3-login-attempt-screenshot.png" width="100%" /></p>

<p>But it fails! The error says the username doesn't exist:</p>

<p><img alt="BisouLand signup errot screenshot" src="/images/xl-3-login-failure-screenshot.png" width="100%" /></p>

<p>Inspecting the database shows that the player data wasn't inserted.</p>

<p>The Smoke Tests didn't catch directly the login error,
because it's an error printed inside the HTML,
and our tests only check for status code <code>200</code>.</p>

<p>So this highlights the limits of Smoke Tests
(though we have to recognise that they did indirectly catch the issue,
with players being unable to login).</p>

<p>The code handling signing up is located in <code>./apps/monolith/web/phpincludes/inscription.php</code>,
and hold on to your socks because it looks like this:</p>

<pre><code class="php">&lt;?php
if (false == $_SESSION['logged']) {
    $send = 0;
    $pseudo = '';
    $mdp = '';
    if (isset($_POST['inscription'])) {
        // Mesure de securite.
        $pseudo = htmlentities(addslashes($_POST['Ipseudo']));
        $mdp = htmlentities(addslashes($_POST['Imdp']));
        $mdp2 = htmlentities(addslashes($_POST['Imdp2']));
        // Prevoir empecher de prendre un pseudo deje existant
        // Si les variables contenant le pseudo, le mot de passe existent et contiennent quelque chose.
        if (isset($_POST['Ipseudo'], $_POST['Imdp'], $_POST['Imdp2']) &amp;&amp; !empty($_POST['Ipseudo']) &amp;&amp; !empty($_POST['Imdp']) &amp;&amp; !empty($_POST['Imdp2'])) {
            if ($mdp == $mdp2) {
                // Si le pseudo est superieur e 3 caracteres et inferieur e 35 caracteres.
                $taille = strlen(trim($_POST['Ipseudo']));
                if ($taille &gt;= 4 &amp;&amp; $taille &lt;= 15) {
                    /* //Mesure de securite.
                    $pseudo = htmlentities(addslashes($_POST['pseudo']));
                    $mdp = htmlentities(addslashes($_POST['mdp']));*/

                    // La requete qui compte le nombre de pseudos
                    $sql = mysql_query("SELECT COUNT(*) AS nb_pseudo FROM membres WHERE pseudo='".$pseudo."'");

                    // Verifie si le pseudo n'est pas deje pris.
                    if (0 == mysql_result($sql, 0, 'nb_pseudo') &amp;&amp; 'BisouLand' != $pseudo) {
                        // Verifie que le pseudo est correct.
                        if (preg_match("!^\w+$!", $pseudo)) {
                            if (preg_match("!^\w+$!", $mdp)) {
                                // Si le mot de passe est superieur e 4 caracteres.
                                $taille = strlen(trim($_POST['Imdp']));
                                if ($taille &gt;= 5 &amp;&amp; $taille &lt;= 15) {
                                    // On execute la requete qui enregistre un nouveau membre.

                                    // Hashage du mot de passe avec md5().
                                    $hmdp = md5($mdp);

                                    mysql_query("INSERT INTO membres (id, pseudo, mdp, confirmation, lastconnect) VALUES ('', '".$pseudo."', '".$hmdp."', '1', ".time().')');

                                    echo 'Ton inscription est confirm√©e ! Tu peux maintenant te connecter.&lt;br /&gt;';
                                    $send = 1;
                                } else {
                                    echo 'Erreur : le mot de passe est soit trop court, soit trop long !';
                                }
                            } else {
                                echo 'Erreur : le mot de passe n\'est pas valide !';
                            }
                        } else {
                            echo 'Erreur : le pseudo n\'est pas valide !';
                        }
                    } else {
                        echo 'Erreur : pseudo deje pris !';
                    }
                } else {
                    echo 'Erreur : le pseudo est soit trop court, soit trop long !';
                }
            } else {
                echo 'Erreur : Tu n\'as pas rentre deux fois le meme mot de passe !';
            }
        } else {
            echo 'Erreur : Pense e remplir tous les champs !';
        }
    }
    if (0 == $send) {
        ?&gt;
&lt;form method="post" class="formul" action="inscription.html"&gt;
    &lt;label&gt;Pseudo :&lt;br /&gt;&lt;span class="petit"&gt;(Entre 4 et 15 caracteres)&lt;/span&gt;&lt;br /&gt;&lt;input type="text" name="Ipseudo" tabindex="10" size="15" maxlength="15" value="&lt;?php echo stripslashes($pseudo); ?&gt;"/&gt;&lt;/label&gt;&lt;br /&gt;
    &lt;label&gt;Mot de passe : &lt;br /&gt;&lt;span class="petit"&gt;(Entre 5 et 15 caracteres)&lt;/span&gt;&lt;br /&gt;&lt;input type="password" name="Imdp" tabindex="20" size="15" maxlength="15" value=""/&gt;&lt;/label&gt;&lt;br /&gt;
    &lt;label&gt;Reecris le mot de passe : &lt;br /&gt;&lt;input type="password" name="Imdp2" tabindex="30" size="15" maxlength="15" value=""/&gt;&lt;/label&gt;&lt;br /&gt;
    &lt;input type="submit" name="inscription" value="S'inscrire" /&gt;
&lt;/form&gt;
&lt;?php
    }
} else {
    echo 'Pfiou t\'es dja connected toi !!';
}
?&gt;
</code></pre>

<p>Now, that's eXtreme Legacy!!!</p>

<p>Let's focus on the problematic line,
which is supposed to save the player's data in the database
(I've reformatted it a bit for readability):</p>

<pre><code class="php">mysql_query(
    'INSERT INTO membres (id, pseudo, mdp, confirmation, timestamp, lastconnect, amour)'
    ." VALUES ('', '{$pseudo}', '{$hmdp}', '1', ".time().', '.time().", '300')"
);
</code></pre>

<p>There are many problems here (deprecated function, SQL injection vulnerability,
use of cryptologically broken md5 for password hashing etc),
but what jumps to my attention is the use of <code>''</code> for the ID value.</p>

<p>After some research it turns out this code worked fine in older MySQL versions,
because MySQL would silently convert the empty string to <code>0</code>,
and since the id field is an <code>AUTO_INCREMENT</code> integer,
MySQL would then treat that <code>0</code> as a signal to generate the next sequence value.</p>

<p>However MySQL 5.7 (which is the version we picked!), released in October 2015,
introduced a significant change: <code>STRICT_TRANS_TABLES</code> became enabled by default.
This means MySQL now rejects data type error like this one.</p>

<p>So to fix the issue we can change the MySQL version,
but the end goal is to upgrade the versions to the most recent, not to downgrade,
so let's instead just fix the code.</p>

<p>But first, we need to write a test: Test Driven Development, or no tests at all! ü§ò</p>

<h2 id="writing-the-test">Writing the test</h2>

<p>There are two kinds of tests that I hate: Smoke Tests, and End to End Tests.</p>

<p>End to End tests usually are about navigating the application, which is slow,
and checking for the content of the response, which is brittle.</p>

<p>However in this scenario, there are no alternative to test the features:
there are no HTTP framework, or handler / controller / services classes used
to allow us to write Functional / Integration / System tests.</p>

<p>To test our sign-up, all we can do is:</p>

<ul>
<li>issue a POST request to simulate the form being submitted</li>
<li>check in the database if the expected record has been persisted</li>
</ul>

<p>So let's just do that:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace Bl\Qa\Tests\EndToEnd;

use Bl\Qa\Tests\EndToEnd\Assertion\Assert;
use Bl\Qa\Tests\Infrastructure\Scenario\SignUpNewPlayer;
use Bl\Qa\Tests\Infrastructure\TestKernelSingleton;
use PHPUnit\Framework\Attributes\CoversNothing;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\Attributes\Large;
use PHPUnit\Framework\Attributes\TestDox;
use PHPUnit\Framework\TestCase;

#[CoversNothing]
#[Large]
final class SignUpTest extends TestCase
{
    public function test_it_allows_visitors_to_become_players(): void
    {
        $httpClient = TestKernelSingleton::get()-&gt;httpClient();

        $player = SignUpNewPlayer::run(
            'BisouTest',
            'password',
            'password',
        );

        Assert::signedUpCount($player-&gt;username, 1);
    }

    #[DataProvider('invalidCredentialsProvider')]
    #[TestDox('It prevents invalid credentials: $description')]
    public function test_it_prevents_invalid_credentials(string $username, string $password, string $description): void
    {
        SignUpNewPlayer::run(
            $username,
            $password,
            $password,
        );

        Assert::signedUpCount($username, 0);
    }

    /**
     * [string $username, string $password, string $description][].
     *
     * @return array&lt;array{string, string, string}&gt;
     */
    public static function invalidCredentialsProvider(): array
    {
        return [
            ['usr', 'password', 'username too short (&lt; 4 characters)'],
            ['test_sign_up02__', 'password', 'username too long (&gt; 15 characters)'],
            ['test_sign_up03!', 'password', 'username contains special characters (non alpha-numerical, not an underscore (`_`))'],
            ['test_sign_up05', 'pass', 'password too short (&lt; 5 characters)'],
            ['test_sign_up06', 'passwordthatistoolong', 'password too long (&gt; 15 characters)'],
            ['test_sign_up07', 'password!', 'password contains special characters (non alpha-numerical, not an underscore (`_`))'],
            ['BisouLand', 'password', 'system account, for notifications'],
        ];
    }

    #[TestDox('It prevents usernames that are already used')]
    public function test_it_prevents_usernames_that_are_already_used(): void
    {
        $httpClient = TestKernelSingleton::get()-&gt;httpClient();

        $username = 'BisouTest_';
        $password = 'password';
        $passwordConfirmation = $password;

        // First registration should succeed
        SignUpNewPlayer::run(
            $username,
            $password,
            $passwordConfirmation,
        );
        // Second registration should fail
        SignUpNewPlayer::run(
            $username,
            $password,
            $passwordConfirmation,
        );

        Assert::signedUpCount($username, 1);
    }

    public function test_it_prevents_passwords_that_do_not_match_confirmation(): void
    {
        $httpClient = TestKernelSingleton::get()-&gt;httpClient();

        $username = 'BisouTest';
        $password = 'password';
        $passwordConfirmation = 'different';

        SignUpNewPlayer::run(
            $username,
            $password,
            $passwordConfirmation
        );

        Assert::signedUpCount($username, 0);
    }
}
</code></pre>

<p>If I've read the long and nested if statements correctly,
this should cover all the different sign-up scenarios,
including username and password checking.</p>

<p>For now let's just run the "happy scenario" test to make sure it fails:</p>

<pre><code class="console">make test arg='--testdox --filter test_it_allows_visitors_to_become_players'
PHPUnit 12.3.2 by Sebastian Bergmann and contributors.

Runtime:       PHP 8.4.12
Configuration: /apps/qa/phpunit.xml.dist

F                                                                   1 / 1 (100%)

Time: 00:00.032, Memory: 18.00 MB

Sign Up (Bl\Qa\Tests\EndToEnd\SignUp)
 ‚úò It allows visitors to become players
   ‚îê
   ‚îú Failed asserting that Signed Up Count 0 is 1
   ‚îÇ
   ‚îÇ /apps/qa/tests/EndToEnd/Assertion/Assert.php:114
   ‚îÇ /apps/qa/tests/EndToEnd/SignUpTest.php:30
   ‚î¥

FAILURES!
Tests: 1, Assertions: 1, Failures: 1.
</code></pre>

<p>Brilliant! Before we fix it, I'll dive a bit more in the test details.</p>

<h2 id="test-data-cleanup">Test data cleanup</h2>

<p>I was surprised to find out that the username <code>BisouLand</code> was forbidden,
turns out it is used to send system notifications
(though I note that the checks are case sensitive only).</p>

<p>This is actually what inspired me to use <code>BisouTest</code> as a special test username,
if you remember correctly in the <code>SignUpNewPlayer</code> scenario,
which we've reused from the Smoke Tests as we would have done the exact same logic,
we have the following:</p>

<pre><code class="php">        if ('BisouTest' === $username) {
            $username = substr('BisouTest_'.uniqid(), 0, 15);
        }
</code></pre>

<p>This makes sure that there will be no username duplicates.</p>

<p>One thing I didn't mention in my previous article was that I've setup a way
to cleanup the test data with the <code>DeleteAllTestPlayers</code> scenario:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace Bl\Qa\Tests\Infrastructure\Scenario;

use Bl\Qa\Tests\Infrastructure\TestKernelSingleton;

final readonly class DeleteAllTestPlayers
{
    public static function run(): void
    {
        $pdo = TestKernelSingleton::get()-&gt;pdo();

        $pdo-&gt;query("DELETE FROM membres WHERE pseudo LIKE 'BisouTest%'");
    }
}
</code></pre>

<p>This is called by a PHPUnit subscriber for the <code>TestRunner\Finished</code> event:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace Bl\Qa\Tests\Infrastructure\Subscriber;

use Bl\Qa\Tests\Infrastructure\Scenario\DeleteAllTestPlayers;
use PHPUnit\Event\TestRunner\Finished;
use PHPUnit\Event\TestRunner\FinishedSubscriber;

final readonly class TestCleanupSubscriber implements FinishedSubscriber
{
    public function notify(Finished $event): void
    {
        DeleteAllTestPlayers::run();
    }
}
</code></pre>

<p>This will be called once the testsuite is finished executing,
but only if we register the subscriber in a PHPUnit Extension:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace Bl\Qa\Tests\Infrastructure\Subscriber;

use PHPUnit\Runner\Extension\Extension;
use PHPUnit\Runner\Extension\Facade;
use PHPUnit\Runner\Extension\ParameterCollection;
use PHPUnit\TextUI\Configuration\Configuration;

final readonly class TestCleanupExtension implements Extension
{
    public function bootstrap(Configuration $configuration, Facade $facade, ParameterCollection $parameters): void
    {
        $facade-&gt;registerSubscriber(new TestCleanupSubscriber());
    }
}
</code></pre>

<p>The extension also has to be registered in the <code>phpunit.xml</code> config:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- https://phpunit.readthedocs.io/en/latest/configuration.html --&gt;
&lt;phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         cacheDirectory=".phpunit.cache"
         executionOrder="depends,defects"
         shortenArraysForExportThreshold="10"
         requireCoverageMetadata="true"
         beStrictAboutCoverageMetadata="true"
         beStrictAboutOutputDuringTests="true"
         displayDetailsOnPhpunitDeprecations="true"
         colors="true"
         failOnPhpunitDeprecation="true"
         failOnRisky="true"
         failOnWarning="true"&gt;
    &lt;php&gt;
        &lt;ini name="display_errors" value="1" /&gt;
        &lt;ini name="error_reporting" value="-1" /&gt;
        &lt;env name="APP_ENV" value="test" force="true" /&gt;
        &lt;env name="SHELL_VERBOSITY" value="-1" /&gt;
    &lt;/php&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="smoke"&gt;
            &lt;directory&gt;tests/Smoke&lt;/directory&gt;
        &lt;/testsuite&gt;
        &lt;testsuite name="end-to-end"&gt;
            &lt;directory&gt;tests/EndToEnd&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;

    &lt;extensions&gt;
        &lt;bootstrap class="Bl\Qa\Tests\Infrastructure\Subscriber\TestCleanupExtension"/&gt;
    &lt;/extensions&gt;

    &lt;source ignoreIndirectDeprecations="true" restrictNotices="true" restrictWarnings="true"&gt;
        &lt;include&gt;
            &lt;directory&gt;../monolith/web&lt;/directory&gt;
        &lt;/include&gt;
    &lt;/source&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="custom-assertion">Custom Assertion</h2>

<p>I've created a <code>signedUpCount</code> custom assertion,
which will count in the database the number of records persisted for a given
username:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace Bl\Qa\Tests\EndToEnd\Assertion;

use Bl\Qa\Tests\Infrastructure\TestKernelSingleton;
use PHPUnit\Framework\Assert as PHPUnitAssert;

final readonly class Assert
{
    public static function signedUpCount(string $username, int $expectedCount): void
    {
        $pdo = TestKernelSingleton::get()-&gt;pdo();

        $stmt = $pdo-&gt;prepare('SELECT COUNT(*) FROM membres WHERE pseudo = :username');
        $stmt-&gt;execute([
            'username' =&gt; $username,
        ]);
        $actualCount = (int) $stmt-&gt;fetchColumn();

        PHPUnitAssert::assertSame(
            $expectedCount,
            $actualCount,
            "Failed asserting that Signed Up Count {$actualCount} is {$expectedCount}",
        );
    }
}
</code></pre>

<p>I think there's an argument to have had made two assertions
(eg <code>signedUpSuccessful</code> count = 1, and <code>signedUpFailed</code> count = 0),
but for now I'm happy with this.</p>

<h2 id="fixing-the-bug">Fixing the bug</h2>

<p>We're going to fix that bug by removing the ID field from the query:</p>

<pre><code class="php">mysql_query(
    'INSERT INTO membres (pseudo, mdp, confirmation, timestamp, lastconnect, amour)'
    ." VALUES ('{$pseudo}', '{$hmdp}', '1', ".time().', '.time().", '300')"
);
</code></pre>

<p>Let's see if the bug is fixed by running the one test:</p>

<pre><code class="console">make test arg='--testdox --filter test_it_allows_visitors_to_become_players'
PHPUnit 12.3.2 by Sebastian Bergmann and contributors.

Runtime:       PHP 8.4.12
Configuration: /apps/qa/phpunit.xml.dist

.                                                                   1 / 1 (100%)

Time: 00:00.018, Memory: 18.00 MB

Sign Up (Bl\Qa\Tests\EndToEnd\SignUp)
 ‚úî It allows visitors to become players

OK (1 test, 1 assertion)
</code></pre>

<p>So far so good, let's confirm by running all the tests:</p>

<pre><code class="console">make test
PHPUnit 12.3.2 by Sebastian Bergmann and contributors.

Runtime:       PHP 8.4.12
Configuration: /apps/qa/phpunit.xml.dist

.................................................                 49 / 49 (100%)

Time: 00:00.162, Memory: 18.00 MB

OK (49 tests, 49 assertions)
</code></pre>

<p>Excellent! All fixed!</p>

<h2 id="conclusion">Conclusion</h2>

<p>I believe there will be many more instances of this,
and given the success of this fix we can assume it's safe to apply to all instances.</p>

<p>But I know these <code>mysql_query</code> calls will be removed very soon:</p>

<ul>
<li>they are deprecated</li>
<li>the query used is vulnerable to SQL Injection</li>
</ul>

<p>The End to End tests we've written also allow us to refactor the code,
instead of a nested list we can for example make use of early returns.</p>

<p>But if I have to refactor that code, I want to do it right,
by first writing unit tests which will make a design model emerge,
and by creating an API so we can also have integration tests.</p>

<p>Once we have these, both the Smoke Tests and End to End tests can be removed.</p>

<p>So I'm going to leave this as is for now.</p>

<blockquote>
  <p>‚ÅâÔ∏è <em>What do you mean, "the code is ugly"??</em></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[eXtreme Legacy 2: Smoke Tests]]></title>
            <link href="/2025/09/17/xl-2-smoke-tests.html"/>
            <updated>2025-09-17T00:00:00+01:00</updated>
            <id>/2025/09/17/xl-2-smoke-tests.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p>ü§ò The Quality Avenger emerges from the burning forges of Coding Standards,
  smelting the ores of Static Analysis into the moulds of Automated Testing. üî•</p>
</blockquote>

<p>In this series, we're dealing with BisouLand, an eXtreme Legacy application
(2005 LAMP spaghetti code base). So far, we have:</p>

<ol>
<li><a href="/2025/09/10/xl-1-dockerizing-2005-lamp-app.html">üêã got it to run in a local container</a></li>
</ol>

<p>This means we can access it (http://localhost:8080/) and manually check it.
Unfortunately looking at the <a href="https://github.com/pyricau/bisouland/tree/4.0.1">code</a>,
it's obvious we cannot launch it to production as is:</p>

<ul>
<li>Encoding Issues</li>
<li>Broken Authentication and Session Management</li>
<li>Cross-Site Scripting (XSS) Flaws</li>
<li>Injection Flaws, including SQL injection</li>
<li>Improper Error Handling</li>
<li>Non Compliance with GDPR requirements</li>
</ul>

<p>But how do we know we're not breaking anything when fixing these?
As things currently stand, we don't even know what features BisouLand has.</p>

<p>So, we're going to need to write tests, which will be today's second article focus.</p>

<ul>
<li><a href="#qa-app">QA app</a></li>
<li><a href="#smoke-tests">Smoke Tests</a></li>
<li><a href="#custom-assertions">Custom Assurance</a></li>
<li><a href="#scenarios">Scenarios</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="qa-app">QA app</h2>

<p>The first plan of action is to move the current app into the <code>./apps/monolith</code>
sub-folder, and to create a new QA one in <code>./apps/qa</code>.</p>

<p>This approach will allow us to isolate the legacy code from any tooling we might
need to bring it up to standards.</p>

<p>The QA application has the following tree directory:</p>

<pre><code>apps/qa/
‚îú‚îÄ‚îÄ composer.json
‚îú‚îÄ‚îÄ composer.lock
‚îú‚îÄ‚îÄ compose.yaml
‚îú‚îÄ‚îÄ Dockerfile
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ phpstan-baseline.neon
‚îú‚îÄ‚îÄ phpstan.neon.dist
‚îú‚îÄ‚îÄ phpunit.xml.dist
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tests/
</code></pre>

<p>As you can see, it has its own <code>Dockerfile</code>:</p>

<pre><code># syntax=docker/dockerfile:1

###
# PHP Dev Container
# Utility Tools: PHP, bash, Composer
###
FROM php:8.4-cli-alpine AS php_dev_container

# Composer environment variables:
# * default user is superuser (root), so allow them
# * put cache directory in a readable/writable location
# _Note_: When running `composer` in container, use `--no-cache` option
ENV COMPOSER_ALLOW_SUPERUSER=1 \
    COMPOSER_CACHE_DIR=/tmp/.composer/cache

# Install dependencies:
# * bash for shell access and scripting
# * zip for composer packages that use ZIP archives
# _Note (Alpine)_: `--no-cache` includes `--update` and keeps image size minimal
#
# Then install PHP extensions
#
# _Note (Hadolint)_: No version locking, since Alpine only ever provides one version
# hadolint ignore=DL3018
RUN apk add --update --no-cache \
        bash \
        libzip-dev \
        zip \
    &amp;&amp; docker-php-ext-install \
        bcmath \
        pdo \
        pdo_mysql \
        zip

# Copy Composer binary from composer image
# _Note (Hadolint)_: False positive as `COPY` works with images too
# See: https://github.com/hadolint/hadolint/issues/197#issuecomment-1016595425
# hadolint ignore=DL3022
COPY --from=composer:2 /usr/bin/composer /usr/bin/composer

WORKDIR /apps/qa

# Caching `composer install`, as long as composer.{json,lock} don't change.
COPY composer.json composer.lock ./
RUN composer install \
    --no-cache \
    --no-interaction \
    --no-plugins \
    --no-scripts \
    --optimize-autoloader

# Copy the remaining application files (excluding those listed in .dockerignore)
COPY . .
</code></pre>

<p>And <code>compose.yaml</code>:</p>

<pre><code class="yaml">name: skyswoon-qa

services:
  app:
    build: .
    command: php -S 0.0.0.0:8081
    volumes:
      # Mount current directory into container for QA tools and configs
      - .:/apps/qa
      # Mount the monolith source code for analysis
      - ../monolith:/apps/monolith
    networks:
      - default
      - skyswoon-monolith_default

networks:
  skyswoon-monolith_default:
    external: true
</code></pre>

<p>This allows us to have QA in its own container (with PHP 8.4),
but it can still communicate with the monolith container,
so we can issue curl requets or query the MySQL database.</p>

<p>It also allows access to the monolith source files,
so we can run toolings on them like phpstan, rector, PHP CS Fixer, etc.</p>

<h2 id="smoke-tests">Smoke Tests</h2>

<p>There are two kinds of tests that I hate
(this is coming from a Test Driven Development practitioner, btw!)
and one of them is Smoke Tests.</p>

<p>Those basically issue a curl request,
and only check the bare minimum such as the status code is <code>200</code>.</p>

<p>I don't like these because they are slow (remote requests),
unreliable (errors like form validation, page not found, etc will still return <code>200</code>),
and overall don't provide much value at all.</p>

<p>However in this specific case I still think Smoke Tests can help us,
notably to make a list of what pages the website has,
and also differentiate the ones that are public,
and the ones that should only be accessed by logged in players.</p>

<p>This will be valuable knowledge,
and once we have better test coverage <strong>we can get rid of those</strong>.</p>

<p>After manually navigating the website, checking the <code>pages.php</code> file,
and overall getting familiar with the app,
I've documented my findings in a data provider in the following Smoke Test,
which checks if all private pages are accessible to logged in players,
but not for logged out visitors:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace Bl\Qa\Tests\Smoke;

use Bl\Qa\Tests\Infrastructure\Scenario\GetLoggedInPlayer;
use Bl\Qa\Tests\Infrastructure\TestKernelSingleton;
use Bl\Qa\Tests\Smoke\Assertion\Assert;
use PHPUnit\Framework\Attributes\CoversNothing;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\Attributes\Large;
use PHPUnit\Framework\Attributes\TestDox;
use PHPUnit\Framework\TestCase;

#[CoversNothing]
#[Large]
final class PlayerPagesTest extends TestCase
{
    #[TestDox('it blocks $pageName page (`$url`) for visitors')]
    #[DataProvider('playerPagesProvider')]
    public function test_it_blocks_player_page_for_visitors(string $url, string $pageName): void
    {
        $httpClient = TestKernelSingleton::get()-&gt;httpClient();

        $response = $httpClient-&gt;request('GET', $url);

        Assert::blocksPageForLoggedOutVisitors($response);
    }

    #[TestDox('it loads $pageName page (`$url`) for logged in players')]
    #[DataProvider('playerPagesProvider')]
    public function test_it_loads_player_page_for_logged_in_players(string $url, string $pageName): void
    {
        $httpClient = TestKernelSingleton::get()-&gt;httpClient();

        $loggedInPlayer = GetLoggedInPlayer::run();

        $response = $httpClient-&gt;request('GET', $url, [
            'headers' =&gt; [
                'Cookie' =&gt; $loggedInPlayer-&gt;sessionCookie,
            ],
        ]);

        Assert::loadsPageForLoggedInPlayers($response);
    }

    /**
     * @return array&lt;array{string, string}&gt;
     */
    public static function playerPagesProvider(): array
    {
        return [
            ['/connected.html', 'account'],
            ['/action.html', 'blow kisses'],
            ['/cerveau.html', 'brain'],
            ['/changepass.html', 'change password'],
            ['/nuage.html', 'clouds'],
            ['/yeux.html', 'eyes'],
            ['/boite.html', 'inbox'],
            ['/bisous.html', 'kisses'],
            ['/construction.html', 'organs'],
            ['/infos.html', 'reference'],
            ['/techno.html', 'techniques'],
            ['/lire.html', 'view message'],
        ];
    }
}
</code></pre>

<p>Running this test <em>should</em> output the following:</p>

<pre><code class="console">&gt; make test arg='--testdox --filter PlayerPages'
PHPUnit 12.3.2 by Sebastian Bergmann and contributors.

Runtime:       PHP 8.4.11
Configuration: /apps/qa/phpunit.xml.dist

........................                                          24 / 24 (100%)

Time: 00:00.606, Memory: 18.00 MB

Player Pages (Bl\Qa\Tests\Smoke\PlayerPages)
 ‚úî it blocks organs page (`/construction.html`) for visitors
 ‚úî it blocks account page (`/connected.html`) for visitors
 ‚úî it blocks reference page (`/infos.html`) for visitors
 ‚úî it blocks kisses page (`/bisous.html`) for visitors
 ‚úî it blocks brain page (`/cerveau.html`) for visitors
 ‚úî it blocks change¬∑password page (`/changepass.html`) for visitors
 ‚úî it blocks eyes page (`/yeux.html`) for visitors
 ‚úî it blocks view¬∑message page (`/lire.html`) for visitors
 ‚úî it blocks clouds page (`/nuage.html`) for visitors
 ‚úî it blocks inbox page (`/boite.html`) for visitors
 ‚úî it blocks techniques page (`/techno.html`) for visitors
 ‚úî it blocks blow¬∑kisses page (`/action.html`) for visitors
 ‚úî it loads view¬∑message page (`/lire.html`) for logged in players
 ‚úî it loads eyes page (`/yeux.html`) for logged in players
 ‚úî it loads brain page (`/cerveau.html`) for logged in players
 ‚úî it loads change¬∑password page (`/changepass.html`) for logged in players
 ‚úî it loads techniques page (`/techno.html`) for logged in players
 ‚úî it loads account page (`/connected.html`) for logged in players
 ‚úî it loads reference page (`/infos.html`) for logged in players
 ‚úî it loads inbox page (`/boite.html`) for logged in players
 ‚úî it loads kisses page (`/bisous.html`) for logged in players
 ‚úî it loads organs page (`/construction.html`) for logged in players
 ‚úî it loads clouds page (`/nuage.html`) for logged in players
 ‚úî it loads blow¬∑kisses page (`/action.html`) for logged in players

OK (24 tests, 24 assertions)
</code></pre>

<blockquote>
  <p><em>üîó Check</em>: <a href="/2025/07/31/phpunit-best-practices.html">PHPUnit Best Practices</a></p>
</blockquote>

<p>The test is structured as follow:</p>

<ol>
<li>get an instance of HttpClient through TestKernelSingleton</li>
<li>optionally run some setup scenario such as <code>SignUpNewPlayer</code>, <code>LogInPlayer</code>, etc</li>
<li>send the remote request, and get the HTTP response</li>
<li>check that the HTTP Response satisfies our expectations</li>
</ol>

<h2 id="custom-assertions">Custom Assertions</h2>

<p>To be able to see if a page is blocked for a non logged in visitor,
we cannot just rely on the HTTP Status (it will always be 200),
so we have to instead check for error messages contained in the page.</p>

<p>Through my search, I've discovered that various messages get displayed when a
logged out visitor tries to access a private page,
I've documented this in the following custom assertion:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace Bl\Qa\Tests\Smoke\Assertion;

use PHPUnit\Framework\Assert as PHPUnitAssert;
use Symfony\Contracts\HttpClient\ResponseInterface;

final readonly class Assert
{
    private const array NOT_LOGGED_IN_MESSAGES = [
        // Warning: side bar contains `Tu n'es pas connect&amp;eacute;.`
        'standard' =&gt; 'es pas connect√© !!',
        'variant 1 (inbox)' =&gt; 'es pas connect&amp;eacute; !!',
        'variant 2 (kisses, organs, techniques, account)' =&gt; 'Veuillez vous connecter.',
        'variant 3 (reference)' =&gt; 'Erreur... et vouaip !! :D',
    ];

    public static function blocksPageForLoggedOutVisitors(ResponseInterface $response): void
    {
        $content = (string) $response-&gt;getContent();

        foreach (self::NOT_LOGGED_IN_MESSAGES as $message) {
            if (str_contains($content, $message)) {
                PHPUnitAssert::assertSame(200, $response-&gt;getStatusCode(), $content);

                return;
            }
        }

        PHPUnitAssert::fail('Failed asserting that Page is blocked for logged out visitors');
    }

    public static function loadsPageForLoggedInPlayers(ResponseInterface $response): void
    {
        $content = (string) $response-&gt;getContent();

        foreach (self::NOT_LOGGED_IN_MESSAGES as $message) {
            if (str_contains($content, $message)) {
                PHPUnitAssert::fail('Failed asserting that Page loads for logged in players');
            }
        }

        PHPUnitAssert::assertSame(200, $response-&gt;getStatusCode(), $content);
    }
}
</code></pre>

<h2 id="scenarios">Scenarios</h2>

<p>For some of our tests, we need to have a visitor to first sign up as a player,
which I've done through the following "Scenario" class:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace Bl\Qa\Tests\Infrastructure\Scenario;

use Bl\Qa\Tests\Infrastructure\TestKernelSingleton;

final readonly class SignUpNewPlayer
{
    public static function run(
        string $username = 'BisouTest',
        string $password = 'password',
        string $passwordConfirmation = 'password',
    ): Player {
        $httpClient = TestKernelSingleton::get()-&gt;httpClient();

        if ('BisouTest' === $username) {
            $username = substr('BisouTest_'.uniqid(), 0, 15);
        }

        $httpClient-&gt;request('POST', '/inscription.html', [
            'body' =&gt; [
                'Ipseudo' =&gt; $username,
                'Imdp' =&gt; $password,
                'Imdp2' =&gt; $passwordConfirmation,
                'inscription' =&gt; "S'inscrire",
            ],
            'headers' =&gt; [
                'Content-Type' =&gt; 'application/x-www-form-urlencoded',
            ],
        ]);

        return new Player($username, $password);
    }
}
</code></pre>

<p>Here we do an HTTP request that will simulate posting the HTML form,
alternatives for this would have been doing a SQL query to directly
create the player in the database, but we risk missing other insertions
that might be required.</p>

<p>The advantage of the current approach is that it also smoke tests the signup form.</p>

<p>We also need the player to be logged in:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace Bl\Qa\Tests\Infrastructure\Scenario;

use Bl\Qa\Tests\Infrastructure\TestKernelSingleton;
use Symfony\Component\HttpClient\Exception\RedirectionException;

final readonly class LogInPlayer
{
    public static function run(Player $player): string
    {
        $httpClient = TestKernelSingleton::get()-&gt;httpClient();

        try {
            $response = $httpClient-&gt;request('POST', '/redirect.php', [
                'body' =&gt; [
                    'pseudo' =&gt; $player-&gt;username,
                    'mdp' =&gt; $player-&gt;password,
                    'connexion' =&gt; 'Se connecter',
                ],
                'headers' =&gt; [
                    'Content-Type' =&gt; 'application/x-www-form-urlencoded',
                ],
                'max_redirects' =&gt; 0,
            ]);
        } catch (RedirectionException $e) { // @phpstan-ignore catch.neverThrown
            // With max_redirects=0, HttpClient throws an exception when we get a 302
            // This is expected on successful login
            $response = $e-&gt;getResponse();
        }

        $headers = $response-&gt;getHeaders(false);
        $cookies = $headers['set-cookie'] ?? $headers['Set-Cookie'] ?? [];
        foreach ($cookies as $cookie) {
            if (str_starts_with($cookie, 'PHPSESSID=')) {
                return $cookie;
            }
        }

        $content = $response-&gt;getContent(false);
        $allCookies = implode(', ', $cookies);

        throw new \RuntimeException("Login failed: PHPSESSID cookie not found. Cookies: [{$allCookies}], Content: {$content}");
    }
}
</code></pre>

<p>Similarly to the <code>SignUpNewPlayer</code> scenario,
<code>LogInPlayer</code> posts a HTTP request that simulates the log in form.</p>

<p>To be abe to then act as the logged in player, we need their Session Cookie string,
so we make sure to return it.</p>

<p>Finally the <code>GetLoggedInPlayer</code> scenario will sign up and login a player once,
and always return it to save us some overhead in the test suite:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace Bl\Qa\Tests\Infrastructure\Scenario;

final class GetLoggedInPlayer
{
    private static ?LoggedInPlayer $loggedInPlayer = null;

    public static function run(): LoggedInPlayer
    {
        if (null === self::$loggedInPlayer) {
            $player = SignUpNewPlayer::run();
            $sessionCookie = LogInPlayer::run($player);

            self::$loggedInPlayer = new LoggedInPlayer($player-&gt;username, $player-&gt;password, $sessionCookie);
        }

        return self::$loggedInPlayer;
    }
}
</code></pre>

<p>These scenarios will come in handy when we start writing other kinds of tests.</p>

<h2 id="conclusion">Conclusion</h2>

<blockquote>
  <p>üíª <strong>Source code</strong>:</p>
  
  <ul>
  <li><a href="https://github.com/pyricau/bisouland/tree/4.0.5">Before our changes</a></li>
  <li><a href="https://github.com/pyricau/bisouland/tree/4.0.6">After Smoke Tests</a></li>
  </ul>
</blockquote>

<p>Now we can type:</p>

<pre><code class="console">make test arg='--testdox --filter PlayerPages'
</code></pre>

<p>And get the list of all public and private pages.</p>

<blockquote>
  <p>‚ÅâÔ∏è <em>What do you mean, "tests are failing"??</em></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHPUnit Best Practices (Ultimate Guide)]]></title>
            <link href="/2025/07/31/phpunit-best-practices.html"/>
            <updated>2025-07-31T00:00:00+01:00</updated>
            <id>/2025/07/31/phpunit-best-practices.html</id>
            <content type="html"><![CDATA[<p>Forge battle-tested code, under the hammer of PHPUnit.</p>

<ul>
<li><a href="#unit-tests">Unit Tests</a>

<ul>
<li><a href="#factory-methods">Factory Methods</a></li>
<li><a href="#attributes">Attributes</a></li>
<li><a href="#data-providers">Data Providers</a></li>
<li><a href="#testdox">Testdox</a></li>
<li><a href="#coding-standards">Coding Standards</a></li>
<li><a href="#principles">Principles</a></li>
</ul></li>
<li><a href="#mocking">Mocking</a></li>
<li><a href="#integration-tests">Integration Tests</a>

<ul>
<li><a href="#smoke-tests">Smoke Tests</a></li>
</ul></li>
<li><a href="#useful-cli-options">Useful CLI options</a>

<ul>
<li><a href="#configuration">Configuration</a></li>
</ul></li>
</ul>

<h2 id="unit-tests">Unit Tests</h2>

<blockquote>
  <p><em>Inspired by <strong>Sebastian Bergmann</strong>, _Sources</em>:</p>
  
  <ul>
  <li><a href="https://www.youtube.com/watch?v=qwRdnoeq1H8">So you think you know PHPUnit - Sebastian Bergmann - PHPDD2024</a></li>
  <li><a href="https://www.youtube.com/watch?v=wR6YflVkAt4">Optimizing Your Test Suite - Sebastian Bergmann - PHP fwdays 2021</a></li>
  <li><a href="https://github.com/sebastianbergmann/raytracer/">Sebastian's raytracer project</a></li>
  <li><a href="https://phpunit.de/documentation.html">PHPUnit documentation</a></li>
  </ul>
</blockquote>

<p>Here's a unit test for a <code>CheckArray-&gt;check(string $field, mixed $value): array</code> class:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace App\Tests\Unit\Domain\Check;

use App\Domain\Check\CheckArray;
use App\Domain\Exception\ValidationFailedException;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\Attributes\Small;
use PHPUnit\Framework\Attributes\TestDox;
use PHPUnit\Framework\TestCase;

#[CoversClass(CheckArray::class)]
#[Small]
class CheckArrayTest extends TestCase
{
    private const string FIELD = 'path.field_name';

    private function checkArray(): CheckArray
    {
        return new CheckArray();
    }

    public function test_it_accepts_valid_array(): void
    {
        $validArray = [23, 42, 1337];

        $this-&gt;assertSame($validArray, $this-&gt;checkArray()-&gt;check(
            self::FIELD,
            $validArray,
        ));
    }

    public function test_it_accepts_null(): void
    {
        // When checking that no exception is thrown
        $this-&gt;expectNotToPerformAssertions();

        $this-&gt;checkArray()-&gt;check(
            self::FIELD,
            null,
        );
    }

    /**
     * @return array&lt;string, array{mixed}&gt;
     */
    public static function nonArrayTypesProvider(): array
    {
        return [
            'string' =&gt; ['hello world'],
            'integer' =&gt; [42],
            'boolean' =&gt; [false],
        ];
    }

    #[DataProvider('nonArrayTypesProvider')]
    public function test_it_rejects_non_array_types(mixed $notAnArray): void
    {
        $this-&gt;expectException(ValidationFailedException::class);

        $this-&gt;checkArray()-&gt;check(
            self::FIELD,
            $notAnArray,
        );
    }
}
</code></pre>

<h3 id="factory-methods">Factory Methods</h3>

<p>When the System Under Test (SUT) has a simple constructor,
or its instantiation is clear and consistent,
then instantiate it directly in each test method.</p>

<p>But when the SUT's constructor has multiple parameters,
or a couple of test method require the same specific configuration, 
consider moving that creation logic to a private factory method:</p>

<ul>
<li>it ensures test consistency and validity by eliminating configuration drift</li>
<li>it centralizes complex instantiation logic, making tests more readable</li>
</ul>

<p>Finally, when your SUT legitimately needs to be tested under different configurations,
create explicit factory methods that document these variations.</p>

<h3 id="attributes">Attributes</h3>

<p>Attributes (<code>#[&lt;Name&gt;]</code>) were introduced in PHP 8 and PHPUnit 10,
they replace Annotations (PHPdoc <code>@&lt;Name&gt;</code>) which have been deprecated in PHPUnit 10
and removed in PHPUnit 12.</p>

<p>Their goal is to make PHP tooling more robust and IDE integration more reliable, use them!</p>

<p><strong>Specify targeted class</strong>:</p>

<ul>
<li><code>#[CoversClass]</code>: enforces proper test boundaries, prevents accidental coverage,
and makes the intent clearer both to the readers and tools
(code coverage, static analysis, etc)</li>
<li><code>#[UsesClass]</code>: if code from other classes is expected to be used</li>
</ul>

<p><strong>Categorize tests</strong> based on their scope, complexity and resource usage:</p>

<ul>
<li><code>#[Small]</code> for testing individual components in isolation (unit),
fast execution (typically under 100ms)</li>
<li><code>#[Medium]</code> for testing multiple components together in isolation (integration),
moderate execution (typically under 1s)</li>
<li><code>#[Large]</code> for complete workflows (end to end),
slow execution (over 1s)</li>
<li><code>#[Group]</code> for arbitrary categories (including temporary ones, eg <code>wip</code>)</li>
</ul>

<h3 id="data-providers">Data Providers</h3>

<p><strong>Use Data Providers</strong> to test different sets of inputs / outputs:</p>

<ul>
<li><code>#[DataProvider(string $publicStaticMethodName)]</code>
for a method in the test class</li>
<li><code>#[DataProviderExternal(string $className, string $publicStaticMethodName)]</code>
for a method in a different class from the test one</li>
<li><code>#[TestWith(array $data)]</code>
to provide one set at a time, without having to declare a static method</li>
</ul>

<h3 id="testdox">Testdox</h3>

<p><strong>Run PHPUnit with <code>--testdox</code> option</strong> to get executable specifications:</p>

<ul>
<li><code>#[TestDox(string $text)]</code>
to customize what PHPUnit will display</li>
</ul>

<blockquote>
  <p><strong>Note 1</strong></p>
  
  <p>Running <code>phpunit --testdox</code> with the following data provider:</p>

<pre><code class="php">    public static function nonArrayTypesProvider(): array
    {
        return [
            ['hello world'],
            [42],
            [false],
        ];
    }

    #[DataProvider('nonArrayTypesProvider')]
    public function test_it_rejects_non_array_types(mixed $notAnArray): void
</code></pre>
  
  <p>Will output:</p>

<pre><code>Check Array (App\Tests\Unit\Domain\Check\CheckArray)
 ‚úî It rejects non array types with data set 0
 ‚úî It rejects non array types with data set 1
 ‚úî It rejects non array types with data set 2
</code></pre>
</blockquote>

<hr />

<blockquote>
  <p><strong>Note 2</strong></p>
  
  <p>This is equivalent to:</p>

<pre><code class="php">    #[TestWith(['hello world'])]
    #[TestWith([42])]
    #[TestWith([false])]
    public function test_it_rejects_non_array_types(mixed $notAnArray): void
</code></pre>
</blockquote>

<hr />

<blockquote>
  <p><strong>Note 3</strong></p>
  
  <p>However, we can use string keys to describe each set:</p>

<pre><code class="php">    public static function nonArrayTypesProvider(): array
    {
        return [
            'string' =&gt; ['hello world'],
            'integer' =&gt; [42],
            'boolean' =&gt; [false],
        ];
    }

    #[DataProvider('nonArrayTypesProvider')]
    public function test_it_rejects_non_array_types(mixed $notAnArray): void
</code></pre>
  
  <p>Which will output:</p>

<pre><code>Check Array (App\Tests\Unit\Domain\Check\CheckArray)
 ‚úî It rejects non array types with string
 ‚úî It rejects non array types with integer
 ‚úî It rejects non array types with boolean
</code></pre>
</blockquote>

<hr />

<blockquote>
  <p><strong>Note 4</strong></p>
  
  <p>Finally, we can also change the text with <code>#[TestDox]</code>:</p>

<pre><code class="php">    public static function nonArrayTypesProvider(): array
    {
        return [
            'string' =&gt; ['hello world'],
            'integer' =&gt; [42],
            'boolean' =&gt; [false],
        ];
    }

    #[DataProvider('nonArrayTypesProvider')]
    #[TestDox('it rejects `$notAnArray` because it does not have type `array`')]
    public function test_it_rejects_non_array_types(mixed $notAnArray): void
</code></pre>
  
  <p>Which will output:</p>

<pre><code>Check Array (App\Tests\Unit\Domain\Check\CheckArray)
 ‚úî it rejects `hello¬∑world` because it does not have type `array`
 ‚úî it rejects `42` because it does not have type `array`
 ‚úî it rejects `false` because it does not have type `array`
</code></pre>
</blockquote>

<h3 id="coding-standards">Coding Standards</h3>

<p><strong>Follow Coding Standards</strong> to ensure consistency across the PHP ecosystem,
and internal projects:</p>

<ul>
<li><a href="https://www.php-fig.org/psr/psr-4/">PSR-4</a> for file, namespace and class names</li>
<li><a href="https://www.php-fig.org/psr/psr-12/">PSR-12</a> for the rest</li>
<li>discuss, agree and enforce coding styles in your team
eg using <a href="https://cs.symfony.com/">PHP CS Fixer</a></li>
</ul>

<p><em>Here are examples of topics you can debate</em>:</p>

<ul>
<li><strong>Enforce strict types declaration</strong> (<code>declare(strict_types=1)</code>)
to prevent type coercion bugs that can cause tests to pass when they shouldn't</li>
<li><strong>Make test classes final</strong> 
as they should never be extended from</li>
<li><strong>Use visibility and type hint keywords</strong> 
for future-proofing against language changes</li>
<li><strong>Follow snake case for test method names</strong>
so they read as text, with underscores representing spaces</li>
<li><strong>Use <code>$this</code> over <code>self</code></strong>
to call PHPUnit assertions</li>
<li><strong>Use <code>#[Test]</code> attribute and <code>it_</code> prefix</strong>
to help name test methods in an articulate way</li>
</ul>

<h3 id="principles">Principles</h3>

<p>FIRST properties of Unit Tests, they should be:</p>

<ul>
<li><strong>Fast</strong>: to provide a short feedback loop</li>
<li><strong>Isolated</strong>: one test failure shouldn't impact another test</li>
<li><strong>Repeatable</strong>: the outcome of a test should be consistent over time</li>
<li><strong>Self-validating</strong>: automated test should fail or pass for the right reason</li>
<li><strong>Timely</strong>: write the test around the time the code was written, not long after (but ideally before)</li>
</ul>

<p>Follow <a href="https://wiki.c2.com/?ArrangeActAssert">AAA</a>,
each test method should group these functional sections, separated by blank lines:</p>

<ol>
<li><strong>Arrange</strong>: all necessary preconditions and input</li>
<li><strong>Act</strong>: on the System Under Test (SUT)</li>
<li><strong>Assert</strong>: that the expected results have occurred</li>
</ol>

<p>Not necessarily in that order (eg when testing exceptions: Arrange, Expect, Act).</p>

<p><a href="https://wiki.c2.com/?DontRepeatYourself">DRY</a> vs DAMP (aka WET),
it's all about finding the right balance: pick whichever is more readable,
on a case-by-case basis.</p>

<blockquote>
  <p>"DRY (Don't Repeat Yourself) increases maintainability
  by isolating change (risk) to only those parts of the system that must change.</p>
  
  <p>DAMP (Descriptive And Meaningful Phrases, <em>aka WET: We Edit Twice</em>) increases maintainability
  by reducing the time necessary to read and understand the code."</p>
  
  <p>‚Äî Chris Edwards</p>
</blockquote>

<h2 id="mocking">Mocking</h2>

<blockquote>
  <p><strong>Note</strong>: this is "In My Humble Opinion".</p>
</blockquote>

<p>There are two Test Driven Development (TDD) schools of thought:</p>

<ul>
<li><strong>Chicago / Detroit (classical)</strong>: use real objects, avoid mocks</li>
<li><strong>London (specification Behaviour Driven Development - spec BDD)</strong>:
use mocks to describe interactions between the System Under Test (SUT) and its dependencies (collaborators)</li>
</ul>

<p>The mocking library <a href="https://github.com/phpspec/prophecy">prophecy</a>'s expressive syntax
allows for an approach that's more aligned with spec BDD.
It can be used in PHPUnit with the <code>phpspec/prophecy-phpunit</code> package:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace App\Tests\Unit\Domain\Event\Check;

use App\Domain\Check\CheckDateTimeIso8601;
use App\Domain\Event\Check\CheckStart;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\Small;
use PHPUnit\Framework\TestCase;
use Prophecy\PhpUnit\ProphecyTrait;

#[CoversClass(CheckStart::class)]
#[Small]
final class CheckStartTest extends TestCase
{
    use ProphecyTrait;

    private const string FIELD = 'start';
    private const string START = '2025-06-17T13:00:00';

    public function test_it_checks_start(): void
    {
        $checkDateTimeIso8601 = $this-&gt;prophesize(CheckDateTimeIso8601::class);

        $checkDateTimeIso8601-&gt;check(
            self::FIELD,
            self::START,
        )-&gt;shouldBeCalled()-&gt;willReturn(self::START);

        $checkStart = new CheckStart(
            $checkDateTimeIso8601-&gt;reveal(),
        );
        $this-&gt;assertSame(self::START, $checkStart-&gt;check(
            self::FIELD,
            self::START,
        ));
    }
}
</code></pre>

<h2 id="integration-tests">Integration Tests</h2>

<blockquote>
  <p>ü§´ <strong>Super Secret Tip</strong>:</p>
  
  <p>PHPUnit instantiates the test class once per test method and once per data provider row.
  This is a fundamental design decision that prioritizes test isolation over performance.</p>
  
  <p>So if you have:</p>
  
  <ul>
  <li>5 regular test methods: that's 5 instances</li>
  <li>1 test method with 10 data provider rows: that's 10 instances</li>
  <li>Total: 15 instances created</li>
  </ul>
  
  <p>Why This Matters:</p>
  
  <ul>
  <li><strong>Performance</strong> : expensive <code>setUp()</code> and constructors will have a measurable impact</li>
  <li><strong>Memory Usage</strong>: Each instance holds its own state in memory until the end of the testsuite run</li>
  <li><strong>Test Isolation</strong>: Ensures no state leakage between tests (the main benefit)</li>
  </ul>
  
  <p>Since each test method creates a new instance, expensive operations compound quickly. Watch out for:</p>
  
  <ul>
  <li>repeated kernel booting</li>
  <li>database connections</li>
  <li>fixture loading (especially when Doctrine ORM Entity hydration is involved)</li>
  <li>external API calls</li>
  </ul>
  
  <p>You can use singletons for stateless services, transactions for database cleanup, and mocks for external dependencies.
  The example below uses <code>AppSingleton::get()</code> to share a stateless application instance across the entire testsuite.</p>
</blockquote>

<h3 id="smoke-tests">Smoke Tests</h3>

<blockquote>
  <p><strong>Note</strong>: this is the pragmatic approach.</p>
</blockquote>

<p>For controllers and commands, no need to mock internal dependencies
or asserting on complex business logic.</p>

<p>Just craft the input, pass it to application, and verify the status code.</p>

<p>This tests the entire request-response cycle:
routing, middleware, validation, business logic, serialization... Everything.</p>

<p>Here's an integration test for a <code>POST /v1/events</code> endpoint controller:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace App\Tests\Integration\Controller\Event;

use App\Controller\Event\CreateController;
use App\Tests\AppSingleton;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\Medium;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

#[CoversClass(CreateController::class)]
#[Medium]
final class CreateControllerTest extends TestCase
{
    public function test_it_creates_new_one(): void
    {
        $appKernel = AppSingleton::get()-&gt;appKernel();

        $headers = [
            'CONTENT_TYPE' =&gt; 'application/json',
        ];
        $request = Request::create('/v1/events', 'POST', [], [], [], $headers, (string) json_encode([
            'title' =&gt; 'Daily stand up',
            'start' =&gt; (new \DateTimeImmutable('now'))-&gt;format('Y-m-d\TH:i:s'),
            'end' =&gt; (new \DateTimeImmutable('now + 1 second'))-&gt;format('Y-m-d\TH:i:s'),
        ]));

        $response = $appKernel-&gt;handle($request);
        $appKernel-&gt;terminate($request, $response);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), (string) $response-&gt;getContent());
    }

    public function test_it_cannot_create_new_one_without_required_fields(): void
    {
        $appKernel = AppSingleton::get()-&gt;appKernel();

        $headers = [
            'CONTENT_TYPE' =&gt; 'application/json',
        ];
        $request = Request::create('/v1/events', 'POST', [], [], [], $headers, (string) json_encode([
            'start' =&gt; '2025-07-09T09:00:00+00:00',
            'end' =&gt; '2025-07-09T09:15:00+00:00',
        ]));

        $response = $appKernel-&gt;handle($request);
        $appKernel-&gt;terminate($request, $response);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), (string) $response-&gt;getContent());
    }
}
</code></pre>

<p>And here's an integration test for a <code>./bin/console events:list</code> CLI command:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace App\Tests\Integration\Command\Event;

use App\Command\Event\ListCommand;
use App\Tests\AppSingleton;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\Medium;
use PHPUnit\Framework\TestCase;
use Symfony\Component\Console\Command\Command;

#[CoversClass(ListCommand::class)]
#[Medium]
final class ListCommandTest extends TestCase
{
    public function test_it_lists_existing_ones(): void
    {
        $applicationTester = AppSingleton::get()-&gt;applicationTester();

        $input = [
            ListCommand::NAME,
        ];

        $statusCode = $applicationTester-&gt;run($input);

        $this-&gt;assertSame(Command::SUCCESS, $statusCode, $applicationTester-&gt;getDisplay());
    }
}
</code></pre>

<h2 id="useful-cli-options">Useful CLI options</h2>

<pre><code class="console">phpunit

  # Configuration:
  --generate-configuration             Generate configuration file with suggested settings
  --migrate-configuration              Migrate configuration file to current format

  # Selection:
  --list-groups                        List available test groups
  --group small                        Only run tests from the specified group(s)
  --exclude-group small                Exclude tests from the specified group(s)

  --list-tests                         List available tests
  --covers 'CheckArray'                Only run tests that intend to cover &lt;name&gt;
  --filter 'CheckArrayTest'            Filter which tests to run (test class, or test method)
  --filter 'test_it_accepts_valid_array'

  ## Useful for running testsuites individually, in the CI
  --list-testsuites                    List available testsuites
  --testsuite unit                     Only run tests from the specified testsuite(s)
  --exclude-testsuite unit             Exclude tests from the specified testsuite(s)

  # Execution
  --stop-on-failure                    Stop after first failure
  --order-by &lt;order&gt;                   Run tests in order: default|defects|depends|duration|no-depends|random|reverse|size

  # Reporting
  --no-progress                        Disable output of test execution progress (the dots)
  --testdox                            Replace default result output with TestDox format
</code></pre>

<blockquote>
  <p><strong>Order By options</strong>:</p>
  
  <ul>
  <li><code>default</code>: tests run in the order they're discovered
  (filesystem order, typically alphabetical)</li>
  <li><code>defects</code>: previously failed/errored tests run first
  (requires <code>--cache-result</code> to remember past failures)</li>
  <li><code>depends</code>: tests with dependencies run after their dependencies, non-dependent tests run first</li>
  <li><code>duration</code>: fastest tests run first, slowest tests run last
  (requires <code>--cache-result</code> to remember execution times)</li>
  <li><code>no-depends</code>: ignores test dependencies and runs tests in discovery order</li>
  <li><code>random</code>: tests run in random order
  (use <code>--random-order-seed &lt;N&gt;</code> for reproducible randomness)</li>
  <li><code>reverse</code>: tests run in reverse discovery order</li>
  <li><code>size</code>: tests run by size: <code>#[Small]</code>, then <code>#[Medium]</code>, after <code>#[Large]</code>, and finally unsized tests</li>
  </ul>
  
  <p><em>Worth noting</em>: > * Combining options: <code>--order-by=depends,defects</code></p>
</blockquote>

<h3 id="configuration">Configuration</h3>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- https://phpunit.readthedocs.io/en/latest/configuration.html --&gt;
&lt;phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="tests/bootstrap.php"

         cacheDirectory=".phpunit.cache"
         executionOrder="depends,defects"
         requireCoverageMetadata="true"
         beStrictAboutCoverageMetadata="true"
         beStrictAboutOutputDuringTests="true"
         displayDetailsOnPhpunitDeprecations="true"
         failOnPhpunitDeprecation="true"
         failOnRisky="true"
         failOnWarning="true"

         shortenArraysForExportThreshold="10"
         colors="true"
&gt;
    &lt;php&gt;
        &lt;!-- Useful for CI environments --&gt;
        &lt;ini name="display_errors" value="1" /&gt;
        &lt;ini name="error_reporting" value="-1" /&gt;

        &lt;!-- Useful for Symfony --&gt;
        &lt;env name="KERNEL_CLASS" value="App\Kernel" /&gt;
        &lt;env name="APP_ENV" value="test" force="true" /&gt;
        &lt;env name="APP_DEBUG" value="0" force="true" /&gt;
        &lt;env name="SHELL_VERBOSITY" value="-1" /&gt;
    &lt;/php&gt;

    &lt;testsuites&gt;
        &lt;testsuite name="unit"&gt;
            &lt;directory&gt;tests/Unit&lt;/directory&gt;
        &lt;/testsuite&gt;
        &lt;testsuite name="integration"&gt;
            &lt;directory&gt;tests/Integration&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;

    &lt;source
        ignoreIndirectDeprecations="true"
        restrictNotices="true"
        restrictWarnings="true"
    &gt;
        &lt;include&gt;
            &lt;directory&gt;src&lt;/directory&gt;
        &lt;/include&gt;
    &lt;/source&gt;
&lt;/phpunit&gt;
</code></pre>

<blockquote>
  <p><strong>Notes</strong>:</p>
  
  <ul>
  <li><code>bootstrap</code> defaults to <code>vendor/autoload.php</code></li>
  <li><code>shortenArraysForExportThreshold</code> defaults to <code>0</code> from v11.3 and <code>10</code> from v12</li>
  <li><code>colors</code> defaults to <code>false</code>, for automated/scripted environment compatibility</li>
  </ul>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHPUnit setUp() is a lie]]></title>
            <link href="/2024/07/03/phpunit-setup-is-a-lie.html"/>
            <updated>2024-07-03T00:00:00+01:00</updated>
            <id>/2024/07/03/phpunit-setup-is-a-lie.html</id>
            <content type="html"><![CDATA[<p><a href="https://phpunit.de/index.html">PHPUnit</a> creates as many instances a Test Class, as it has test methods.</p>

<h2 id="proof-and-it-gets-worse">Proof (and it gets worse)</h2>

<p>Let's set up a project to verify our claim:</p>

<pre><code>mkdir /tmp/phpunit-is-a-cake &amp;&amp; cd "$_"
composer init --no-interaction --name 'follow/the-white-rabbit' --type project --autoload '.'
composer require -o --dev phpunit/phpunit:^9.6
</code></pre>

<p>Next we write a catchy test:</p>

<pre><code>&lt;?php declare(strict_types=1);
use PHPUnit\Framework\TestCase;

class CatchyTest extends TestCase
{
    private string $letMeCountThemForYou = '';

    public function __construct($name = null, array $data = [], $dataName = '')
    {
        parent::__construct($name, $data, $dataName);

        echo "How many times have I, how many times have I, how many times have I been instanciated?\n";
    }

    public function __destruct()
    {
        echo "Till the morning light\n";
    }

    public function testOne(): void
    {
        $this-&gt;letMeCountThemForYou .= 'One';

        echo "{$this-&gt;letMeCountThemForYou}\n";
    }

    public function testTwo(): void
    {
        $this-&gt;letMeCountThemForYou .= 'Two';

        echo "{$this-&gt;letMeCountThemForYou}\n";
    }

    /**
     * @dataProvider provider
     */
    public function testMore($times): void
    {
        $this-&gt;letMeCountThemForYou .= $times;

        echo "{$this-&gt;letMeCountThemForYou}\n";
    }

    public function provider(): array
    {
        return [['Three'], ['Four'], ['Five'], ['Six'], ['Seven'], ['Eight']];
    }
}
</code></pre>

<p>Finally we run the tests to see the output:</p>

<pre><code>&gt; phpunit ./CatchyTest.php
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
Till the morning light
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
PHPUnit 9.6.19 by Sebastian Bergmann and contributors.

ROne
RTwo
RThree
RFour
RFive
RSix
RSeven
R                                                            8 / 8 (100%)Eight
// [...]
Till the morning light
Till the morning light
Till the morning light
Till the morning light
Till the morning light
Till the morning light
Till the morning light
Till the morning light
</code></pre>

<p>And Bob's your uncle! Hang on, what?</p>

<p>The constructor has been called 3 (test methods) + 6 (items in data provider) = 9 times
and we can observe that the class attribute's value isn't shared between the test methods
but gets reset every time.</p>

<p>And those instances stay alive until the vey end of the run,
meaning a concerningly increasing memory usage througout the test suite,
which also slows it down!</p>

<h2 id="%22solution%22">"Solution"</h2>

<p>There's <a href="https://kriswallsmith.net/post/18029585104/faster-phpunit">a hack that's been around for decades</a>
to free the memory and speed up the test suites:</p>

<pre><code>&lt;?php declare(strict_types=1);
use PHPUnit\Framework\TestCase;

abstract class BaseTestCase extends TestCase
{
    protected function tearDown()
    {
        $refl = new ReflectionObject($this);
        foreach ($refl-&gt;getProperties() as $prop) {
            if (!$prop-&gt;isStatic() &amp;&amp; 0 !== strpos($prop-&gt;getDeclaringClass()-&gt;getName(), 'PHPUnit\\')) {
                $prop-&gt;setAccessible(true);
                $prop-&gt;setValue($this, null);
            }
        }
    }
}
</code></pre>

<p>The <code>tearDown</code> method is called after each test method, so it's a good place to unset class attributes.</p>

<p>To avoid having to think about it, a catch all solution using relfection can be put inside a custom <code>BaseTestCase</code>
that'll be extended by all our test classes.</p>

<p>And indeed most of the code bases don't directly extend PHPUnit's TestCase,
for example <a href="https://symfony.com/doc/current/testing.html">Symfony's documentation suggest to use FrameworkBundle's KernelTestCase</a>.</p>

<p>But what does it do exactly?</p>

<h2 id="showing-the-bad-example">Showing the bad example</h2>

<p>Here's a highly opinionated summary of its code:</p>

<pre><code>&lt;?php

namespace Symfony\Bundle\FrameworkBundle\Test;

use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpKernel\KernelInterface;

abstract class KernelTestCase extends TestCase
{
    protected static ?KernelInterface $kernel = null;

    protected static function bootKernel(): KernelInterface
    {
        static::$kernel = new \AppKernel('test', true);
        $kernel-&gt;boot();

        return static::$kernel;
    }

    protected function tearDown(): void
    {
        if (null !== static::$kernel) {
            static::$kernel-&gt;shutdown();
            static::$kernel = null;
        }
    }
}
</code></pre>

<p>Symfony's HttpKernel is stateless, so being able to boot it (which is slow) only once
and store it in a static attribute of a TestCase that all our functional test implement is great!</p>

<p>However calling <code>bootKernel</code> will always return a new instance of the application kernel and will always boot it,
while the <code>tearDown</code> method also makes sure to nuke it after each test method...</p>

<p>Now I can't pretend to know the reason behind this (maybe assuming that applications are stateful?),
nor am I familiar with all the different applications out there and their specific use cases,
but that seems very unfortunate to me.</p>

<p>To fix it, we can rewrite it as follow:</p>

<pre><code>&lt;?php declare(strict_types=1);
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpKernel\KernelInterface;

abstract class MyTestCase extends TestCase
{
    protected static ?KernelInterface $kernel = null;

    protected static function getKernel(): KernelInterface
    {
        if (null === static::$kernel) {
            static::$kernel = new \AppKernel('test', true);
            $kernel-&gt;boot();
        }

        return static::$kernel;
    }
}
</code></pre>

<p>We got rid of the kernel shutdown shenanigans (can be called manually if needed),
and made sure the Kernel is instanciated (and booted) only once.</p>

<p>But why have this as part of the TestCase? This should be extracted into its own class:</p>

<pre><code>&lt;?php declare(strict_types=1);
use Symfony\Component\HttpKernel\KernelInterface;

class KernelSingleton
{
    protected static ?KernelInterface $kernel = null;

    protected static function get(): KernelInterface
    {
        if (null === static::$kernel) {
            static::$kernel = new \AppKernel('test', true);
            $kernel-&gt;boot();
        }

        return static::$kernel;
    }
}
</code></pre>

<p>I know, I know. The Singleton desing pattern has been receiving a lot of bad rap over the years.
But here, it's a legitimate use case!</p>

<h2 id="conclusion">Conclusion</h2>

<p>What have we learned?</p>

<p>That each PHPUnit test method is run in isolation inside its own Test Class instance,
so class attribute values will rapidly consume more and more memory (and slow down the test suite),
and they cannot be shared between two test methods unless you make them static.</p>

<p>And perhaps consider using Singletons instead of relying on "FrameworkTestCase".</p>

<p>As for PHPUnit's setUp method, in your opinion, is it best described as "executed before each test method",
or as "executed everytime the test class is instanciated"?</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[ChatGPT: fluff or not? SpecBDD]]></title>
            <link href="/2023/04/19/chat-gpt-spec-bdd.html"/>
            <updated>2023-04-19T00:00:00+01:00</updated>
            <id>/2023/04/19/chat-gpt-spec-bdd.html</id>
            <content type="html"><![CDATA[<p>Now that a couple of months have passed since its over hyped launch,
surely <a href="https://openai.com/blog/chatgpt/">ChatGPT</a> has found some
use cases where it could be of any actual use. Or is it all fluff? Let's find out.</p>

<p>In my quest to find a use for ChatGPT in my day to day developer activity,
I've finally found a helpful scenario!</p>

<p>Let me walk you through my findings about ChatGPT and its "Spec Gen" capacity,
so we can learn a thing or two.</p>

<h2 id="spec-gen">Spec Gen</h2>

<p>When tasked to write a feature, I first write a unit test that specifies the
behaviour, for example:</p>

<pre><code>&lt;?php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    private const FILENAME = '/tmp/file.txt';
    private const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem): void
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_creates_new_files(File $file, Filesystem $filesystem): void
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>When using <a href="https://phpspec.net/en/stable/">phpspec</a>,
especially with the extension <a href="https://github.com/memio/spec-gen">spec-gen</a>,
running the test will bootstrap for me the corresponding class:</p>

<pre><code>&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesytem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open(string $argument1, bool $argument2)
    {
    }
}
</code></pre>

<p>That's pretty good, but it could be better: what if it was able to generate the complete code?</p>

<h2 id="gpt-gen">GPT Gen</h2>

<p>Let's forget about phpspec and use instead <a href="https://phpunit.de/">PHPUnit</a>,
but still with the <a href="https://github.com/phpspec/prophecy">Prophecy</a>
Mocking framework.</p>

<p>Let's ask ChatGPT. Here's the priming prompt:</p>

<blockquote>
  <p><strong>USER</strong>:
  Act as an expert PHP developer,
    who's been writing high quality API code for 20 years.
  Acknowledge with "ok".</p>
</blockquote>

<p>Because ChatGPT's Large Language Model (LLM) is able to generate a wide range
of text (conversation, essays, movie script, poetry, etc), assigning it a role
helps it narrow down its context, hence improving its accuracy for the task we
want it to complete: writing PHP code, on a professional level
(persona/role prompt engineering technique).</p>

<p>We also need to consider the Goldfish Memory issue of ChatGPT: it only takes
into account the last ~4000 tokens to generate its response, so asking it to
give us a short reply helps us save some space.</p>

<blockquote>
  <p><strong>ChatGPT</strong>: ok</p>
</blockquote>

<p>LLMs perform better when given some examples, and indeed before asking it to
generate code we might want to give ChatGPT some of our code samples
(X-Shot prompt engineering technique).</p>

<p>Since coding also requires some level of logic, it is also helpful to include
reasoning steps (Chain of Thought prompt engineering technique).</p>

<p>Similarly, asking the LLM to first generate some topic related knowledge,
and then reuse that in the further prompts will also increase our success rate
(Generated Knowledge prompt engineering technique).</p>

<p>With this in mind, here's the second prompt that provides a test class example:</p>

<blockquote>
  <p><strong>USER</strong>: Here's an example of test class from the project you're working on:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace tests\Ssc\Btlr\Cht\Message\Templates\Prompts;

use Ssc\Btlr\App\Filesystem\ReadFile;
use Ssc\Btlr\App\Template\Replace;
use Ssc\Btlr\Cht\Message\Logs\Type;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;
use Ssc\Btlr\Cht\Message\Templates\Prompts\Template;
use tests\Ssc\Btlr\AppTest\BtlrServiceTestCase;

class TemplateTest extends BtlrServiceTestCase
{
    /**
     * @test
     */
    public function it_creates_prompt_from_template(): void
    {
        // Fixtures
        $thoseParameters = [
            'last_messages' =&gt; 'USER (1968-04-02T18:40:23+00:00): Write code for me, please',
        ];
        $forType = Type::AUGMENTED_PROMPT;
        $withConfig = [
            'chunk_memory_size' =&gt; 15,
            'llm_engine' =&gt; 'chatgpt-gpt-3.5-turbo',
            'logs_filename' =&gt; './var/cht/logs',
            'prompt_templates_filename' =&gt; './templates/cht/prompts',
        ];

        $template = "LAST MESSAGES:\n%last_messages%\nBTLR:\n";
        $prompt = "LAST MESSAGES:\n{$thoseParameters['last_messages']}\nBTLR:\n";
        $data = [
            'entry' =&gt; $prompt,
        ];

        // Dummies
        $readFile = $this-&gt;prophesize(ReadFile::class);
        $replace = $this-&gt;prophesize(Replace::class);
        $writeLog = $this-&gt;prophesize(WriteLog::class);

        // Stubs &amp; Mocks
        $readFile-&gt;in("{$withConfig['prompt_templates_filename']}/{$forType['name']}.txt")
            -&gt;willReturn($template);
        $replace-&gt;in($template, $thoseParameters)
            -&gt;willReturn($prompt);
        $writeLog-&gt;for($data, $forType, $withConfig)
            -&gt;shouldBeCalled();

        // Assertion
        $template = new Template(
            $readFile-&gt;reveal(),
            $replace-&gt;reveal(),
            $writeLog-&gt;reveal(),
        );
        self::assertSame($prompt, $template-&gt;replace(
            $thoseParameters,
            $forType,
            $withConfig,
        ));
    }
}
</code></pre>

<blockquote>
  <p><strong>USER</strong>:
  Acknowledge by describing how the use of fixtures, dummies, stubs, mocks
  and assertions allow to make sure the tested code is behaving as expected.
  And note the use of the special BtlrServiceTestCase parent class for <code>TemplateTest</code>.</p>
</blockquote>

<p>By the way, the code is from my Super Secret Code project
<a href="https://github.com/gnugat/ssc-btlr">Btlr</a>.</p>

<p>Here's ChatGPT's response:</p>

<blockquote>
  <p><strong>ChatGPT</strong>:
  In this test class, fixtures are used to provide the necessary data for
  testing the <code>Template</code> class. The parameters and configuration are defined in
  <code>$thoseParameters</code> and <code>$withConfig</code> respectively, and the template and prompt
  strings are defined in <code>$template</code> and <code>$prompt</code>.</p>
  
  <p>Dummies are used to provide the interface of the <code>ReadFile</code>, <code>Replace</code>, and
  <code>WriteLog</code> classes, without providing any actual implementation, since these
  classes are not the focus of the test.</p>
  
  <p>Stubs are used to replace the implementation of <code>ReadFile</code> and <code>Replace</code>
  classes, by returning a fixed value when their respective methods are called.
  This ensures that the expected values are used for testing the <code>Template</code> class.</p>
  
  <p>Mocks are used to verify that the <code>WriteLog</code> class is called with the expected
  parameters. The <code>shouldBeCalled()</code> method ensures that the <code>for()</code> method of
  <code>WriteLog</code> class is actually called during the test.</p>
  
  <p>Finally, the assertion compares the result returned by the <code>replace()</code> method
  of the <code>Template</code> class with the expected prompt string.</p>
  
  <p>The <code>BtlrServiceTestCase</code> class is a special parent class that sets up a test
  environment for the Btlr service, which can include initializing dependencies,
  connecting to databases, and setting up configurations. This helps to ensure
  that tests are run in a consistent and isolated environment, and makes it easier
  to write tests for the Btlr service.</p>
</blockquote>

<p>ChatGPT doesn't have access to the project and its code, it only knows what we've
provided in the conversation so far.</p>

<p>So for example it took a wild guess at what <code>BtlrServiceTestCase</code> does and got
it wrong, but for our purpose this is good enough.</p>

<p>The third prompt is an example of the corresponding class:</p>

<blockquote>
  <p><strong>USER</strong>:
  When tasked with generating the corresponding <code>Template</code> class, from the above
  <code>TemplateTest</code> test class, here's the code you wrote:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace Ssc\Btlr\Cht\Message\Templates\Prompts;

use Ssc\Btlr\App\Filesystem\ReadFile;
use Ssc\Btlr\App\Template\Replace;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;

class Template
{
    public function __construct(
        private ReadFile $readFile,
        private Replace $replace,
        private WriteLog $writeLog,
    ) {
    }

    public function replace(
        array $thoseParameters,
        array $forType,
        array $withConfig,
    ): string {
        $template = $this-&gt;readFile-&gt;in(
            "{$withConfig['prompt_templates_filename']}/{$forType['name']}.txt",
        );
        $prompt = $this-&gt;replace-&gt;in($template, $thoseParameters);
        $this-&gt;writeLog-&gt;for([
            'entry' =&gt; $prompt,
        ], $forType, $withConfig);

        return $prompt;
    }
}
</code></pre>

<blockquote>
  <p><strong>USER</strong>: Acknowledge by describing how the test class got translated into its
  corresponding class.</p>
</blockquote>

<p>To which ChatGPT replies:</p>

<blockquote>
  <p><strong>ChatGPT</strong>:
  The <code>TemplateTest</code> test class served as a guide for implementing the
  <code>Template</code> class.</p>
  
  <p>First, the constructor of <code>Template</code> class takes three dependencies, which
  are also injected in the <code>TemplateTest</code> class as dummies or mocks.</p>
  
  <p>Next, the <code>replace()</code> method of <code>Template</code> class has the same signature as
  the test method <code>it_creates_prompt_from_template()</code>, with the addition of a
  return type declaration for the prompt string.</p>
  
  <p>The implementation of <code>replace()</code> method in <code>Template</code> class uses the
  injected <code>ReadFile</code> instance to read the template string from the filesystem,
  using the <code>$forType['name']</code> parameter to construct the file path.
  It then uses the injected <code>Replace</code> instance to replace placeholders in the
  template with values provided in the <code>$thoseParameters</code> array, resulting in
  a <code>$prompt</code> string.</p>
  
  <p>Finally, the method calls the injected <code>WriteLog</code> instance with the <code>$prompt</code>,
  <code>$forType</code>, and <code>$withConfig</code> parameters, which logs the prompt for the given
  type and configuration.</p>
  
  <p>Overall, the implementation of the <code>Template</code> class closely follows the
  structure of the <code>TemplateTest</code> class, and the use of dependency injection
  ensures that the class can be easily tested in isolation from its
  dependencies.</p>
</blockquote>

<p>With ChatGPT noting that the corresponding class closely follows the structure
of its test, it should be now ready.</p>

<p>Let's give it a new test class, and ask it to generate the corresponding code:</p>

<blockquote>
  <p><strong>USER</strong>: Brilliant. Now, in the same coding style as <code>TemplateTest</code> and
  <code>Template</code>, you are tasked to write a the corresponding code for the
  following <code>ReplyTest</code> test class:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace tests\Ssc\Btlr\Cht\Message;

use Ssc\Btlr\Cht\Message\Logs\Type;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;
use Ssc\Btlr\Cht\Message\Memory\Consolidate;
use Ssc\Btlr\Cht\Message\Reply;
use Ssc\Btlr\Cht\Message\Reply\Augment;
use Ssc\Btlr\Cht\Message\Reply\UsingLlm;
use tests\Ssc\Btlr\AppTest\BtlrServiceTestCase;

class ReplyTest extends BtlrServiceTestCase
{
    /**
     * @test
     */
    public function it_replies_to_user_prompt_using_llm(): void
    {
        // Fixtures
        $userPrompt = 'Write code for me, please';
        $withConfig = [
            'chunk_memory_size' =&gt; 15,
            'llm_engine' =&gt; 'chatgpt-gpt-3.5-turbo',
            'logs_filename' =&gt; './var/cht/logs',
            'prompt_templates_filename' =&gt; './templates/cht/prompts',
        ];

        $userPromptData = [
            'entry' =&gt; $userPrompt,
        ];
        $augmentedPrompt = "USER: {$userPrompt}\nBLTR:";
        $modelCompletion = "I'm sorry, dev. I'm afraid I can't do that.";
        $modelCompletionData = [
            'entry' =&gt; $modelCompletion,
            'llm_engine' =&gt; $withConfig['llm_engine'],
        ];

        // Dummies
        $augment = $this-&gt;prophesize(Augment::class);
        $consolidate = $this-&gt;prophesize(Consolidate::class);
        $usingLlm = $this-&gt;prophesize(UsingLlm::class);
        $writeLog = $this-&gt;prophesize(WriteLog::class);

        // Stubs &amp; Mocks
        $writeLog-&gt;for($userPromptData, Type::USER_PROMPT, $withConfig)
            -&gt;shouldBeCalled();
        $augment-&gt;the($userPrompt, $withConfig)
            -&gt;willReturn($augmentedPrompt);
        $usingLlm-&gt;complete($augmentedPrompt)
            -&gt;willReturn($modelCompletion);
        $writeLog-&gt;for($modelCompletionData, Type::MODEL_COMPLETION, $withConfig)
            -&gt;shouldBeCalled();
        $consolidate-&gt;memories($withConfig)
            -&gt;shouldBeCalled();

        // Assertion
        $reply = new Reply(
            $augment-&gt;reveal(),
            $consolidate-&gt;reveal(),
            $usingLlm-&gt;reveal(),
            $writeLog-&gt;reveal(),
        );
        self::assertSame($modelCompletion, $reply-&gt;to(
            $userPrompt,
            $withConfig,
        ));
    }
}
</code></pre>

<blockquote>
  <p><strong>USER</strong>: Acknowledge by generating the code for the <code>Reply</code> class.</p>
</blockquote>

<p>And here's what ChatGPT came up with:</p>

<blockquote>
  <p><strong>ChatGPT</strong>: Sure thing! Here's the code for the <code>Reply</code> class based on the
  <code>ReplyTest</code> test class:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace Ssc\Btlr\Cht\Message;

use Ssc\Btlr\Cht\Message\Logs\Type;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;
use Ssc\Btlr\Cht\Message\Memory\Consolidate;
use Ssc\Btlr\Cht\Message\Reply\Augment;
use Ssc\Btlr\Cht\Message\Reply\UsingLlm;

class Reply
{
    public function __construct(
        private Augment $augment,
        private Consolidate $consolidate,
        private UsingLlm $usingLlm,
        private WriteLog $writeLog,
    ) {
    }

    public function to(string $userPrompt, array $withConfig): string
    {
        $userPromptData = [
            'entry' =&gt; $userPrompt,
        ];

        // Augment the user prompt
        $augmentedPrompt = $this-&gt;augment-&gt;the($userPrompt, $withConfig);

        // Use LLM to generate a model completion
        $modelCompletion = $this-&gt;usingLlm-&gt;complete($augmentedPrompt);

        // Log the user prompt and model completion
        $this-&gt;writeLog-&gt;for($userPromptData, Type::USER_PROMPT, $withConfig);
        $modelCompletionData = [
            'entry' =&gt; $modelCompletion,
            'llm_engine' =&gt; $withConfig['llm_engine'],
        ];
        $this-&gt;writeLog-&gt;for($modelCompletionData, Type::MODEL_COMPLETION, $withConfig);

        // Consolidate the memories
        $this-&gt;consolidate-&gt;memories($withConfig);

        return $modelCompletion;
    }
}
</code></pre>

<blockquote>
  <p><strong>ChatGPT</strong>: This <code>Reply</code> class has a <code>to</code> method that takes a user prompt
  and a configuration array as input, and returns the model completion
  generated by LLM.
  The <code>Reply</code> class constructor takes in four dependencies: <code>Augment</code>,
  <code>Consolidate</code>, <code>UsingLlm</code>, and <code>WriteLog</code>, and stores them as private
  properties.
  The <code>to</code> method then uses these dependencies to augment the user prompt,
  generate the model completion, log both the user prompt and the model
  completion, and consolidate the memories.</p>
</blockquote>

<p>Which is pretty much spot on.</p>

<p>I'd personnally have written something slightly different (no comments, have
 <code>writeLog</code> for the user prompt at the begining of the method, and possibly
not have any intermediate variables).</p>

<p>But I can easily apply those changes!</p>

<h2 id="takeways">Takeways</h2>

<p>Thanks to Prompt Engineering (with techniques such as Role / Persona priming
prompt, X-Shot, Chain of Thought and Generated Knowledge), it is possible
to ask ChatGPT to generate code.</p>

<p>I'm personally using the following prompts to generate the corresponding code
for a given Test Class.</p>

<p>Priming Prompt:</p>

<blockquote>
  <p>Act as an expert PHP developer, who's been writing high quality API code for 20 years.
  Acknowledge with "ok".</p>
</blockquote>

<p>Test Class example prompt:</p>

<blockquote>
  <p>Here's an example of test class from the project you're working on:</p>
  
  <p><code>%example_test_class_code%</code></p>
  
  <p>Acknowledge by describing how the use of fixtures, dummies, stubs, mocks
  and assertions allow to make sure the tested code is behaving as expected.
  And note the use of the special BtlrServiceTestCase parent class for
  <code>%example_test_class_name%</code>.</p>
</blockquote>

<p>Corresponding class example prompt:</p>

<blockquote>
  <p>When tasked with generating the corresponding <code>%example_class_name%</code> class,
  from the above <code>%%example_test_class_name</code> test class, here's the code you wrote:</p>
  
  <p><code>%example_class_code%</code></p>
  
  <p>Acknowledge by describing how the test class got translated into its
  corresponding class.</p>
</blockquote>

<p>Code generation request from Test Class prompt:</p>

<blockquote>
  <p>Brilliant. Now, in the same coding style as <code>%example_test_class_name%</code> and
  <code>%example_class_name%</code>, you are tasked to write a the corresponding code for
  the following <code>%test_class_name%</code> test class:</p>
  
  <p><code>%test_class_code%</code></p>
  
  <p>Acknowledge by generating the code for the <code>%class_name%</code> class.</p>
</blockquote>

<p>Now, what if you're not practicing Test Driven Development?</p>

<p>I suppose you can tweek it to get ChatGPT to generate tests for you:</p>

<ul>
<li>Use the same priming prompt</li>
<li>Then use the class example prompt</li>
<li>Next use the "corresponding" test example prompt</li>
<li>Finally provide a class and ask ChatGPT to generate its corresponding test</li>
</ul>

<p>All in all, the exploration of ChatGPT's text generation potential turned out
to be quite worthwhile, as I ended up finding a practical use case for it in my
day to day developer activity.</p>

<p>Yet I suspect there's plenty more scenarions where ChatGPT can help, so I guess
the quest continues.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Decouple from Libraries]]></title>
            <link href="/2015/10/12/decouple-from-libraries.html"/>
            <updated>2015-10-12T00:00:00+01:00</updated>
            <id>/2015/10/12/decouple-from-libraries.html</id>
            <content type="html"><![CDATA[<p>Libraries are similar to frameworks: they solve infrastructure problems (e.g.
requesting remote endpoints or querying databases). They also don't directly
add any value to our projects: the business need will not be fulfilled by
connecting to a database.</p>

<p>They also share the same Backward Compatibility (BC) break issue, since they will
change to solve their own concerns, regardless of our projects.</p>

<p>Here's a true story with <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>: we
started to use version 2 in our project and spread direct calls to it in different places.
After a while we've decided to use <a href="http://flysystem.thephpleague.com/">Flysystem</a>
and its <a href="http://aws.amazon.com/sdkforphp">SDK for Amazon S3</a> but we had a problem:
it required Guzzle 3.
This means tracking down every usage of Guzzle in the project and adapting the
calls to the new version. It's a dawnting task, especially when the project doesn't
have strong enough tests.</p>

<p>Later on, when Amazon S3 SDK stabilized, it started to require Guzzle 5...</p>

<p><a href="http://knowyourmeme.com/memes/rage-guy-fffffuuuuuuuu"><img src="http://i0.kym-cdn.com/photos/images/newsfeed/000/000/578/1234931504682.jpg" alt="Screaming with anger" /></a></p>

<p>Does that mean that we shouldn't use any libraries? Should we just don't care and
continue to use them in the same way?</p>

<p>This article will explain how to avoid both extremes, by decoupling from the library.
It can be done by using the Inversion of Control principle: instead of relying
on the library we rely on interfaces and provide an implementation that uses the library.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>In <a href="/2015/09/30/decouple-from-frameworks.html">the previous article</a>,
we started to create an endpoint allowing us to subit new quotes for a
<a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a> application.</p>

<p>We're now going to create a SDK for it:</p>

<pre><code>mkdir fortune-sdk
cd fortune-sdk
</code></pre>

<p>To do so, we'll create the <code>composer.json</code> file:</p>

<pre><code>{
    "name": "acme/fortune-sdk",
    "description": "A PHP SDK for Fortune",
    "type": "library",
    "license": "MIT",
    "autoload": {
        "psr-4": {
            "Acme\\FortuneSdk\\": "src/Acme/FortuneSdk"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Acme\\FortuneSdk\\Fixtures\\": "fixtures",
            "Acme\\FortuneSdk\\Tests\\": "tests"
        }
    },
    "require": {
        "php": "&gt;=5.4",
    },
    "require-dev": {
        "phpspec/phpspec": "^2.3",
        "phpunit/phpunit": "^4.5",
        "symfony/console": "^2.3",
        "symfony/yaml": "^2.2"
    }
}
</code></pre>

<p>Then create a test script:</p>

<pre><code>#!/usr/bin/env sh

# bin/test.sh

composer --quiet --no-interaction update --optimize-autoloader &gt; /dev/null

vendor/bin/phpspec --no-interaction run -f dot &amp;&amp; vendor/bin/phpunit
</code></pre>

<p>And finally configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/4.1/en/appendixes.configuration.html --&gt;
&lt;phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
         backupGlobals="false"
         colors="true"
         bootstrap="vendor/autoload.php"
&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="Fortune SDK Test Suite"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="request-handler">Request Handler</h2>

<p>Since Guzzle might completly change next year, we're going to abstract it behind
our own HTTP client:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Remote/RequestHandler.php

namespace Acme\FortuneSdk\Remote;

use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

interface RequestHandler
{
    /**
     * @param RequestInterface $request
     *
     * @return ResponseInterface
     *
     * @throws ClientException If client throws an unexpected exception (e.g. connection error, etc)
     */
    public function handle(RequestInterface $request);
}
</code></pre>

<p>We've decided to use the new PSR-7 standard:</p>

<pre><code>composer require psr/http-message:^1.0
</code></pre>

<p>We'll hide any errors behind our own exception:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Remote/ClientException.php

namespace Acme\FortuneSdk\Remote;

use RuntimeException;

class ClientException extends RuntimeException
{
}
</code></pre>

<p>Its first implementation will be with Guzzle 6:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Remote/RequestHandler/GuzzleSixRequestHandler.php

namespace Acme\FortuneSdk\Remote\RequestHandler;

use Acme\FortuneSdk\Remote\ClientException;
use Acme\FortuneSdk\Remote\RequestHandler;
use Exception;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\BadResponseException;
use Psr\Http\Message\RequestInterface;

class GuzzleSixRequestHandler implements RequestHandler
{
    private $client;

    public function __construct(Client $client)
    {
        $this-&gt;client = $client;
    }

    public function handle(RequestInterface $request)
    {
        try {
            return $this-&gt;client-&gt;send($request);
        } catch (BadResponseException $e) {
            return $e-&gt;getResponse();
        } catch (Exception $e) {
            throw new ClientException('Client threw an unexpected exception', 0, $e);
        }
    }
}
</code></pre>

<p>And that's it. When Guzzle 7 will be released, we'll just have to create a new
implementation and throw away the old one instead of having to replace it everywhere
in our project. We can even change our mind and use a completly different HTTP client
(Buzz, etc).</p>

<p>Since we've started to softly depend on Guzzle, we need to install it with Composer:</p>

<pre><code>composer require guzzlehttp/guzzle:^6.0
</code></pre>

<h2 id="functional-test">Functional test</h2>

<p>We can now create a functional test describing our service:</p>

<pre><code class="php">&lt;?php

// tests/Quote/SubmitNewQuoteTest.php

namespace Acme\FortuneSdk\Tests\Quote;

use Acme\FortuneSdk\Quote\SubmitNewQuote\RemoteSubmitNewQuote;
use Acme\FortuneSdk\Fixtures\FixturesRequestHandler;
use PHPUnit_Framework_TestCase;

class SubmitNewQuoteTest extends PHPUnit_Framework_TestCase
{
    const URL = 'http://example.com';
    const QUOTE = 'Nobody expects the Spanish Inquisition!';

    private $submitNewQuote;

    protected function setUp()
    {
        $requestHandler = new FixturesRequestHandler();
        $this-&gt;submitNewQuote = new RemoteSubmitNewQuote($requestHandler, self::URL);
    }

    /**
     * @test
     */
    public function it_can_submit_a_new_quote()
    {
        $quote = $this-&gt;submitNewQuote-&gt;submit(self::QUOTE);

        self::assertSame(self::QUOTE, $quote['quote']);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>sh ./bin/test.sh
</code></pre>

<p>It fails because <code>FixturesRequestHandler</code> doesn't exist. It's an implementation
of <code>RequestHandler</code> designed for our tests: even if the endpoint actually existed,
relying on network calls in our tests would only make them brittle
(because it's slow and unreliable).</p>

<p>Let's create it:</p>

<pre><code class="php">&lt;?php

// fixtures/FixturesRequestHandler.php

namespace Acme\FortuneSdk\Fixtures;

use Acme\FortuneSdk\Remote\RequestHandler;
use Psr\Http\Message\RequestInterface;
use Zend\Diactoros\Response;
use Zend\Diactoros\Stream;

class FixturesRequestHandler implements RequestHandler
{
    private $routes;

    public function __construct()
    {
        $this-&gt;routes = array(
            array(
                'controller' =&gt; new Controller\Quote\SubmitNewQuoteController(),
                'pattern' =&gt; '#/quotes#',
                'methods' =&gt; array('POST'),
            ),
        );
    }

    public function handle(RequestInterface $request)
    {
        $path = $request-&gt;getUri()-&gt;getPath();
        $method = $request-&gt;getMethod();
        foreach ($this-&gt;routes as $route) {
            if (1 === preg_match($route['pattern'], $path)) {
                if (false === in_array($method, $route['methods'], true)) {
                    $body = new Stream('php://temp', 'w');
                    $body-&gt;write(json_encode(array(
                        'message' =&gt; "Method \"$method\" for route \"$path\" not supported (supported methods are: ".implode(', ', $route['methods']).")",
                    )));

                    return new Response($body, 405, array('Content-Type' =&gt; 'application/json'));
                }
                try {
                    return $route['controller']-&gt;handle($request);
                } catch (FixturesException $e) {
                    $body = new Stream('php://temp', 'w');
                    $body-&gt;write($e-&gt;getMessage());

                    return new Response($body, $e-&gt;getCode(), array('Content-Type' =&gt; 'application/json'));
                }
            }
        }
        $body = new Stream('php://temp', 'w');
        $body-&gt;write(json_encode(array(
            'message' =&gt; "Route \"$path\" not found",
        )));

        return new Response($body, 404, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>We've decided to rely on Zend Diactoros to build the request, since it is the de
facto implementation of PSR-7:</p>

<pre><code>composer require zendframework/zend-diactoros:^1.0
</code></pre>

<p>We've open the possibility of managing many endpoints with this class. We now need
to define a controller for the quote submission one:</p>

<pre><code class="php">&lt;?php

// fixtures/Controller/Quote/SubmitNewQuoteController.php

namespace Acme\FortuneSdk\Fixtures\Controller\Quote;

use Acme\FortuneSdk\Remote\RequestHandler;
use Acme\FortuneSdk\Fixtures\FixturesException;
use Psr\Http\Message\RequestInterface;
use Zend\Diactoros\Response;
use Zend\Diactoros\Stream;

class SubmitNewQuoteController implements RequestHandler
{
    public function handle(RequestInterface $request)
    {
        $submitNewQuote = json_decode($request-&gt;getBody()-&gt;__toString(), true);
        if (false === isset($submitNewQuote['quote'])) {
            throw FixturesException::make('Missing required "quote" parameter', 422);
        }
        $quote = (string) $submitNewQuote['quote'];
        if ('' === $quote) {
            throw FixturesException::make('Invalid "quote" parameter: must not be empty', 422);
        }
        $body = new Stream('php://temp', 'w');
        $body-&gt;write(json_encode(array(
            'id' =&gt; '',
            'quote' =&gt; $quote
        )));

        return new Response($body, 201, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>Finally we need to write the exception class:</p>

<pre><code class="php">&lt;?php

// fixtures/FixturesException.php

namespace fixtures\Acme\FortuneSdk\Fixtures;

use DomainException;

class FixturesException extends DomainException
{
    /**
     * @param string $message
     * @param int    $statusCode
     *
     * @return FixturesException
     */
    public static function make($message, $statusCode)
    {
        return new self(json_encode(array('message' =&gt; $message)), $statusCode);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>sh ./bin/test.sh
</code></pre>

<p>They now fail because <code>SubmitNewQuote</code> doesn't exist.</p>

<h2 id="submitnewquote">SubmitNewQuote</h2>

<p>First of all, we'll define our service as an interface:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Quote/SubmitNewQuote.php

namespace Acme\FortuneSdk\Quote;

interface SubmitNewQuote
{
    public function submit($quote);
}
</code></pre>

<p>This will allow developers using our SDK to create their own implementation for testing
or extension purpose.
It will also allow us to create Composite implementation: we can have a remote
implementation that does the actual work, wrapped in a lazy cache implementation
itself wrapped in a log implementation.</p>

<p>Here we'll just take care of the remote one, let's bootstrap its test:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\FortuneSdk\Quote\SubmitNewQuote\RemoteSubmitNewQuote'
</code></pre>

<p>And now we can write the tests:</p>

<pre><code class="php">&lt;?php

// spec/Acme/FortuneSdk/Quote/SubmitNewQuote.php

namespace spec\Acme\FortuneSdk\Quote\SubmitNewQuote;

use Acme\FortuneSdk\Remote\RequestHandler;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamInterface;

class RemoteSubmitNewQuoteSpec extends ObjectBehavior
{
    const URL = 'http://example.com';
    const QUOTE = 'Nobody expects the Spanish Inquisition!';

    function let(RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($requestHandler, self::URL);
    }

    function it_is_a_submit_new_quote()
    {
        $this-&gt;shouldImplement('Acme\FortuneSdk\Quote\SubmitNewQuote');
    }

    function it_calls_the_remote_endpoint(
        RequestHandler $requestHandler,
        ResponseInterface $response,
        StreamInterface $stream
    ) {
        $quote = array(
            'quote' =&gt; self::QUOTE,
        );

        $request = Argument::type('Psr\Http\Message\RequestInterface');
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $response-&gt;getBody()-&gt;willReturn($stream);
        $stream-&gt;__toString()-&gt;willReturn(json_encode($quote));

        $this-&gt;submit(self::QUOTE)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>In this test, we've used a wildcard to represent the request since the service is
going to create it. This is at the cost of not knowing how it is built.</p>

<p>If we absolutely want to have control over this, we need to delegate the request
construction to a factory, it then becomes possible to mock the request and check
how it is built:</p>

<pre><code class="php">&lt;?php

// spec/Acme/FortuneSdk/Quote/SubmitNewQuote.php

namespace spec\Acme\FortuneSdk\Quote\SubmitNewQuote;

use Acme\FortuneSdk\Remote\RequestFactory;
use Acme\FortuneSdk\Remote\RequestHandler;
use PhpSpec\ObjectBehavior;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamInterface;

class RemoteSubmitNewQuoteSpec extends ObjectBehavior
{
    const URL = 'http://example.com';
    const QUOTE = 'Nobody expects the Spanish Inquisition!';

    function let(RequestFactory $requestFactory, RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($requestFactory, $requestHandler, self::URL);
    }

    function it_is_a_submit_new_quote()
    {
        $this-&gt;shouldImplement('Acme\FortuneSdk\Quote\SubmitNewQuote');
    }

    function it_calls_the_remote_endpoint(
        RequestFactory $requestFactory,
        RequestHandler $requestHandler,
        RequestInterface $request,
        ResponseInterface $response,
        StreamInterface $stream
    ) {
        $quote = array(
            'quote' =&gt; self::QUOTE,
        );

        $requestFactory-&gt;make(self::URL.'/v1/quotes', 'POST', json_encode($quote), array(
            'Content-Type' =&gt; 'application/json'
        ))-&gt;willReturn($request);
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $response-&gt;getBody()-&gt;willReturn($stream);
        $stream-&gt;__toString()-&gt;willReturn(json_encode($quote));

        $this-&gt;submit(self::QUOTE)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>The choice between the first solution and the second one really depends on our preferences
and on what we're trying to achieve. For the sake of this article, we'll stick
to the first one (to avoid having to create the factory class and change the functional test,
this article is already long enough!).</p>

<p>Let's run our tests to bootstrap the code:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>Now we can write the actual code:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Quote/SubmitNewQuote/RemoteSubmitNewQuote.php

namespace Acme\FortuneSdk\Quote\SubmitNewQuote;

use Acme\FortuneSdk\Quote\SubmitNewQuote;
use Acme\FortuneSdk\Remote\RequestHandler;
use Zend\Diactoros\Request;
use Zend\Diactoros\Stream;

class RemoteSubmitNewQuote implements SubmitNewQuote
{
    private $requestHandler;
    private $url;

    public function __construct(RequestHandler $requestHandler, $url)
    {
        $this-&gt;requestHandler = $requestHandler;
        $this-&gt;url = $url;
    }

    public function submit($quote)
    {
        $body = new Stream('php://memory', 'w');
        $body-&gt;write(json_encode(array(
            'quote' =&gt; $quote,
        )));
        $request = new Request($this-&gt;url.'/v1/quotes', 'POST', $body, array(
            'Content-Type' =&gt; 'application/json'
        ));
        $quote = json_decode($this-&gt;requestHandler-&gt;handle($request)-&gt;getBody()-&gt;__toString(), true);

        return $quote;
    }
}
</code></pre>

<p>This should be sufficient to make our tests pass:</p>

<pre><code>sh ./bin/test.sh
</code></pre>

<p>All green!</p>

<p>We now have a SDK that provides a <code>SubmitNewQuote</code> service allowing us to submit new quotes.
Since we've mocked the network connection, we can't be sure that our SDK actually works.
Manual testing can be sufficient in this case: we can build a Command Line Interface (CLI)
client and check by ourselves if everything is fine, once in a while.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Inversion of Control is a principle that can come handy when dealing with third party library,
especially the ones that change often like Guzzle. It can be applied easily:
instead of making our high level classes rely on concrete low level ones, we just
need to introduce an interface.</p>

<p>Once again, all projects are different and this solution might not apply in every
case. If we're building an application that we expect to maintain for a couple of years
it can be worth it to protect ourselves from external changes.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Decouple from Frameworks]]></title>
            <link href="/2015/09/30/decouple-from-frameworks.html"/>
            <updated>2015-09-30T00:00:00+01:00</updated>
            <id>/2015/09/30/decouple-from-frameworks.html</id>
            <content type="html"><![CDATA[<p>Frameworks solve infrastructure problems, for example how to create a HTTP or CLI application.
While necessary, those concerns don't add any value to your project: the business
need will not be fulfilled by creating an empty application.</p>

<p>As always, different responsibilities mean also different reasons to change: frameworks
have a history of Backward Compatibility (BC) breaks and they do so regardless of your
project.</p>

<p>Take for example <a href="http://symfony.com/">Symfony</a>: it only started to follow <a href="http://semver.org/">Semantic Versioning</a>
from version 2.3. The upgrade to version 3 has been made easier by allowing developers
to know what was deprecated, but the removal of those features still means a lot of
work in your application.
The arrival of the <a href="http://www.php-fig.org/psr/psr-7/">new standard PSR-7</a> brings
a lot of questions on the future of Symfony: for now it <a href="http://symfony.com/blog/psr-7-support-in-symfony-is-here">allows to choose</a>
between <code>symfony/http-foundation</code> and <code>psr/http-message</code>, but if Symfony doesn't
want to fall back behind (<a href="http://framework.zend.com/blog/announcing-the-zend-framework-3-roadmap.html">Zend 3 is fully based on PSR-7</a>)
it might have to introduce another big BC break (event listeners with the Request
and Response <a href="http://evertpot.com/psr-7-issues/">are not possible the way they are now with PSR-7</a>).</p>

<p>Migrating Symfony applications (from symfony1, from symfony 2.0, etc) is so hard
that it is a business on its own.</p>

<p>Does that mean that we shouldn't use any frameworks? Should we just don't care and
embrace fully frameworks?</p>

<p>This article will explain how to avoid both extremes, by decoupling from the framework.
It can be done by restricting the framework to its infrastructure responsibilities
(HTTP, CLI), by only using its entry points (Controller, Command) and by using
the Command Bus pattern.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>We're going to build part of a <a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a>
application for our example, more precisely we're going to build an endpoint allowing us to
submit quotes.</p>

<p>To do so, we'll bootstrap a symfony application using the <a href="https://github.com/gnugat/symfony-empty-edition">Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition fortune
cd fortune
</code></pre>

<p>We'll need to install our test frameworks:</p>

<pre><code>composer require --dev phpunit/phpunit
composer require --dev phpspec/phpspec
</code></pre>

<p>Then add them to our test script:</p>

<pre><code>#!/usr/bin/env sh

# bin/test.sh

echo ''
echo '// Building test environment'

rm -rf app/cache/test app/logs/*test.log
composer --quiet --no-interaction install --optimize-autoloader  &gt; /dev/null
php app/console --env=test --quiet cache:clear

echo ''
echo ' [OK] Test environment built'
echo ''

vendor/bin/phpspec --format=dot &amp;&amp; vendor/bin/phpunit
</code></pre>

<p>Finally we'll configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="app/bootstrap.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="System Tests"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="request-listener">Request listener</h2>

<p>Our endpoint will receive JSON encoded content. PHP does not populate <code>$_POST</code> with
this data, causing an empty <code>$request-&gt;request</code>. We can create an event listener
to fix this issue:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/JsonRequestListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class JsonRequestListener
{
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('PATCH', 'POST', 'PUT'), true);
        $isJson = (1 === preg_match('#application/json#', $request-&gt;headers-&gt;get('Content-Type')));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new Response('{"error":"Invalid or malformed JSON"}', 400, array('Content-Type' =&gt; 'application/json')));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>This logic is infrastructure related, so it makes sense to keep it in <code>AppBundle</code>.</p>

<p>To enable it, configure it in the Dependency Injection Container:</p>

<pre><code># app/config/services/event_listener.yml

services:
    app.json_request_listener:
        class: AppBundle\EventListener\JsonRequestListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<p>We also need to make sure files in <code>app/config/services</code> are imported:</p>

<pre><code class="php">&lt;?php
// app/config/importer.php

use Symfony\Component\Finder\Finder;

$finder = new Finder();
$files = $finder-&gt;files()-&gt;name('*.yml')-&gt;in(__DIR__.'/services');
foreach ($files as $file) {
    $loader-&gt;import($file-&gt;getRealpath());
}
</code></pre>

<h2 id="controller">Controller</h2>

<p>Our first step will be to describe how the endpoint should work, with a test:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Controller/QuoteControllerTest.php

namespace tests\AppBundle\Controller;

use AppKernel;
use PHPUnit_Framework_TestCase;
use Symfony\Component\HttpFoundation\Request;

class QuoteControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new AppKernel('test', false);
        $this-&gt;app-&gt;boot();
    }

    /**
     * @test
     */
    public function it_submits_a_new_quote()
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $request = Request::create('/v1/quotes', 'POST', array(), array(), array(), $headers, json_encode(array(
            'quote' =&gt; 'Nobody expects the spanish inquisition',
        )));

        $response = $this-&gt;app-&gt;handle($request);

        self::assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Testing only the status code is called "Smoke Testing" and is a very
  efficient way to check if the application is broken.
  Testing the content would be tedious and would make our test fragile as it might change often.</p>
</blockquote>

<p>Let's run it:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>The tests fail because the controller doesn't exist. Let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/QuoteController.php

namespace AppBundle\Controller;

use Acme\Fortune\Quote\SubmitNewQuote;
use Acme\Fortune\Quote\SubmitNewQuoteHandler;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class QuoteController
{
    private $submitNewQuoteHandler;

    public function __construct(SubmitNewQuoteHandler $submitNewQuoteHandler)
    {
        $this-&gt;submitNewQuoteHandler = $submitNewQuoteHandler;
    }

    public function submitNewAction(Request $request)
    {
        $sumbitNewQuote = new SubmitNewQuote(
            $request-&gt;request-&gt;get('quote')
        );
        $newQuote = $this-&gt;submitNewQuoteHandler-&gt;handle($sumbitNewQuote);

        return new Response(json_encode($newQuote), 201, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>Now we need to configure the controller as a service:</p>

<pre><code># app/config/services/controller.yml

services:
    app.quote_controller:
        class: AppBundle\Controller\QuoteController
        arguments:
            - "@app.submit_new_quote_handler"
</code></pre>

<p>Then we need to configure the route:</p>

<pre><code># app/config/routings/quote.yml

submit_new_quote:
    path: /v1/quotes
    defaults:
        _controller: app.quote_controller:submitNew
    methods:
        - POST
</code></pre>

<p>This file needs to be imported:</p>

<pre><code># app/config/routing.yml

quote:
    resource: routings/quote.yml
</code></pre>

<p>Finally we can run the test again:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>It now fails for a different reason: <code>SubmitNewQuote</code> and its handler class don't exist.</p>

<h2 id="command-from-commandbus">Command (from CommandBus)</h2>

<p><code>SubmitNewQuote</code> is a Data Transfer Object (DTO): its responsibility is to wrap
input parameters in a well named class (in this case a class that describes the action intended).
It's also the best place to do some basic validation on the input parameters.</p>

<blockquote>
  <p><strong>Note</strong>: In the Command Bus pattern, <code>SubmitNewQuote</code> would be a Command (different from the CLI Command).</p>
</blockquote>

<p>We'll write a test for this, but first we'll bootstrap the test class:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\Fortune\Quote\SubmitNewQuote'
</code></pre>

<p>Now we can decribe the different validation rules:</p>

<pre><code class="php">&lt;?php
// spec/Acme/Fortune/Quote/SubmitNewQuoteSpec.php

namespace spec\Acme\Fortune\Quote;

use PhpSpec\ObjectBehavior;

class SubmitNewQuoteSpec extends ObjectBehavior
{
    const QUOTE = 'Nobody expects the spanish inquisition';

    function it_fails_if_required_quote_parameter_is_missing()
    {
        $this-&gt;beConstructedWith(null);

        $this-&gt;shouldThrow('Acme\Fortune\Exception\ValidationFailedException')-&gt;duringInstantiation();
    }

    function it_fails_if_quote_parameter_is_empty()
    {
        $this-&gt;beConstructedWith('');

        $this-&gt;shouldThrow('Acme\Fortune\Exception\ValidationFailedException')-&gt;duringInstantiation();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Since this class has nothing to do with Symfony, we don't put it in <code>AppBundle</code>.
  By keeping it in its own namespace, we protect it from framework directory tree changes,
  for example before <code>AppBundle</code> the norm was <code>Acme\FortuneBundle</code>. We also allow ourselves
  to move it to another framework (e.g. Laravel, Zend, etc).</p>
</blockquote>

<p>Let's run the tests:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>It fails because the exception doesn't exist yet:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Exception/ValidationFailedException.php

namespace Acme\Fortune\Exception;

class ValidationFailedException extends FortuneException
{
}
</code></pre>

<p>We're making it a sub type of <code>FortuneException</code>: that way we can catch all exceptions
related to our code (all other exceptions can be considered as Internal Server Errors).</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Exception/FortuneException.php

namespace Acme\Fortune\Exception;

use DomainException;

class FortuneException extends DomainException
{
}
</code></pre>

<p>Now we need to create the Command:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Quote/SubmitNewQuote.php

namespace Acme\Fortune\Quote;

use Acme\Fortune\Exception\ValidationFailedException;

class SubmitNewQuote
{
    public function __construct($quote)
    {
        if (null === $quote) {
            throw new ValidationFailedException('Missing required "quote" parameter');
        }
        if ('' === $quote) {
            throw new ValidationFailedException('Invalid "quote" parameter: must not be empty');
        }
        $this-&gt;quote = (string) $quote;
    }
}
</code></pre>

<p>Running the tests again:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>Everything seems fine.</p>

<h2 id="exception-listener">Exception listener</h2>

<p>Instead of catching exceptions in our controllers we can create an event listener:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/FortuneExceptionListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class FortuneExceptionListener
{
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof FortuneException) {
            return;
        }
        $content = json_encode(array('error' =&gt; $exception-&gt;getMessage()));
        $statusCode = Response::HTTP_UNPROCESSABLE_ENTITY;
        $event-&gt;setResponse(new Response($content, $statusCode, array('Content-Type' =&gt; 'application/json')));
    }
}
</code></pre>

<p>This lowers the risk of forgetting to catch an exception and it also keeps our controller slim.</p>

<p>Let's enable it in the DIC:</p>

<pre><code># app/config/services/event_listener.yml

services:
    app.fortune_exception_listener:
        class: AppBundle\EventListener\FortuneExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException }

    app.json_request_listener:
        class: AppBundle\EventListener\JsonRequestListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<h2 id="command-handler">Command Handler</h2>

<p><code>SubmitNewQuoteHandler</code>'s responsibility is to validate <code>SubmitNewQuote</code> data against
business rules (e.g. no quote duplicates, author must exist, etc) and to call the
appropriate services to process it.
Reading its code feels like reading the details of a use case:</p>

<blockquote>
  <p>To handle the submission of a new quote,
  we need to generate a unique identifier
  and then we need to save the new quote.</p>
</blockquote>

<p>Let's bootstrap its test:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\Fortune\Quote\SubmitNewQuoteHandler'
</code></pre>

<p>Then edit the test:</p>

<pre><code class="php">&lt;?php
// spec/Acme/Fortune/Quote/SubmitNewQuoteHandlerSpec.php

namespace spec\Acme\Fortune\Quote;

use Acme\Fortune\Quote\SubmitNewQuote;
use Acme\Fortune\Quote\Service\SaveNewQuote;
use Acme\Fortune\Quote\Service\UniqueIdentifierGenerator;
use PhpSpec\ObjectBehavior;

class SubmitNewQuoteHandlerSpec extends ObjectBehavior
{
    const ID = '921410e8-eb98-4f99-ba98-055d46980511';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    function let(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $this-&gt;beConstructedWith($saveNewQuote, $uniqueIdentifierGenerator);
    }

    function it_saves_new_quote(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $submitNewQuote = new SubmitNewQuote(self::QUOTE);
        $quote = array(
            'id' =&gt; self::ID,
            'quote' =&gt; self::QUOTE,
        );

        $uniqueIdentifierGenerator-&gt;generate()-&gt;willReturn(self::ID);
        $saveNewQuote-&gt;save($quote)-&gt;shouldBeCalled();

        $this-&gt;handle($submitNewQuote)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>After generating interfaces for <code>SaveNewQuote</code> and <code>UniqueIdentifierGenerator</code>
and after bootstrapping the code for <code>SubmitNewQuoteHandler</code>, the test will fail
because we need to complete it:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Quote/SubmitNewQuoteHandler.php

namespace Acme\Fortune\Quote;

use Acme\Fortune\Quote\Service\SaveNewQuote;
use Acme\Fortune\Quote\Service\UniqueIdentifierGenerator;

class SubmitNewQuoteHandler
{
    private $saveNewQuote;
    private $uniqueIdentifierGenerator;

    public function __construct(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $this-&gt;saveNewQuote = $saveNewQuote;
        $this-&gt;uniqueIdentifierGenerator = $uniqueIdentifierGenerator;
    }

    public function handle(SubmitNewQuote $sumbitNewQuote)
    {
        $quote = array(
            'id' =&gt; $this-&gt;uniqueIdentifierGenerator-&gt;generate(),
            'quote' =&gt; $sumbitNewQuote-&gt;quote,
        );
        $this-&gt;saveNewQuote-&gt;save($quote);

        return $quote;
    }
}
</code></pre>

<p>Now we can configure the service:</p>

<pre><code class="php"># app/config/services/quote.yml

services:
    app.submit_new_quote_handler:
        class: Acme\Fortune\Quote\SubmitNewQuoteHandler
        arguments:
            - "@app.save_new_quote"
            - "@app.unique_identifier_generator"
</code></pre>

<p>Finally can run the tests one last time:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>Allmost green!</p>

<p>They fail because <code>app.save_new_quote</code> and <code>app.unique_identifier_generator</code> don't
exist yet. They will be the topic of another article ;) .</p>

<h2 id="conclusion">Conclusion</h2>

<p>By restricting frameworks to their entry points (Controllers, Commands, etc) and
using the Command Bus to define our project entry points (domain boundaries) we
are able to decouple from the framework, allowing us to restrict the impact of BC breaks.</p>

<p>Of course, all projects are different and this solution might not be possible everywhere.
RAD development is a robust solution for web agencies, especially if they are chosen
to bootstrap a project as fast as possible and then need to pass the project over
to their customer after a short period.</p>

<p>On the other hand some companies are creating projects they will have to maintain
for decades and those are also in need of delivering a first version early.
Decoupling from the framework isn't something that slows down development, and there
are ways to still release early (e.g. define Minimum Valuable Product and deliver
small features iterations by iterations).</p>

<blockquote>
  <p><strong>Note</strong>: There are a couple of bundles that provides Symfony with a Command Bus, among them:</p>
  
  <ul>
  <li><a href="/2015/09/09/tactician.html">Tactician</a></li>
  <li><a href="/2015/08/04/simple-bus.html">SimpleBus</a></li>
  </ul>
</blockquote>

<p>If you're interrested on the subject, here's some resources:</p>

<ul>
<li>The framework as an implementation detail
(<a href="http://www.slideshare.net/marcello.duarte/the-framework-as-an-implementation-detail">slides</a>
and <a href="https://www.youtube.com/watch?v=0L_9NutiJlc">video</a>),
by <a href="http://marcelloduarte.net/">Marcello Duarte</a>
and <a href="http://everzet.com/">Konstantin Kudryashov</a></li>
<li><a href="https://blog.8thlight.com/uncle-bob/2014/05/11/FrameworkBound.html">Framework bound</a>,
by <a href="https://sites.google.com/site/unclebobconsultingllc/">Robert Cecil Martin</a></li>
<li><a href="http://kristopherwilson.com/2013/11/27/decoupling-the-framework/">Decoupling the Framework</a>,
by <a href="https://twitter.com/mrkrstphr">Kristopher Wilson</a></li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHPUnit with phpspec]]></title>
            <link href="/2015/09/23/phpunit-with-phpspec.html"/>
            <updated>2015-09-23T00:00:00+01:00</updated>
            <id>/2015/09/23/phpunit-with-phpspec.html</id>
            <content type="html"><![CDATA[<p><a href="https://phpunit.de/">PHPUnit</a> is a port of <a href="http://junit.org/">jUnit</a>, its name
might be deceptive: it allows you to write any type of tests (unit, but also functional,
system, integration, end to end, acceptance, etc).</p>

<p><a href="http://www.phpspec.net">phpspec</a> was at first a port of <a href="http://rspec.info/">rspec</a>,
it can be considered as a unit test framework that enforces practices it considers best.</p>

<blockquote>
  <p><strong>Note</strong>: <a href="/2015/08/03/phpspec.html">read more about phpspec</a>.</p>
</blockquote>

<p>In this article, we'll see how to use both tools together in a same project.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>We're going to build part of a <a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a>
application for our example, more precisely we're going to build a CLI allowing us to save quotes.</p>

<p>To do so, we'll bootstrap a symfony application using the <a href="https://github.com/gnugat/symfony-empty-edition">Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition fortune
cd fortune
</code></pre>

<p>We'll need to install our test frameworks:</p>

<pre><code>composer require --dev phpunit/phpunit
composer require --dev phpspec/phpspec
</code></pre>

<p>Finally we'll configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="app/bootstrap.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="System Tests"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="the-command">The command</h2>

<p>Our first step will be to write a <strong>system test</strong> describing the command:</p>

<pre><code class="php">&lt;?php
// tests/Command/SaveQuoteCommandTest.php

namespace AppBundle\Tests\Command;

use AppKernel;
use PHPUnit_Framework_TestCase;
use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Tester\ApplicationTester;

class SaveQuoteCommandTest extends PHPUnit_Framework_TestCase
{
    const EXIT_SUCCESS = 0;

    private $app;

    protected function setUp()
    {
        $kernel = new AppKernel('test', false);
        $application = new Application($kernel);
        $application-&gt;setAutoExit(false);
        $this-&gt;app = new ApplicationTester($application);
    }

    /**
     * @test
     */
    public function it_saves_a_new_quote()
    {
        $exitCode = $this-&gt;app-&gt;run(array(
            'quote:save',
            'quote' =&gt; 'Nobody expects the spanish inquisition',
        ));

        self::assertSame(self::EXIT_SUCCESS, $exitCode, $this-&gt;app-&gt;getDisplay());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Testing only the exit code is called "Smoke Testing" and is a very
  efficient way to check if the application is broken.
  Testing the output would be tedious and would make our test fragile as it might change often.</p>
</blockquote>

<p>Let's run it:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>The tests fails because the command doesn't exist. Let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Command/SaveQuoteCommand.php

namespace AppBundle\Command;

use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;

class SaveQuoteCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this-&gt;setName('quote:save');
        $this-&gt;addArgument('quote', InputArgument::REQUIRED);
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $output-&gt;writeln('');
        $output-&gt;writeln('// Saving quote');

        $this-&gt;getContainer()-&gt;get('app.save_new_quote')-&gt;save(
            $input-&gt;getArgument('quote')
        );

        $output-&gt;writeln('');
        $output-&gt;writeln(' [OK] Quote saved');
        $output-&gt;writeln('');
    }
}
</code></pre>

<p>Then run the test again:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>It now fails for a different reason: the service used doesn't exist.</p>

<h2 id="the-service">The service</h2>

<p>The second step is to write the unit test for the service. With phpspec we can
first bootstrap it:</p>

<pre><code>vendor/bin/phpspec describe 'AppBundle\Service\SaveNewQuote'
</code></pre>

<p>Then we need to edit it:</p>

<pre><code class="php">&lt;?php
// spec/AppBundle/Service/SaveNewQuoteSpec.php

namespace spec\AppBundle\Service;

use PhpSpec\ObjectBehavior;
use Symfony\Component\Filesystem\Filesystem;

class SaveNewQuoteSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/quotes.txt';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem, self::FILENAME);
    }

    function it_saves_new_quote(Filesystem $filesystem)
    {
        $filesystem-&gt;dumpFile(self::FILENAME, self::QUOTE)-&gt;shouldBeCalled();

        $this-&gt;save(self::QUOTE);
    }
}
</code></pre>

<p>Time to run the suite:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>phpspec will detect that the tested class doesn't exist and will bootstrap it for us,
so we just have to edit it:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/SaveNewQuote.php

namespace AppBundle\Service;

use Symfony\Component\Filesystem\Filesystem;

class SaveNewQuote
{
    private $filesystem;
    private $filename;

    public function __construct(Filesystem $filesystem, $filename)
    {
        $this-&gt;filesystem = $filesystem;
        $this-&gt;filename = $filename;
    }

    public function save($quote)
    {
        $this-&gt;filesystem-&gt;dumpFile($this-&gt;filename, $quote);
    }
}
</code></pre>

<p>Again, we're going to run our unit test:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>It's finally green! Our final step will be to define our service in the Dependency Injection
Container:</p>

<pre><code># app/config/config.yml

imports:
    - { resource: parameters.yml }
    - { resource: importer.php }

framework:
    secret: "%secret%"

services:
    app.save_new_quote:
        class: AppBundle\Service\SaveNewQuote
        arguments:
            - "@filesystem"
            - "%kernel.root_dir%/cache/quotes"
</code></pre>

<p>To make sure everything is fine, let's clear the cache and run the test:</p>

<pre><code>rm -rf app/cache/*
vendor/bin/phpunit
</code></pre>

<p>It's <a href="https://www.youtube.com/watch?v=lFeLDc2CzOs">Super Green</a>!</p>

<h2 id="conclusion">Conclusion</h2>

<p>As we can see, PHPUnit and phpspec can work perfectly well together.</p>

<p>Of course we could write our unit test in a similar manner with PHPUnit:</p>

<pre><code>&lt;?php
// tests/Service/SaveNewQuoteTest.php

namespace AppBundle\Tests\Service;

use AppBundle\Service\SaveNewQuote;
use PHPUnit_Framework_TestCase;

class SaveNewQuoteTest extends PHPUnit_Framework_TestCase
{
    const FILENAME = '/tmp/quotes.txt';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    private $filesystem;
    private $saveNewQuote;

    protected function setUp()
    {
        $this-&gt;filesystem = $this-&gt;prophesize('Symfony\Component\Filesystem\Filesystem');
        $this-&gt;saveNewQuote = new SaveNewQuote($this-&gt;filesystem-&gt;reveal(), self::FILENAME);
    }

    /**
     * @test
     * @group unit
     */
    public function it_saves_new_quote()
    {
        $this-&gt;filesystem-&gt;dumpFile(self::FILENAME, self::QUOTE)-&gt;shouldBeCalled();

        $this-&gt;saveNewQuote-&gt;save(self::QUOTE);
    }
}
</code></pre>

<p>And run it separately:</p>

<pre><code>vendor/bin/phpunit --group=unit
</code></pre>

<p>But then we would lose all the advantages of phpspec:</p>

<ul>
<li>it adds less overhead (this same test runs in ~20ms with phpspec, and ~80ms with PHPUnit)</li>
<li>it tells you when it thinks you're doing something wrong (typically by making it harder/impossible for you to do it)</li>
<li>it bootstraps things for you if you follow the TDD workflow (test first, then code)</li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
    </feed>