<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[LoÃ¯c Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2025-08-20T13:22:13+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[LoÃ¯c Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[PHPUnit Best Practices (Ultimate Guide)]]></title>
            <link href="/2025/07/31/phpunit-best-practices.html"/>
            <updated>2025-07-31T00:00:00+01:00</updated>
            <id>/2025/07/31/phpunit-best-practices.html</id>
            <content type="html"><![CDATA[<p>Forge battle-tested code, under the hammer of PHPUnit.</p>

<ul>
<li><a href="#unit-tests">Unit Tests</a>

<ul>
<li><a href="#factory-methods">Factory Methods</a></li>
<li><a href="#attributes">Attributes</a></li>
<li><a href="#data-providers">Data Providers</a></li>
<li><a href="#testdox">Testdox</a></li>
<li><a href="#coding-standards">Coding Standards</a></li>
<li><a href="#principles">Principles</a></li>
</ul></li>
<li><a href="#mocking">Mocking</a></li>
<li><a href="#integration-tests">Integration Tests</a>

<ul>
<li><a href="#smoke-tests">Smoke Tests</a></li>
</ul></li>
<li><a href="#useful-cli-options">Useful CLI options</a>

<ul>
<li><a href="#configuration">Configuration</a></li>
</ul></li>
</ul>

<h2 id="unit-tests">Unit Tests</h2>

<blockquote>
  <p><em>Inspired by <strong>Sebastian Bergmann</strong>, _Sources</em>:</p>
  
  <ul>
  <li><a href="https://www.youtube.com/watch?v=qwRdnoeq1H8">So you think you know PHPUnit - Sebastian Bergmann - PHPDD2024</a></li>
  <li><a href="https://www.youtube.com/watch?v=wR6YflVkAt4">Optimizing Your Test Suite - Sebastian Bergmann - PHP fwdays 2021</a></li>
  <li><a href="https://github.com/sebastianbergmann/raytracer/">Sebastian's raytracer project</a></li>
  <li><a href="https://phpunit.de/documentation.html">PHPUnit documentation</a></li>
  </ul>
</blockquote>

<p>Here's a unit test for a <code>CheckArray-&gt;check(string $field, mixed $value): array</code> class:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace App\Tests\Unit\Domain\Check;

use App\Domain\Check\CheckArray;
use App\Domain\Exception\ValidationFailedException;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\DataProvider;
use PHPUnit\Framework\Attributes\Small;
use PHPUnit\Framework\Attributes\TestDox;
use PHPUnit\Framework\TestCase;

#[CoversClass(CheckArray::class)]
#[Small]
class CheckArrayTest extends TestCase
{
    private const string FIELD = 'path.field_name';

    private function checkArray(): CheckArray
    {
        return new CheckArray();
    }

    public function test_it_accepts_valid_array(): void
    {
        $validArray = [23, 42, 1337];

        $this-&gt;assertSame($validArray, $this-&gt;checkArray()-&gt;check(
            self::FIELD,
            $validArray,
        ));
    }

    public function test_it_accepts_null(): void
    {
        // When checking that no exception is thrown
        $this-&gt;expectNotToPerformAssertions();

        $this-&gt;checkArray()-&gt;check(
            self::FIELD,
            null,
        );
    }

    /**
     * @return array&lt;string, array{mixed}&gt;
     */
    public static function nonArrayTypesProvider(): array
    {
        return [
            'string' =&gt; ['hello world'],
            'integer' =&gt; [42],
            'boolean' =&gt; [false],
        ];
    }

    #[DataProvider('nonArrayTypesProvider')]
    public function test_it_rejects_non_array_types(mixed $notAnArray): void
    {
        $this-&gt;expectException(ValidationFailedException::class);

        $this-&gt;checkArray()-&gt;check(
            self::FIELD,
            $notAnArray,
        );
    }
}
</code></pre>

<h3 id="factory-methods">Factory Methods</h3>

<p>When the System Under Test (SUT) has a simple constructor,
or its instantiation is clear and consistent,
then instantiate it directly in each test method.</p>

<p>But when the SUT's constructor has multiple parameters,
or a couple of test method require the same specific configuration, 
consider moving that creation logic to a private factory method:</p>

<ul>
<li>it ensures test consistency and validity by eliminating configuration drift</li>
<li>it centralizes complex instantiation logic, making tests more readable</li>
</ul>

<p>Finally, when your SUT legitimately needs to be tested under different configurations,
create explicit factory methods that document these variations.</p>

<h3 id="attributes">Attributes</h3>

<p>Attributes (<code>#[&lt;Name&gt;]</code>) were introduced in PHP 8 and PHPUnit 10,
they replace Annotations (PHPdoc <code>@&lt;Name&gt;</code>) which have been deprecated in PHPUnit 10
and removed in PHPUnit 12.</p>

<p>Their goal is to make PHP tooling more robust and IDE integration more reliable, use them!</p>

<p><strong>Specify targeted class</strong>:</p>

<ul>
<li><code>#[CoversClass]</code>: enforces proper test boundaries, prevents accidental coverage,
and makes the intent clearer both to the readers and tools
(code coverage, static analysis, etc)</li>
<li><code>#[UsesClass]</code>: if code from other classes is expected to be used</li>
</ul>

<p><strong>Categorize tests</strong> based on their scope, complexity and resource usage:</p>

<ul>
<li><code>#[Small]</code> for testing individual components in isolation (unit),
fast execution (typically under 100ms)</li>
<li><code>#[Medium]</code> for testing multiple components together in isolation (integration),
moderate execution (typically under 1s)</li>
<li><code>#[Large]</code> for complete workflows (end to end),
slow execution (over 1s)</li>
<li><code>#[Group]</code> for arbitrary categories (including temporary ones, eg <code>wip</code>)</li>
</ul>

<h3 id="data-providers">Data Providers</h3>

<p><strong>Use Data Providers</strong> to test different sets of inputs / outputs:</p>

<ul>
<li><code>#[DataProvider(string $publicStaticMethodName)]</code>
for a method in the test class</li>
<li><code>#[DataProviderExternal(string $className, string $publicStaticMethodName)]</code>
for a method in a different class from the test one</li>
<li><code>#[TestWith(array $data)]</code>
to provide one set at a time, without having to declare a static method</li>
</ul>

<h3 id="testdox">Testdox</h3>

<p><strong>Run PHPUnit with <code>--testdox</code> option</strong> to get executable specifications:</p>

<ul>
<li><code>#[TestDox(string $text)]</code>
to customize what PHPUnit will display</li>
</ul>

<blockquote>
  <p><strong>Note 1</strong></p>
  
  <p>Running <code>phpunit --testdox</code> with the following data provider:</p>

<pre><code class="php">    public static function nonArrayTypesProvider(): array
    {
        return [
            ['hello world'],
            [42],
            [false],
        ];
    }

    #[DataProvider('nonArrayTypesProvider')]
    public function test_it_rejects_non_array_types(mixed $notAnArray): void
</code></pre>
  
  <p>Will output:</p>

<pre><code>Check Array (App\Tests\Unit\Domain\Check\CheckArray)
 âœ” It rejects non array types with data set 0
 âœ” It rejects non array types with data set 1
 âœ” It rejects non array types with data set 2
</code></pre>
</blockquote>

<hr />

<blockquote>
  <p><strong>Note 2</strong></p>
  
  <p>This is equivalent to:</p>

<pre><code class="php">    #[TestWith(['hello world'])]
    #[TestWith([42])]
    #[TestWith([false])]
    public function test_it_rejects_non_array_types(mixed $notAnArray): void
</code></pre>
</blockquote>

<hr />

<blockquote>
  <p><strong>Note 3</strong></p>
  
  <p>However, we can use string keys to describe each set:</p>

<pre><code class="php">    public static function nonArrayTypesProvider(): array
    {
        return [
            'string' =&gt; ['hello world'],
            'integer' =&gt; [42],
            'boolean' =&gt; [false],
        ];
    }

    #[DataProvider('nonArrayTypesProvider')]
    public function test_it_rejects_non_array_types(mixed $notAnArray): void
</code></pre>
  
  <p>Which will output:</p>

<pre><code>Check Array (App\Tests\Unit\Domain\Check\CheckArray)
 âœ” It rejects non array types with string
 âœ” It rejects non array types with integer
 âœ” It rejects non array types with boolean
</code></pre>
</blockquote>

<hr />

<blockquote>
  <p><strong>Note 4</strong></p>
  
  <p>Finally, we can also change the text with <code>#[TestDox]</code>:</p>

<pre><code class="php">    public static function nonArrayTypesProvider(): array
    {
        return [
            'string' =&gt; ['hello world'],
            'integer' =&gt; [42],
            'boolean' =&gt; [false],
        ];
    }

    #[DataProvider('nonArrayTypesProvider')]
    #[TestDox('it rejects `$notAnArray` because it does not have type `array`')]
    public function test_it_rejects_non_array_types(mixed $notAnArray): void
</code></pre>
  
  <p>Which will output:</p>

<pre><code>Check Array (App\Tests\Unit\Domain\Check\CheckArray)
 âœ” it rejects `helloÂ·world` because it does not have type `array`
 âœ” it rejects `42` because it does not have type `array`
 âœ” it rejects `false` because it does not have type `array`
</code></pre>
</blockquote>

<h3 id="coding-standards">Coding Standards</h3>

<p><strong>Follow Coding Standards</strong> to ensure consistency across the PHP ecosystem,
and internal projects:</p>

<ul>
<li><a href="https://www.php-fig.org/psr/psr-4/">PSR-4</a> for file, namespace and class names</li>
<li><a href="https://www.php-fig.org/psr/psr-12/">PSR-12</a> for the rest</li>
<li>discuss, agree and enforce coding styles in your team
eg using <a href="https://cs.symfony.com/">PHP CS Fixer</a></li>
</ul>

<p><em>Here are examples of topics you can debate</em>:</p>

<ul>
<li><strong>Enforce strict types declaration</strong> (<code>declare(strict_types=1)</code>)
to prevent type coercion bugs that can cause tests to pass when they shouldn't</li>
<li><strong>Make test classes final</strong> 
as they should never be extended from</li>
<li><strong>Use visibility and type hint keywords</strong> 
for future-proofing against language changes</li>
<li><strong>Follow snake case for test method names</strong>
so they read as text, with underscores representing spaces</li>
<li><strong>Use <code>$this</code> over <code>self</code></strong>
to call PHPUnit assertions</li>
<li><strong>Use <code>#[Test]</code> attribute and <code>it_</code> prefix</strong>
to help name test methods in an articulate way</li>
</ul>

<h3 id="principles">Principles</h3>

<p>FIRST properties of Unit Tests, they should be:</p>

<ul>
<li><strong>Fast</strong>: to provide a short feedback loop</li>
<li><strong>Isolated</strong>: one test failure shouldn't impact another test</li>
<li><strong>Repeatable</strong>: the outcome of a test should be consistent over time</li>
<li><strong>Self-validating</strong>: automated test should fail or pass for the right reason</li>
<li><strong>Timely</strong>: write the test around the time the code was written, not long after (but ideally before)</li>
</ul>

<p>Follow <a href="https://wiki.c2.com/?ArrangeActAssert">AAA</a>,
each test method should group these functional sections, separated by blank lines:</p>

<ol>
<li><strong>Arrange</strong>: all necessary preconditions and input</li>
<li><strong>Act</strong>: on the System Under Test (SUT)</li>
<li><strong>Assert</strong>: that the expected results have occurred</li>
</ol>

<p>Not necessarily in that order (eg when testing exceptions: Arrange, Expect, Act).</p>

<p><a href="https://wiki.c2.com/?DontRepeatYourself">DRY</a> vs DAMP (aka WET),
it's all about finding the right balance: pick whichever is more readable,
on a case-by-case basis.</p>

<blockquote>
  <p>"DRY (Don't Repeat Yourself) increases maintainability
  by isolating change (risk) to only those parts of the system that must change.</p>
  
  <p>DAMP (Descriptive And Meaningful Phrases, <em>aka WET: We Edit Twice</em>) increases maintainability
  by reducing the time necessary to read and understand the code."</p>
  
  <p>â€” Chris Edwards</p>
</blockquote>

<h2 id="mocking">Mocking</h2>

<blockquote>
  <p><strong>Note</strong>: this is "In My Humble Opinion".</p>
</blockquote>

<p>There are two Test Driven Development (TDD) schools of thought:</p>

<ul>
<li><strong>Chicago / Detroit (classical)</strong>: use real objects, avoid mocks</li>
<li><strong>London (specification Behaviour Driven Development - spec BDD)</strong>:
use mocks to describe interactions between the System Under Test (SUT) and its dependencies (collaborators)</li>
</ul>

<p>The mocking library <a href="https://github.com/phpspec/prophecy">prophecy</a>'s expressive syntax
allows for an approach that's more aligned with spec BDD.
It can be used in PHPUnit with the <code>phpspec/prophecy-phpunit</code> package:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace App\Tests\Unit\Domain\Event\Check;

use App\Domain\Check\CheckDateTimeIso8601;
use App\Domain\Event\Check\CheckStart;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\Small;
use PHPUnit\Framework\TestCase;
use Prophecy\PhpUnit\ProphecyTrait;

#[CoversClass(CheckStart::class)]
#[Small]
final class CheckStartTest extends TestCase
{
    use ProphecyTrait;

    private const string FIELD = 'start';
    private const string START = '2025-06-17T13:00:00';

    public function test_it_checks_start(): void
    {
        $checkDateTimeIso8601 = $this-&gt;prophesize(CheckDateTimeIso8601::class);

        $checkDateTimeIso8601-&gt;check(
            self::FIELD,
            self::START,
        )-&gt;shouldBeCalled()-&gt;willReturn(self::START);

        $checkStart = new CheckStart(
            $checkDateTimeIso8601-&gt;reveal(),
        );
        $this-&gt;assertSame(self::START, $checkStart-&gt;check(
            self::FIELD,
            self::START,
        ));
    }
}
</code></pre>

<h2 id="integration-tests">Integration Tests</h2>

<blockquote>
  <p>ðŸ¤« <strong>Super Secret Tip</strong>:</p>
  
  <p>PHPUnit instantiates the test class once per test method and once per data provider row.
  This is a fundamental design decision that prioritizes test isolation over performance.</p>
  
  <p>So if you have:</p>
  
  <ul>
  <li>5 regular test methods: that's 5 instances</li>
  <li>1 test method with 10 data provider rows: that's 10 instances</li>
  <li>Total: 15 instances created</li>
  </ul>
  
  <p>Why This Matters:</p>
  
  <ul>
  <li><strong>Performance</strong> : expensive <code>setUp()</code> and constructors will have a measurable impact</li>
  <li><strong>Memory Usage</strong>: Each instance holds its own state in memory until the end of the testsuite run</li>
  <li><strong>Test Isolation</strong>: Ensures no state leakage between tests (the main benefit)</li>
  </ul>
  
  <p>Since each test method creates a new instance, expensive operations compound quickly. Watch out for:</p>
  
  <ul>
  <li>repeated kernel booting</li>
  <li>database connections</li>
  <li>fixture loading (especially when Doctrine ORM Entity hydration is involved)</li>
  <li>external API calls</li>
  </ul>
  
  <p>You can use singletons for stateless services, transactions for database cleanup, and mocks for external dependencies.
  The example below uses <code>AppSingleton::get()</code> to share a stateless application instance across the entire testsuite.</p>
</blockquote>

<h3 id="smoke-tests">Smoke Tests</h3>

<blockquote>
  <p><strong>Note</strong>: this is the pragmatic approach.</p>
</blockquote>

<p>For controllers and commands, no need to mock internal dependencies
or asserting on complex business logic.</p>

<p>Just craft the input, pass it to application, and verify the status code.</p>

<p>This tests the entire request-response cycle:
routing, middleware, validation, business logic, serialization... Everything.</p>

<p>Here's an integration test for a <code>POST /v1/events</code> endpoint controller:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace App\Tests\Integration\Controller\Event;

use App\Controller\Event\CreateController;
use App\Tests\AppSingleton;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\Medium;
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpFoundation\Request;

#[CoversClass(CreateController::class)]
#[Medium]
final class CreateControllerTest extends TestCase
{
    public function test_it_creates_new_one(): void
    {
        $appKernel = AppSingleton::get()-&gt;appKernel();

        $headers = [
            'CONTENT_TYPE' =&gt; 'application/json',
        ];
        $request = Request::create('/v1/events', 'POST', [], [], [], $headers, (string) json_encode([
            'title' =&gt; 'Daily stand up',
            'start' =&gt; (new \DateTimeImmutable('now'))-&gt;format('Y-m-d\TH:i:s'),
            'end' =&gt; (new \DateTimeImmutable('now + 1 second'))-&gt;format('Y-m-d\TH:i:s'),
        ]));

        $response = $appKernel-&gt;handle($request);
        $appKernel-&gt;terminate($request, $response);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), (string) $response-&gt;getContent());
    }

    public function test_it_cannot_create_new_one_without_required_fields(): void
    {
        $appKernel = AppSingleton::get()-&gt;appKernel();

        $headers = [
            'CONTENT_TYPE' =&gt; 'application/json',
        ];
        $request = Request::create('/v1/events', 'POST', [], [], [], $headers, (string) json_encode([
            'start' =&gt; '2025-07-09T09:00:00+00:00',
            'end' =&gt; '2025-07-09T09:15:00+00:00',
        ]));

        $response = $appKernel-&gt;handle($request);
        $appKernel-&gt;terminate($request, $response);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), (string) $response-&gt;getContent());
    }
}
</code></pre>

<p>And here's an integration test for a <code>./bin/console events:list</code> CLI command:</p>

<pre><code class="php">&lt;?php

declare(strict_types=1);

namespace App\Tests\Integration\Command\Event;

use App\Command\Event\ListCommand;
use App\Tests\AppSingleton;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\Attributes\Medium;
use PHPUnit\Framework\TestCase;
use Symfony\Component\Console\Command\Command;

#[CoversClass(ListCommand::class)]
#[Medium]
final class ListCommandTest extends TestCase
{
    public function test_it_lists_existing_ones(): void
    {
        $applicationTester = AppSingleton::get()-&gt;applicationTester();

        $input = [
            ListCommand::NAME,
        ];

        $statusCode = $applicationTester-&gt;run($input);

        $this-&gt;assertSame(Command::SUCCESS, $statusCode, $applicationTester-&gt;getDisplay());
    }
}
</code></pre>

<h2 id="useful-cli-options">Useful CLI options</h2>

<pre><code class="console">phpunit

  # Configuration:
  --generate-configuration             Generate configuration file with suggested settings
  --migrate-configuration              Migrate configuration file to current format

  # Selection:
  --list-groups                        List available test groups
  --group small                        Only run tests from the specified group(s)
  --exclude-group small                Exclude tests from the specified group(s)

  --list-tests                         List available tests
  --covers 'CheckArray'                Only run tests that intend to cover &lt;name&gt;
  --filter 'CheckArrayTest'            Filter which tests to run (test class, or test method)
  --filter 'test_it_accepts_valid_array'

  ## Useful for running testsuites individually, in the CI
  --list-testsuites                    List available testsuites
  --testsuite unit                     Only run tests from the specified testsuite(s)
  --exclude-testsuite unit             Exclude tests from the specified testsuite(s)

  # Execution
  --stop-on-failure                    Stop after first failure
  --order-by &lt;order&gt;                   Run tests in order: default|defects|depends|duration|no-depends|random|reverse|size

  # Reporting
  --no-progress                        Disable output of test execution progress (the dots)
  --testdox                            Replace default result output with TestDox format
</code></pre>

<blockquote>
  <p><strong>Order By options</strong>:</p>
  
  <ul>
  <li><code>default</code>: tests run in the order they're discovered
  (filesystem order, typically alphabetical)</li>
  <li><code>defects</code>: previously failed/errored tests run first
  (requires <code>--cache-result</code> to remember past failures)</li>
  <li><code>depends</code>: tests with dependencies run after their dependencies, non-dependent tests run first</li>
  <li><code>duration</code>: fastest tests run first, slowest tests run last
  (requires <code>--cache-result</code> to remember execution times)</li>
  <li><code>no-depends</code>: ignores test dependencies and runs tests in discovery order</li>
  <li><code>random</code>: tests run in random order
  (use <code>--random-order-seed &lt;N&gt;</code> for reproducible randomness)</li>
  <li><code>reverse</code>: tests run in reverse discovery order</li>
  <li><code>size</code>: tests run by size: <code>#[Small]</code>, then <code>#[Medium]</code>, after <code>#[Large]</code>, and finally unsized tests</li>
  </ul>
  
  <p><em>Worth noting</em>: > * Combining options: <code>--order-by=depends,defects</code></p>
</blockquote>

<h3 id="configuration">Configuration</h3>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- https://phpunit.readthedocs.io/en/latest/configuration.html --&gt;
&lt;phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="tests/bootstrap.php"

         cacheDirectory=".phpunit.cache"
         executionOrder="depends,defects"
         requireCoverageMetadata="true"
         beStrictAboutCoverageMetadata="true"
         beStrictAboutOutputDuringTests="true"
         displayDetailsOnPhpunitDeprecations="true"
         failOnPhpunitDeprecation="true"
         failOnRisky="true"
         failOnWarning="true"

         shortenArraysForExportThreshold="10"
         colors="true"
&gt;
    &lt;php&gt;
        &lt;!-- Useful for CI environments --&gt;
        &lt;ini name="display_errors" value="1" /&gt;
        &lt;ini name="error_reporting" value="-1" /&gt;

        &lt;!-- Useful for Symfony --&gt;
        &lt;env name="KERNEL_CLASS" value="App\Kernel" /&gt;
        &lt;env name="APP_ENV" value="test" force="true" /&gt;
        &lt;env name="APP_DEBUG" value="0" force="true" /&gt;
        &lt;env name="SHELL_VERBOSITY" value="-1" /&gt;
    &lt;/php&gt;

    &lt;testsuites&gt;
        &lt;testsuite name="unit"&gt;
            &lt;directory&gt;tests/Unit&lt;/directory&gt;
        &lt;/testsuite&gt;
        &lt;testsuite name="integration"&gt;
            &lt;directory&gt;tests/Integration&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;

    &lt;source
        ignoreIndirectDeprecations="true"
        restrictNotices="true"
        restrictWarnings="true"
    &gt;
        &lt;include&gt;
            &lt;directory&gt;src&lt;/directory&gt;
        &lt;/include&gt;
    &lt;/source&gt;
&lt;/phpunit&gt;
</code></pre>

<blockquote>
  <p><strong>Notes</strong>:</p>
  
  <ul>
  <li><code>bootstrap</code> defaults to <code>vendor/autoload.php</code></li>
  <li><code>shortenArraysForExportThreshold</code> defaults to <code>0</code> from v11.3 and <code>10</code> from v12</li>
  <li><code>colors</code> defaults to <code>false</code>, for automated/scripted environment compatibility</li>
  </ul>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHPUnit setUp() is a lie]]></title>
            <link href="/2024/07/03/phpunit-setup-is-a-lie.html"/>
            <updated>2024-07-03T00:00:00+01:00</updated>
            <id>/2024/07/03/phpunit-setup-is-a-lie.html</id>
            <content type="html"><![CDATA[<p><a href="https://phpunit.de/index.html">PHPUnit</a> creates as many instances a Test Class, as it has test methods.</p>

<h2 id="proof-and-it-gets-worse">Proof (and it gets worse)</h2>

<p>Let's set up a project to verify our claim:</p>

<pre><code>mkdir /tmp/phpunit-is-a-cake &amp;&amp; cd "$_"
composer init --no-interaction --name 'follow/the-white-rabbit' --type project --autoload '.'
composer require -o --dev phpunit/phpunit:^9.6
</code></pre>

<p>Next we write a catchy test:</p>

<pre><code>&lt;?php declare(strict_types=1);
use PHPUnit\Framework\TestCase;

class CatchyTest extends TestCase
{
    private string $letMeCountThemForYou = '';

    public function __construct($name = null, array $data = [], $dataName = '')
    {
        parent::__construct($name, $data, $dataName);

        echo "How many times have I, how many times have I, how many times have I been instanciated?\n";
    }

    public function __destruct()
    {
        echo "Till the morning light\n";
    }

    public function testOne(): void
    {
        $this-&gt;letMeCountThemForYou .= 'One';

        echo "{$this-&gt;letMeCountThemForYou}\n";
    }

    public function testTwo(): void
    {
        $this-&gt;letMeCountThemForYou .= 'Two';

        echo "{$this-&gt;letMeCountThemForYou}\n";
    }

    /**
     * @dataProvider provider
     */
    public function testMore($times): void
    {
        $this-&gt;letMeCountThemForYou .= $times;

        echo "{$this-&gt;letMeCountThemForYou}\n";
    }

    public function provider(): array
    {
        return [['Three'], ['Four'], ['Five'], ['Six'], ['Seven'], ['Eight']];
    }
}
</code></pre>

<p>Finally we run the tests to see the output:</p>

<pre><code>&gt; phpunit ./CatchyTest.php
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
Till the morning light
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
How many times have I, how many times have I, how many times have I been instanciated?
PHPUnit 9.6.19 by Sebastian Bergmann and contributors.

ROne
RTwo
RThree
RFour
RFive
RSix
RSeven
R                                                            8 / 8 (100%)Eight
// [...]
Till the morning light
Till the morning light
Till the morning light
Till the morning light
Till the morning light
Till the morning light
Till the morning light
Till the morning light
</code></pre>

<p>And Bob's your uncle! Hang on, what?</p>

<p>The constructor has been called 3 (test methods) + 6 (items in data provider) = 9 times
and we can observe that the class attribute's value isn't shared between the test methods
but gets reset every time.</p>

<p>And those instances stay alive until the vey end of the run,
meaning a concerningly increasing memory usage througout the test suite,
which also slows it down!</p>

<h2 id="%22solution%22">"Solution"</h2>

<p>There's <a href="https://kriswallsmith.net/post/18029585104/faster-phpunit">a hack that's been around for decades</a>
to free the memory and speed up the test suites:</p>

<pre><code>&lt;?php declare(strict_types=1);
use PHPUnit\Framework\TestCase;

abstract class BaseTestCase extends TestCase
{
    protected function tearDown()
    {
        $refl = new ReflectionObject($this);
        foreach ($refl-&gt;getProperties() as $prop) {
            if (!$prop-&gt;isStatic() &amp;&amp; 0 !== strpos($prop-&gt;getDeclaringClass()-&gt;getName(), 'PHPUnit\\')) {
                $prop-&gt;setAccessible(true);
                $prop-&gt;setValue($this, null);
            }
        }
    }
}
</code></pre>

<p>The <code>tearDown</code> method is called after each test method, so it's a good place to unset class attributes.</p>

<p>To avoid having to think about it, a catch all solution using relfection can be put inside a custom <code>BaseTestCase</code>
that'll be extended by all our test classes.</p>

<p>And indeed most of the code bases don't directly extend PHPUnit's TestCase,
for example <a href="https://symfony.com/doc/current/testing.html">Symfony's documentation suggest to use FrameworkBundle's KernelTestCase</a>.</p>

<p>But what does it do exactly?</p>

<h2 id="showing-the-bad-example">Showing the bad example</h2>

<p>Here's a highly opinionated summary of its code:</p>

<pre><code>&lt;?php

namespace Symfony\Bundle\FrameworkBundle\Test;

use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpKernel\KernelInterface;

abstract class KernelTestCase extends TestCase
{
    protected static ?KernelInterface $kernel = null;

    protected static function bootKernel(): KernelInterface
    {
        static::$kernel = new \AppKernel('test', true);
        $kernel-&gt;boot();

        return static::$kernel;
    }

    protected function tearDown(): void
    {
        if (null !== static::$kernel) {
            static::$kernel-&gt;shutdown();
            static::$kernel = null;
        }
    }
}
</code></pre>

<p>Symfony's HttpKernel is stateless, so being able to boot it (which is slow) only once
and store it in a static attribute of a TestCase that all our functional test implement is great!</p>

<p>However calling <code>bootKernel</code> will always return a new instance of the application kernel and will always boot it,
while the <code>tearDown</code> method also makes sure to nuke it after each test method...</p>

<p>Now I can't pretend to know the reason behind this (maybe assuming that applications are stateful?),
nor am I familiar with all the different applications out there and their specific use cases,
but that seems very unfortunate to me.</p>

<p>To fix it, we can rewrite it as follow:</p>

<pre><code>&lt;?php declare(strict_types=1);
use PHPUnit\Framework\TestCase;
use Symfony\Component\HttpKernel\KernelInterface;

abstract class MyTestCase extends TestCase
{
    protected static ?KernelInterface $kernel = null;

    protected static function getKernel(): KernelInterface
    {
        if (null === static::$kernel) {
            static::$kernel = new \AppKernel('test', true);
            $kernel-&gt;boot();
        }

        return static::$kernel;
    }
}
</code></pre>

<p>We got rid of the kernel shutdown shenanigans (can be called manually if needed),
and made sure the Kernel is instanciated (and booted) only once.</p>

<p>But why have this as part of the TestCase? This should be extracted into its own class:</p>

<pre><code>&lt;?php declare(strict_types=1);
use Symfony\Component\HttpKernel\KernelInterface;

class KernelSingleton
{
    protected static ?KernelInterface $kernel = null;

    protected static function get(): KernelInterface
    {
        if (null === static::$kernel) {
            static::$kernel = new \AppKernel('test', true);
            $kernel-&gt;boot();
        }

        return static::$kernel;
    }
}
</code></pre>

<p>I know, I know. The Singleton desing pattern has been receiving a lot of bad rap over the years.
But here, it's a legitimate use case!</p>

<h2 id="conclusion">Conclusion</h2>

<p>What have we learned?</p>

<p>That each PHPUnit test method is run in isolation inside its own Test Class instance,
so class attribute values will rapidly consume more and more memory (and slow down the test suite),
and they cannot be shared between two test methods unless you make them static.</p>

<p>And perhaps consider using Singletons instead of relying on "FrameworkTestCase".</p>

<p>As for PHPUnit's setUp method, in your opinion, is it best described as "executed before each test method",
or as "executed everytime the test class is instanciated"?</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[ChatGPT: fluff or not? SpecBDD]]></title>
            <link href="/2023/04/19/chat-gpt-spec-bdd.html"/>
            <updated>2023-04-19T00:00:00+01:00</updated>
            <id>/2023/04/19/chat-gpt-spec-bdd.html</id>
            <content type="html"><![CDATA[<p>Now that a couple of months have passed since its over hyped launch,
surely <a href="https://openai.com/blog/chatgpt/">ChatGPT</a> has found some
use cases where it could be of any actual use. Or is it all fluff? Let's find out.</p>

<p>In my quest to find a use for ChatGPT in my day to day developer activity,
I've finally found a helpful scenario!</p>

<p>Let me walk you through my findings about ChatGPT and its "Spec Gen" capacity,
so we can learn a thing or two.</p>

<h2 id="spec-gen">Spec Gen</h2>

<p>When tasked to write a feature, I first write a unit test that specifies the
behaviour, for example:</p>

<pre><code>&lt;?php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    private const FILENAME = '/tmp/file.txt';
    private const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem): void
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_creates_new_files(File $file, Filesystem $filesystem): void
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>When using <a href="https://phpspec.net/en/stable/">phpspec</a>,
especially with the extension <a href="https://github.com/memio/spec-gen">spec-gen</a>,
running the test will bootstrap for me the corresponding class:</p>

<pre><code>&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesytem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open(string $argument1, bool $argument2)
    {
    }
}
</code></pre>

<p>That's pretty good, but it could be better: what if it was able to generate the complete code?</p>

<h2 id="gpt-gen">GPT Gen</h2>

<p>Let's forget about phpspec and use instead <a href="https://phpunit.de/">PHPUnit</a>,
but still with the <a href="https://github.com/phpspec/prophecy">Prophecy</a>
Mocking framework.</p>

<p>Let's ask ChatGPT. Here's the priming prompt:</p>

<blockquote>
  <p><strong>USER</strong>:
  Act as an expert PHP developer,
    who's been writing high quality API code for 20 years.
  Acknowledge with "ok".</p>
</blockquote>

<p>Because ChatGPT's Large Language Model (LLM) is able to generate a wide range
of text (conversation, essays, movie script, poetry, etc), assigning it a role
helps it narrow down its context, hence improving its accuracy for the task we
want it to complete: writing PHP code, on a professional level
(persona/role prompt engineering technique).</p>

<p>We also need to consider the Goldfish Memory issue of ChatGPT: it only takes
into account the last ~4000 tokens to generate its response, so asking it to
give us a short reply helps us save some space.</p>

<blockquote>
  <p><strong>ChatGPT</strong>: ok</p>
</blockquote>

<p>LLMs perform better when given some examples, and indeed before asking it to
generate code we might want to give ChatGPT some of our code samples
(X-Shot prompt engineering technique).</p>

<p>Since coding also requires some level of logic, it is also helpful to include
reasoning steps (Chain of Thought prompt engineering technique).</p>

<p>Similarly, asking the LLM to first generate some topic related knowledge,
and then reuse that in the further prompts will also increase our success rate
(Generated Knowledge prompt engineering technique).</p>

<p>With this in mind, here's the second prompt that provides a test class example:</p>

<blockquote>
  <p><strong>USER</strong>: Here's an example of test class from the project you're working on:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace tests\Ssc\Btlr\Cht\Message\Templates\Prompts;

use Ssc\Btlr\App\Filesystem\ReadFile;
use Ssc\Btlr\App\Template\Replace;
use Ssc\Btlr\Cht\Message\Logs\Type;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;
use Ssc\Btlr\Cht\Message\Templates\Prompts\Template;
use tests\Ssc\Btlr\AppTest\BtlrServiceTestCase;

class TemplateTest extends BtlrServiceTestCase
{
    /**
     * @test
     */
    public function it_creates_prompt_from_template(): void
    {
        // Fixtures
        $thoseParameters = [
            'last_messages' =&gt; 'USER (1968-04-02T18:40:23+00:00): Write code for me, please',
        ];
        $forType = Type::AUGMENTED_PROMPT;
        $withConfig = [
            'chunk_memory_size' =&gt; 15,
            'llm_engine' =&gt; 'chatgpt-gpt-3.5-turbo',
            'logs_filename' =&gt; './var/cht/logs',
            'prompt_templates_filename' =&gt; './templates/cht/prompts',
        ];

        $template = "LAST MESSAGES:\n%last_messages%\nBTLR:\n";
        $prompt = "LAST MESSAGES:\n{$thoseParameters['last_messages']}\nBTLR:\n";
        $data = [
            'entry' =&gt; $prompt,
        ];

        // Dummies
        $readFile = $this-&gt;prophesize(ReadFile::class);
        $replace = $this-&gt;prophesize(Replace::class);
        $writeLog = $this-&gt;prophesize(WriteLog::class);

        // Stubs &amp; Mocks
        $readFile-&gt;in("{$withConfig['prompt_templates_filename']}/{$forType['name']}.txt")
            -&gt;willReturn($template);
        $replace-&gt;in($template, $thoseParameters)
            -&gt;willReturn($prompt);
        $writeLog-&gt;for($data, $forType, $withConfig)
            -&gt;shouldBeCalled();

        // Assertion
        $template = new Template(
            $readFile-&gt;reveal(),
            $replace-&gt;reveal(),
            $writeLog-&gt;reveal(),
        );
        self::assertSame($prompt, $template-&gt;replace(
            $thoseParameters,
            $forType,
            $withConfig,
        ));
    }
}
</code></pre>

<blockquote>
  <p><strong>USER</strong>:
  Acknowledge by describing how the use of fixtures, dummies, stubs, mocks
  and assertions allow to make sure the tested code is behaving as expected.
  And note the use of the special BtlrServiceTestCase parent class for <code>TemplateTest</code>.</p>
</blockquote>

<p>By the way, the code is from my Super Secret Code project
<a href="https://github.com/gnugat/ssc-btlr">Btlr</a>.</p>

<p>Here's ChatGPT's response:</p>

<blockquote>
  <p><strong>ChatGPT</strong>:
  In this test class, fixtures are used to provide the necessary data for
  testing the <code>Template</code> class. The parameters and configuration are defined in
  <code>$thoseParameters</code> and <code>$withConfig</code> respectively, and the template and prompt
  strings are defined in <code>$template</code> and <code>$prompt</code>.</p>
  
  <p>Dummies are used to provide the interface of the <code>ReadFile</code>, <code>Replace</code>, and
  <code>WriteLog</code> classes, without providing any actual implementation, since these
  classes are not the focus of the test.</p>
  
  <p>Stubs are used to replace the implementation of <code>ReadFile</code> and <code>Replace</code>
  classes, by returning a fixed value when their respective methods are called.
  This ensures that the expected values are used for testing the <code>Template</code> class.</p>
  
  <p>Mocks are used to verify that the <code>WriteLog</code> class is called with the expected
  parameters. The <code>shouldBeCalled()</code> method ensures that the <code>for()</code> method of
  <code>WriteLog</code> class is actually called during the test.</p>
  
  <p>Finally, the assertion compares the result returned by the <code>replace()</code> method
  of the <code>Template</code> class with the expected prompt string.</p>
  
  <p>The <code>BtlrServiceTestCase</code> class is a special parent class that sets up a test
  environment for the Btlr service, which can include initializing dependencies,
  connecting to databases, and setting up configurations. This helps to ensure
  that tests are run in a consistent and isolated environment, and makes it easier
  to write tests for the Btlr service.</p>
</blockquote>

<p>ChatGPT doesn't have access to the project and its code, it only knows what we've
provided in the conversation so far.</p>

<p>So for example it took a wild guess at what <code>BtlrServiceTestCase</code> does and got
it wrong, but for our purpose this is good enough.</p>

<p>The third prompt is an example of the corresponding class:</p>

<blockquote>
  <p><strong>USER</strong>:
  When tasked with generating the corresponding <code>Template</code> class, from the above
  <code>TemplateTest</code> test class, here's the code you wrote:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace Ssc\Btlr\Cht\Message\Templates\Prompts;

use Ssc\Btlr\App\Filesystem\ReadFile;
use Ssc\Btlr\App\Template\Replace;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;

class Template
{
    public function __construct(
        private ReadFile $readFile,
        private Replace $replace,
        private WriteLog $writeLog,
    ) {
    }

    public function replace(
        array $thoseParameters,
        array $forType,
        array $withConfig,
    ): string {
        $template = $this-&gt;readFile-&gt;in(
            "{$withConfig['prompt_templates_filename']}/{$forType['name']}.txt",
        );
        $prompt = $this-&gt;replace-&gt;in($template, $thoseParameters);
        $this-&gt;writeLog-&gt;for([
            'entry' =&gt; $prompt,
        ], $forType, $withConfig);

        return $prompt;
    }
}
</code></pre>

<blockquote>
  <p><strong>USER</strong>: Acknowledge by describing how the test class got translated into its
  corresponding class.</p>
</blockquote>

<p>To which ChatGPT replies:</p>

<blockquote>
  <p><strong>ChatGPT</strong>:
  The <code>TemplateTest</code> test class served as a guide for implementing the
  <code>Template</code> class.</p>
  
  <p>First, the constructor of <code>Template</code> class takes three dependencies, which
  are also injected in the <code>TemplateTest</code> class as dummies or mocks.</p>
  
  <p>Next, the <code>replace()</code> method of <code>Template</code> class has the same signature as
  the test method <code>it_creates_prompt_from_template()</code>, with the addition of a
  return type declaration for the prompt string.</p>
  
  <p>The implementation of <code>replace()</code> method in <code>Template</code> class uses the
  injected <code>ReadFile</code> instance to read the template string from the filesystem,
  using the <code>$forType['name']</code> parameter to construct the file path.
  It then uses the injected <code>Replace</code> instance to replace placeholders in the
  template with values provided in the <code>$thoseParameters</code> array, resulting in
  a <code>$prompt</code> string.</p>
  
  <p>Finally, the method calls the injected <code>WriteLog</code> instance with the <code>$prompt</code>,
  <code>$forType</code>, and <code>$withConfig</code> parameters, which logs the prompt for the given
  type and configuration.</p>
  
  <p>Overall, the implementation of the <code>Template</code> class closely follows the
  structure of the <code>TemplateTest</code> class, and the use of dependency injection
  ensures that the class can be easily tested in isolation from its
  dependencies.</p>
</blockquote>

<p>With ChatGPT noting that the corresponding class closely follows the structure
of its test, it should be now ready.</p>

<p>Let's give it a new test class, and ask it to generate the corresponding code:</p>

<blockquote>
  <p><strong>USER</strong>: Brilliant. Now, in the same coding style as <code>TemplateTest</code> and
  <code>Template</code>, you are tasked to write a the corresponding code for the
  following <code>ReplyTest</code> test class:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace tests\Ssc\Btlr\Cht\Message;

use Ssc\Btlr\Cht\Message\Logs\Type;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;
use Ssc\Btlr\Cht\Message\Memory\Consolidate;
use Ssc\Btlr\Cht\Message\Reply;
use Ssc\Btlr\Cht\Message\Reply\Augment;
use Ssc\Btlr\Cht\Message\Reply\UsingLlm;
use tests\Ssc\Btlr\AppTest\BtlrServiceTestCase;

class ReplyTest extends BtlrServiceTestCase
{
    /**
     * @test
     */
    public function it_replies_to_user_prompt_using_llm(): void
    {
        // Fixtures
        $userPrompt = 'Write code for me, please';
        $withConfig = [
            'chunk_memory_size' =&gt; 15,
            'llm_engine' =&gt; 'chatgpt-gpt-3.5-turbo',
            'logs_filename' =&gt; './var/cht/logs',
            'prompt_templates_filename' =&gt; './templates/cht/prompts',
        ];

        $userPromptData = [
            'entry' =&gt; $userPrompt,
        ];
        $augmentedPrompt = "USER: {$userPrompt}\nBLTR:";
        $modelCompletion = "I'm sorry, dev. I'm afraid I can't do that.";
        $modelCompletionData = [
            'entry' =&gt; $modelCompletion,
            'llm_engine' =&gt; $withConfig['llm_engine'],
        ];

        // Dummies
        $augment = $this-&gt;prophesize(Augment::class);
        $consolidate = $this-&gt;prophesize(Consolidate::class);
        $usingLlm = $this-&gt;prophesize(UsingLlm::class);
        $writeLog = $this-&gt;prophesize(WriteLog::class);

        // Stubs &amp; Mocks
        $writeLog-&gt;for($userPromptData, Type::USER_PROMPT, $withConfig)
            -&gt;shouldBeCalled();
        $augment-&gt;the($userPrompt, $withConfig)
            -&gt;willReturn($augmentedPrompt);
        $usingLlm-&gt;complete($augmentedPrompt)
            -&gt;willReturn($modelCompletion);
        $writeLog-&gt;for($modelCompletionData, Type::MODEL_COMPLETION, $withConfig)
            -&gt;shouldBeCalled();
        $consolidate-&gt;memories($withConfig)
            -&gt;shouldBeCalled();

        // Assertion
        $reply = new Reply(
            $augment-&gt;reveal(),
            $consolidate-&gt;reveal(),
            $usingLlm-&gt;reveal(),
            $writeLog-&gt;reveal(),
        );
        self::assertSame($modelCompletion, $reply-&gt;to(
            $userPrompt,
            $withConfig,
        ));
    }
}
</code></pre>

<blockquote>
  <p><strong>USER</strong>: Acknowledge by generating the code for the <code>Reply</code> class.</p>
</blockquote>

<p>And here's what ChatGPT came up with:</p>

<blockquote>
  <p><strong>ChatGPT</strong>: Sure thing! Here's the code for the <code>Reply</code> class based on the
  <code>ReplyTest</code> test class:</p>
</blockquote>

<pre><code>&lt;?php

declare(strict_types=1);

namespace Ssc\Btlr\Cht\Message;

use Ssc\Btlr\Cht\Message\Logs\Type;
use Ssc\Btlr\Cht\Message\Logs\WriteLog;
use Ssc\Btlr\Cht\Message\Memory\Consolidate;
use Ssc\Btlr\Cht\Message\Reply\Augment;
use Ssc\Btlr\Cht\Message\Reply\UsingLlm;

class Reply
{
    public function __construct(
        private Augment $augment,
        private Consolidate $consolidate,
        private UsingLlm $usingLlm,
        private WriteLog $writeLog,
    ) {
    }

    public function to(string $userPrompt, array $withConfig): string
    {
        $userPromptData = [
            'entry' =&gt; $userPrompt,
        ];

        // Augment the user prompt
        $augmentedPrompt = $this-&gt;augment-&gt;the($userPrompt, $withConfig);

        // Use LLM to generate a model completion
        $modelCompletion = $this-&gt;usingLlm-&gt;complete($augmentedPrompt);

        // Log the user prompt and model completion
        $this-&gt;writeLog-&gt;for($userPromptData, Type::USER_PROMPT, $withConfig);
        $modelCompletionData = [
            'entry' =&gt; $modelCompletion,
            'llm_engine' =&gt; $withConfig['llm_engine'],
        ];
        $this-&gt;writeLog-&gt;for($modelCompletionData, Type::MODEL_COMPLETION, $withConfig);

        // Consolidate the memories
        $this-&gt;consolidate-&gt;memories($withConfig);

        return $modelCompletion;
    }
}
</code></pre>

<blockquote>
  <p><strong>ChatGPT</strong>: This <code>Reply</code> class has a <code>to</code> method that takes a user prompt
  and a configuration array as input, and returns the model completion
  generated by LLM.
  The <code>Reply</code> class constructor takes in four dependencies: <code>Augment</code>,
  <code>Consolidate</code>, <code>UsingLlm</code>, and <code>WriteLog</code>, and stores them as private
  properties.
  The <code>to</code> method then uses these dependencies to augment the user prompt,
  generate the model completion, log both the user prompt and the model
  completion, and consolidate the memories.</p>
</blockquote>

<p>Which is pretty much spot on.</p>

<p>I'd personnally have written something slightly different (no comments, have
 <code>writeLog</code> for the user prompt at the begining of the method, and possibly
not have any intermediate variables).</p>

<p>But I can easily apply those changes!</p>

<h2 id="takeways">Takeways</h2>

<p>Thanks to Prompt Engineering (with techniques such as Role / Persona priming
prompt, X-Shot, Chain of Thought and Generated Knowledge), it is possible
to ask ChatGPT to generate code.</p>

<p>I'm personally using the following prompts to generate the corresponding code
for a given Test Class.</p>

<p>Priming Prompt:</p>

<blockquote>
  <p>Act as an expert PHP developer, who's been writing high quality API code for 20 years.
  Acknowledge with "ok".</p>
</blockquote>

<p>Test Class example prompt:</p>

<blockquote>
  <p>Here's an example of test class from the project you're working on:</p>
  
  <p><code>%example_test_class_code%</code></p>
  
  <p>Acknowledge by describing how the use of fixtures, dummies, stubs, mocks
  and assertions allow to make sure the tested code is behaving as expected.
  And note the use of the special BtlrServiceTestCase parent class for
  <code>%example_test_class_name%</code>.</p>
</blockquote>

<p>Corresponding class example prompt:</p>

<blockquote>
  <p>When tasked with generating the corresponding <code>%example_class_name%</code> class,
  from the above <code>%%example_test_class_name</code> test class, here's the code you wrote:</p>
  
  <p><code>%example_class_code%</code></p>
  
  <p>Acknowledge by describing how the test class got translated into its
  corresponding class.</p>
</blockquote>

<p>Code generation request from Test Class prompt:</p>

<blockquote>
  <p>Brilliant. Now, in the same coding style as <code>%example_test_class_name%</code> and
  <code>%example_class_name%</code>, you are tasked to write a the corresponding code for
  the following <code>%test_class_name%</code> test class:</p>
  
  <p><code>%test_class_code%</code></p>
  
  <p>Acknowledge by generating the code for the <code>%class_name%</code> class.</p>
</blockquote>

<p>Now, what if you're not practicing Test Driven Development?</p>

<p>I suppose you can tweek it to get ChatGPT to generate tests for you:</p>

<ul>
<li>Use the same priming prompt</li>
<li>Then use the class example prompt</li>
<li>Next use the "corresponding" test example prompt</li>
<li>Finally provide a class and ask ChatGPT to generate its corresponding test</li>
</ul>

<p>All in all, the exploration of ChatGPT's text generation potential turned out
to be quite worthwhile, as I ended up finding a practical use case for it in my
day to day developer activity.</p>

<p>Yet I suspect there's plenty more scenarions where ChatGPT can help, so I guess
the quest continues.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Decouple from Libraries]]></title>
            <link href="/2015/10/12/decouple-from-libraries.html"/>
            <updated>2015-10-12T00:00:00+01:00</updated>
            <id>/2015/10/12/decouple-from-libraries.html</id>
            <content type="html"><![CDATA[<p>Libraries are similar to frameworks: they solve infrastructure problems (e.g.
requesting remote endpoints or querying databases). They also don't directly
add any value to our projects: the business need will not be fulfilled by
connecting to a database.</p>

<p>They also share the same Backward Compatibility (BC) break issue, since they will
change to solve their own concerns, regardless of our projects.</p>

<p>Here's a true story with <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>: we
started to use version 2 in our project and spread direct calls to it in different places.
After a while we've decided to use <a href="http://flysystem.thephpleague.com/">Flysystem</a>
and its <a href="http://aws.amazon.com/sdkforphp">SDK for Amazon S3</a> but we had a problem:
it required Guzzle 3.
This means tracking down every usage of Guzzle in the project and adapting the
calls to the new version. It's a dawnting task, especially when the project doesn't
have strong enough tests.</p>

<p>Later on, when Amazon S3 SDK stabilized, it started to require Guzzle 5...</p>

<p><a href="http://knowyourmeme.com/memes/rage-guy-fffffuuuuuuuu"><img src="http://i0.kym-cdn.com/photos/images/newsfeed/000/000/578/1234931504682.jpg" alt="Screaming with anger" /></a></p>

<p>Does that mean that we shouldn't use any libraries? Should we just don't care and
continue to use them in the same way?</p>

<p>This article will explain how to avoid both extremes, by decoupling from the library.
It can be done by using the Inversion of Control principle: instead of relying
on the library we rely on interfaces and provide an implementation that uses the library.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>In <a href="/2015/09/30/decouple-from-frameworks.html">the previous article</a>,
we started to create an endpoint allowing us to subit new quotes for a
<a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a> application.</p>

<p>We're now going to create a SDK for it:</p>

<pre><code>mkdir fortune-sdk
cd fortune-sdk
</code></pre>

<p>To do so, we'll create the <code>composer.json</code> file:</p>

<pre><code>{
    "name": "acme/fortune-sdk",
    "description": "A PHP SDK for Fortune",
    "type": "library",
    "license": "MIT",
    "autoload": {
        "psr-4": {
            "Acme\\FortuneSdk\\": "src/Acme/FortuneSdk"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Acme\\FortuneSdk\\Fixtures\\": "fixtures",
            "Acme\\FortuneSdk\\Tests\\": "tests"
        }
    },
    "require": {
        "php": "&gt;=5.4",
    },
    "require-dev": {
        "phpspec/phpspec": "^2.3",
        "phpunit/phpunit": "^4.5",
        "symfony/console": "^2.3",
        "symfony/yaml": "^2.2"
    }
}
</code></pre>

<p>Then create a test script:</p>

<pre><code>#!/usr/bin/env sh

# bin/test.sh

composer --quiet --no-interaction update --optimize-autoloader &gt; /dev/null

vendor/bin/phpspec --no-interaction run -f dot &amp;&amp; vendor/bin/phpunit
</code></pre>

<p>And finally configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/4.1/en/appendixes.configuration.html --&gt;
&lt;phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
         backupGlobals="false"
         colors="true"
         bootstrap="vendor/autoload.php"
&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="Fortune SDK Test Suite"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="request-handler">Request Handler</h2>

<p>Since Guzzle might completly change next year, we're going to abstract it behind
our own HTTP client:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Remote/RequestHandler.php

namespace Acme\FortuneSdk\Remote;

use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

interface RequestHandler
{
    /**
     * @param RequestInterface $request
     *
     * @return ResponseInterface
     *
     * @throws ClientException If client throws an unexpected exception (e.g. connection error, etc)
     */
    public function handle(RequestInterface $request);
}
</code></pre>

<p>We've decided to use the new PSR-7 standard:</p>

<pre><code>composer require psr/http-message:^1.0
</code></pre>

<p>We'll hide any errors behind our own exception:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Remote/ClientException.php

namespace Acme\FortuneSdk\Remote;

use RuntimeException;

class ClientException extends RuntimeException
{
}
</code></pre>

<p>Its first implementation will be with Guzzle 6:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Remote/RequestHandler/GuzzleSixRequestHandler.php

namespace Acme\FortuneSdk\Remote\RequestHandler;

use Acme\FortuneSdk\Remote\ClientException;
use Acme\FortuneSdk\Remote\RequestHandler;
use Exception;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\BadResponseException;
use Psr\Http\Message\RequestInterface;

class GuzzleSixRequestHandler implements RequestHandler
{
    private $client;

    public function __construct(Client $client)
    {
        $this-&gt;client = $client;
    }

    public function handle(RequestInterface $request)
    {
        try {
            return $this-&gt;client-&gt;send($request);
        } catch (BadResponseException $e) {
            return $e-&gt;getResponse();
        } catch (Exception $e) {
            throw new ClientException('Client threw an unexpected exception', 0, $e);
        }
    }
}
</code></pre>

<p>And that's it. When Guzzle 7 will be released, we'll just have to create a new
implementation and throw away the old one instead of having to replace it everywhere
in our project. We can even change our mind and use a completly different HTTP client
(Buzz, etc).</p>

<p>Since we've started to softly depend on Guzzle, we need to install it with Composer:</p>

<pre><code>composer require guzzlehttp/guzzle:^6.0
</code></pre>

<h2 id="functional-test">Functional test</h2>

<p>We can now create a functional test describing our service:</p>

<pre><code class="php">&lt;?php

// tests/Quote/SubmitNewQuoteTest.php

namespace Acme\FortuneSdk\Tests\Quote;

use Acme\FortuneSdk\Quote\SubmitNewQuote\RemoteSubmitNewQuote;
use Acme\FortuneSdk\Fixtures\FixturesRequestHandler;
use PHPUnit_Framework_TestCase;

class SubmitNewQuoteTest extends PHPUnit_Framework_TestCase
{
    const URL = 'http://example.com';
    const QUOTE = 'Nobody expects the Spanish Inquisition!';

    private $submitNewQuote;

    protected function setUp()
    {
        $requestHandler = new FixturesRequestHandler();
        $this-&gt;submitNewQuote = new RemoteSubmitNewQuote($requestHandler, self::URL);
    }

    /**
     * @test
     */
    public function it_can_submit_a_new_quote()
    {
        $quote = $this-&gt;submitNewQuote-&gt;submit(self::QUOTE);

        self::assertSame(self::QUOTE, $quote['quote']);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>sh ./bin/test.sh
</code></pre>

<p>It fails because <code>FixturesRequestHandler</code> doesn't exist. It's an implementation
of <code>RequestHandler</code> designed for our tests: even if the endpoint actually existed,
relying on network calls in our tests would only make them brittle
(because it's slow and unreliable).</p>

<p>Let's create it:</p>

<pre><code class="php">&lt;?php

// fixtures/FixturesRequestHandler.php

namespace Acme\FortuneSdk\Fixtures;

use Acme\FortuneSdk\Remote\RequestHandler;
use Psr\Http\Message\RequestInterface;
use Zend\Diactoros\Response;
use Zend\Diactoros\Stream;

class FixturesRequestHandler implements RequestHandler
{
    private $routes;

    public function __construct()
    {
        $this-&gt;routes = array(
            array(
                'controller' =&gt; new Controller\Quote\SubmitNewQuoteController(),
                'pattern' =&gt; '#/quotes#',
                'methods' =&gt; array('POST'),
            ),
        );
    }

    public function handle(RequestInterface $request)
    {
        $path = $request-&gt;getUri()-&gt;getPath();
        $method = $request-&gt;getMethod();
        foreach ($this-&gt;routes as $route) {
            if (1 === preg_match($route['pattern'], $path)) {
                if (false === in_array($method, $route['methods'], true)) {
                    $body = new Stream('php://temp', 'w');
                    $body-&gt;write(json_encode(array(
                        'message' =&gt; "Method \"$method\" for route \"$path\" not supported (supported methods are: ".implode(', ', $route['methods']).")",
                    )));

                    return new Response($body, 405, array('Content-Type' =&gt; 'application/json'));
                }
                try {
                    return $route['controller']-&gt;handle($request);
                } catch (FixturesException $e) {
                    $body = new Stream('php://temp', 'w');
                    $body-&gt;write($e-&gt;getMessage());

                    return new Response($body, $e-&gt;getCode(), array('Content-Type' =&gt; 'application/json'));
                }
            }
        }
        $body = new Stream('php://temp', 'w');
        $body-&gt;write(json_encode(array(
            'message' =&gt; "Route \"$path\" not found",
        )));

        return new Response($body, 404, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>We've decided to rely on Zend Diactoros to build the request, since it is the de
facto implementation of PSR-7:</p>

<pre><code>composer require zendframework/zend-diactoros:^1.0
</code></pre>

<p>We've open the possibility of managing many endpoints with this class. We now need
to define a controller for the quote submission one:</p>

<pre><code class="php">&lt;?php

// fixtures/Controller/Quote/SubmitNewQuoteController.php

namespace Acme\FortuneSdk\Fixtures\Controller\Quote;

use Acme\FortuneSdk\Remote\RequestHandler;
use Acme\FortuneSdk\Fixtures\FixturesException;
use Psr\Http\Message\RequestInterface;
use Zend\Diactoros\Response;
use Zend\Diactoros\Stream;

class SubmitNewQuoteController implements RequestHandler
{
    public function handle(RequestInterface $request)
    {
        $submitNewQuote = json_decode($request-&gt;getBody()-&gt;__toString(), true);
        if (false === isset($submitNewQuote['quote'])) {
            throw FixturesException::make('Missing required "quote" parameter', 422);
        }
        $quote = (string) $submitNewQuote['quote'];
        if ('' === $quote) {
            throw FixturesException::make('Invalid "quote" parameter: must not be empty', 422);
        }
        $body = new Stream('php://temp', 'w');
        $body-&gt;write(json_encode(array(
            'id' =&gt; '',
            'quote' =&gt; $quote
        )));

        return new Response($body, 201, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>Finally we need to write the exception class:</p>

<pre><code class="php">&lt;?php

// fixtures/FixturesException.php

namespace fixtures\Acme\FortuneSdk\Fixtures;

use DomainException;

class FixturesException extends DomainException
{
    /**
     * @param string $message
     * @param int    $statusCode
     *
     * @return FixturesException
     */
    public static function make($message, $statusCode)
    {
        return new self(json_encode(array('message' =&gt; $message)), $statusCode);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>sh ./bin/test.sh
</code></pre>

<p>They now fail because <code>SubmitNewQuote</code> doesn't exist.</p>

<h2 id="submitnewquote">SubmitNewQuote</h2>

<p>First of all, we'll define our service as an interface:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Quote/SubmitNewQuote.php

namespace Acme\FortuneSdk\Quote;

interface SubmitNewQuote
{
    public function submit($quote);
}
</code></pre>

<p>This will allow developers using our SDK to create their own implementation for testing
or extension purpose.
It will also allow us to create Composite implementation: we can have a remote
implementation that does the actual work, wrapped in a lazy cache implementation
itself wrapped in a log implementation.</p>

<p>Here we'll just take care of the remote one, let's bootstrap its test:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\FortuneSdk\Quote\SubmitNewQuote\RemoteSubmitNewQuote'
</code></pre>

<p>And now we can write the tests:</p>

<pre><code class="php">&lt;?php

// spec/Acme/FortuneSdk/Quote/SubmitNewQuote.php

namespace spec\Acme\FortuneSdk\Quote\SubmitNewQuote;

use Acme\FortuneSdk\Remote\RequestHandler;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamInterface;

class RemoteSubmitNewQuoteSpec extends ObjectBehavior
{
    const URL = 'http://example.com';
    const QUOTE = 'Nobody expects the Spanish Inquisition!';

    function let(RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($requestHandler, self::URL);
    }

    function it_is_a_submit_new_quote()
    {
        $this-&gt;shouldImplement('Acme\FortuneSdk\Quote\SubmitNewQuote');
    }

    function it_calls_the_remote_endpoint(
        RequestHandler $requestHandler,
        ResponseInterface $response,
        StreamInterface $stream
    ) {
        $quote = array(
            'quote' =&gt; self::QUOTE,
        );

        $request = Argument::type('Psr\Http\Message\RequestInterface');
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $response-&gt;getBody()-&gt;willReturn($stream);
        $stream-&gt;__toString()-&gt;willReturn(json_encode($quote));

        $this-&gt;submit(self::QUOTE)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>In this test, we've used a wildcard to represent the request since the service is
going to create it. This is at the cost of not knowing how it is built.</p>

<p>If we absolutely want to have control over this, we need to delegate the request
construction to a factory, it then becomes possible to mock the request and check
how it is built:</p>

<pre><code class="php">&lt;?php

// spec/Acme/FortuneSdk/Quote/SubmitNewQuote.php

namespace spec\Acme\FortuneSdk\Quote\SubmitNewQuote;

use Acme\FortuneSdk\Remote\RequestFactory;
use Acme\FortuneSdk\Remote\RequestHandler;
use PhpSpec\ObjectBehavior;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamInterface;

class RemoteSubmitNewQuoteSpec extends ObjectBehavior
{
    const URL = 'http://example.com';
    const QUOTE = 'Nobody expects the Spanish Inquisition!';

    function let(RequestFactory $requestFactory, RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($requestFactory, $requestHandler, self::URL);
    }

    function it_is_a_submit_new_quote()
    {
        $this-&gt;shouldImplement('Acme\FortuneSdk\Quote\SubmitNewQuote');
    }

    function it_calls_the_remote_endpoint(
        RequestFactory $requestFactory,
        RequestHandler $requestHandler,
        RequestInterface $request,
        ResponseInterface $response,
        StreamInterface $stream
    ) {
        $quote = array(
            'quote' =&gt; self::QUOTE,
        );

        $requestFactory-&gt;make(self::URL.'/v1/quotes', 'POST', json_encode($quote), array(
            'Content-Type' =&gt; 'application/json'
        ))-&gt;willReturn($request);
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $response-&gt;getBody()-&gt;willReturn($stream);
        $stream-&gt;__toString()-&gt;willReturn(json_encode($quote));

        $this-&gt;submit(self::QUOTE)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>The choice between the first solution and the second one really depends on our preferences
and on what we're trying to achieve. For the sake of this article, we'll stick
to the first one (to avoid having to create the factory class and change the functional test,
this article is already long enough!).</p>

<p>Let's run our tests to bootstrap the code:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>Now we can write the actual code:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Quote/SubmitNewQuote/RemoteSubmitNewQuote.php

namespace Acme\FortuneSdk\Quote\SubmitNewQuote;

use Acme\FortuneSdk\Quote\SubmitNewQuote;
use Acme\FortuneSdk\Remote\RequestHandler;
use Zend\Diactoros\Request;
use Zend\Diactoros\Stream;

class RemoteSubmitNewQuote implements SubmitNewQuote
{
    private $requestHandler;
    private $url;

    public function __construct(RequestHandler $requestHandler, $url)
    {
        $this-&gt;requestHandler = $requestHandler;
        $this-&gt;url = $url;
    }

    public function submit($quote)
    {
        $body = new Stream('php://memory', 'w');
        $body-&gt;write(json_encode(array(
            'quote' =&gt; $quote,
        )));
        $request = new Request($this-&gt;url.'/v1/quotes', 'POST', $body, array(
            'Content-Type' =&gt; 'application/json'
        ));
        $quote = json_decode($this-&gt;requestHandler-&gt;handle($request)-&gt;getBody()-&gt;__toString(), true);

        return $quote;
    }
}
</code></pre>

<p>This should be sufficient to make our tests pass:</p>

<pre><code>sh ./bin/test.sh
</code></pre>

<p>All green!</p>

<p>We now have a SDK that provides a <code>SubmitNewQuote</code> service allowing us to submit new quotes.
Since we've mocked the network connection, we can't be sure that our SDK actually works.
Manual testing can be sufficient in this case: we can build a Command Line Interface (CLI)
client and check by ourselves if everything is fine, once in a while.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Inversion of Control is a principle that can come handy when dealing with third party library,
especially the ones that change often like Guzzle. It can be applied easily:
instead of making our high level classes rely on concrete low level ones, we just
need to introduce an interface.</p>

<p>Once again, all projects are different and this solution might not apply in every
case. If we're building an application that we expect to maintain for a couple of years
it can be worth it to protect ourselves from external changes.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Decouple from Frameworks]]></title>
            <link href="/2015/09/30/decouple-from-frameworks.html"/>
            <updated>2015-09-30T00:00:00+01:00</updated>
            <id>/2015/09/30/decouple-from-frameworks.html</id>
            <content type="html"><![CDATA[<p>Frameworks solve infrastructure problems, for example how to create a HTTP or CLI application.
While necessary, those concerns don't add any value to your project: the business
need will not be fulfilled by creating an empty application.</p>

<p>As always, different responsibilities mean also different reasons to change: frameworks
have a history of Backward Compatibility (BC) breaks and they do so regardless of your
project.</p>

<p>Take for example <a href="http://symfony.com/">Symfony</a>: it only started to follow <a href="http://semver.org/">Semantic Versioning</a>
from version 2.3. The upgrade to version 3 has been made easier by allowing developers
to know what was deprecated, but the removal of those features still means a lot of
work in your application.
The arrival of the <a href="http://www.php-fig.org/psr/psr-7/">new standard PSR-7</a> brings
a lot of questions on the future of Symfony: for now it <a href="http://symfony.com/blog/psr-7-support-in-symfony-is-here">allows to choose</a>
between <code>symfony/http-foundation</code> and <code>psr/http-message</code>, but if Symfony doesn't
want to fall back behind (<a href="http://framework.zend.com/blog/announcing-the-zend-framework-3-roadmap.html">Zend 3 is fully based on PSR-7</a>)
it might have to introduce another big BC break (event listeners with the Request
and Response <a href="http://evertpot.com/psr-7-issues/">are not possible the way they are now with PSR-7</a>).</p>

<p>Migrating Symfony applications (from symfony1, from symfony 2.0, etc) is so hard
that it is a business on its own.</p>

<p>Does that mean that we shouldn't use any frameworks? Should we just don't care and
embrace fully frameworks?</p>

<p>This article will explain how to avoid both extremes, by decoupling from the framework.
It can be done by restricting the framework to its infrastructure responsibilities
(HTTP, CLI), by only using its entry points (Controller, Command) and by using
the Command Bus pattern.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>We're going to build part of a <a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a>
application for our example, more precisely we're going to build an endpoint allowing us to
submit quotes.</p>

<p>To do so, we'll bootstrap a symfony application using the <a href="https://github.com/gnugat/symfony-empty-edition">Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition fortune
cd fortune
</code></pre>

<p>We'll need to install our test frameworks:</p>

<pre><code>composer require --dev phpunit/phpunit
composer require --dev phpspec/phpspec
</code></pre>

<p>Then add them to our test script:</p>

<pre><code>#!/usr/bin/env sh

# bin/test.sh

echo ''
echo '// Building test environment'

rm -rf app/cache/test app/logs/*test.log
composer --quiet --no-interaction install --optimize-autoloader  &gt; /dev/null
php app/console --env=test --quiet cache:clear

echo ''
echo ' [OK] Test environment built'
echo ''

vendor/bin/phpspec --format=dot &amp;&amp; vendor/bin/phpunit
</code></pre>

<p>Finally we'll configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="app/bootstrap.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="System Tests"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="request-listener">Request listener</h2>

<p>Our endpoint will receive JSON encoded content. PHP does not populate <code>$_POST</code> with
this data, causing an empty <code>$request-&gt;request</code>. We can create an event listener
to fix this issue:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/JsonRequestListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class JsonRequestListener
{
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('PATCH', 'POST', 'PUT'), true);
        $isJson = (1 === preg_match('#application/json#', $request-&gt;headers-&gt;get('Content-Type')));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new Response('{"error":"Invalid or malformed JSON"}', 400, array('Content-Type' =&gt; 'application/json')));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>This logic is infrastructure related, so it makes sense to keep it in <code>AppBundle</code>.</p>

<p>To enable it, configure it in the Dependency Injection Container:</p>

<pre><code># app/config/services/event_listener.yml

services:
    app.json_request_listener:
        class: AppBundle\EventListener\JsonRequestListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<p>We also need to make sure files in <code>app/config/services</code> are imported:</p>

<pre><code class="php">&lt;?php
// app/config/importer.php

use Symfony\Component\Finder\Finder;

$finder = new Finder();
$files = $finder-&gt;files()-&gt;name('*.yml')-&gt;in(__DIR__.'/services');
foreach ($files as $file) {
    $loader-&gt;import($file-&gt;getRealpath());
}
</code></pre>

<h2 id="controller">Controller</h2>

<p>Our first step will be to describe how the endpoint should work, with a test:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Controller/QuoteControllerTest.php

namespace tests\AppBundle\Controller;

use AppKernel;
use PHPUnit_Framework_TestCase;
use Symfony\Component\HttpFoundation\Request;

class QuoteControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new AppKernel('test', false);
        $this-&gt;app-&gt;boot();
    }

    /**
     * @test
     */
    public function it_submits_a_new_quote()
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $request = Request::create('/v1/quotes', 'POST', array(), array(), array(), $headers, json_encode(array(
            'quote' =&gt; 'Nobody expects the spanish inquisition',
        )));

        $response = $this-&gt;app-&gt;handle($request);

        self::assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Testing only the status code is called "Smoke Testing" and is a very
  efficient way to check if the application is broken.
  Testing the content would be tedious and would make our test fragile as it might change often.</p>
</blockquote>

<p>Let's run it:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>The tests fail because the controller doesn't exist. Let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/QuoteController.php

namespace AppBundle\Controller;

use Acme\Fortune\Quote\SubmitNewQuote;
use Acme\Fortune\Quote\SubmitNewQuoteHandler;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class QuoteController
{
    private $submitNewQuoteHandler;

    public function __construct(SubmitNewQuoteHandler $submitNewQuoteHandler)
    {
        $this-&gt;submitNewQuoteHandler = $submitNewQuoteHandler;
    }

    public function submitNewAction(Request $request)
    {
        $sumbitNewQuote = new SubmitNewQuote(
            $request-&gt;request-&gt;get('quote')
        );
        $newQuote = $this-&gt;submitNewQuoteHandler-&gt;handle($sumbitNewQuote);

        return new Response(json_encode($newQuote), 201, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>Now we need to configure the controller as a service:</p>

<pre><code># app/config/services/controller.yml

services:
    app.quote_controller:
        class: AppBundle\Controller\QuoteController
        arguments:
            - "@app.submit_new_quote_handler"
</code></pre>

<p>Then we need to configure the route:</p>

<pre><code># app/config/routings/quote.yml

submit_new_quote:
    path: /v1/quotes
    defaults:
        _controller: app.quote_controller:submitNew
    methods:
        - POST
</code></pre>

<p>This file needs to be imported:</p>

<pre><code># app/config/routing.yml

quote:
    resource: routings/quote.yml
</code></pre>

<p>Finally we can run the test again:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>It now fails for a different reason: <code>SubmitNewQuote</code> and its handler class don't exist.</p>

<h2 id="command-from-commandbus">Command (from CommandBus)</h2>

<p><code>SubmitNewQuote</code> is a Data Transfer Object (DTO): its responsibility is to wrap
input parameters in a well named class (in this case a class that describes the action intended).
It's also the best place to do some basic validation on the input parameters.</p>

<blockquote>
  <p><strong>Note</strong>: In the Command Bus pattern, <code>SubmitNewQuote</code> would be a Command (different from the CLI Command).</p>
</blockquote>

<p>We'll write a test for this, but first we'll bootstrap the test class:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\Fortune\Quote\SubmitNewQuote'
</code></pre>

<p>Now we can decribe the different validation rules:</p>

<pre><code class="php">&lt;?php
// spec/Acme/Fortune/Quote/SubmitNewQuoteSpec.php

namespace spec\Acme\Fortune\Quote;

use PhpSpec\ObjectBehavior;

class SubmitNewQuoteSpec extends ObjectBehavior
{
    const QUOTE = 'Nobody expects the spanish inquisition';

    function it_fails_if_required_quote_parameter_is_missing()
    {
        $this-&gt;beConstructedWith(null);

        $this-&gt;shouldThrow('Acme\Fortune\Exception\ValidationFailedException')-&gt;duringInstantiation();
    }

    function it_fails_if_quote_parameter_is_empty()
    {
        $this-&gt;beConstructedWith('');

        $this-&gt;shouldThrow('Acme\Fortune\Exception\ValidationFailedException')-&gt;duringInstantiation();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Since this class has nothing to do with Symfony, we don't put it in <code>AppBundle</code>.
  By keeping it in its own namespace, we protect it from framework directory tree changes,
  for example before <code>AppBundle</code> the norm was <code>Acme\FortuneBundle</code>. We also allow ourselves
  to move it to another framework (e.g. Laravel, Zend, etc).</p>
</blockquote>

<p>Let's run the tests:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>It fails because the exception doesn't exist yet:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Exception/ValidationFailedException.php

namespace Acme\Fortune\Exception;

class ValidationFailedException extends FortuneException
{
}
</code></pre>

<p>We're making it a sub type of <code>FortuneException</code>: that way we can catch all exceptions
related to our code (all other exceptions can be considered as Internal Server Errors).</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Exception/FortuneException.php

namespace Acme\Fortune\Exception;

use DomainException;

class FortuneException extends DomainException
{
}
</code></pre>

<p>Now we need to create the Command:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Quote/SubmitNewQuote.php

namespace Acme\Fortune\Quote;

use Acme\Fortune\Exception\ValidationFailedException;

class SubmitNewQuote
{
    public function __construct($quote)
    {
        if (null === $quote) {
            throw new ValidationFailedException('Missing required "quote" parameter');
        }
        if ('' === $quote) {
            throw new ValidationFailedException('Invalid "quote" parameter: must not be empty');
        }
        $this-&gt;quote = (string) $quote;
    }
}
</code></pre>

<p>Running the tests again:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>Everything seems fine.</p>

<h2 id="exception-listener">Exception listener</h2>

<p>Instead of catching exceptions in our controllers we can create an event listener:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/FortuneExceptionListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class FortuneExceptionListener
{
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof FortuneException) {
            return;
        }
        $content = json_encode(array('error' =&gt; $exception-&gt;getMessage()));
        $statusCode = Response::HTTP_UNPROCESSABLE_ENTITY;
        $event-&gt;setResponse(new Response($content, $statusCode, array('Content-Type' =&gt; 'application/json')));
    }
}
</code></pre>

<p>This lowers the risk of forgetting to catch an exception and it also keeps our controller slim.</p>

<p>Let's enable it in the DIC:</p>

<pre><code># app/config/services/event_listener.yml

services:
    app.fortune_exception_listener:
        class: AppBundle\EventListener\FortuneExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException }

    app.json_request_listener:
        class: AppBundle\EventListener\JsonRequestListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<h2 id="command-handler">Command Handler</h2>

<p><code>SubmitNewQuoteHandler</code>'s responsibility is to validate <code>SubmitNewQuote</code> data against
business rules (e.g. no quote duplicates, author must exist, etc) and to call the
appropriate services to process it.
Reading its code feels like reading the details of a use case:</p>

<blockquote>
  <p>To handle the submission of a new quote,
  we need to generate a unique identifier
  and then we need to save the new quote.</p>
</blockquote>

<p>Let's bootstrap its test:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\Fortune\Quote\SubmitNewQuoteHandler'
</code></pre>

<p>Then edit the test:</p>

<pre><code class="php">&lt;?php
// spec/Acme/Fortune/Quote/SubmitNewQuoteHandlerSpec.php

namespace spec\Acme\Fortune\Quote;

use Acme\Fortune\Quote\SubmitNewQuote;
use Acme\Fortune\Quote\Service\SaveNewQuote;
use Acme\Fortune\Quote\Service\UniqueIdentifierGenerator;
use PhpSpec\ObjectBehavior;

class SubmitNewQuoteHandlerSpec extends ObjectBehavior
{
    const ID = '921410e8-eb98-4f99-ba98-055d46980511';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    function let(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $this-&gt;beConstructedWith($saveNewQuote, $uniqueIdentifierGenerator);
    }

    function it_saves_new_quote(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $submitNewQuote = new SubmitNewQuote(self::QUOTE);
        $quote = array(
            'id' =&gt; self::ID,
            'quote' =&gt; self::QUOTE,
        );

        $uniqueIdentifierGenerator-&gt;generate()-&gt;willReturn(self::ID);
        $saveNewQuote-&gt;save($quote)-&gt;shouldBeCalled();

        $this-&gt;handle($submitNewQuote)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>After generating interfaces for <code>SaveNewQuote</code> and <code>UniqueIdentifierGenerator</code>
and after bootstrapping the code for <code>SubmitNewQuoteHandler</code>, the test will fail
because we need to complete it:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Quote/SubmitNewQuoteHandler.php

namespace Acme\Fortune\Quote;

use Acme\Fortune\Quote\Service\SaveNewQuote;
use Acme\Fortune\Quote\Service\UniqueIdentifierGenerator;

class SubmitNewQuoteHandler
{
    private $saveNewQuote;
    private $uniqueIdentifierGenerator;

    public function __construct(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $this-&gt;saveNewQuote = $saveNewQuote;
        $this-&gt;uniqueIdentifierGenerator = $uniqueIdentifierGenerator;
    }

    public function handle(SubmitNewQuote $sumbitNewQuote)
    {
        $quote = array(
            'id' =&gt; $this-&gt;uniqueIdentifierGenerator-&gt;generate(),
            'quote' =&gt; $sumbitNewQuote-&gt;quote,
        );
        $this-&gt;saveNewQuote-&gt;save($quote);

        return $quote;
    }
}
</code></pre>

<p>Now we can configure the service:</p>

<pre><code class="php"># app/config/services/quote.yml

services:
    app.submit_new_quote_handler:
        class: Acme\Fortune\Quote\SubmitNewQuoteHandler
        arguments:
            - "@app.save_new_quote"
            - "@app.unique_identifier_generator"
</code></pre>

<p>Finally can run the tests one last time:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>Allmost green!</p>

<p>They fail because <code>app.save_new_quote</code> and <code>app.unique_identifier_generator</code> don't
exist yet. They will be the topic of another article ;) .</p>

<h2 id="conclusion">Conclusion</h2>

<p>By restricting frameworks to their entry points (Controllers, Commands, etc) and
using the Command Bus to define our project entry points (domain boundaries) we
are able to decouple from the framework, allowing us to restrict the impact of BC breaks.</p>

<p>Of course, all projects are different and this solution might not be possible everywhere.
RAD development is a robust solution for web agencies, especially if they are chosen
to bootstrap a project as fast as possible and then need to pass the project over
to their customer after a short period.</p>

<p>On the other hand some companies are creating projects they will have to maintain
for decades and those are also in need of delivering a first version early.
Decoupling from the framework isn't something that slows down development, and there
are ways to still release early (e.g. define Minimum Valuable Product and deliver
small features iterations by iterations).</p>

<blockquote>
  <p><strong>Note</strong>: There are a couple of bundles that provides Symfony with a Command Bus, among them:</p>
  
  <ul>
  <li><a href="/2015/09/09/tactician.html">Tactician</a></li>
  <li><a href="/2015/08/04/simple-bus.html">SimpleBus</a></li>
  </ul>
</blockquote>

<p>If you're interrested on the subject, here's some resources:</p>

<ul>
<li>The framework as an implementation detail
(<a href="http://www.slideshare.net/marcello.duarte/the-framework-as-an-implementation-detail">slides</a>
and <a href="https://www.youtube.com/watch?v=0L_9NutiJlc">video</a>),
by <a href="http://marcelloduarte.net/">Marcello Duarte</a>
and <a href="http://everzet.com/">Konstantin Kudryashov</a></li>
<li><a href="https://blog.8thlight.com/uncle-bob/2014/05/11/FrameworkBound.html">Framework bound</a>,
by <a href="https://sites.google.com/site/unclebobconsultingllc/">Robert Cecil Martin</a></li>
<li><a href="http://kristopherwilson.com/2013/11/27/decoupling-the-framework/">Decoupling the Framework</a>,
by <a href="https://twitter.com/mrkrstphr">Kristopher Wilson</a></li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHPUnit with phpspec]]></title>
            <link href="/2015/09/23/phpunit-with-phpspec.html"/>
            <updated>2015-09-23T00:00:00+01:00</updated>
            <id>/2015/09/23/phpunit-with-phpspec.html</id>
            <content type="html"><![CDATA[<p><a href="https://phpunit.de/">PHPUnit</a> is a port of <a href="http://junit.org/">jUnit</a>, its name
might be deceptive: it allows you to write any type of tests (unit, but also functional,
system, integration, end to end, acceptance, etc).</p>

<p><a href="http://www.phpspec.net">phpspec</a> was at first a port of <a href="http://rspec.info/">rspec</a>,
it can be considered as a unit test framework that enforces practices it considers best.</p>

<blockquote>
  <p><strong>Note</strong>: <a href="/2015/08/03/phpspec.html">read more about phpspec</a>.</p>
</blockquote>

<p>In this article, we'll see how to use both tools together in a same project.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>We're going to build part of a <a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a>
application for our example, more precisely we're going to build a CLI allowing us to save quotes.</p>

<p>To do so, we'll bootstrap a symfony application using the <a href="https://github.com/gnugat/symfony-empty-edition">Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition fortune
cd fortune
</code></pre>

<p>We'll need to install our test frameworks:</p>

<pre><code>composer require --dev phpunit/phpunit
composer require --dev phpspec/phpspec
</code></pre>

<p>Finally we'll configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="app/bootstrap.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="System Tests"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="the-command">The command</h2>

<p>Our first step will be to write a <strong>system test</strong> describing the command:</p>

<pre><code class="php">&lt;?php
// tests/Command/SaveQuoteCommandTest.php

namespace AppBundle\Tests\Command;

use AppKernel;
use PHPUnit_Framework_TestCase;
use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Tester\ApplicationTester;

class SaveQuoteCommandTest extends PHPUnit_Framework_TestCase
{
    const EXIT_SUCCESS = 0;

    private $app;

    protected function setUp()
    {
        $kernel = new AppKernel('test', false);
        $application = new Application($kernel);
        $application-&gt;setAutoExit(false);
        $this-&gt;app = new ApplicationTester($application);
    }

    /**
     * @test
     */
    public function it_saves_a_new_quote()
    {
        $exitCode = $this-&gt;app-&gt;run(array(
            'quote:save',
            'quote' =&gt; 'Nobody expects the spanish inquisition',
        ));

        self::assertSame(self::EXIT_SUCCESS, $exitCode, $this-&gt;app-&gt;getDisplay());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Testing only the exit code is called "Smoke Testing" and is a very
  efficient way to check if the application is broken.
  Testing the output would be tedious and would make our test fragile as it might change often.</p>
</blockquote>

<p>Let's run it:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>The tests fails because the command doesn't exist. Let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Command/SaveQuoteCommand.php

namespace AppBundle\Command;

use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;

class SaveQuoteCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this-&gt;setName('quote:save');
        $this-&gt;addArgument('quote', InputArgument::REQUIRED);
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $output-&gt;writeln('');
        $output-&gt;writeln('// Saving quote');

        $this-&gt;getContainer()-&gt;get('app.save_new_quote')-&gt;save(
            $input-&gt;getArgument('quote')
        );

        $output-&gt;writeln('');
        $output-&gt;writeln(' [OK] Quote saved');
        $output-&gt;writeln('');
    }
}
</code></pre>

<p>Then run the test again:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>It now fails for a different reason: the service used doesn't exist.</p>

<h2 id="the-service">The service</h2>

<p>The second step is to write the unit test for the service. With phpspec we can
first bootstrap it:</p>

<pre><code>vendor/bin/phpspec describe 'AppBundle\Service\SaveNewQuote'
</code></pre>

<p>Then we need to edit it:</p>

<pre><code class="php">&lt;?php
// spec/AppBundle/Service/SaveNewQuoteSpec.php

namespace spec\AppBundle\Service;

use PhpSpec\ObjectBehavior;
use Symfony\Component\Filesystem\Filesystem;

class SaveNewQuoteSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/quotes.txt';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem, self::FILENAME);
    }

    function it_saves_new_quote(Filesystem $filesystem)
    {
        $filesystem-&gt;dumpFile(self::FILENAME, self::QUOTE)-&gt;shouldBeCalled();

        $this-&gt;save(self::QUOTE);
    }
}
</code></pre>

<p>Time to run the suite:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>phpspec will detect that the tested class doesn't exist and will bootstrap it for us,
so we just have to edit it:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/SaveNewQuote.php

namespace AppBundle\Service;

use Symfony\Component\Filesystem\Filesystem;

class SaveNewQuote
{
    private $filesystem;
    private $filename;

    public function __construct(Filesystem $filesystem, $filename)
    {
        $this-&gt;filesystem = $filesystem;
        $this-&gt;filename = $filename;
    }

    public function save($quote)
    {
        $this-&gt;filesystem-&gt;dumpFile($this-&gt;filename, $quote);
    }
}
</code></pre>

<p>Again, we're going to run our unit test:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>It's finally green! Our final step will be to define our service in the Dependency Injection
Container:</p>

<pre><code># app/config/config.yml

imports:
    - { resource: parameters.yml }
    - { resource: importer.php }

framework:
    secret: "%secret%"

services:
    app.save_new_quote:
        class: AppBundle\Service\SaveNewQuote
        arguments:
            - "@filesystem"
            - "%kernel.root_dir%/cache/quotes"
</code></pre>

<p>To make sure everything is fine, let's clear the cache and run the test:</p>

<pre><code>rm -rf app/cache/*
vendor/bin/phpunit
</code></pre>

<p>It's <a href="https://www.youtube.com/watch?v=lFeLDc2CzOs">Super Green</a>!</p>

<h2 id="conclusion">Conclusion</h2>

<p>As we can see, PHPUnit and phpspec can work perfectly well together.</p>

<p>Of course we could write our unit test in a similar manner with PHPUnit:</p>

<pre><code>&lt;?php
// tests/Service/SaveNewQuoteTest.php

namespace AppBundle\Tests\Service;

use AppBundle\Service\SaveNewQuote;
use PHPUnit_Framework_TestCase;

class SaveNewQuoteTest extends PHPUnit_Framework_TestCase
{
    const FILENAME = '/tmp/quotes.txt';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    private $filesystem;
    private $saveNewQuote;

    protected function setUp()
    {
        $this-&gt;filesystem = $this-&gt;prophesize('Symfony\Component\Filesystem\Filesystem');
        $this-&gt;saveNewQuote = new SaveNewQuote($this-&gt;filesystem-&gt;reveal(), self::FILENAME);
    }

    /**
     * @test
     * @group unit
     */
    public function it_saves_new_quote()
    {
        $this-&gt;filesystem-&gt;dumpFile(self::FILENAME, self::QUOTE)-&gt;shouldBeCalled();

        $this-&gt;saveNewQuote-&gt;save(self::QUOTE);
    }
}
</code></pre>

<p>And run it separately:</p>

<pre><code>vendor/bin/phpunit --group=unit
</code></pre>

<p>But then we would lose all the advantages of phpspec:</p>

<ul>
<li>it adds less overhead (this same test runs in ~20ms with phpspec, and ~80ms with PHPUnit)</li>
<li>it tells you when it thinks you're doing something wrong (typically by making it harder/impossible for you to do it)</li>
<li>it bootstraps things for you if you follow the TDD workflow (test first, then code)</li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
    </feed>