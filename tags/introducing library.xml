<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2025-08-06T07:48:09+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[porpaginas]]></title>
            <link href="/2015/11/05/porpaginas.html"/>
            <updated>2015-11-05T00:00:00+00:00</updated>
            <id>/2015/11/05/porpaginas.html</id>
            <content type="html"><![CDATA[<p>Pagination libraries like <a href="https://github.com/whiteoctober/Pagerfanta">Pagerfanta</a>
or <a href="https://github.com/KnpLabs/KnpPaginatorBundle">KnpPaginator</a> usually require
a <code>QueryBuilder</code>:</p>

<pre><code>// Usually in a controller
$queryBuilder = $this-&gt;itemRepository-&gt;queryBuilderForFindAll();
$results = $paginationService-&gt;paginate(
    $queryBuilder,
    $currentPageNumber,
    $itemsPerPage
);
</code></pre>

<p>This is necessary because we need to get the result for the page as well as the
number of total results (with a database it would mean two queries).
Unfortunately this kind of logic tends to leak in our controllers which is why
<a href="http://www.whitewashing.de/">Benjamin Eberlei</a> suggests an elegant alternative:</p>

<pre><code class="php">// Can be done in a service
$result = $this-&gt;itemRepository-&gt;findAll();

// Can be done in a ViewListener
$page = $result-&gt;take($currentPageNumber, $itemsPerPage);
</code></pre>

<p>The <code>QueryBuilder</code> is actually wrapped in a <code>Result</code> which provides the possibility
to get all of them or a single portion.
Its <code>take</code> method returns the <code>PaginatorService</code> wrapped in a <code>Page</code> which contains
all the meta data we usually expect (page number, total elements, etc).</p>

<p>To make it possible he created <a href="http://github.com/beberlei/porpaginas">porpaginas</a>,
a small library that provides <code>Result</code> and <code>Page</code> as interfaces.
The actual pagination logic is delegated to the library of our choice, using adapters.</p>

<p>Enjoy!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHPUnit with phpspec]]></title>
            <link href="/2015/09/23/phpunit-with-phpspec.html"/>
            <updated>2015-09-23T00:00:00+01:00</updated>
            <id>/2015/09/23/phpunit-with-phpspec.html</id>
            <content type="html"><![CDATA[<p><a href="https://phpunit.de/">PHPUnit</a> is a port of <a href="http://junit.org/">jUnit</a>, its name
might be deceptive: it allows you to write any type of tests (unit, but also functional,
system, integration, end to end, acceptance, etc).</p>

<p><a href="http://www.phpspec.net">phpspec</a> was at first a port of <a href="http://rspec.info/">rspec</a>,
it can be considered as a unit test framework that enforces practices it considers best.</p>

<blockquote>
  <p><strong>Note</strong>: <a href="/2015/08/03/phpspec.html">read more about phpspec</a>.</p>
</blockquote>

<p>In this article, we'll see how to use both tools together in a same project.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>We're going to build part of a <a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a>
application for our example, more precisely we're going to build a CLI allowing us to save quotes.</p>

<p>To do so, we'll bootstrap a symfony application using the <a href="https://github.com/gnugat/symfony-empty-edition">Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition fortune
cd fortune
</code></pre>

<p>We'll need to install our test frameworks:</p>

<pre><code>composer require --dev phpunit/phpunit
composer require --dev phpspec/phpspec
</code></pre>

<p>Finally we'll configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="app/bootstrap.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="System Tests"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="the-command">The command</h2>

<p>Our first step will be to write a <strong>system test</strong> describing the command:</p>

<pre><code class="php">&lt;?php
// tests/Command/SaveQuoteCommandTest.php

namespace AppBundle\Tests\Command;

use AppKernel;
use PHPUnit_Framework_TestCase;
use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Tester\ApplicationTester;

class SaveQuoteCommandTest extends PHPUnit_Framework_TestCase
{
    const EXIT_SUCCESS = 0;

    private $app;

    protected function setUp()
    {
        $kernel = new AppKernel('test', false);
        $application = new Application($kernel);
        $application-&gt;setAutoExit(false);
        $this-&gt;app = new ApplicationTester($application);
    }

    /**
     * @test
     */
    public function it_saves_a_new_quote()
    {
        $exitCode = $this-&gt;app-&gt;run(array(
            'quote:save',
            'quote' =&gt; 'Nobody expects the spanish inquisition',
        ));

        self::assertSame(self::EXIT_SUCCESS, $exitCode, $this-&gt;app-&gt;getDisplay());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Testing only the exit code is called "Smoke Testing" and is a very
  efficient way to check if the application is broken.
  Testing the output would be tedious and would make our test fragile as it might change often.</p>
</blockquote>

<p>Let's run it:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>The tests fails because the command doesn't exist. Let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Command/SaveQuoteCommand.php

namespace AppBundle\Command;

use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;

class SaveQuoteCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this-&gt;setName('quote:save');
        $this-&gt;addArgument('quote', InputArgument::REQUIRED);
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $output-&gt;writeln('');
        $output-&gt;writeln('// Saving quote');

        $this-&gt;getContainer()-&gt;get('app.save_new_quote')-&gt;save(
            $input-&gt;getArgument('quote')
        );

        $output-&gt;writeln('');
        $output-&gt;writeln(' [OK] Quote saved');
        $output-&gt;writeln('');
    }
}
</code></pre>

<p>Then run the test again:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>It now fails for a different reason: the service used doesn't exist.</p>

<h2 id="the-service">The service</h2>

<p>The second step is to write the unit test for the service. With phpspec we can
first bootstrap it:</p>

<pre><code>vendor/bin/phpspec describe 'AppBundle\Service\SaveNewQuote'
</code></pre>

<p>Then we need to edit it:</p>

<pre><code class="php">&lt;?php
// spec/AppBundle/Service/SaveNewQuoteSpec.php

namespace spec\AppBundle\Service;

use PhpSpec\ObjectBehavior;
use Symfony\Component\Filesystem\Filesystem;

class SaveNewQuoteSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/quotes.txt';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem, self::FILENAME);
    }

    function it_saves_new_quote(Filesystem $filesystem)
    {
        $filesystem-&gt;dumpFile(self::FILENAME, self::QUOTE)-&gt;shouldBeCalled();

        $this-&gt;save(self::QUOTE);
    }
}
</code></pre>

<p>Time to run the suite:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>phpspec will detect that the tested class doesn't exist and will bootstrap it for us,
so we just have to edit it:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/SaveNewQuote.php

namespace AppBundle\Service;

use Symfony\Component\Filesystem\Filesystem;

class SaveNewQuote
{
    private $filesystem;
    private $filename;

    public function __construct(Filesystem $filesystem, $filename)
    {
        $this-&gt;filesystem = $filesystem;
        $this-&gt;filename = $filename;
    }

    public function save($quote)
    {
        $this-&gt;filesystem-&gt;dumpFile($this-&gt;filename, $quote);
    }
}
</code></pre>

<p>Again, we're going to run our unit test:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>It's finally green! Our final step will be to define our service in the Dependency Injection
Container:</p>

<pre><code># app/config/config.yml

imports:
    - { resource: parameters.yml }
    - { resource: importer.php }

framework:
    secret: "%secret%"

services:
    app.save_new_quote:
        class: AppBundle\Service\SaveNewQuote
        arguments:
            - "@filesystem"
            - "%kernel.root_dir%/cache/quotes"
</code></pre>

<p>To make sure everything is fine, let's clear the cache and run the test:</p>

<pre><code>rm -rf app/cache/*
vendor/bin/phpunit
</code></pre>

<p>It's <a href="https://www.youtube.com/watch?v=lFeLDc2CzOs">Super Green</a>!</p>

<h2 id="conclusion">Conclusion</h2>

<p>As we can see, PHPUnit and phpspec can work perfectly well together.</p>

<p>Of course we could write our unit test in a similar manner with PHPUnit:</p>

<pre><code>&lt;?php
// tests/Service/SaveNewQuoteTest.php

namespace AppBundle\Tests\Service;

use AppBundle\Service\SaveNewQuote;
use PHPUnit_Framework_TestCase;

class SaveNewQuoteTest extends PHPUnit_Framework_TestCase
{
    const FILENAME = '/tmp/quotes.txt';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    private $filesystem;
    private $saveNewQuote;

    protected function setUp()
    {
        $this-&gt;filesystem = $this-&gt;prophesize('Symfony\Component\Filesystem\Filesystem');
        $this-&gt;saveNewQuote = new SaveNewQuote($this-&gt;filesystem-&gt;reveal(), self::FILENAME);
    }

    /**
     * @test
     * @group unit
     */
    public function it_saves_new_quote()
    {
        $this-&gt;filesystem-&gt;dumpFile(self::FILENAME, self::QUOTE)-&gt;shouldBeCalled();

        $this-&gt;saveNewQuote-&gt;save(self::QUOTE);
    }
}
</code></pre>

<p>And run it separately:</p>

<pre><code>vendor/bin/phpunit --group=unit
</code></pre>

<p>But then we would lose all the advantages of phpspec:</p>

<ul>
<li>it adds less overhead (this same test runs in ~20ms with phpspec, and ~80ms with PHPUnit)</li>
<li>it tells you when it thinks you're doing something wrong (typically by making it harder/impossible for you to do it)</li>
<li>it bootstraps things for you if you follow the TDD workflow (test first, then code)</li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Tactician]]></title>
            <link href="/2015/09/09/tactician.html"/>
            <updated>2015-09-09T00:00:00+01:00</updated>
            <id>/2015/09/09/tactician.html</id>
            <content type="html"><![CDATA[<p>Just like <a href="/2015/08/04/simple-bus.html">SimpleBus</a>,
<a href="https://tactician.thephpleague.com/">Tactician</a> is a lightweight library created by
<a href="http://rosstuck.com/">Ross Tuck</a> allowing you to use the Command Bus design pattern
in your applications.</p>

<blockquote>
  <p><strong>Note</strong>: Command Bus is often used to comply to [CQRS](/2015/08/25/cqrs.html, but not only.</p>
</blockquote>

<h2 id="usage-example">Usage example</h2>

<p>Here's how to install Tactician:</p>

<pre><code>composer require league/tactician:^0.6
</code></pre>

<p>Then we have to associate a Command to a CommandHandler:</p>

<pre><code class="php">&lt;?php

use League\Tactician\Setup\QuickStart;

require __DIR__.'/vendor/autoload.php';

$commandBus = QuickStart::create(array(
    'Vendor\Project\Member\RegisterMember' =&gt; new Vendor\Project\Member\RegisterMemberHandler(),
));
</code></pre>

<p>It provides many framework integrations, including one for <a href="http://symfony.com/">Symfony</a>:</p>

<pre><code>composer require league/tactician-bundle:^0.3
# Don't forget to register `League\Tactician\Bundle\TacticianBundle` in `AppKernel`
</code></pre>

<p>Then we just have to use the <code>tactician.commandBus</code> service. To register Command Handler, we
need to tag service definitions as follow:</p>

<pre><code>services:
    register_member_handler:
        class: Vendor\Project\Member\RegisterMemberHandler
        tags:
            - { name: tactician.handler, command: Vendor\Project\Member\RegisterMember }
</code></pre>

<p>Now that the configuration is settled, here's a usage example:</p>

<pre><code class="php">$username = isset($argv[1]) ? $argv[1] : null;
$commandBus-&gt;handle(new RegisterMember($username));
</code></pre>

<p>The command would look like this:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project\Member;

class RegisterMember
{
    private $username;

    public function __construct($username)
    {
        if (null === $username) {
            throw new \InvalidArgumentException('Missing required "username" parameter');
        }
        $this-&gt;username = $username;
    }

    public function getUsername()
    {
        return $this-&gt;username;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Commands validate simple input logic (required parameters, parameter type, etc).</p>
</blockquote>

<p>The Command Handler could look like this:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project\Member;

class RegisterMemberHandler
{
    private $memberRepository;

    public function __construct(MemberRespository $memberRepository)
    {
        $this-&gt;memberRepository = $memberRepository;
    }

    public function handle(RegisterMember $registerMember)
    {
        $username = $registerMember-&gt;getUsername();
        if ($memberRepository-&gt;has($username)) {
            throw new \DomainException(sprintf('Given username "%s" already exists, and duplicates are not allowed', $username));
        }
        $memberRepository-&gt;register($registerMember);
    }
}
</code></pre>

<p>The Command Handler validates more complex logic (member username duplication, etc).</p>

<p>Here's a nice reference about command validation: <a href="http://verraes.net/2015/02/form-command-model-validation/">Form, Command, and Model Validation</a>.</p>

<h2 id="tips">Tips</h2>

<p>Here are some personal tips!</p>

<p>CommandBus is able to return the value of the executed CommandHandler.
While this isn't advised in asynchronous applications (think messaging queues, like RabbitMQ)
it can be useful in simple applications.</p>

<p>Because Commands also contain simple input validation you can write unit test for them,
but since they're mainly DTOs it might not be too important.</p>

<p>CommandHandlers on the other way are good candidates for unit tests.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Remember when people said that controllers shouldn't have any logic in it?
With the Command Bus pattern this becomes possible.
It also makes this kind of logic reusable and testable.</p>

<p>Tactician is a nice library for this: it doesn't get in our way and allows you to choose between
the "good" way or the "pragmatic" way (if you don't choose wisely, then shame on you).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Diactoros (PSR-7)]]></title>
            <link href="/2015/08/07/diactoros-psr7.html"/>
            <updated>2015-08-07T00:00:00+01:00</updated>
            <id>/2015/08/07/diactoros-psr7.html</id>
            <content type="html"><![CDATA[<p><a href="https://github.com/zendframework/zend-diactoros">Zend Diactoros</a> is a lightweight
library providing implementations for <a href="http://www.php-fig.org/psr/psr-7/">PSR-7 interfaces</a>.</p>

<p>It can be installed using <a href="https://getcomposer.org/download/">Composer</a>:</p>

<pre><code>composer require zendframework/zend-diactoros:^1.0
</code></pre>

<h2 id="example">Example</h2>

<p>We'd like to retrieve data from remote endpoints, using our internal <code>RequestHandler</code>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Psr\Http\Message\RequestInterface;

interface RequestHandler
{
    // @return \Psr\Http\Message\ResponseInterface
    public function handle(RequestInterface $request);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For the sake of our example we use this interface, but in your application
  you'd use an actual HTTP client (e.g. <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>).</p>
</blockquote>

<p><code>RequestHandler</code> expects a <code>Request</code> parameter, so we're going to build it:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Zend\Diactoros\Request;
use Zend\Diactoros\Stream;

class MemberGateway
{
    private $requestHandler;
    private $username;
    private $password;

    public function __construct(RequestHandler $requestHandler, $username, $password)
    {
        $this-&gt;requestHandler = $requestHandler;
        $this-&gt;username = $username;
        $this-&gt;password = $password;
    }

    public function findOne($id)
    {
        $request = new Request('http://example.com/members/'.$id, 'GET', 'php://memory', array(
            'Authorization' =&gt; 'Basic '.base64_encode($this-&gt;username.':'.$this-&gt;password),
        ));
        $item = json_decode($this-&gt;requestHandler-&gt;handle($request)-&gt;getBody()-&gt;__toString(), true);

        return array(
            'id' =&gt; $item['id'],
            'name' =&gt; $item['name'],
            'description' =&gt; $item['description'],
        );
    }

    public function createOne($name, $description)
    {
        $body = new Stream('php://memory', 'w');
        $body-&gt;write(json_encode(array(
            'name' =&gt; $name,
            'description' =&gt; $description,
        )));
        $request = new Request('http://example.com/members/'.$id, 'GET', $body, array(
            'Authorization' =&gt; 'Basic '.base64_encode($this-&gt;username.':'.$this-&gt;password),
        ));
        $item = json_decode($this-&gt;requestHandler-&gt;handle($request)-&gt;getBody()-&gt;__toString(), true);

        return array(
            'id' =&gt; $item['id'],
            'name' =&gt; $item['name'],
            'description' =&gt; $item['description'],
        );
    }
}
</code></pre>

<p>The body of <code>Request</code> and <code>Response</code> is wrapped in a <code>Stream</code> (as specified in PSR-7).</p>

<h2 id="tips">Tips</h2>

<p>If the <code>Request</code> body should be empty, simply pass <code>php://memory</code>.</p>

<p>If the <code>Response</code> has a body, we can convert the <code>Stream</code> into a string using <code>__toString</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Zend Diactoros is becoming the de facto PSR-7 implementation, for example it's
used in <a href="http://symfony.com/blog/psr-7-support-in-symfony-is-here">Symfony</a>.</p>

<p>You should give it a try!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Pomm Foundation]]></title>
            <link href="/2015/08/06/pomm-foundation.html"/>
            <updated>2015-08-06T00:00:00+01:00</updated>
            <id>/2015/08/06/pomm-foundation.html</id>
            <content type="html"><![CDATA[<p><a href="http://www.pomm-project.org/">Pomm</a> is an interresting alternative to Doctrine
(<a href="http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/reference/introduction.html">DBAL</a>
or <a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/tutorials/getting-started.html">ORM</a>), it specializes in one database vendor: <a href="http://www.postgresql.org/docs/9.4/static/intro-whatis.html">PostgreSQL</a>.</p>

<p>In this article we'll quickly have a look at <a href="https://github.com/pomm-project/Foundation#foundation">Pomm Foundation</a>.</p>

<h2 id="installation">Installation</h2>

<p>Pomm can be installed using <a href="https://getcomposer.org/download/">Composer</a>:</p>

<pre><code>composer require pomm-project/foundation:^2.0@rc
</code></pre>

<p>Then we need to create a <code>QueryManager</code>:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

$pomm = new PommProject\Foundation\Pomm(
    'database_name' =&gt; array(
        'dsn' =&gt; 'pgsql://database_user:database_pass@database_host:database_port/database_name',
        'class:session_builder' =&gt; '\PommProject\Foundation\SessionBuilder',
    ),
);

/**
 * @var PommProject\Foundation\QueryManager\QueryManagerInterface
 */
$queryManager = $pomm-&gt;getDefaultSession()-&gt;getQueryManager();
</code></pre>

<h2 id="usage">Usage</h2>

<p>The <code>QueryManager</code> allows us to send query to our database:</p>

<pre><code class="php">$items = $queryManager-&gt;query('SELECT * FROM item WHERE name = $1 AND description = $2', array(
    'Arthur Dent',
    'Nobody expects the Spanish Inquisition!',
));
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <a href="https://twitter.com/mvrhov/status/573098943321653248">Named parameters are not supported</a>.</p>
</blockquote>

<p>The returned value is an iterator, each element is a row (an associative array):</p>

<pre><code class="php">foreach ($items as $item) {
    echo $item['description'];
}
</code></pre>

<p>If you'd rather get all elements as an array, you can use <code>iterator_to_array</code>:</p>

<pre><code class="php">$arrayItems = iterator_to_array($items);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Behind the scene the result is stored in a <code>resource</code>, which is usually more efficient than a PHP array.
  The iterator allows to get the rows from the <code>resource</code> one by one, which can save memory.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>Pomm Foundation provides an efficient abstraction over <code>pg_*</code> functions.</p>

<p>In comparison Doctrine DBAL uses <code>PDO</code> and tries to abstract vendor features,
so if you're using PostgresSQL and don't need an ORM, you can give it a try!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[phinx]]></title>
            <link href="/2015/08/05/phinx.html"/>
            <updated>2015-08-05T00:00:00+01:00</updated>
            <id>/2015/08/05/phinx.html</id>
            <content type="html"><![CDATA[<p><a href="https://phinx.org/">phinx</a> is a lightweight migration library, completly decoupled
from any framework and libraries. In its most simple form, it allows you to write SQL
statements to upgrade and downgrade your schema, or insert / delete data.</p>

<h2 id="installation">Installation</h2>

<p>First of all, we need to install it using <a href="https://getcomposer.org/download/">Composer</a>:</p>

<pre><code>composer require robmorgan/phinx:^0.4
</code></pre>

<p>With this we get a phar that can be run:</p>

<pre><code>phinx
</code></pre>

<blockquote>
  <p><strong>Tip</strong>: make your vendor's binaries available by adding <code>vendor/bin</code> to your <code>$PATH</code>.
  <code>export PATH="vendor/bin:$PATH"</code>.</p>
</blockquote>

<p>Then we need to configure the settings:</p>

<pre><code class="php">&lt;?php
// File: phinx.php

$parameters = \Symfony\Component\Yaml\Yaml::parse(file_get_contents(__DIR__.'/app/config/parameters.yml'));

return array(
    'paths' =&gt; array(
        'migrations' =&gt; __DIR__.'/migrations'
    ),
    'environments' =&gt; array(
        'default_migration_table' =&gt; 'migration',
        'default_database' =&gt; 'prod',
        'prod' =&gt; array(
            'adapter' =&gt; 'pgsql', // Could also be "mysql", "sqlite" or "sqlsrv"
            'host' =&gt; $parameters['parameters']['database_host'],
            'name' =&gt; $parameters['parameters']['database_name'],
            'user' =&gt; $parameters['parameters']['database_user'],
            'pass' =&gt; $parameters['parameters']['database_pass'],
            'port' =&gt; $parameters['parameters']['database_port'],
            'charset' =&gt; 'utf8',
        ),
        'test' =&gt; array(
            'adapter' =&gt; 'pgsql',
            'host' =&gt; $parameters['parameters']['database_host'],
            'name' =&gt; $parameters['parameters']['database_name'].'_test',
            'user' =&gt; $parameters['parameters']['database_user'],
            'pass' =&gt; $parameters['parameters']['database_pass'],
            'port' =&gt; $parameters['parameters']['database_port'],
            'charset' =&gt; 'utf8',
        ),
    ),
);
</code></pre>

<p>The configuration could also be written in YAML, here I used PHP to be able to share
the database configuration with the application's one.</p>

<h2 id="usage-example">Usage example</h2>

<p>Migration files can be bootstrapped using the command:</p>

<pre><code>phinx create FirstVersion
</code></pre>

<p>Which results in the following file (<code>migrations/20150805201245_first_version.php</code>):</p>

<pre><code class="php">&lt;?php

use Phinx\Migration\AbstractMigration;

class FirstVersion extends AbstractMigration
{
    public function change()
    {
    }
}
</code></pre>

<p>In the <code>change</code> method we need to get a <code>Table</code> object using <code>$this-&gt;table('table_name')</code>
and then use it to describe the changes in the schema: phinx is then able to figure out
how to reverse them if necessary.</p>

<p>If you'd rather write SQL queries directly you need to remove <code>change</code> and define
a <code>up</code> and a <code>down</code> method. In them you can use <code>$this-&gt;query('SQL')</code> to execute
your queries.</p>

<p>Example:</p>

<pre><code class="php">&lt;?php

use Phinx\Migration\AbstractMigration;

class FirstVersion extends AbstractMigration
{
    public function up()
    {
        $this-&gt;query('CREATE TABLE my_table;');
    }

    public function down()
    {
        $this-&gt;query('DROP TABLE my_table;');
    }
}
</code></pre>

<p>Migrating an application then becomes as simple as:</p>

<pre><code>phinx migrate
</code></pre>

<p>And rolling back:</p>

<pre><code>phinx rollback
</code></pre>

<h2 id="tips">Tips</h2>

<p>Time for the personal tips!</p>

<p>Using <a href="http://www.doctrine-project.org/projects/migrations.html">Doctrine Migrations</a>
is fine when using Doctrine ORM, but for the rest (including Doctrine DBAL) I'd rather use phinx.</p>

<p>While <code>Table</code> allows to write portable migrations and saves you the time of writing the <code>down</code> method,
I'd advise you to write directly SQL queries: it's a layer less to learn and it will be consistent
with the migrations where you insert / update data.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Migration libraries are all very similar, the nice touch of phinx is that it's not
coupled to any framework and it doesn't require any integration.</p>

<p>Give it a try!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Simple Bus]]></title>
            <link href="/2015/08/04/simple-bus.html"/>
            <updated>2015-08-04T00:00:00+01:00</updated>
            <id>/2015/08/04/simple-bus.html</id>
            <content type="html"><![CDATA[<p><a href="http://simplebus.github.io/MessageBus/">Simple Bus</a> is a lightweight library
created by <a href="https://twitter.com/matthiasnoback">Matthias Noback</a> allowing you to
use the Command Bus design pattern in your applications.</p>

<h2 id="command-%2F-query-responsibility-separation">Command / Query Responsibility Separation</h2>

<p>The <a href="http://martinfowler.com/bliki/CQRS.html">CQRS principle</a> specifies that an
application entry point (e.g. console command, or web controller) should only do
an imperative command (e.g. register a member) or an interrogatory command (how many members?).</p>

<p>Here's a nice reference about the different kinds of commands, by
<a href="https://twitter.com/mathiasverraes">Mathias Verraes</a>: <a href="http://verraes.net/2015/01/messaging-flavours/">Messaging flavours</a>.</p>

<p>This allows to simplify the application and the code base: those are two different
concerns and with the <a href="http://www.objectmentor.com/resources/articles/srp.pdf">Single Responsibility Principle</a>
we've learned that they shouldn't be mixed.</p>

<p>The Command Bus pattern aims at solving the imperative command part.</p>

<h2 id="command-bus">Command Bus</h2>

<p>With this design pattern, we have 3 different kinds of class:</p>

<ul>
<li>Command: a Data Transfer Object (no logic) with a name describing the command (e.g. <code>RegisterMember</code>)</li>
<li>Command Handler: the service that does the actions require by the Command (note: 1 Command =  1 Command Handler)</li>
<li>Command Bus: given a Command, it will execute the appropriate Command Handler</li>
</ul>

<p>Our entry points would create the command using the parameters received
(e.g. console input or request content), and then give it to the Command Bus.</p>

<p>Having a Command Bus class is really nice as it allows us to execute things before and
after every commands: for example in a test environment we could wrap SQL queries in transactions
and roll them back.</p>

<h2 id="usage-example">Usage example</h2>

<p>Here's how to install Simple Bus:</p>

<pre><code>composer require simple-bus/message-bus:^3.0
</code></pre>

<p>Since it allows us to choose how the Command Bus will find the Command Handler, we
have to set it up:</p>

<pre><code class="php">&lt;?php

use SimpleBus\Message\Bus\Middleware\MessageBusSupportingMiddleware;
use SimpleBus\Message\CallableResolver\CallableMap;
use SimpleBus\Message\CallableResolver\ServiceLocatorAwareCallableResolver;
use SimpleBus\Message\Handler\DelegatesToMessageHandlerMiddleware;
use SimpleBus\Message\Handler\Resolver\NameBasedMessageHandlerResolver;
use SimpleBus\Message\Name\ClassBasedNameResolver;

require __DIR__.'/vendor/autoload.php';

$commandHandlerMap = new CallableMap(array(
    'Vendor\Project\Member\RegisterMember' =&gt; array('register_member_handler', 'handle'),
), new ServiceLocatorAwareCallableResolver(function ($serviceId) {
    if ('register_member_handler' === $serviceId) {
        return new Vendor\Project\Member\RegisterMemberHandler();
    }
}));

$commandBus = new MessageBusSupportingMiddleware();
$commandBus-&gt;appendMiddleware(new DelegatesToMessageHandlerMiddleware(new NameBasedMessageHandlerResolver(
    new ClassBasedNameResolver(),
    $commandHandlerMap
)));
</code></pre>

<p>This create a Command Bus that will use the given Command's Fully Qualified ClassName
(FQCN, the class name with its full namespace) to call the associated Command Handler
in the map. Also, the Command Handler will only be created if it is used!</p>

<p>This configuration looks a bit scary, but thankfully if we use <a href="http://symfony.com/">Symfony</a>
we can just install the bundle:</p>

<pre><code>composer require simple-bus/symfony-bridge:^3.0
# Don't forget to register `SimpleBus\SymfonyBridge\SimpleBusCommandBusBundle` in `AppKernel`
</code></pre>

<p>Then we just have to use the <code>command_bus</code> service. To register Command Handler, we
need to tag service definitions as follow:</p>

<pre><code>services:
    register_member_handler:
        class: Vendor\Project\Member\RegisterMemberHandler
        tags:
            - { name: command_handler, handles: Vendor\Project\Member\RegisterMember }
</code></pre>

<p>Now that the configuration is settled, here's a usage example:</p>

<pre><code class="php">$username = isset($argv[1]) ? $argv[1] : null;
$commandBus-&gt;handle(new RegisterMember($username));
</code></pre>

<p>The command would look like this:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project\Member;

class RegisterMember
{
    public $username;

    public function __construct($username)
    {
        if (null === $username) {
            throw new \InvalidArgumentException('Missing required "username" parameter');
        }
        $this-&gt;username = $username;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Commands validate simple input logic (required parameters, parameter type, etc).</p>
</blockquote>

<p>The Command Handler could look like this:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project\Member;

class RegisterMember
{
    private $memberRepository;

    public function __construct(MemberRespository $memberRepository)
    {
        $this-&gt;memberRepository = $memberRepository;
    }

    public function handle(RegisterMember $registerMember)
    {
        if ($memberRepository-&gt;has($registerMember-&gt;username)) {
            throw new \DomainException(sprintf('Given username "%s" already exists, and duplicates are not allowed', $registerMember-&gt;username));
        }
        $memberRepository-&gt;register($registerMember);
    }
}
</code></pre>

<p>The Command Handler validates more complex logic (member username duplication, etc).</p>

<p>Here's a nice reference about command validation: <a href="http://verraes.net/2015/02/form-command-model-validation/">Form, Command, and Model Validation</a>.</p>

<h2 id="tips">Tips</h2>

<p>Here are some personal tips!</p>

<p>We can reuse Command Handlers by injecting them into other Command Handlers
(don't inject the Command Bus in a Command Handler).</p>

<p>Command Handlers were not meant to return anything (think of asynchrone messages).
But this might not always be pragmatic: in this case we can store a return value in the Command.</p>

<p>We've talked about the Command part in CQRS, what about the Query part?
I've experimented a bit with a "Query Bus", but in the end I've settled down with
a Search Engine class, to which a Criteria is given.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Remember when people said that controllers shouldn't have any logic in it?
With the Command Bus pattern this becomes possible.
It also makes this kind of logic reusable and testable.</p>

<p>Simple Bus is a nice library for this: it doesn't get in our way.
For more information about it, read the series of articles published for its first release
(caution: the public API changed a lot since): <a href="http://php-and-symfony.matthiasnoback.nl/tags/SimpleBus/">A wave of command buses</a>.</p>

<p>An alternative in the PHP world would be <a href="http://tactician.thephpleague.com/">Tactician</a>.</p>

<p>Here's also some nice slides by <a href="https://twitter.com/mr_r_miller">Richard Miller</a>
about CQRS: <a href="https://speakerdeck.com/richardmiller/avoiding-the-mud">Avoiding the Mud</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[phpspec]]></title>
            <link href="/2015/08/03/phpspec.html"/>
            <updated>2015-08-03T00:00:00+01:00</updated>
            <id>/2015/08/03/phpspec.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is kept up to date.</p>
</blockquote>

<p><a href="http://www.phpspec.net">phpspec</a> is a highly opinionated unit test framework:
it was conceived to practice <a href="http://dannorth.net/introducing-bdd/">specBDD</a>
(test method names should be sentences) and
<a href="http://martinfowler.com/articles/mocksArentStubs.html">Mockist TDD</a>
(collaborators should always be mocked) and tries to enforce some testing practices
(see <a href="https://twitter.com/_md">Marcello Duarte</a>'s <a href="http://techportal.inviqa.com/2014/09/11/my-top-ten-favourite-phpspec-limitations/">top 10 favourite phpspec limitations</a>).</p>

<p>The <a href="http://blog.astrumfutura.com/2008/01/the-phpspec-zend-framework-app-testing-manifesto-zf-integration/">first version</a>
was created by <a href="https://twitter.com/padraicb">Pádraic Brady</a> as a port of <a href="http://rspec.info/">rspec</a>,
but Marcello Duarte and <a href="https://twitter.com/everzet">Konstantin Kudryashov</a>
took over and released a second version which added code generation.
<a href="https://twitter.com/CiaranMcNulty">Ciaran McNulty</a> then took the lead from v2.1
and added many features like collaborator generation, better exception specification
and currently for version 2.3 better constructor specification.</p>

<h2 id="usage-example">Usage example</h2>

<p>Let's have a look at how phpspec works. For this we'll need to have a project configured with
<a href="https://getcomposer.org/download">Composer</a>. Here's the <code>composer.json</code> file:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>We can install phpspec with the following:</p>

<pre><code>composer require --dev phpspec/phpspec:^2.2
</code></pre>

<p>Let's say we want to create a class that edits text files. We can call this class
<code>TextEditor</code>:</p>

<pre><code>phpspec describe 'Vendor\Project\TextEditor'
</code></pre>

<blockquote>
  <p><strong>Tip</strong>: make your vendor's binaries available by adding <code>vendor/bin</code> to your <code>$PATH</code>.
  <code>export PATH="vendor/bin:$PATH"</code>.</p>
</blockquote>

<p>We should now have the <code>spec/Vendor/Project/TextEditorSpec.php</code> file, bootstraped
for us by phpspec:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class TextEditorSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\TextEditor');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: this test can only be used to test the <code>TextEditor</code> class.</p>
</blockquote>

<p>Our first use case will be about creating a file if it doesn't already exist.
Those are filesystem operations, so we decide to delegate the actual logic to a
<code>Filesystem</code> class (we'll create it later).</p>

<p>So our first step will be to create a set up method (it will be executed before
every test method) that initializes our object:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/TextEditorSpec.php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }
}
</code></pre>

<p>Arguments passed to test methods are actually test doubles (phpspec uses the typehint
to know what to mock).</p>

<p>Now we can create the actual test method:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/TextEditorSpec.php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_can_force_file_creation_if_it_does_not_already_exists(File $file, Filesystem $filesystem)
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>This is roughly the equivalent of the following with <a href="https://phpunit.de/">PHPUnit</a>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project\Tests;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorTest extends PHPUnit_Framewor_TestCase
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    private $prophet;
    private $filesystem;
    private $textEditor;

    protected function setUp()
    {
        $this-&gt;prophet = new \Prophecy\Prophet();
        $this-&gt;filesystem = $this-&gt;prophet-&gt;prophesize('Vendor\Project\Service\Filesystem');
        $this-&gt;textEditor = new TextEditor($filesystem-&gt;reveal());
    }

    protected function tearDown()
    {
        $this-&gt;prophet-&gt;checkPredictions();
    }

    /**
     * @test
     */
    public function it_can_force_file_creation_if_it_does_not_already_exists()
    {
        $file = $this-&gt;prophet-&gt;prophesize('Vendor\Project\File');
        $this-&gt;filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $this-&gt;filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        self::assertSame($file, $this-&gt;textEditor-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION));
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We tried to make the test method as descriptive as possible (e.g. not <code>testOpen()</code>).
  This is the whole point of specBDD (specification Behavior Driven Development).</p>
</blockquote>

<p>phpspec uses the mocking library prophecy (also available in PHPUnit since version 4.4),
which tries to be as less verbose as possible: to describe interractions, test doubles
can almost be used as the actual object, except we need to add a <code>-&gt;willreturn()</code> or
<code>-&gt;shouldBeCalled()</code> call afterwards.</p>

<blockquote>
  <p><strong>Note</strong>: By mocking all collaborators, we are forced to think how our object interracts with them.
  This is the whole point of Mockist TDD (Mockist Test Driven Development).</p>
</blockquote>

<p>Now that we have a test, we are going to execute the test suite (as advocated by TDD):</p>

<pre><code>phpspec run
</code></pre>

<p>It will ask the following 7 questions:</p>

<ol>
<li>Would you like me to generate an interface <code>Vendor\Project\Service\Filesystem</code> for you?</li>
<li>Would you like me to generate an interface <code>Vendor\Project\File</code> for you?</li>
<li>Would you like me to generate a method signature <code>Vendor\Project\Service\Filesystem::exists()</code> for you?</li>
<li>Would you like me to generate a method signature <code>Vendor\Project\Service\Filesystem::create()</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\TextEditor</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\TextEditor::__construct()</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\TextEditor::open()</code> for you?</li>
</ol>

<p>By accepting everytime, phpspec will bootstrap the following
<code>src/Vendor/Project/Vendor/TextEditor.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class TextEditor
{

    public function __construct($argument1)
    {
        // TODO: write logic here
    }

    public function open($argument1, $argument2)
    {
        // TODO: write logic here
    }
}
</code></pre>

<p>In our specification, we make use of non existing class (<code>File</code> and <code>Filesystem</code>)
but phpspec also bootstraped them for us, for example <code>src/Vendor/Project/Vendor/Filesystem.php</code>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project\Service;

interface Filesystem
{

    public function exists($argument1);

    public function create($argument1);
}
</code></pre>

<p>This is extremely usefull to kickstart our TDD cycle!</p>

<p>Once the code is written, we'll execute the test suite again, and then we'll add more
use cases to the test class (e.g. what happens if the file already exists?).</p>

<p>For further usage example, have a look at: <a href="tags/phpspec">articles tagged with phpspec</a>.</p>

<h2 id="specgen">SpecGen</h2>

<p>phpspec's code generator is a big part of its value, but it could do more for us.
Hence the <a href="https://github.com/memio/spec-gen">SpecGen</a> extension!</p>

<p>We can install it as follow:</p>

<pre><code>composer require --dev memio/spec-gen:^0.4
echo 'extensions:' &gt; phpspec.yml
echo '  - Memio\SpecGen\MemioSpecGenExtension' &gt;&gt; phpspec.yml
</code></pre>

<p>If we remove the code generated by phpspec:</p>

<pre><code>rm src/Vendor/Project/TextEditor.php
</code></pre>

<p>And re-run the tests:</p>

<pre><code>phpspec run
</code></pre>

<p>Then the generated class will be:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open($argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="emergent-design">Emergent Design</h2>

<p>Test are more than simple regression checks: when a class is hard to test it indicates
that it does too many things or is too coupled.</p>

<p>They can also be used as a design tool: in our test method we can define exactly how
we would like to use the future object. We can even decide on the go that some logic
could be done by collaborators that don't exist yet and start defining how we like to
interract with them.</p>

<p>This is what Emergent Design is all about: the design emerges on the go from the tests.
Then they stop being simple tests, they become specifications: a live documentation
of your code, which never become out of date.</p>

<h2 id="tips">Tips</h2>

<p>Here are some personal tips:</p>

<ul>
<li>use <code>willReturn</code> if you need the returned value of a collaborator (official name: Mock)</li>
<li>use <code>shouldBeCalled</code> to check that a collaborator is called (official name: Stub)</li>
<li>do not chain <code>willReturn</code> and <code>shouldBeCalled</code>, you have to pick one!</li>
<li>create a <code>it_is_a_</code> test method with a <code>shouldImplement</code> check when testing implementations</li>
<li>the <code>shouldBe</code> matcher is usually the only one you need</li>
<li>if you have a lot (how many? that's your call) of test methods, maybe it's time to split your object</li>
<li>if you copy paste the same block of code in many test methods, maybe it's time extract it into an object</li>
</ul>

<p>If the tested object (official name: System Under Test, SUT) creates a value object and passes
it to a collaborator you have two choices:</p>

<ul>
<li>pass <code>Argument::type('MyValueObject')</code></li>
<li>create a factory and add it as a dependency</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>phpspec is a nice unit testing framework, with many advantages:</p>

<ul>
<li>it's fast: on average projects the test suite is run in less than a second</li>
<li>it's a good pair-programming partner: when something is hard to test, it means that there is a better diffrent way to do it</li>
<li>it's a time saver: the code bootstrapping feature is a must have!</li>
<li>it isn't verbose: tests can be read as documented code examples</li>
</ul>

<p>Give it a try!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[SpecGen v0.3]]></title>
            <link href="/2015/05/28/spec-gen-0-3.html"/>
            <updated>2015-05-28T00:00:00+01:00</updated>
            <id>/2015/05/28/spec-gen-0-3.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> v0.3 inserts a property for each constructor argument.</p>
</blockquote>

<p>SpecGen is a <a href="http://phpspec.net">phpspec</a> extension which enhance its code generator.
With the latest release, v0.3, we get the following features:</p>

<ul>
<li>method generation:

<ul>
<li>it inserts method at the end of the class</li>
<li>it typehints object, array and callable arguments</li>
<li>it names object arguments after their type</li>
<li>it names scalar arguments after a generic name (<code>argument</code>)</li>
<li>it adds number on names that could collide (e.g. <code>$argument1, $argument2</code>)</li>
</ul></li>
<li>constructor generation, same as method except:

<ul>
<li>it inserts constructor at the begining of the class</li>
<li>it inserts properties with initialization for each constructor arguments</li>
</ul></li>
</ul>

<p>Here's a simple example to demonstrate how helpful it can be.</p>

<h2 id="example">Example</h2>

<p>First of all, we need to set up a project with <a href="https://getcomposer.org/download">Composer</a>.
Let's write the following <code>composer.json</code>:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>Then we can install phpspec with SpecGen by running those commands:</p>

<pre><code>composer require --dev phpspec/phpspec:~2.2
composer require --dev memio/spec-gen:~0.3
echo 'extensions:' &gt; phpspec.yml
echo '  - Memio\SpecGen\MemioSpecGenExtension' &gt;&gt; phpspec.yml
</code></pre>

<p>In our example, we'll specify a <code>TextEditor</code> service, it should be able to
create new files by relying on <code>Filesystem</code>, another service.</p>

<p>This can be done as follow:</p>

<pre><code>phpspec describe 'Vendor\Project\TextEditor'
````

&gt; **Tip**: make your vendor's binaries available by adding `vendor/bin` to your `$PATH`.
&gt; `export PATH="vendor/bin:$PATH"`.

This should generate a `spec\Vendor\Project\TextEditorSpec.php` file:

```php
&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class TextEditorSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\TextEditor');
    }
}
</code></pre>

<p>It needs to be edited to fit our needs:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_creates_new_files(File $file, Filesystem $filesystem)
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>The Test Driven Development cycle advises us to run the test suite now:</p>

<pre><code>phpspec run
</code></pre>

<p>This will bootstrap the following code:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open($argument1, $argument2)
    {
    }
}
</code></pre>

<p>It created a <code>filesystem</code> property to mirror the constructor arguments. Neat!</p>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>In our example phpspec also generated the collaborators (<code>File</code> and <code>Filesystem</code>).
These don't beneficiate from SpecGen help yet, so the next release (v0.4) will
probably be about using it for collaborators.</p>

<p>Other features that could be implemented would be PHPdoc generation, or avoiding the
<code>Interface</code> / <code>Abstract</code> suffix/prefix in interface and abstract object argument names.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[SpecGen v0.2]]></title>
            <link href="/2015/05/20/spec-gen-0-2.html"/>
            <updated>2015-05-20T00:00:00+01:00</updated>
            <id>/2015/05/20/spec-gen-0-2.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> v0.2 inserts use statements.</p>
</blockquote>

<p>SpecGen v0.2 has been released, it introduces a small change: use statement insertion.</p>

<h2 id="it-inserts-use-statements">It inserts use statements</h2>

<p>Let's go back to the sources of the example used in the <a href="/2015/05/13/memio-spec-gen.html">previous article</a>
and clean it a little bit:</p>

<pre><code>rm -rf src
</code></pre>

<p>Given the following specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Message\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Message\Response');
    }
}
</code></pre>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following file, with a use statement:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Message\Request;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="it-doesn%27t-insert-use-statements-twice">It doesn't insert use statements twice</h2>

<p>Given the following new step in our specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Message\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Message\Response');
    }

    function it_supports_request(Request $request)
    {
        $this-&gt;supports($request)-&gt;shouldBe(true);
    }
}
</code></pre>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following file, without new use statements:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Message\Request;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }

    public function supports(Request $request)
    {
    }
}
</code></pre>

<h2 id="it-doesn%27t-insert-use-statement-for-same-namespace">It doesn't insert use statement for same namespace</h2>

<p>Let's clear everything:</p>

<pre><code>rm -rf src
</code></pre>

<p>Given the following specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <code>Request</code> and <code>RequestHandler</code> are both in the same namespace.</p>
</blockquote>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following, without any use statements:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="behind-the-hood">Behind the hood</h2>

<p>This small feature was the occasion to refactor SpecGen a bit! This resulted in the
introduction of <code>CodeEditor</code>, a facade for a home made <code>CommandBus</code> and for
<a href="http://gnugat.github.io/redaktilo">Redaktilo</a>'s <code>Editor</code>.</p>

<p>With these, the code to generate a method and insert a use statement looks like this:</p>

<pre><code class="php">$file = $this-&gt;codeEditor-&gt;open($fileName);
$this-&gt;codeEditor-&gt;handle(new InsertUseStatements($file, $fullyQualifiedNames));
$this-&gt;codeEditor-&gt;handle(new InsertMethod($file, $method));
$this-&gt;codeEditor-&gt;save($file);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>While some improvements can still be done (use statements in alphabetical order,
typehint interfaces only), the version 0.3 will mainly be about the introduction
of a new generator: insertion of properties when the method is a constructor.</p>

<p>Stay tuned!</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio SpecGen v0.1]]></title>
            <link href="/2015/05/13/memio-spec-gen.html"/>
            <updated>2015-05-13T00:00:00+01:00</updated>
            <id>/2015/05/13/memio-spec-gen.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> is a <a href="http://phpspec.net">phpspec</a>
  extension that improves its code generator. Currently available: type hinted method arguments.</p>
</blockquote>

<p>With <a href="http://memio.github.io/memio">Memio v1.0 released</a>, it is now possible to
create powerful code generators without re-inventing the wheel.
<a href="http://github.com/memio/spec-gen">SpecGen</a> is the first project to use this library, let's
see what it can do for us.</p>

<h2 id="phpspec">phpspec</h2>

<p>First of all we'll talk about <a href="http://phpspec.net">phpspec</a>, which is an exciting
project that provides many benefits:</p>

<ul>
<li>a testing tool (allows to write specifications, which are kind of unit tests)</li>
<li>a "best practice" enforcer (for e.g. cannot test private methods to force us to split code into smaller public APIs)</li>
<li>a time saver (bootstraps tests and code)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: See <a href="http://techportal.inviqa.com/2014/09/11/my-top-ten-favourite-phpspec-limitations/">My top 10 favourite phpsepc limitations</a>.</p>
</blockquote>

<p>It makes Test Driven Development cycles even more meaningful:</p>

<ol>
<li>bootstrap test by thinking on a class name</li>
<li>write a test by thinking how the class should behave</li>
<li>bootstrap the corresponding code by running the whole test suite</li>
<li>write code as quick as possible without thinking about best practices or design patterns (be pragmatic)</li>
<li>run the test suite to check if the code fulfills the test's specifications</li>
<li>refactor the code (manage the technical debt)</li>
<li>run the test suite to check for regressions</li>
<li>repeat!</li>
</ol>

<p>phpspec's code generator is a big part of its value. Let's see if we can improve it.</p>

<h2 id="phpspec-example">phpspec example</h2>

<p>Let's have a look at how phpspec works. For this we'll need to have a project configured with
<a href="https://getcomposer.org/download">Composer</a>:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>We can install phpspec with the following:</p>

<pre><code>composer require --dev phpspec/phpspec:~2.2
</code></pre>

<p>Let's say we want to create a class that handles requests, conforming to the HTTP protocol
(take a <code>Request</code>, return a <code>Response</code>). We can call this class <code>RequestHandler</code>:</p>

<pre><code>phpspec describe 'Vendor\Project\RequestHandler'
</code></pre>

<blockquote>
  <p><strong>Tip</strong>: make your vendor's binaries available by adding <code>vendor/bin</code> to your <code>$PATH</code>.
  <code>export PATH="vendor/bin:$PATH"</code>.</p>
</blockquote>

<p>We should now have the <code>spec/Vendor/Project/RequestHandlerSpec.php</code> file, bootstraped
for us by phpspec:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\RequestHandler');
    }
}
</code></pre>

<p>We can directly start by writing our first specification (test method) in it:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response(Request $request)
    {
        $this-&gt;handle($request)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We tried to make the test method as descriptive as possible (e.g. not <code>testHandler()</code>).
  This is the whole point of specBDD (specification Behavior Driven Development).</p>
</blockquote>

<p>With this we can start to boostrap the code by simply running the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>It will ask the following 3 questions:</p>

<ol>
<li>Would you like me to generate an interface <code>Vendor\Project\Request</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\RequestHandler</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\RequestHandler::handle()</code> for you?</li>
</ol>

<p>By accepting everytime, phpspec will bootstrap the following
<code>src/Vendor/Project/Vendor/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{

    public function handle($argument1)
    {
        // TODO: write logic here
    }
}
</code></pre>

<p>In our specification, we make use of a non existing <code>Request</code> class, and phpspec
also bootstraped it for us in <code>src/Vendor/Project/Vendor/Request.php</code>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

interface Request
{
}
</code></pre>

<p>This is extremely usefull to kickstart our TDD cycle!</p>

<h2 id="memio-specgen">Memio SpecGen</h2>

<p>SpecGen is a phpspec extension, it makes use of Memio (the PHP code generator library)
to make the above bootstraping even more awesome.</p>

<p>Here's how to install it:</p>

<pre><code>composer require --dev memio/spec-gen:~0.1
</code></pre>

<p>We also need to register it as a phpspec extension by writing the following <code>phpspec.yml</code> file:</p>

<pre><code>extensions:
  - Memio\SpecGen\MemioSpecGenExtension
</code></pre>

<p>Its first release, v0.1 (unstable for now), improves the method generation with:</p>

<ul>
<li>type hinted arguments</li>
<li>object arguments named after their type</li>
<li>putting each arguments on their own lines if the inline alternative would have been longer than 120 characters</li>
</ul>

<p>To be fair, this is exactly what already <a href="https://ciaranmcnulty.com/">Ciaran McNulty</a>'s
<a href="https://github.com/ciaranmcnulty/phpspec-typehintedmethods">Typehinted Methods extension</a>
provides, so why would we choose SpecGen? Well simply because it intends to do much more:</p>

<ul>
<li>insertion of <code>use</code> statements</li>
<li>constructor generation (each argument will have a corresponding property and a property initialization)</li>
<li>PHPdoc</li>
<li>???</li>
<li>profit!</li>
</ul>

<h2 id="memio-specgen-example">Memio SpecGen example</h2>

<p>Let's give it a try by first removing the code we boostrapped until now:</p>

<pre><code>rm -rf src
</code></pre>

<p>In order to demonstrate more type hints, we'll add more arguments:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<p>We can now run the test suite to bootstrap the code:</p>

<pre><code>phpspec run
</code></pre>

<p>This should create the following <code>src/Vendor/Project/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: for now <code>use</code> statements aren't generated. In our example it doesn't
  matter since <code>Request</code> is in the same namespace as <code>RequestHandler</code>.</p>
</blockquote>

<p>Let's remove again the generated code:</p>

<pre><code>rm -rf src
</code></pre>

<p>Now we'd like to see this multiline feature by adding many arguments to our specifiction:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response()
    {
        $this-&gt;myMethod(1, 2, 3, 4, 5, 6, 7, 8);
    }
}
</code></pre>

<p>Again, we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>This should bootstrap the following <code>src/Vendor/Project/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function myMethod(
        $argument1,
        $argument2,
        $argument3,
        $argument4,
        $argument5,
        $argument6,
        $argument7,
        $argument8
    )
    {
    }
}
</code></pre>

<p>And that's it!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio SpecGen improves phpspec's generator by adding better named, type hinted
and PSR-2 compliant method arguments.</p>

<p>Note that this kind of improvement has to be done in extension. They cannot be
done directly in phpspec because it tries to enforce best practices, and one of
them is to type hint only against interfaces. As it happens, the current extensions
can also type hint against implementations, depending on how the developers write
their specifications.</p>

<p>The next versions will bring even more exciting features, such as constructor and PHPdoc
generation.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio v1.0]]></title>
            <link href="/2015/05/06/memio.html"/>
            <updated>2015-05-06T00:00:00+01:00</updated>
            <id>/2015/05/06/memio.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://memio.github.io/memio">Memio</a> is a PHP code generator library,
  the main repository provides integration with Twig templates, but by using the
  smaller package <code>pretty-printer</code> on its own it is possible to be decoupled from any template engines.</p>
</blockquote>

<p><a href="http://memio.github.io/memio">Memio</a> has finally be released in version 1.0 (stable).
In this article, we'll see how the different packages are assembled in the main repository.</p>

<h2 id="standard-edition">Standard Edition</h2>

<p>Memio is composed of small packages (<code>linter</code>, <code>model</code>, <code>pretty-printer</code>, <code>twig-template-engine</code>, <code>validator</code>),
the main repository (<a href="http://gituhb.com/memio/memio">memio/memio</a>) is a standard selection of those
to make their usage easier:</p>

<p><img src="http://yuml.me/8686d889" alt="Package diagram" /></p>

<p>It can be installed using <a href="http://getcomposer.com/">Composer</a>:</p>

<pre><code>composer require memio/memio:~1.0
</code></pre>

<p>It provides two services, which can be instanciated as follow:</p>

<pre><code class="php">&lt;?php
// File: memio.php

require __DIR__.'/vendor/autoload.php';

use Memio\Memio\Config\Build;

$linter = Build::linter();
$prettyPrinter = Build::prettyPrinter();
</code></pre>

<p>To see how to use them, let's describe a request handler method:</p>

<pre><code class="php">// ...

use Memio\Model\Method;
use Memio\Model\Argument;

$handle = Method::make('handle')
    -&gt;addArgument(Argument::make('Request', 'request'))
    -&gt;addArgument(Argument::make('int', 'type')
        -&gt;setDefaultValue('self::MASTER_REQUEST')
    )
    -&gt;addArgument(Argument::make('bool', 'catch')
        -&gt;setDefaultValue('true')
    )
;
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Each Model can be constructed using <code>new</code> or the static constructor <code>make</code>.
  The last one has the advantage to allow method chaining (e.g. <code>Method::make('doHandle')-&gt;makePrivate()</code>).</p>
</blockquote>

<p>We can lint this model:</p>

<pre><code class="php">// ...

$linter-&gt;validate($handler); // @throws Memio\Validator\Exception\InvalidModelException if the model contains syntax errors.
</code></pre>

<p>And we can generate the corresponding PHP code:</p>

<pre><code class="php">// ...

$generatedCode = $prettyPrinter-&gt;generateCode($handle);
</code></pre>

<p>We can check in our console's output the result:</p>

<pre><code class="php">// ...

echo $generatedCode;
</code></pre>

<p>This should print:</p>

<pre><code class="php">    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
    {
    }
</code></pre>

<h2 id="limitations">Limitations</h2>

<p>Currently it is possible to describe:</p>

<ul>
<li>a File (License header, use statements)</li>
<li>a Class (abstract, final, with parents, PHPdoc) or an Interface (with parents, PHPdoc)</li>
<li>a class Constant</li>
<li>a class Property (static, default value, PHPdoc)</li>
<li>a class Method (static, abstract, final, visibility, PHPdoc)</li>
<li>a method Argument (typehint, default value)</li>
</ul>

<p>It is possible to describe a method Body, but only with a string:</p>

<pre><code class="php">// ...

$handle-&gt;setBody(&lt;&lt;&lt;BODY
        try {
            $this-&gt;requestHandler-&gt;handle($request);
        } catch (\Exception $e) {
            if (!$catch) {
                throw $e;
            }
        }
BODY
);
</code></pre>

<h2 id="use-cases">Use cases</h2>

<p>In real life, models wouldn't be built manually as in the above examples. They would
be built dynamically:</p>

<pre><code class="php">// ...

array_shift($argv); // remove binary name (php)
array_shift($argv); // remove script name (memio.php)
$methodName = array_shift($argv); // first argument = method name
$arguments = $argv; // all other arguments = argument types (e.g. `int`, `bool`, `DateTime`, etc)

$method = new Method($methodName);
$index = 1;
foreach ($arguments as $argumentType) {
    $argumentName = 'argument'.$index++;
    $method-&gt;addArgument(new Argument($argumentType, $argumentName));
}

echo $prettyPrinter-&gt;generatedCode($method);
</code></pre>

<p>Have a try by running <code>php memio.php handle Request int bool</code>, it should print the following:</p>

<pre><code class="php">    public function handle(Request $argument1, $argument2, $argument3)
    {
    }
</code></pre>

<p>With this we can already improve <a href="http://phpspec.net">phpspec</a> generator (generate typehinted arguments, PHPdoc, etc).
This is going to be the next Memio package, a phpspec extension.</p>

<h2 id="extension-points">Extension points</h2>

<p>The coding style can be changed by creating our custom templates. Those can be loaded as follow:</p>

<pre><code class="php">// ...

$prettyPrinter-&gt;addTemplatePath(__DIR__.'/our-custom-templates-dir');
</code></pre>

<p>Custom constraints can be written to check more things, for example we can ensure
that arguments are always object.</p>

<p>Those steps, just like the rest, are heavily described in the official <a href="http://memio.github.io/memio">documentation</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio is a library that provides a PHP Code Generator:</p>

<ol>
<li>First we describe what we want by building <code>Models</code> (e.g. <code>new Method('__construct')</code>)</li>
<li>Optionally we can <code>Lint</code> them to check if we introduced syntax errors (e.g. <code>Method cannot be both abstract and final</code>)</li>
<li>Then we use a <code>PrettyPrinter</code> to get the generated code (returns a string, can be displayed on the output or saved in a file, etc)</li>
</ol>

<p>You can read more about it with the following articles:</p>

<ul>
<li><a href="/2015/04/08/introducing-memio-code-generator.html">Introducing Memio</a></li>
<li><a href="/2015/04/15/memio-models.html">Memio Models</a></li>
<li><a href="/2015/04/22/memio-validator-linter.html">Memio Validator and Linter</a></li>
<li><a href="/2015/04/29/memio-pretty-printer.html">Memio PrettyPrinter and TwigTemplateEngine</a></li>
</ul>

<p>It also has an <a href="http://memio.github.io/memio">official documentation</a>.</p>

<p>The next step is to create a <a href="http://phpspec.net">phpspec</a> extension to improve its
code generator.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio Pretty Printer]]></title>
            <link href="/2015/04/29/memio-pretty-printer.html"/>
            <updated>2015-04-29T00:00:00+01:00</updated>
            <id>/2015/04/29/memio-pretty-printer.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/pretty-printer">PrettyPrinter</a> converts a
  <a href="http://github.com/memio/model">Model</a> into its PHP code (returns a string),
  using <a href="http://twig.sensiolabs.org/">Twig templates</a>.</p>
</blockquote>

<p>Until now we've seen how to build Memio <a href="http://github.com/memio/model">Models</a>
to describe PHP code and how to <a href="http://github.com/memio/validator">validate</a>
the <a href="http://github.com/memio/linter">syntax</a>.</p>

<p>It's now time to take things seriously with the newly released package:
<a href="http://github.com/memio/pretty-printer">PrettyPrinter</a>, the actual code generator.</p>

<h2 id="what-is-a-pretty-printer%3F">What is a pretty printer?</h2>

<p>As opposed to "fidelity printers" which are supposed to generate code according to
the developer's coding style, "pretty printer" rely on their own.</p>

<p>If we were to open an existing PHP file with Memio and then to generate it again immediately,
chances are that the code would look slightly different.</p>

<blockquote>
  <p><strong>Note</strong>: Memio actually complies to <a href="http://www.php-fig.org/psr/">PHP standards</a>,
  with some extra rules.</p>
</blockquote>

<p>The name "printer" is a bit misleading: one could think that the service would
print the generated code in the console's output or a web page, but all it really
does is to return a simple string.</p>

<blockquote>
  <p><strong>Note</strong>: The terminology used is inspired by this <a href="http://stackoverflow.com/a/5834775/3437428">StackOverflow answer</a>.</p>
</blockquote>

<h2 id="template-engine-agnostic">Template engine agnostic</h2>

<p>Memio makes use of templates, making it easy to change the style. It defines a
<code>TemplateEngine</code> interface that has to be implemented, in order to comply with
<a href="http://webmozarts.com/">webmozart</a>'s <a href="https://github.com/memio/memio/issues/51">request</a>.</p>

<p>For now the only package available is <a href="http://github.com/memio/twig-template-engine">TwigTemplateEngine</a>,
it provides <a href="http://twig.sensiolabs.org/">Twig templates</a>.</p>

<h2 id="code-generation-example">Code generation example</h2>

<p>Enough talk, let's code! First of all we have to create our <code>PrettyPrinter</code>:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

$loader = new \Twig_Loader_Filesystem(\Memio\TwigTemplateEngine\Config\Locate::templates());
$twig = new \Twig_Environment($loader);

$line = new \Memio\TwigTemplateEngine\TwigExtension\Line\Line();
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\ContractLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\FileLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\MethodPhpdocLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\ObjectLineStrategy());
$line-&gt;add(new \Memio\TwigTemplateEngine\TwigExtension\Line\StructurePhpdocLineStrategy());

$twig-&gt;addExtension(new \Memio\TwigTemplateEngine\TwigExtension\Type());
$twig-&gt;addExtension(new \Memio\TwigTemplateEngine\TwigExtension\Whitespace($line));

$templateEngine = new \Memio\TwigTemplateEngine\TwigTemplateEngine($twig);
$prettyPrinter = new \Memio\PrettyPrinter\PrettyPrinter($templateEngine);
</code></pre>

<p>Wow! That was quite painful to write! Thankfully the next package to be released
will make life really easier (spoiler alert: <code>Build::prettyPrinter()</code>).</p>

<p>Now let's build some models:</p>

<pre><code class="php">// ...

$myMethod = new \Memio\Model\Method('myMethod');
for ($i = 1; $i &lt; 10; $i++) {
    $myMethod-&gt;addArgument(new \Memio\Model\Argument('mixed', 'argument'.$i));
}
</code></pre>

<p>All it takes to generate the code is this:</p>

<pre><code class="php">// ...

$generatedCode = $prettyPrinter-&gt;generateCode($myMethod);
</code></pre>

<p>Let's see in the console output what it did:</p>

<pre><code class="php">// ...

echo $generatedCode;
</code></pre>

<p>We should get the following:</p>

<pre><code class="php">    public function myMethod(
        $argument1,
        $argument2,
        $argument3,
        $argument4,
        $argument5,
        $argument6,
        $argument7,
        $argument8,
        $argument9
    )
    {
    }
</code></pre>

<p>Each arguments are displayed on their own line, because the inline equivalent
would have been longer than 120 characters.</p>

<h2 id="custom-templates">Custom templates</h2>

<p>Memio has extra rules regarding coding standards, for example it adds an empty
line between the PHP opening tag and the namespace statement.</p>

<p>We can get rid of this by creating our own custom template: first we copy the <code>file.twig</code>
template in our project:</p>

<pre><code>
{#- File: my_templates/file.twig -#}
&lt;?php
{% if file.licensePhpdoc is not empty %}

{% include 'phpdoc/license_phpdoc.twig' with { 'license_phpdoc': file.licensePhpdoc } only %}
{% endif %}
namespace {{ file.namespace }};

{% include 'collection/fully_qualified_name_collection.twig' with {
    'fully_qualified_name_collection': file.allFullyQualifiedNames
} only %}
{% if needs_line_after(file, 'fully_qualified_names') %}

{% endif %}
{% if file.structure is contract %}
{% include 'contract.twig' with { 'contract': file.structure } only %}
{% else %}
{% include 'object.twig' with { 'object': file.structure } only %}
{% endif %}

</code></pre>

<p>We've removed the line between <code>{% endif %}</code> and <code>namespace {{ file.namespace }};</code>.</p>

<p>In order for our custom template to be used, we'll need to add its directory path to <code>PrettyPrinter</code>:</p>

<pre><code class="php">// ...

$prettyPrinter-&gt;addTemplatePath(__DIR__.'/my_templates');
</code></pre>

<p>And we're done!</p>

<p>Let's check the result:</p>

<pre><code class="php">// ...

$file = \Memio\Model\File::make('src/Vendor/Project/MyClass.php')
    -&gt;setStructure(new \Memio\Model\Object('Vendor\Project\MyClass'))
;

echo $prettyPrinter-&gt;generateCode($file);
</code></pre>

<p>This will output:</p>

<pre><code class="php">&lt;?php
namespace Vendor\Project;

class MyClass
{
}
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>PrettyPrinter can convert Models into PHP code, it uses templates behind the scene
so we can tweak the coding style our way. It isn't tied to any Template Engine,
but we can install Memio's TwigTemplateEngine package .</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio validator and linter]]></title>
            <link href="/2015/04/22/memio-validator-linter.html"/>
            <updated>2015-04-22T00:00:00+01:00</updated>
            <id>/2015/04/22/memio-validator-linter.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Write <a href="http://github.com/memio/validator">constraints</a> to check
  <a href="http://github.com/memio/model">models</a> integrity.
  <a href="http://github.com/memio/linter">Linter</a> constraints (e.g. syntax error) are already available.</p>
</blockquote>

<p>Everyday Memio, the higly opinionated PHP code generation library, progresses
toward its stable release.</p>

<p>In this article, we'll have a look at two packages that have been freshly extracted:
<code>memio/validator</code> and <code>memio/linter</code>.</p>

<h2 id="writing-constraints">Writing constraints</h2>

<p>The <a href="http://github.com/memio/validator">validator</a> packages provides an easy way
to write constraints. Let's write one to check that method arguments are never scalar.</p>

<blockquote>
  <p><strong>Note</strong>: This is one of the principle in <a href="http://williamdurand.fr/2013/06/03/object-calisthenics">object calisthenics</a>:
  <a href="http://williamdurand.fr/2013/06/03/object-calisthenics/#3-wrap-all-primitives-and-strings">wrap all primitives and string</a>.</p>
</blockquote>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Memio\Validator\Constraint;
use Memio\Validator\Violation\NoneViolation;
use Memio\Validator\Violation\SomeViolation;

class ArgumentCannotBeScalar implements Constraint
{
    public function validate($model)
    {
        $type = $model-&gt;getType();
        if (in_array($type, array('array', 'bool', 'callable', 'double', 'int', 'mixed', 'null', 'resource', 'string'), true)) {
            return new SomeViolation(sprintf('Argument "%s" cannot be scalar', $model-&gt;getName()));
        }

        return new NoneViolation();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Naming constraints after their error message allow for better reability.</p>
</blockquote>

<p>The next step is to register our constraint in a validator. Since our constraint
aims <code>Argument</code> models, we'll register it in an <code>ArgumentValidator</code>:</p>

<pre><code class="php">// ...

use Memio\Validator\ModelValidator\ArgumentValidator;

$argumentValidator = new ArgumentValidator();
$argumentValidator-&gt;add(new ArgumentCannotBeScalar());
</code></pre>

<p>When building models, <code>Arguments</code> are burried in <code>Methods</code>, which themselves are burried in
<code>Contracts</code> or <code>Objects</code> which in turn are burried in <code>File</code>.</p>

<p>To make things easy, we'd like to simply give the top most model (e.g. <code>File</code>) to
a generic <code>Validator</code>. Its responsibility would be to go through each models and execute
the appropriate <code>ModelValidator</code>.</p>

<p>In order to do so, we have to create all <code>ModelValidators</code> and assemble them as follow:</p>

<pre><code class="php">// ...

use Memio\Validator\ModelValidator\CollectionValidator;
use Memio\Validator\ModelValidator\ContractValidator;
use Memio\Validator\ModelValidator\FileValidator;
use Memio\Validator\ModelValidator\MethodValidator;
use Memio\Validator\ModelValidator\ObjectValidator;

$collectionValidator = new CollectionValidator();
$methodValidator = new MethodValidator($argumentValidator, $collectionValidator);
$contractValidator = new ContractValidator($collectionValidator, $methodValidator);
$objectValidator = new ObjectValidator($collectionValidator, $methodValidator);
$fileValidator = new FileValidator($contractValidator, $objectValidator);
</code></pre>

<p>Finally, we need to create a validator and register our <code>ModelValidators</code> in it:</p>

<pre><code class="php">// ...

use Memio\Validator\Validator;

$calisthenicValidator = new Validator();
$calisthenicValidator-&gt;add($argumentValidator);
$calisthenicValidator-&gt;add($collectionValidator);
$calisthenicValidator-&gt;add($methodValidator);
$calisthenicValidator-&gt;add($contractValidator);
$calisthenicValidator-&gt;add($objectValidator);
$calisthenicValidator-&gt;add($fileValidator);
</code></pre>

<p>We can now validate our Models:</p>

<pre><code class="php">// ...

$calisthenicValidator-&gt;validate($file); // @throws Memio\Validator\InvalidModelException if one or more constraint fail
</code></pre>

<p>The <code>InvalidModelException</code>'s message has one line per violation.</p>

<h2 id="linter">Linter</h2>

<p>Out of the box, Memio provides a <a href="http://github.com/memio/linter">Linter</a> which
provides the following constraints:</p>

<ul>
<li>Collection cannot have name duplicates</li>
<li>Concrete Object Methods cannot be abstract</li>
<li>Contract Methods can only be public</li>
<li>Contract Methods cannot be final</li>
<li>Contract Methods cannot be static</li>
<li>Contract Methods cannot have a body</li>
<li>Method cannot be abstract and have a body</li>
<li>Method cannot be both abstract and final</li>
<li>Method cannot be both abstract and private</li>
<li>Method cannot be both abstract and static</li>
<li>Object Argument can only default to null</li>
</ul>

<p>As we've seen above, constructing and assembling constraints and validators can be quite
tiresome.</p>

<p>That's where <code>memio/memio</code>, the main central repository, starts to be useful by
providing a simple way to get a ready to use linter:</p>

<pre><code class="php">&lt;?php

require __DIR__.'/vendor/autoload.php';

use Memio\Memio\Config\Build;

$linter = Build::linter();

$linter-&gt;validate($file); // @throws Memio\Validator\InvalidModelException if one or more constraint fail
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Validator allows the creation of custom constraint to ensure that the build Models
are valid. Linter is a set of constraints ready to use, allowing to prevent syntax errors
(e.g. a method cannot be both final and abstract).</p>

<p>If you'd like to find out more about Memio Validator, have a look at the documentation:</p>

<ul>
<li><a href="http://memio.github.io/memio/doc/03-validation-tutorial.html">Validator Tutorial</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio models]]></title>
            <link href="/2015/04/15/memio-models.html"/>
            <updated>2015-04-15T00:00:00+01:00</updated>
            <id>/2015/04/15/memio-models.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Describe code by building <a href="http://github.com/memio/model">models</a>.</p>
</blockquote>

<p>Memio is a highly opinionated PHP code generation library, its version 1.0.0 (stable)
is going to be released soon: currently the main package <code>memio/memio</code> is being
split into smaller packages.</p>

<p>In this article, we'll have a look at the very first package to be ready: <code>memio/model</code>.</p>

<h2 id="describing-code">Describing code</h2>

<p>Let's have a look at the following method:</p>

<pre><code class="php">    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
    {
    }
</code></pre>

<p>We have many things here:</p>

<ul>
<li>a method named <code>handle</code> which is:

<ul>
<li>public</li>
<li>non static</li>
<li>non final</li>
<li>non abstract</li>
</ul></li>
</ul>

<p>It has the following arguments:</p>

<ul>
<li>a <code>Request</code> object named <code>request</code></li>
<li>an integer named <code>type</code> which defaults to <code>self::MASTER_REQUEST</code></li>
<li>a boolean named <code>catch</code> which defaults to <code>true</code></li>
</ul>

<p>Memio provides models that allow us to describe this method by constructing objects:</p>

<pre><code class="php">&lt;?php

use Memio\Model\Argument;
use Memio\Model\Method;

require __DIR__.'/vendor/autoload.php';

$method = Method::make('handle')
    -&gt;addArgument(Argument::make('Request', 'request'))
    -&gt;addArgument(Argument::make('int', 'type')
        -&gt;setDefaultValue('self::MASTER_REQUEST')
    )
    -&gt;addArgument(Argument::make('bool', 'catch')
        -&gt;setDefaultValue('true')
    )
;
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Static constructors are used to allow fluent interface (chaining calls).
  From PHP 5.6 it is possible to do the following:
  <code>(new Method('handle'))-&gt;addArgument(new Argument('Request', 'request'));</code></p>
</blockquote>

<h2 id="building-models-dynamically">Building models dynamically</h2>

<p>Usually models aren't built manually, they could be constructed using:</p>

<ul>
<li>a configuration (a PHP array, a YAML file, etc)</li>
<li>parameters (from CLI input, a web request, etc)</li>
<li>existing code (using <a href="http://nikic.github.io/aboutMe.html">nikic</a>'s <a href="https://github.com/nikic/PHP-Parser">PHP-Parser</a> for instance)</li>
</ul>

<p>Here's a usage example. When running the test suite, <a href="http://phpspec.net">phpspec</a>
generates missing methods in our code (amongst many other nice things).</p>

<p>If the following call is found in a test:</p>

<pre><code class="php">        $this-&gt;handle($request);
</code></pre>

<p>And if the <code>handle</code> method isn't defined in the class currently tested, then phpspec
gathers the following parameters:</p>

<ul>
<li><code>$methodName</code>, which here is set to <code>'handle'</code></li>
<li><code>$arguments</code>, which here is set to <code>array($request)</code></li>
</ul>

<p>Let's re-write its generator using Memio:</p>

<pre><code class="php">&lt;?php

use Memio\Model\Argument;
use Memio\Model\Method;

require __DIR__.'/vendor/autoload.php';

function phpspec_generator($methodName, array $arguments) {
    $method = new Method($methodName);
    $index = 1;
    foreach ($arguments as $argument) {
        $type = is_object($argument) ? get_class($argument) : gettype($argument);
        $argumentName = 'argument'.$index++;
        $method-&gt;addArgument(new Argument($type, $argumentName));
    }

    return $method
}
</code></pre>

<p>Pretty straightforward!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Models are Memio's core, almost every memio packages will rely on them:</p>

<ul>
<li><code>memio/linter</code> will scan models to detect errors (e.g. abstract methods in a final class)</li>
<li><code>memio/twig-template</code> will use them to actually generate the corresponding code</li>
</ul>

<p>For now they can describe:</p>

<ul>
<li>a method argument (typehint when needed, default value)</li>
<li>a method (with PHPdoc, visibility, staticness, abstracness and if it's final)</li>
<li>a property (with PHPdoc, visibility, staticness, default value)</li>
<li>a constant</li>
<li>a class (with PHPdoc, parents, interfaces, abstractness and if it's final)</li>
<li>an interface (with PHPdoc, parent interfaces)</li>
<li>a file (with license header, namespace, use statements)</li>
</ul>

<p>There are some limitations:</p>

<ul>
<li>it can only describe a method's body using a string (e.g. <code>$toto = 42;\necho $toto;</code>)</li>
<li>a file must have a class or an interface</li>
</ul>

<p>For now, it will be sufficient to start working on exciting projects!</p>

<p>If you'd like to find out more about Memio Models, have a look at the documentation:</p>

<ul>
<li><a href="http://memio.github.io/memio/doc/01-model-tutorial.html">regular Models</a></li>
<li><a href="http://memio.github.io/memio/doc/02-phpdoc-tutorial.html">PHPdoc Models</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Introducing Memio, code generator]]></title>
            <link href="/2015/04/08/introducing-memio-code-generator.html"/>
            <updated>2015-04-08T00:00:00+01:00</updated>
            <id>/2015/04/08/introducing-memio-code-generator.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Work in Progress: Memio, a library for PHP code generation.</p>
</blockquote>

<p>Code generators write code for you, so you don't have to! There's many kinds out there:</p>

<ul>
<li>the ones that bootstrap code but can't add anything to it later</li>
<li>the ones that create code but you can't add anything to it later</li>
<li>the ones that can add new things to existing files</li>
<li>the ones that will completly change the style of existing file if they add anything to it</li>
</ul>

<p>Many frameworks provide code generators, because they can be a real time saver by
automating repetitive boring tasks (e.g. bootstraping a CRUD controller). The only
issue is that usually we can't customize them.</p>

<p>For example with <a href="https://github.com/sensiolabs/SensioGeneratorBundle">GeneratorBundle</a>,
it's impossible to create REST controllers.</p>

<p>Some of them provide templates but don't template engines, like <a href="http://phpspec.net/">phpspec</a>
for example: this is a step forward but that's not enough.</p>

<p>Now let's have a look at code generator libraries: the main ones don't allow an easy
way to customize the coding style of generated code:</p>

<ul>
<li><a href="http://framework.zend.com/manual/current/en/modules/zend.code.generator.examples.html">Zend Code Generator</a></li>
<li><a href="https://github.com/nikic/PHP-Parser">PHP Parser</a></li>
</ul>

<p>Some of them do use a template engine, but you need to write a lot of code in order to use
them:</p>

<ul>
<li><a href="https://github.com/cedriclombardot/TwigGenerator">TwigGenerator</a></li>
</ul>

<p>Don't panic! Memio is a code generator library that uses a template engine and provide
out of the box templates, generators and even validation!</p>

<p>Started in september 2014 under the name "Medio", it has now matured enough to be soon
released in stable version (1.0.0).</p>

<p>Let's have a look at what's going to be achieved with it.</p>

<h2 id="improving-phpspec">Improving phpspec</h2>

<p>The <a href="https://github.com/ciaranmcnulty/phpspec-typehintedmethods">phpspec typehint extension</a> was
a good playground for Memio: it allowed to test generation of a method argument by:</p>

<ul>
<li>adding typehints when needed</li>
<li>naming object arguments after their types</li>
</ul>

<p>Once Memio is stable, it will provide its own phpspec extension that aims at:</p>

<ul>
<li>generating argument's PHPdoc</li>
<li>generating use statements for object arguments (no more fully qualified classnames)</li>
<li>generating dependency injection</li>
</ul>

<p>Curious about this last bullet point? Then read on.</p>

<h2 id="automating-dependency-injection">Automating Dependency Injection</h2>

<p>There are many ways to use constructors, and one of them is dependency injection:
each argument is stored in a property and the class can then use them.</p>

<blockquote>
  <p><strong>Note</strong>: Remember, Dependency Injection is a fancy word for passing arguments.</p>
</blockquote>

<p>When doing so, we need to write a lot of boilerplate code:</p>

<ul>
<li>add argument to constructor (with PHPdoc, typehint, name after the type)</li>
<li>add property initialization in constructor body</li>
<li>add property (with PHPdoc)</li>
<li>add use statement, if necessary</li>
</ul>

<p>Memio will automate this in its phpspec extension.</p>

<h2 id="possibly-more%3F">Possibly more?</h2>

<p>We talked about GeneratorBundle: the issue is that we can't define our own templates.
Well Memio could solve this issue in a reusable way!</p>

<p>Usually each applications have its own style, its own requirements, etc. In short:
we can't use the same code generator between projects. But if we focus on a single
project, then we can start using the same code generator to boostrap many classes:
endpoint/page controllers, entities, etc. The possibilities are endless!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio, once stable, will provide a powerful and reusable way of generating code.</p>

<p>What's left to do before the release of v1.0? Mainly splitting the main package
(<code>memio/memio</code>) into small ones (<code>model</code>, <code>template-engine</code>, <code>validator</code>, etc).
The main package would become a "standard edition", allowing developers to select
the features they want, for example the template engine (as <a href="https://github.com/memio/memio/issues/51">requested</a>
by <a href="https://github.com/webmozart">webmozart</a>).</p>

<p>Stay tuned!</p>

<h3 id="thanks">Thanks</h3>

<p>I'd like to thank the following early contributors:</p>

<ul>
<li><a href="https://github.com/funivan">funivan</a></li>
<li><a href="https://github.com/pyrech">pyrech</a></li>
<li><a href="https://github.com/tigitz">tigitz</a></li>
<li><a href="https://github.com/TomasVotruba">TomasVotruba</a></li>
</ul>

<p>Keep up the good work!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Redaktilo: because your code too needs an editor]]></title>
            <link href="/2014/05/09/redaktilo.html"/>
            <updated>2014-05-09T00:00:00+01:00</updated>
            <id>/2014/05/09/redaktilo.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>I've been working on a silly library lately:
<a href="https://github.com/gnugat/redaktilo">Redaktilo</a> (it means editor in esperanto).</p>

<p>Redaktilo has been created to fulfill actual needs. In this article we'll see
what it is all about, and why it won't stay silly for long.</p>

<h2 id="use-case-1%3A-yaml-configuration-edition">Use case 1: YAML configuration edition</h2>

<p><a href="https://github.com/Incenteev/ParameterHandler">Incenteev\ParameterHandler</a>
is a good example: it updates a YAML configuration after each update of the
dependencies using <a href="https://getcomposer.org/">Composer</a>.</p>

<p>It uses the
<a href="http://symfony.com/doc/current/components/yaml/introduction.html">Symfony2 Yaml component</a>
which converts a YAML string into a PHP array, and then converts it back.
The problem with it is that it strips empty lines, custom formatting and
comments...</p>

<p>Redaktilo only inserts a new line in the file, leaving it as it is.</p>

<h2 id="use-case-2%3A-json-file-edition">Use case 2: JSON file edition</h2>

<p>The <code>composer.json</code> file is really usefull and can be almost completly edited
using the <code>composer.phar</code> CLI application.</p>

<p>Some part still need manual edition, like the script section. To automate this
you could use <code>json_decode</code> and <code>json_encode</code>, but similarly to the previous use
case you would lose empty lines and custom formatting...</p>

<p>Redaktilo aims at solving this problem, but isn't ready yet: inserting a line
in JSON often means adding a comma at the end of the previous one.</p>

<h2 id="use-case-3%3A-php-source-code-edition">Use case 3: PHP source code edition</h2>

<p>To be fair this use case isn't limited to PHP source code: it can be useful for
any plain text files (text, XML, java, python, anything).</p>

<p><a href="https://github.com/gnugat/GnugatWizardBundle">GnugatWizardBundle</a> automatically
registers new bundles installed using Composer in your Symfony2 application.</p>

<p>To do so it uses
<a href="https://github.com/sensiolabs/SensioGeneratorBundle">SensioGeneratorBundle</a>'s
<a href="https://github.com/sensiolabs/SensioGeneratorBundle/blob/8b7a33aa3d22388443b6de0b0cf184122e9f60d2/Manipulator/KernelManipulator.php">KernelManipulator</a>
to insert a line in the <code>app/AppKernel.php</code>. However this class registers bundles for every
environments, and doesn't take into account bundle which depend on the kernel.</p>

<p>If you take a look at the <a href="https://github.com/sensiolabs/SensioGeneratorBundle/blob/8b7a33aa3d22388443b6de0b0cf184122e9f60d2/Manipulator/KernelManipulator.php">KernelManipulator source code</a>
you'll realise it has been a bit over engineered as it parses PHP tokens.</p>

<p>A new <code>KernelManipulator</code> could be written using Redaktilo as follow:</p>

<pre><code class="php">&lt;?php

namespace Sensio\Bundle\GeneratorBundle\Manipulator;

use Gnugat\Redaktilo\Editor;

class KernelManipulator extends Manipulator
{
    protected $editor;
    protected $appKernelFilename;

    public function __construct(Editor $editor, $appKernelFilename)
    {
        $this-&gt;editor = $editor;
        $this-&gt;appKernelFilename = $appKernelFilename;
    }

    public function addBundle($bundle)
    {
        $file = $this-&gt;editor-&gt;open($this-&gt;appKernelFilename);
        $newLine = sprintf('            new %s(),', $bundle);

        $this-&gt;editor-&gt;jumpDownTo('    public function registerBundles()');
        $this-&gt;editor-&gt;jumpDownTo('        $bundles = array(');
        $this-&gt;editor-&gt;jumpDownTo('        );');

        $this-&gt;editor-&gt;addBefore($file, $newLine);

        $this-&gt;editor-&gt;save($file);

        return true;
    }
}
</code></pre>

<h2 id="usage">Usage</h2>

<p>A great effort has been put to document the project, as you can see in the
<a href="https://github.com/gnugat/redaktilo/#redaktilo">README</a>.</p>

<p>Here's an overview!</p>

<p>You can install Redaktilo using <a href="https://getcomposer.org/">Composer</a>:</p>

<pre><code>composer require "gnugat/redaktilo:~0.3@dev"
</code></pre>

<p>Then you need to create an instance of the <code>Editor</code> class:</p>

<pre><code class="php">&lt;?php
require_once __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\Filesystem;
use Gnugat\Redaktilo\Editor;
use Symfony\Component\Filesystem\Filesystem as SymfonyFilesystem;

$symfonyFilesystem = new SymfonyFilesystem();
$filesystem = new Filesystem($symfonyFilesystem);
$editor = new Editor($filesystem);
</code></pre>

<p><code>Editor</code> is completly stateless, which means you can use the same instance
everywhere in your scripts/applications/libraries.</p>

<p>Let's now have a look at the available classes and their responsibility.</p>

<h2 id="file">File</h2>

<p>The basic idea behind Redaktilo is to provide an object oriented way to
represent files:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class File
{
    public function getFilename();

    public function read();
    public function write($newContent);

    // ...
}
</code></pre>

<p>Once this domain model available, you can build services to manipulate it.</p>

<h2 id="filesystem">Filesystem</h2>

<p>This is the first service available:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class Filesystem
{
    public function open($filename); // Cannot open new files
    public function create($filename); // Cannot create existing files

    public function exists($filename);

    public function write(File $file);
}
</code></pre>

<p>It creates instances of <code>File</code> and write their content in the actual file.</p>

<h2 id="editor">Editor</h2>

<p>Developers should only use the <code>Editor</code> class: it's a facade which provides the
text edition metaphor:</p>

<pre><code class="php">&lt;?php

namespace Gnugat\Redaktilo;

class Editor
{
    // Filesystem operations.
    public function open($filename, $force = false);
    public function save(File $file);

    // Line insertion.
    public function addBefore(File $file, $add);
    public function addAfter(File $file, $add);

    // Content navigation.
    public function jumpDownTo(File $file, $line);
    public function jumpUpTo(File $file, $line);
}
</code></pre>

<p>And that's it.It told you it was a small and simple library ;) . Now let's see
what's planned for the next releases.</p>

<h2 id="version-0.4-should-bring-searchengine">Version 0.4 should bring SearchEngine</h2>

<p>There's still some search logic left in <code>Editor</code>.</p>

<p>To remove it, a whole system will be put in place: <code>SearchEngineCollection</code> will
be called by <code>Editor</code> and will ask its <code>SearchEngine</code>s if they support the
pattern.</p>

<p>This should allow many search strategies:</p>

<ul>
<li>find by line (what's currently done, an exact matching)</li>
<li>find by line number</li>
<li>find by regexp</li>
<li>find by symbol (similar to <a href="http://www.sublimetext.com/">SublimeText</a>'s <code>@</code>)</li>
</ul>

<p>You could then have an extending point!</p>

<h2 id="version-0.5-should-bring-contentconverter">Version 0.5 should bring ContentConverter</h2>

<p>Some extra logic are also left in <code>File</code>, regarding the conversion of the
content into an array of lines.</p>

<p><code>ContentConverter</code> could take a file, and convert its content into anything:</p>

<ul>
<li>an array of lines</li>
<li>an array of <code>IndentedLine</code></li>
<li>PHP tokens</li>
</ul>

<p>This would allow new types of <code>SearchEngine</code>, and maybe the creation of
<code>ContentEditor</code> which would bear the single responsibility of inserting,
replacing or removing bits of it.</p>

<h2 id="i-need-your-humble-opinion-%2F-help">I need your humble opinion / help</h2>

<p>I'd like to hear about more use cases: what would you do with Redaktilo? What
would you like to do with it?</p>

<p>You can <a href="https://github.com/gnugat/redaktilo/issues/new">open issues to start discussions</a>,
just make sure to provide a real life use case ;) .</p>

<h2 id="conclusion">Conclusion</h2>

<p><a href="https://github.com/gnugat/redaktilo">Redaktilo</a> provides an Object Oriented way
to manipulate files, through the editor metaphor:</p>

<ul>
<li>your scripts can open a file</li>
<li>they can then navigate in the file to select a line</li>
<li>next, they can insert a new line above/under the current one</li>
<li>finally they can save the changes on the filesystem</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Sessions introduction]]></title>
            <link href="/2014/04/23/sf2-sessions-introduction.html"/>
            <updated>2014-04-23T00:00:00+01:00</updated>
            <id>/2014/04/23/sf2-sessions-introduction.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><em>Last reviewed</em>: 22/02/2016.</p>
</blockquote>

<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>The <a href="http://symfony.com/doc/current/components/http_foundation/introduction.html">Symfony HttpFoundation component</a>
is a library which provides an Object Oriented implementation of the HTTP
protocol: it wraps PHP's variable superglobals (<code>$_POST</code>, <code>$_GET</code>, <code>$_SERVER</code>,
etc) inside objects (<code>Request</code>, <code>Response</code>, <code>Session</code>, etc).</p>

<p>The idea behind it: web applications should receive a Request and return a
Response.</p>

<p>In this article, we'll focus on the Session management which solves many issues
(for example the <a href="https://www.google.com/search?q=php+session+already+started+error">PHP session already started error</a>
nightmare).</p>

<p>This introduction will show you how to use it in a "non-symfony" project:</p>

<ol>
<li><a href="#basics">Basics</a></li>
<li><a href="#examples">Examples</a>

<ul>
<li><a href="#simple-attributes">Simple attributes</a></li>
<li><a href="#deep-attributes">Deep attributes</a></li>
</ul></li>
<li><a href="#going-further">Going further</a>

<ul>
<li><a href="#root-attributes">Root attributes</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
</ul></li>
</ol>

<h2 id="basics">Basics</h2>

<p>In almost any cases, you'll only deal with the following three methods of the
<code>Session</code> object:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpFoundation\Session;

use Symfony\Component\HttpFoundation\Session\SessionBagInterface;

class Session implements SessionInterface, \IteratorAggregate, \Countable
{
    public function registerBag(SessionBagInterface $bag);
    public function start();
    public function getBag($name);
}
</code></pre>

<p>A <code>Bag</code> is a group of attributes stored in the session. Again, in most cases
you'll only deal with the following four methods of the <code>AttributeBag</code> object:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpFoundation\Session\Attribute;

class AttributeBag implements AttributeBagInterface, \IteratorAggregate, \Countable
{
    public function __construct($storageKey = '_sf2_attributes');
    public function setName($name);
    public function get($name, $default = null);
    public function set($name, $value);
}
</code></pre>

<p>When using the sessions, you'll generally need to bootstrap things up as follows:</p>

<pre><code class="php">&lt;?php

$session = new Session();

$myAttributeBag = new AttributeBag('my_storage_key');
$myAttributeBag-&gt;setName('some_descriptive_name');
$session-&gt;registerBag($myAttributeBag);

$session-&gt;start();
</code></pre>

<p>The session <strong>MUST</strong> be started by Symfony, and it <em>SHOULD</em> be started after
the bag registrations.</p>

<h2 id="examples">Examples</h2>

<p>Here's some code samples to make things clear.</p>

<h3 id="simple-attributes">Simple attributes</h3>

<p>Let's assume that our session looks like this:</p>

<pre><code class="php">&lt;?php

$_SESSION = array(
    'user' =&gt; array(
        'first_name' =&gt; 'Arthur',
        'last_name' =&gt; 'Dent',
    ),
);
</code></pre>

<p>Here's the bootstrap code we need:</p>

<pre><code class="php">&lt;?php

$session = new Session();

$userAttributeBag = new AttributeBag('user');
$session-&gt;registerBag($userAttributeBag);

$session-&gt;start();
</code></pre>

<p>The equivalent to:</p>

<pre><code class="php">&lt;?php

$firstName = 'Ford';
if (isset($_SESSION['user']['first_name'])) {
    $firstName = $_SESSION['user']['first_name'];
}
$_SESSION['user']['last_name'] = 'Prefect';
</code></pre>

<p>Would be:</p>

<pre><code class="php">&lt;?php

$userAttributeBag = $session-&gt;getBag('user');

$firstName = $userAttributeBag-&gt;get('first_name', 'Ford');
$userAttributeBag-&gt;set('last_name', 'Prefect');
</code></pre>

<h3 id="deep-attributes">Deep attributes</h3>

<p>Now, let's assume we have a session which has deep attributes:</p>

<pre><code class="php">&lt;?php

$_SESSION = array(
    'authentication' =&gt; array(
        'tokens' =&gt; array(
            'github' =&gt; 'A45E96F',
            'twitter' =&gt; '11AEBC980D456E4EF',
        ),
    ),
);
</code></pre>

<p>Here's the bootstrap code we need:</p>

<pre><code class="php">&lt;?php

$session = new Session();

$authenticationAttributeBag = new NamespacedAttributeBag('authentication');
$session-&gt;registerBag($authenticationAttributeBag);

$session-&gt;start();
</code></pre>

<p>The equivalent to:</p>

<pre><code class="php">&lt;?php

$_SESSION['authentication']['tokens']['github'] = 'AEB558F02C3B346';
</code></pre>

<p>Would be:</p>

<pre><code class="php">&lt;?php

$authenticationAttributeBag = $session-&gt;getBag($authenticationAttributeBag);

$authenticationAttributeBag-&gt;set('tokens/github', 'AEB558F02C3B346');
</code></pre>

<h2 id="going-further">Going further</h2>

<p>The <code>Session</code> has been designed to contain a group of attribute bags. But when
working with legacy sessions, you might have to access attributes which are
located at the root of the session. Here's how to extend the <code>Session</code> to allow
this.</p>

<h3 id="root-attributes">Root attributes</h3>

<p>A root attribute might look like:</p>

<pre><code class="php">&lt;?php

$_SESSION = array(
    'attribute' =&gt; 'value',
);
</code></pre>

<p>You need to create your own kind of <code>Bag</code>:</p>

<pre><code class="php">&lt;?php

namespace Acme\Session;

use Symfony\Component\HttpFoundation\Session\SessionBagInterface;

class RootAttributeBag implements SessionBagInterface
{
    private $name = 'single_attribute';

    /** @var string */
    private $storageKey;

    /** @var mixed */
    private $attribute;

    public function __construct($storageKey)
    {
        $this-&gt;storageKey = $storageKey;
    }

    /** {@inheritdoc} */
    public function getName()
    {
        return $this-&gt;name;
    }

    public function setName($name)
    {
        $this-&gt;name = $name;
    }

    /** {@inheritdoc} */
    public function initialize(array &amp;$array)
    {
        $attribute = !empty($array) ? $array[0] : null;
        $this-&gt;attribute = &amp;$attribute;
    }

    /** {@inheritdoc} */
    public function getStorageKey()
    {
        return $this-&gt;storageKey;
    }

    /** {@inheritdoc} */
    public function clear()
    {
        $this-&gt;attribute = null;
    }

    public function get()
    {
        return $this-&gt;attribute;
    }

    public function set($value)
    {
        $this-&gt;attribute = $value;
    }
}
</code></pre>

<p>The <code>storage key</code> will be directly the attribute's key.</p>

<p>We also need to hack a <code>Storage</code> class which supports our <code>Bag</code>:</p>

<pre><code class="php">&lt;?php

namespace Acme\Session;

use Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage;

class LegacySessionStorage extends NativeSessionStorage
{
    /** {@inheritdoc} */
    protected function loadSession(array &amp;$session = null)
    {
        if (null === $session) {
            $session = &amp;$_SESSION;
        }

        $bags = array_merge($this-&gt;bags, array($this-&gt;metadataBag));

        foreach ($bags as $bag) {
            $key = $bag-&gt;getStorageKey();
            // We cast $_SESSION[$key] to an array, because of the SessionBagInterface::initialize() signature
            $session[$key] = isset($session[$key]) ? (array) $session[$key] : array();
            $bag-&gt;initialize($session[$key]);
        }

        $this-&gt;started = true;
        $this-&gt;closed = false;
    }
}
</code></pre>

<p>Finally, we'll need the following bootstrap code:</p>

<pre><code class="php">&lt;?php

use Acme\Session\LegacySessionStorage;
use Acme\Session\RootAttributeBag;
use Symfony\Component\HttpFoundation\Session\Session;

$sessionStorage = new LegacySessionStorage();
$session = new Session($sessionStorage);

// before: $_SESSION['attribute']
$legacyBag = new RootAttributeBag('attribute');
$legacyBag-&gt;setName('legacy');

// after: $session-&gt;getBag('legacy')-&gt;get()
$session-&gt;registerBag($legacyBag);
</code></pre>

<h3 id="documentation">Documentation</h3>

<p><a href="http://symfony.com/doc/current/components/http_foundation/sessions.html">The official documentation</a>
provides useful information about how the session use it.
For example it explains <a href="http://symfony.com/doc/current/components/http_foundation/sessions.html#flash-messages">how to manage flash messages</a>.</p>

<p>It also explains <a href="http://symfony.com/doc/current/components/http_foundation/session_configuration.html">how the session works behind the scene</a>
with useful tips on how to write the session in a database.</p>

<p><a href="http://symfony.com/doc/current/cookbook/session/index.html">Some cookbooks</a> are
also available.
You can find for instance one describing how to use
<a href="http://symfony.com/doc/current/cookbook/session/proxy_examples.html">session proxy</a>
which is useful if you want to encrypt the session data or to make it read
only.</p>

<h3 id="troubleshooting">Troubleshooting</h3>

<p>The common cases of problems encountered are due to the fact that the session
was started before Symfony2 did.</p>

<p>To fix this, check in your <code>php.ini</code> that the <code>session.auto_start</code> option is set
to <code>0</code> (its default value).</p>

<p>If the session isn't auto started, it means that the application is starting the
session itself. If you cannot prevent this, use
<a href="https://github.com/symfony/HttpFoundation/blob/master/Session/Storage/PhpBridgeSessionStorage.php"><code>PhpBridgeSessionStorage</code></a>
with
<a href="https://github.com/symfony/HttpFoundation/blob/master/Session/Storage/Handler/NativeFileSessionHandler.php"><code>NativeFileSessionHandler</code></a>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\HttpFoundation\Session\Session;
use Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeFileSessionHandler;
use Symfony\Component\HttpFoundation\Session\Storage\PhpBridgeSessionStorage;

$sessionHandler = new NativeFileSessionHandler();
$sessionStorage = new PhpBridgeSessionStorage($sessionHandler);
$session = new Session($sessionStorage);
</code></pre>

<p>Another trouble you can encounter: you register some bags but they're always
empty, even though the <code>$_SESSION</code> contains the targeted values.
This would be because you register your bags after starting the session: if you
can't do otherwise then simply call <code>$session-&gt;migrate()</code> after your bag
registration, this will reload the values.</p>

<p>Finally when doing AJAX request you might notice slow performances, or non
persistence of the data. This might be caused by a
<a href="http://blog.alterphp.com/2012/08/how-to-deal-with-asynchronous-request.html">session locking mechanism</a>
which can be solved like this by saving manually the session:</p>

<pre><code class="php">&lt;?php

$session-&gt;save();
// session_write_close(); // Only required before Symfony 2.1
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>By wrapping <code>$_SESSION</code> and <code>session_*()</code> functions, <code>Session</code> allows you to
make your code more testable
(<a href="http://symfony.com/doc/current/components/http_foundation/session_testing.html">you can mock it</a>)
and to solve starting session issues (just make sure to be the first to start
it).</p>

<p>It's divided into <code>AttributeBag</code> which are arrays of parameters: this allows you
to organize your session by namespaces.</p>

<p>I hope you found some useful tips in this article, if you have any comments or
questions don't be shy and drop me a line on
<a href="https://twitter.com/epiloic">Twitter</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony2 Console component, by example]]></title>
            <link href="/2014/04/09/sf2-console-component-by-example.html"/>
            <updated>2014-04-09T00:00:00+01:00</updated>
            <id>/2014/04/09/sf2-console-component-by-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see
  <a href="/2016/03/02/ultimate-symfony-console.html">The Ultimate Developer Guide to Symfony - Console</a></p>
</blockquote>

<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p><a href="http://symfony.com/">Symfony2</a> is a set of libraries which help you in your
everyday tasks. You can even stack them together and create a framework with it:</p>

<ul>
<li><a href="https://github.com/symfony/symfony-standard">Symfony standard edition</a></li>
<li><a href="https://github.com/gnugat/symfony-empty">Symfony empty edition</a></li>
<li><a href="http://silex.sensiolabs.org/">Silex</a></li>
</ul>

<p>Many frameworks already use a lot of components from Symfony2:</p>

<ul>
<li><a href="http://laravel.com/">Laravel</a></li>
<li><a href="https://drupal.org/">Drupal</a></li>
<li><a href="http://ez.no/">eZ Publish</a></li>
<li><a href="http://phpunit.de/">PHPUnit</a></li>
<li><a href="https://www.phpbb.com/">phpBB</a></li>
<li><a href="https://getcomposer.org/">Composer</a></li>
</ul>

<p>In this article, we'll see the
<a href="http://symfony.com/doc/master/components/console/introduction.html">Console Component</a>,
which allows you to build Command Line Interface (CLI) applications. Symfony 2.5
will be released in may 2014, with great new features for the Console, so I'll
speak about this version here.</p>

<ul>
<li><a href="#introduction">Introduction</a>

<ul>
<li><a href="#application">Application</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#input">Input</a></li>
<li><a href="#output">Output</a></li>
<li><a href="#consolelogger">ConsoleLogger</a></li>
</ul></li>
<li><a href="#standalone-example">Standalone example</a>

<ul>
<li><a href="#creating-the-application">Creating the application</a></li>
<li><a href="#creating-the-command">Creating the command</a></li>
<li><a href="#registering-the-command">Registering the command</a></li>
<li><a href="#using-the-filesystem-component">Using the Filesystem component</a></li>
<li><a href="#thin-controller-many-small-services">Thin controller, many small services</a></li>
<li><a href="#registering-the-services">Registering the services</a></li>
</ul></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>This component allows you to focus on one thing: creating commands. It takes
care of all the coloring output, input gathering and command containing stuff.</p>

<p>The big picture is: you have an <code>Application</code> which contains a set of
<code>Command</code>s. When ran, the <code>Application</code> will create an <code>Input</code> object which
contains <code>Option</code>s and <code>Argument</code>s provided by the user, and will feed it to
the right <code>Command</code>.</p>

<p>The code being the best documentation, we'll now see the strict minimum classes
you should know, with the methods you'll likely use.</p>

<h3 id="application">Application</h3>

<p>All you need to know about the <code>Application</code> is this:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class Application
{
    public function __construct($name = 'UNKNOWN', $version = 'UNKNOWN');
    public function add(Command $command);
    public function setDefaultCommand($commandName); // New in 2.5!
    public function run(InputInterface $input = null, OutputInterface $output = null);
}
</code></pre>

<p>Minimum usage:</p>

<pre><code>#!/usr/bin/env php
&lt;?php

use Symfony\Component\Console\Application;

$application = new Application();
$application-&gt;run();
</code></pre>

<p>By running this script, you should be able to see a colorful output which lists
the available commands (<code>list</code> is the default command, and a <code>help</code> is also
available).</p>

<h3 id="command">Command</h3>

<p>The <code>Command</code> class is the controller of your CLI application:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Command;

use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

class Command
{
    protected function configure();
    protected function execute(InputInterface $input, OutputInterface $output);
    protected function interact(InputInterface $input, OutputInterface $output);

    // To be called in configure
    public function setName($name);
    public function addArgument($name, $mode = null, $description = '', $default = null);
    public function addOption($name, $shortcut = null, $mode = null, $description = '', $default = null);
    public function setDescription($description);
    public function setHelp($help);
    public function setAliases($aliases);
}
</code></pre>

<p>Basically you create a class which extends <code>Command</code>. You need to implement 2
methods:</p>

<ul>
<li><code>configure</code>: the configuration of the command's name, arguments, options, etc</li>
<li><code>execute</code>: where you process the input, call your services and write to the
output</li>
</ul>

<p>The <code>interact</code> method is called before the <code>execute</code> one: it allows you to ask
questions to the user to set more input arguments and options.</p>

<p>Here's my stand on arguments and options modes:</p>

<ul>
<li>an argument should always be required (<code>InputArgument::REQUIRED</code>)</li>
<li>a flag is an option without value (<code>InputOption::VALUE_NONE</code>)</li>
<li>an option should always have a required value (<code>InputOption::VALUE_REQUIRED</code>),
don't forget to provide a default one</li>
</ul>

<h3 id="input">Input</h3>

<p>The container of the arguments and options given by the user:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Input;

interface InputInterface
{
    public function getArgument($name);
    public function getOption($name);
}
</code></pre>

<p>The <code>Application</code> validates a part of the input: it checks if the command
actually accepts the given arguments and options (is the value required? Does
the <code>hello:world</code> command have a <code>--yell</code> option? etc), but you still need to
validate the input against your business rules (the <code>--number</code> option should
be an integer, the <code>name</code> argument should be escaped to avoid SQL injection,
etc).</p>

<h3 id="output">Output</h3>

<p>A convenient object which allows you to write on the console output:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Output;

abstract class Output implements OutputInterface
{
    public function writeln($messages, $type = self::OUTPUT_NORMAL);
}
</code></pre>

<p>The <code>writeln</code> method allows you to write a new line (with a newline character at
the end). If the given <code>message</code> is an array, it will print each elements on a
new line.</p>

<p>The tags allow you to color some parts:</p>

<ul>
<li>green text for informative messages (usage example: <code>&lt;info&gt;foo&lt;/info&gt;</code>)</li>
<li>yellow text for comments (usage example: <code>&lt;comment&gt;foo&lt;/comment&gt;</code>)</li>
<li>black text on a cyan background for questions (usage example: <code>&lt;question&gt;foo&lt;/question&gt;</code>)</li>
<li>white text on a red background for errors (usage example: <code>&lt;error&gt;foo&lt;/error&gt;</code>)</li>
</ul>

<h3 id="consolelogger">ConsoleLogger</h3>

<p>Another brand new class from the version 2.5:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Logger;

use Psr\Log\AbstractLogger;
use Symfony\Component\Console\Output\OutputInterface;

class ConsoleLogger extends AbstractLogger
{
    public function __construct(
        OutputInterface $output,
        array $verbosityLevelMap = array(),
        array $formatLevelMap = array()
    );

    public function log($level, $message, array $context = array());
}
</code></pre>

<p>As you can see, it uses the <code>OutputInterface</code> provided by the <code>Application</code>.
You should inject this logger into your services, this will allow them to write
messages on the standard output of the console while keeping them decoupled from
this component (so you can use these services in a web environment).</p>

<p>Oh, and the good news is: it colors the output and decides whether or not to
print it depending on the verbosity and level of log! An error message would
always be printed in red, an informative message would be printed in green if
you pass the <code>-vv</code> option.</p>

<h2 id="standalone-example">Standalone example</h2>

<p>Just like any other component, the Console can be used as a standalone library.</p>

<p>In this example, we'll create a tool which will create a <code>LICENSE</code> file, just
like <a href="https://github.com/gnugat/fossil">fossil</a> (the <a href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html">bootstraper of markdown files for your FOSS projetcs</a>).</p>

<h3 id="creating-the-application">Creating the application</h3>

<p>To begin, let's install the component using <a href="https://getcomposer.org/">Composer</a>:</p>

<pre><code>$ curl -sS https://getcomposer.org/installer | php # Downloading composer
$ ./composer.phar require "symfony/console:~2.5@dev"
</code></pre>

<p>Then create an empty application:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

require __DIR__.'/vendor/autoload.php';

use Symfony\Component\Console\Application;

$application = new Application('Fossil', '2.0.0');
$application-&gt;run();
</code></pre>

<h3 id="creating-the-command">Creating the command</h3>

<p>Our command has two arguments:</p>

<ul>
<li>the name for the copyright</li>
<li>the year for the copyright</li>
</ul>

<p>It can also take the path of the project as an option (we'll provide the
current directory as default value).</p>

<p>Let's create it:</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class LicenseCommand extends Command
{
    protected function configure()
    {
        $this-&gt;setName('license');
        $this-&gt;setDescription('Bootstraps the license file of your project');

        $this-&gt;addArgument('author', InputArgument::REQUIRED);
        $this-&gt;addArgument('year', InputArgument::REQUIRED);

        $this-&gt;addOption('path', 'p', InputOption::VALUE_REQUIRED, '', getcwd());
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
    }
}
</code></pre>

<h3 id="registering-the-command">Registering the command</h3>

<p>Our command doesn't do anything yet, but we can already register it in our
application:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

require __DIR__.'/vendor/autoload.php';

use Symfony\Component\Console\Application;
use Gnugat\Fossil\LicenseCommand;

$command = new LicenseCommand();

$application = new Application('Fossil', '2.0.0');
$application-&gt;add($command);
$application-&gt;run();
</code></pre>

<p>In order for it to run, you'll need to register the namespace in the autoloader
by editing the <code>composer.json</code> file at the root of the project:</p>

<pre><code>{
    "require": {
        "symfony/console": "~2.5@dev"
    },
    "autoload": {
        "psr-4": { "": "src" }
    }
}
</code></pre>

<p>Then you need to run <code>./composer.phar update</code> to update the configuration.</p>

<h3 id="using-the-filesystem-component">Using the Filesystem component</h3>

<p>In <code>fossil</code>, <a href="https://github.com/gnugat/fossil/tree/master/skeletons">templates</a>
are retrieved using the
<a href="http://symfony.com/doc/current/components/finder.html">Finder component</a>, their
values are replaced using <a href="http://twig.sensiolabs.org/">Twig</a> and written using the
<a href="http://symfony.com/doc/current/components/filesystem.html">Filesystem component</a>.</p>

<p>In order to keep this article short, we'll:</p>

<ul>
<li>use a fictive license which requires only the copyright line</li>
<li>simply store the <code>LICENSE</code> template in the command</li>
<li>inject the values using <code>implode</code></li>
</ul>

<p>This means that you have to install the new component:</p>

<pre><code>$ ./composer.phar require "symfony/filesystem:~2.4"
</code></pre>

<p>And then you need to fill the <code>execute</code> method:</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;

class LicenseCommand extends Command
{
    // configure method...

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $filesystem = new Filesystem();
        $filesystem-&gt;dumpFile($path, $license.PHP_EOL);

        $output-&gt;writeln(sprintf('Created the file %s', $path));
    }
}
</code></pre>

<p>Now running <code>./fossil license "Loïc Chardonnet" "2013-2014" -p="/tmp"</code> will
output the message "Created the file /tmp/LICENSE", which should be what really
happened.</p>

<h3 id="thin-controller%2C-many-small-services">Thin controller, many small services</h3>

<p>I'm not a big fan of putting logic in my commands, so generally I use services
to do the actual job:</p>

<pre><code>&lt;?php
// File src/Gnugat/Fossil/DocumentationWriter.php

namespace Gnugat\Fossil;

use Symfony\Component\Filesystem\Filesystem;
use Psr\Log\LoggerInterface;

class DocumentationWriter
{
    private $filesystem;
    private $logger;

    public function __construct(Filesystem $filesystem, LoggerInterface $logger)
    {
        $this-&gt;filesystem = $filesystem;
        $this-&gt;logger = $logger;
    }

    public function write($path, $content)
    {
        $this-&gt;filesystem-&gt;dumpFile($path, $content);
        $this-&gt;logger-&gt;notice(sprintf('Created file %s', $path));
    }
}
</code></pre>

<p>As you can see, the <code>DocumentationWriter</code> isn't very big. It might seem
overkill, but now it's easy to write tests which will check if the <code>LICENSE</code>
file has been created. Also, in <code>fossil</code> the class does a bit more work: it
checks if the file already exists, and takes a "force overwrite" option into
account.</p>

<p>You'll also notice that we inject a logger to notice the user of what happens.
We need to install the PSR-3 logger interface:</p>

<pre><code>$ composer require "psr/log:~1.0"
</code></pre>

<p>Our command will now be much thinner, just like any controller should be (MVC
can also be applied in CLI):</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Gnugat\Fossil\DocumentationWriter;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Logger\ConsoleLogger;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;

class LicenseCommand extends Command
{
    // configure method...

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $filesystem = new Filesystem();
        $logger = new ConsoleLogger($output);
        $documentationWriter = new DocumentationWriter($filesystem, $logger);

        $documentationWriter-&gt;write($path, $license.PHP_EOL);
    }
}
</code></pre>

<p>To be fair, our command is longer. But it <strong>is</strong> thinner as it now has less
responsibilities:</p>

<ul>
<li>it retrieves the input</li>
<li>creates the dependencies</li>
<li>calls the services</li>
</ul>

<p>If you run again <code>./fossil license "Loïc Chardonnet" "2013-2014" -p="/tmp"</code>,
you won't see anything: <code>ConsoleLogger</code> hides informative messages by default.
You need to pass the verbose option to see the message:</p>

<pre><code>$ ./fossil license -v "Loïc Chardonnet" "2013-2014" -p="/tmp"
</code></pre>

<h3 id="registering-the-services">Registering the services</h3>

<p>The dependency creation isn't a responsibility a controller should have. We'll
delegate this to the
<a href="http://symfony.com/doc/current/components/dependency_injection/introduction.html">Dependency Injection component</a>:</p>

<pre><code>$ ./composer.phar require "symfony/dependency-injection:~2.4"
</code></pre>

<p>We'll also install the
<a href="http://symfony.com/doc/current/components/config/introduction.html">Config component</a>:</p>

<pre><code>$ ./composer.phar require "symfony/config:~2.4"
</code></pre>

<p>If you don't know yet this component, go read
<a href="/2014/01/29/sf2-di-component-by-example.html">this helpful article</a>.</p>

<p>We'll create a XML file to configure the registration of our services:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: config/services.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="symfony.application"
            class="Symfony\Component\Console\Application"&gt;
            &lt;argument key="name"&gt;Fossil&lt;/argument&gt;
            &lt;argument key="version"&gt;2.0.0&lt;/argument&gt;
            &lt;call method="add"&gt;
                 &lt;argument type="service" id="fossil.license_command" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="fossil.license_command" class="Gnugat\Fossil\LicenseCommand"&gt;
            &lt;argument type="service" id="fossil.documentation_writer" /&gt;
        &lt;/service&gt;

        &lt;service id="fossil.documentation_writer" class="Gnugat\Fossil\DocumentationWriter"&gt;
            &lt;argument type="service" id="symfony.filesystem" /&gt;
            &lt;argument type="service" id="symfony.console_logger" /&gt;
        &lt;/service&gt;

        &lt;service id="symfony.filesystem" class="Symfony\Component\Filesystem\Filesystem"&gt;
        &lt;/service&gt;

        &lt;service id="symfony.console_logger" class="Symfony\Component\Console\Logger\ConsoleLogger"&gt;
            &lt;argument type="service" id="symfony.console_output" /&gt;
        &lt;/service&gt;

        &lt;service id="symfony.console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>As you can see, I've delegated <strong>every</strong> construction to the DIC (Dependency
Injection Container), even the construction of the application. Now the command
looks like this:</p>

<pre><code>    &lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Gnugat\Fossil\DocumentationWriter;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class LicenseCommand extends Command
{
    private $documentationWriter;

    public function __construct(DocumentationWriter $documentationWriter)
    {
        $this-&gt;documentationWriter = $documentationWriter;

        parent::__construct();
    }

    protected function configure()
    {
        $this-&gt;setName('license');
        $this-&gt;setDescription('Bootstraps the license file of your project');

        $this-&gt;addArgument('author', InputArgument::REQUIRED);
        $this-&gt;addArgument('year', InputArgument::REQUIRED);

        $this-&gt;addOption('path', 'p', InputOption::VALUE_REQUIRED, '', getcwd());
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $this-&gt;documentationWriter-&gt;write($path, $license.PHP_EOL);
    }
}
</code></pre>

<p>And the console now contains the DIC initialization:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

require __DIR__.'/vendor/autoload.php';

$container = new ContainerBuilder();
$loader = new XmlFileLoader($container, new FileLocator(__DIR__.'/config'));
$loader-&gt;load('services.xml');

$output = $container-&gt;get('symfony.console_output');

$application = $container-&gt;get('symfony.application');
$application-&gt;run(null, $output);
</code></pre>

<p>And voilà! You now know how to create CLI applications :) .</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Console component allows you to create CLI applications. The commands are a
thin layer which gathers the input and call services. Those services can then
output messages to the user using a special kind of logger.</p>

<p>Although this article was a bit long, I might have missed something here, so
if you have any feedbacks/questions, be sure to contact me on
<a href="https://twitter.com/epiloic">Twitter</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony2 Dependency Injection component, by example]]></title>
            <link href="/2014/01/29/sf2-di-component-by-example.html"/>
            <updated>2014-01-29T00:00:00+00:00</updated>
            <id>/2014/01/29/sf2-di-component-by-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see
  <a href="/2016/02/24/ultimate-symfony-dependency-injection.html">The Ultimate Developer Guide to Symfony - Dependency Injection</a></p>
</blockquote>

<p>In <a href="/2014/01/22/ioc-di-and-service-locator.html">the previous article</a>
we've seen among other things the definition of Dependency Injection (DI) and of
the Dependency Injection Container (DIC).</p>

<p>In this article we'll see the Symfony2's DI component which provides a powerful
DIC. Here's the summary:</p>

<ul>
<li>putting the construction of your services into configuration</li>
<li>how to use it to wire your application</li>
</ul>

<p>You don't use Symfony2? Don't worry, this article is all about using this
component as a standalone library (you can use it in your
CakePHP/Zend/Home-made-framework application).</p>

<h2 id="construction-configuration">Construction configuration</h2>

<p>DI is all about passing arguments to the constructor of an object. Because
constructing all those object might become a burden, the DIC is here to
take this responsibility and centralize it.</p>

<p>Let's replace <a href="http://pimple.sensiolabs.org/">Pimple</a> by
<a href="http://symfony.com/doc/current/components/dependency_injection/index.html">Symfony2 DI component</a>
in the code sample from the previous article:</p>

<pre><code>&lt;?php

use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\DependencyInjection\ContainerBuilder;

$container = new ContainerBuilder();

// This is a parameter definition
$container-&gt;setParameter('verbosity_level_map', array(
    OutputInterface::VERBOSITY_NORMAL =&gt; Logger::NOTICE,
    OutputInterface::VERBOSITY_VERBOSE =&gt; Logger::INFO,
    OutputInterface::VERBOSITY_VERY_VERBOSE =&gt; Logger::DEBUG,
    OutputInterface::VERBOSITY_DEBUG =&gt; Logger::DEBUG,
);

// register takes the service name, and then its fully qualified classname as a string
$container-&gt;register(
    'console_output',
    'Symfony\Component\Console\Output\ConsoleOutput'
);
$container-&gt;register(
    'output_formatter',
    'Gnugat\Fossil\ApplicationLayer\OutputFormatter'
);

// You can inject:
// * dependencies which have been declared previously
// * arguments
// * parameters which have been declared previously
// * setter dependencies
$container
    -&gt;register('console_handler', 'Symfony\Bridge\Monolog\Handler\ConsoleHandler')
    -&gt;addArgument(new Reference('console_output'))
    -&gt;addArgument(true)
    -&gt;addArgument('%verbosity_level_map%')
    -&gt;addMethodCall('setFormatter', array(new Reference('output_formatter')));
;

$container
    -&gt;register('logger', 'Monolog\Logger')
    -&gt;addArgument('default.logger')
    -&gt;addMethodCall('pushHandler', array(new Reference('console_handler')));
;

$container-&gt;register('filesystem', 'Symfony\Component\Filesystem\Filesystem');

$container
    -&gt;register('documentation_writer', 'Gnugat\Fossil\MarkdownFile\DocumentationWriter')
    -&gt;addArgument(new Reference('filesystem'))
    -&gt;addArgument(new Reference('logger'))
;
</code></pre>

<p>If you think about it, the construction of objects is a configuration thing:
you need to define for each object their dependencies. Symfony2's DI component
allows you to put all those definition inside a configuration file:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;!-- File: dic_config.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;parameters&gt;
        &lt;parameter key="verbosity_Level_map" type="collection"&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_NORMAL"&gt;Monolog\Logger::NOTICE&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_VERBOSE"&gt;Monolog\Logger::INFO&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_VERY_VERBOSE"&gt;Monolog\Logger::DEBUG&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_DEBUG"&gt;Monolog\Logger::DEBUG&lt;/parameter&gt;
        &lt;/parameter&gt;
    &lt;/parameters&gt;

    &lt;services&gt;
        &lt;service id="console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;

        &lt;service id="output_formatter"
            class="Gnugat\Fossil\ApplicationLayer\OutputFormatter"&gt;
        &lt;/service&gt;

        &lt;service id="console_handler"
            class="Symfony\Bridge\Monolog\Handler\ConsoleHandler"&gt;
            &lt;argument type="service" id="console.output" /&gt;
            &lt;argument key="bubble"&gt;true&lt;/argument&gt;
            &lt;argument&gt;%verbosity_Level_map%&lt;/argument&gt;
            &lt;call method="setFormatter"&gt;
                 &lt;argument type="service" id="output_formatter" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="logger" class="Monolog\Logger"&gt;
            &lt;argument&gt;default.logger&lt;/argument&gt;
            &lt;call method="pushHandler"&gt;
                 &lt;argument type="service" id="console_handler" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="filesystem"
            class="Symfony\Component\Filesystem\Filesystem"&gt;
        &lt;/service&gt;

        &lt;service id="documentation_writer"
            class="Gnugat\Fossil\MarkdownFile\DocumentationWriter"&gt;
            &lt;argument type="service" id="filesystem" /&gt;
            &lt;argument type="service" id="logger" /&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>And here's the code sample allowing you to feed the DIC with this configuration:</p>

<pre><code>&lt;?php

// File: front_controller.php

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$documentationWriter = $container-&gt;get('documentation_writer');
$documentationWriter-&gt;write('/tmp/example.txt', 'Hello world');
</code></pre>

<p>The construction of our objects has been completely removed from the code and
has been put into a configuration file. Actually, we've replaced object
constructions by container initialization, which is way more concise.</p>

<h3 id="configuration-format">Configuration format</h3>

<p>The Symfony2's DI component <a href="http://symfony.com/doc/current/components/dependency_injection/configurators.html">allows many configuration formats</a>:</p>

<ul>
<li>plain PHP (like in our first code sample)</li>
<li>XML (like in our second code sample)</li>
<li><a href="http://www.yaml.org/">YAML</a></li>
</ul>

<p>I wouldn't advise you to use YAML format, as it needs to introduce
<a href="http://symfony.com/doc/current/components/dependency_injection/parameters.html#yaml">special formating in order to support advanced options</a>
like:</p>

<ul>
<li>prefixing services ID's with <code>@</code></li>
<li>prefixing services ID's which aren't mandatory with <code>@?</code></li>
<li>prefixing <code>@</code> with <code>@</code> in order to escape them</li>
<li><a href="http://symfony.com/doc/current/book/service_container.html#using-the-expression-language">prefixing expressions with <code>@=</code></a></li>
</ul>

<p>Not to mention the fact that it doesn't support every options (for instance
<a href="http://symfony.com/doc/current/components/dependency_injection/parameters.html#constants-as-parameters">you cannot declare constants as parameters</a>)</p>

<p>On the other hand, the only thing XML doesn't support is concatenation:</p>

<pre><code>&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;

$container = new ContainerBuilder();
// Needs to be done in plain PHP
$container-&gt;setParameter('skeletons_path', __DIR__.'/skeletons');
</code></pre>

<p>XML can be easily validated and it also can be read by many software like IDE's
which can use it in order to provide you with blissful autocompletion.</p>

<p>If you're concerned about performances (reading XML might be slower than
requiring directly plain PHP), Symfony2's DI component allows you to convert it
into plain PHP and dump it into a cache file which you can then include in
your application: <a href="http://symfony.com/doc/current/components/dependency_injection/compilation.html#dumping-the-configuration-for-performance">take a look at the documentation</a>.</p>

<h2 id="wiring-your-application">Wiring your application</h2>

<p>There's a fantastic conclusion we can deduce from the above section: we can
reduce the lines of codes of our projects simply by extracting object
construction and putting it into configuration files.</p>

<p>Object construction is part of the "wiring layer" of your application: it
doesn't solve your "business problem", nor does it solve your
"application problem". It simply is the boilerplate code necessary to write
those.</p>

<p>Let's explore the impact of wiring your application using Symfony2's DI
component. You might not have noticed it, but the code samples used in the
previous article as well as in this one all come from <a href="https://github.com/gnugat/fossil">fossil</a>,
a command which allows you to bootstrap markdown files of your projects
(<a href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html">cf this article</a>).
It uses Symfony2's Console component which requires some boilerplate code in
order to create the application:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Gnugat\Fossil\DocCommand;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\Console\Application;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$documentationWriter = $container-&gt;get('documentation_writer');

$docCommand = new DocCommand($documentationWriter);

$application = new Application('Fossil', '2.0.0');
$application-&gt;add($docCommand);

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>Can you imagine what this front controller can become if we were to add more
commands? You'd rather not? Me neither, that's why I advise you to put all this
boilerplate code into a configuration file:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: dic_config.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;

        &lt;service id="output_formatter"
            class="Gnugat\Fossil\ApplicationLayer\OutputFormatter"
        &lt;/service&gt;

        &lt;service id="console_handler"
            class="Symfony\Bridge\Monolog\Handler\ConsoleHandler"
            &lt;argument type="service" id="console.output" /&gt;
            &lt;argument key="bubble"&gt;true&lt;/argument&gt;
            &lt;argument&gt;%verbosity_Level_map%&lt;/argument&gt;
            &lt;call method="setFormatter"&gt;
                 &lt;argument type="service" id="output_formatter" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="logger" class="Monolog\Logger"&gt;
            &lt;argument&gt;default.logger&lt;/argument&gt;
            &lt;call method="pushHandler"&gt;
                 &lt;argument type="service" id="console_handler" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="filesystem"
            class="Symfony\Component\Filesystem\Filesystem"
        &lt;/service&gt;

        &lt;service id="documentation_writer"
            class="Gnugat\Fossil\MarkdownFile\DocumentationWriter"
            &lt;argument type="service" id="filesystem" /&gt;
            &lt;argument type="service" id="logger" /&gt;
        &lt;/service&gt;

        &lt;service id="doc_command" class="Gnugat\Fossil\DocCommand"&gt;
            &lt;argument type="service" id="documentation_writer" /&gt;
        &lt;/service&gt;

        &lt;service id="application"
            class="Symfony\Component\Console\Application"&gt;
            &lt;argument key="name"&gt;Fossil&lt;/argument&gt;
            &lt;argument key="version"&gt;2.0.0&lt;/argument&gt;
            &lt;call method="add"&gt;
                 &lt;argument type="service" id="doc_command" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>Which allows us to reduce our front controller:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$application = $container-&gt;get('application');

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>Now our concern is the size of the <code>dic_config.xml</code> file which will keep growing
each time we create new services. Don't panic! You can split it into many files
using the <code>imports</code> tag:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: config/dic.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;imports&gt;
        &lt;import resource="01-application.xml" /&gt;
        &lt;import resource="02-documentation_writer.xml" /&gt;
    &lt;/imports&gt;
&lt;/container&gt;
</code></pre>

<p>We created a <code>config</code> directory to put all those XML files, which means we
should change our front controller to:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__.'/config');

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic.xml');

$application = $container-&gt;get('application');

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>The creation of the <code>config/01-application.xml</code> and
<code>config/02-documentation_writer.xml</code> files is left as an exercise for the
reader.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Symfony2's Dependency Injection component can be used outside of a Symfony2
application. It provides a powerful DIC which can be initialized using
configuration files. This means that boilerplate code (also called "wiring
layer") can be removed from your code and put in configuration files, hooray!</p>

<p>I hope you enjoyed this article, be sure to
<a href="https://twitter.com/epiloic">tweet me what you think about it</a> ;) .</p>

<h3 id="nota-bene">Nota bene</h3>

<p>We've used the component as a standalone library, but everything we've done
here is possible inside a Symfony2 fullstack application.</p>

<p>There's also some tips I'd like to share with you:</p>

<h3 id="doctrine-repositories-as-services">Doctrine repositories as services</h3>

<p>The construction of Doctrine repositories is fully handled by the EntityManager,
which means:</p>

<ol>
<li>you cannot inject them as dependencies in your own services</li>
<li>you cannot inject dependencies into them</li>
</ol>

<p><a href="https://gist.github.com/gnugat/8314217">Or can you?</a></p>

<h3 id="service-locator">Service locator</h3>

<p><a href="/2014/01/22/ioc-di-and-service-locator.html">The previous article</a>
spoke about service locator, which is all about using DIC as a dependency. If
you still don't see what it means, take a look at <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/ContainerAware.php">Symfony2 ContainerAware classes</a>.</p>

<p>For example, a <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/Controller/Controller.php">Symfony2 controller</a>
uses the DIC as a Service Locator. In this specific case it might be justified,
as the controller shouldn't contain any logic: its purpose is to pass the
request's parameters to some services, and to feed their return values as the
response's parameters.</p>

<p>Keep in mind that in your own code, there's a 99.99% chance that using Service
Locator is a unjustified decision ;) .</p>
]]></content>
        </entry>
    </feed>