<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2025-10-23T07:37:26+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[My Symfony Makefile]]></title>
            <link href="/2025/08/13/my-symfony-makefile.html"/>
            <updated>2025-08-13T00:00:00+01:00</updated>
            <id>/2025/08/13/my-symfony-makefile.html</id>
            <content type="html"><![CDATA[<p>Command your codebase with the crown of steel: <a href="https://www.gnu.org/software/make/">Make</a>,
the eternal overlord of task runners.</p>

<p>For a Docker-based Symfony project, typing mundane commands like running tests
can quickly become cumbersome:</p>

<pre><code class="console">docker compose exec app symfony php vendor/bin/phpunit --testdoc
</code></pre>

<p><strong>Make</strong> allows you to define a list of "rules" that provide:</p>

<ul>
<li>simple commands (eg <code>make test</code>)</li>
<li>environment abstraction (eg <code>make console env=prod</code>)</li>
<li>built-in documentation (run <code>make</code> to list available rules)</li>
<li>combining multiple rules into a single one
(eg <code>make qa</code> is equivalent to <code>make cs-check; make static-analysis; make test</code>)</li>
</ul>

<p>With Make, the previous example becomes:</p>

<pre><code class="console">make test arg=--testdox
</code></pre>

<ul>
<li><a href="#makefile">Makefile</a>

<ul>
<li><a href="#usage">Usage</a></li>
<li><a href="#docker-compose-version">Docker Compose version</a></li>
<li><a href="#docker-version">Docker version</a></li>
<li><a href="#native-php-version">Native PHP version</a></li>
</ul></li>
</ul>

<h2 id="makefile">Makefile</h2>

<p>In this article, I'm sharing the Makefiles I use for my Symfony / PHP projects.</p>

<h3 id="usage">Usage</h3>

<p>Here are the rules I usually define:</p>

<pre><code class="console"># 🐳 Docker related rules
## Build the Docker image
make build

## Start the services (eg database, message queue, etc)
make up

## Check the services logs
make logs

## Stop the services
make down

## Open interactive shell in container
make bash

# 🐘 Project related rules
## Install composer dependencies
make composer arg='install --optimize-autoloader'

## Run the Symfony console
make console arg='cache:clear'

### To change the environment
make console env=prod arg='cache:clear'

# 🛂 Quality Assurance related rules
## Run phpstan, php-cs-fixer (check) and phpunit
make qa

## To just run phpstan
make static-analysis

## To just run php-cs-fixer check
make cs-check

## To just run phpunit
make test

### To display technical specifications:
make test arg='--testdox'

### To just run Integration tests:
make test arg='./tests/Integration'

### To just run Unit tests:
make test arg='./tests/Unit'

# Run php-cs-fixer fix
make cs-fix

# Discover everything you can do
make
</code></pre>

<h3 id="docker-compose-version">Docker Compose version</h3>

<p>Here's the <code>Makefile</code> I use in Docker-based Symfony projects, which use a database
(with Docker Compose):</p>

<pre><code class="Makefile"># Parameters (optional)
# * `arg`: arbitrary arguments to pass to rules (default: none)
# * `env`: used to set `APP_ENV` (default: `test`)
arg ?=
env ?= test

# Executables (local)
DOCKER_RUN = docker run -it -v "$(PWD)":/app --user $(shell id -u):$(shell id -g)

# Docker containers
PHP_SERVICE = app
PHP_CONT = $(DOCKER_RUN) $(PHP_SERVICE)

# Executables
PHP = docker compose exec $(PHP_SERVICE) symfony php
COMPOSER = docker compose exec $(PHP_SERVICE) symfony composer
CONSOLE = docker compose exec -e APP_ENV=$(env) $(PHP_SERVICE) symfony console
PHINX = docker compose exec -e APP_ENV=$(env) $(PHP_SERVICE) symfony php vendor/bin/phinx
PHPUNIT = docker compose exec $(PHP_SERVICE) symfony php vendor/bin/phpunit
PHP_CS_FIXER = docker compose exec $(PHP_SERVICE) symfony php vendor/bin/php-cs-fixer
PHPSTAN = docker compose exec $(PHP_SERVICE) symfony php vendor/bin/phpstan

# Misc
.DEFAULT_GOAL = help
.PHONY: *

## —— 🎵 🐳 The Symfony Docker Makefile 🐳 🎵 ——————————————————————————————————
## Based on https://github.com/dunglas/symfony-docker
## (arg) denotes the possibility to pass "arg=" parameter to the target
##     this allows to add command and options, example: make composer arg='dump --optimize'
## (env) denotes the possibility to pass "env=" parameter to the target
##     this allows to set APP_ENV environment variable (default: test), example: make console env='prod' arg='cache:warmup'
help: ## Outputs this help screen
    @grep -E '(^[a-zA-Z0-9\./_-]+:.*?##.*$$)|(^##)' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}{printf "\033[32m%-30s\033[0m %s\n", $$1, $$2}' | sed -e 's/\[32m##/[33m/'

## —— Docker 🐳 ————————————————————————————————————————————————————————————————
build: ## Builds the Docker images
    @docker compose build --pull

up: ## Starts Docker Compose services, in detached mode (no logs)
    @docker compose up --detach

logs: ## Show live logs
    @docker compose logs --tail=0 --follow

down: ## Stops Docker Compose services
    @docker compose down --remove-orphans

bash: ## Connect to the container via bash so up and down arrows go to previous commands
    @docker compose exec $(PHP_SERVICE) bash

## —— PHP 🐘 ———————————————————————————————————————————————————————————————————
composer: ## Runs Composer (arg, eg `arg='install --optimize-autoloader'`)
    @$(COMPOSER) $(arg)

console: ## Runs bin/console (arg, eg `arg='cache:clear'`) (env, eg `env=prod`)
    @$(CONSOLE) $(arg)

phinx: ## Runs Phinx (arg, eg `arg='create MyMigration'`)
    @$(PHINX) $(arg)

migrate: ## Runs DB migrations (arg, eg `arg='--environment prod'`; env, eg env=prod)
    @$(PHINX) migrate --environment=$(env) $(arg)

## —— Quality 🛂 ———————————————————————————————————————————————————————————————
db-reset: ## Resets test database (drop, create, migrate, fixtures)
    @$(CONSOLE) doctrine:database:drop --force --if-exists
    @$(CONSOLE) doctrine:database:create --if-not-exists
    @$(PHINX) migrate --environment=$(env)
    @$(PHINX) seed:run --environment=$(env)

test: ## Runs the tests with PHPUnit (arg, eg `arg='./tests/Unit'`)
    @$(PHPUNIT) $(arg)

static-analysis: ## Static Analysis with phpstan (arg, eg `arg='./src/'`)
    @$(PHPSTAN) analyze $(arg)

cs-check: ## Checks CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) check --verbose $(arg)

qa: ## Equivalent to cs-check &amp;&amp; static-analysis &amp;&amp; test
    @$(MAKE) cs-check
    @$(MAKE) static-analysis
    @$(MAKE) test

cs-fix: ## Fixes CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) fix --verbose $(arg)
</code></pre>

<h3 id="docker-version">Docker version</h3>

<p>If your project doesn't have a database (or services),
and therefore relies on Docker directly (without Docker Compose),
here's what it could look like:</p>

<pre><code class="Makefile"># Parameters (optional)
# * `arg`: arbitrary arguments to pass to rules (default: none)
# * `env`: used to set `APP_ENV` (default: `test`)
arg ?=
env ?= test

# Executables (local)
DOCKER_RUN = docker run -it -v "$(PWD)":/app --user $(shell id -u):$(shell id -g)

# Docker containers
PHP_SERVICE = app
PHP_CONT = $(DOCKER_RUN) $(PHP_SERVICE)

# Executables
PHP = $(PHP_CONT) symfony php
COMPOSER = $(PHP_CONT) symfony composer
CONSOLE = $(DOCKER_RUN) -e APP_ENV=$(env) $(PHP_SERVICE) symfony console
PHPUNIT = $(PHP_CONT) symfony php vendor/bin/phpunit
PHP_CS_FIXER = $(PHP_CONT) symfony php vendor/bin/php-cs-fixer
PHPSTAN = $(PHP_CONT) symfony php vendor/bin/phpstan

# Misc
.DEFAULT_GOAL = help
.PHONY: *

## —— 🎵 🐳 The Symfony Docker Makefile 🐳 🎵 ——————————————————————————————————
## Based on https://github.com/dunglas/symfony-docker
## (arg) denotes the possibility to pass "arg=" parameter to the target
##     this allows to add command and options, example: make composer arg='dump --optimize'
## (env) denotes the possibility to pass "env=" parameter to the target
##     this allows to set APP_ENV environment variable (default: test), example: make console env='prod' arg='cache:warmup'
help: ## Outputs this help screen
    @grep -E '(^[a-zA-Z0-9\./_-]+:.*?##.*$$)|(^##)' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}{printf "\033[32m%-30s\033[0m %s\n", $$1, $$2}' | sed -e 's/\[32m##/[33m/'

## —— Docker 🐳 ————————————————————————————————————————————————————————————————
build: ## Builds the Docker image
    @docker build -t $(PHP_SERVICE) .

bash: ## Connect to the container via bash so up and down arrows go to previous commands
    @$(DOCKER_RUN) $(PHP_SERVICE) bash

## —— PHP 🐘 ———————————————————————————————————————————————————————————————————
composer: ## Runs Composer (arg, eg `arg='install --optimize-autoloader'`)
    @$(COMPOSER) $(arg)

console: ## Runs bin/console (arg, eg `arg='cache:clear'`) (env, eg `env=prod`)
    @$(CONSOLE) $(arg)

## —— Quality 🛂 ———————————————————————————————————————————————————————————————
test: ## Runs the tests with PHPUnit (arg, eg `arg='./tests/Unit'`)
    @$(PHPUNIT) $(arg)

static-analysis: ## Static Analysis with phpstan (arg, eg `arg='./src/'`)
    @$(PHPSTAN) analyze $(arg)

cs-check: ## Checks CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) check --verbose $(arg)

qa: ## Equivalent to cs-check &amp;&amp; static-analysis &amp;&amp; test
    @$(MAKE) cs-check
    @$(MAKE) static-analysis
    @$(MAKE) test

cs-fix: ## Fixes CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) fix --verbose $(arg)
</code></pre>

<h3 id="native-php-version">Native PHP version</h3>

<p>For pure PHP projects without Symfony CLI (or Symfony console),
that don't run in Docker Containers, the <code>Makefile</code> can look like this:</p>

<pre><code class="Makefile"># Parameters (optional)
# * `arg`: arbitrary arguments to pass to rules (default: none)
# * `env`: used to set `APP_ENV` (default: `test`)
arg ?=
env ?= test

# Executables
PHP = php
COMPOSER = composer
PHPUNIT = php vendor/bin/phpunit
PHP_CS_FIXER = php vendor/bin/php-cs-fixer
PHPSTAN = php vendor/bin/phpstan

# Misc
.DEFAULT_GOAL = help
.PHONY: *

## —— 🎵 🐘 The Pure PHP Makefile 🐘 🎵 ——————————————————————————————————————
## Based on https://github.com/dunglas/symfony-docker
## (arg) denotes the possibility to pass "arg=" parameter to the target
##     this allows to add command and options, example: make composer arg='dump --optimize'
## (env) denotes the possibility to pass "env=" parameter to the target
##     this allows to set APP_ENV environment variable (default: test), example: make php env='prod' arg='script.php'
help: ## Outputs this help screen
    @grep -E '(^[a-zA-Z0-9\./_-]+:.*?##.*$$)|(^##)' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}{printf "\033[32m%-30s\033[0m %s\n", $$1, $$2}' | sed -e 's/\[32m##/[33m/'

## —— PHP 🐘 ———————————————————————————————————————————————————————————————————
composer: ## Runs Composer (arg, eg `arg='install --optimize-autoloader'`)
    @$(COMPOSER) $(arg)

php: ## Runs PHP (arg, eg `arg='script.php'`) (env, eg `env=prod`)
    @APP_ENV=$(env) $(PHP) $(arg)

## —— Quality 🛂 ———————————————————————————————————————————————————————————————
test: ## Runs the tests with PHPUnit (arg, eg `arg='./tests/Unit'`)
    @$(PHPUNIT) $(arg)

static-analysis: ## Static Analysis with phpstan (arg, eg `arg='./src/'`)
    @$(PHPSTAN) analyze $(arg)

cs-check: ## Checks CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) check --verbose $(arg)

qa: ## Equivalent to cs-check &amp;&amp; static-analysis &amp;&amp; test
    @$(MAKE) cs-check
    @$(MAKE) static-analysis
    @$(MAKE) test

cs-fix: ## Fixes CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) fix --verbose $(arg)
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>With this, you can streamline your development workflow across projects
and focus on writing code instead of remembering complex Docker commands.</p>

<blockquote>
  <p><strong>Note</strong>: I took massive inspiration from Kevin Dunglas'
  <a href="https://github.com/dunglas/symfony-docker">Symfony Docker Makefile</a>.</p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[My Symfony Dockerfile]]></title>
            <link href="/2025/08/06/my-symfony-dockerfile.html"/>
            <updated>2025-08-06T00:00:00+01:00</updated>
            <id>/2025/08/06/my-symfony-dockerfile.html</id>
            <content type="html"><![CDATA[<p>Dockerize your PHP / Symfony application, to eliminate "works on MY machine".</p>

<p>I'm describing here a solution that ensures consistent development environment,
to run the project locally with just a few commands, without having to worry about:</p>

<ul>
<li>PHP version / extensions</li>
<li><p>database / search engine / messaging queue / services setup</p></li>
<li><p><a href="#dockerfile">Dockerfile</a></p></li>
<li><a href="#dockerignore">Dockerignore</a></li>
<li><a href="#compose">Compose</a></li>
<li><a href="#going-further">Going further</a>

<ul>
<li><a href="#sqlite">SQLite</a></li>
</ul></li>
</ul>

<h2 id="dockerfile">Dockerfile</h2>

<p>The following <code>Dockerfile</code> will build an image with:</p>

<ul>
<li><strong>Alpine Linux</strong>

<ul>
<li>Lightweight distribution (5-10MB compared to 100MB for Ubuntu)</li>
<li>uses <em>musl libc</em> instead of glibc, expect incompatibility issues with some binaries</li>
</ul></li>
<li><strong>PHP 8.3</strong>

<ul>
<li>this is needed for any PHP applications</li>
<li>change the version to your liking</li>
</ul></li>
<li><strong>bash</strong>

<ul>
<li>not required, but I like to use bash as my shell when I connect to the container</li>
</ul></li>
<li><strong>Composer</strong>

<ul>
<li>in production, you don't need the Composer binary in the container</li>
<li>in development, it's useful to have the same running environment for your app and Composer</li>
</ul></li>
<li><strong>PostgreSQL</strong>

<ul>
<li>my favourite database</li>
<li>skip it or switch it to MySQL, SQLite, etc</li>
</ul></li>
<li><strong>Symfony CLI</strong>

<ul>
<li>in production, you don't need the Symfony CLI binary in the container</li>
<li>in development, useful to start a web server</li>
</ul></li>
</ul>

<pre><code># syntax=docker/dockerfile:1

###
# PHP Dev Container
# Utility Tools: PHP, bash, Composer, PostgreSQL, Symfony CLI
###
FROM php:8.3-cli-alpine AS php_dev_container

# Composer environment variables:
# * default user is superuser (root), so allow them
# * put cache directory in a readable/writable location
# _Note_: When running `composer` in container, use `--no-cache` option
ENV COMPOSER_ALLOW_SUPERUSER=1 \
    COMPOSER_CACHE_DIR=/tmp/.composer/cache

# Install dependencies:
# * bash for shell access and scripting
# * postgresql for the database
# * zip for composer packages that use ZIP archives
# _Note (Alpine)_: `--no-cache` includes `--update` and keeps image size minimal
#
# Then install PHP extensions
#
# _Note (Hadolint)_: No version locking, since Alpine only ever provides one version
# hadolint ignore=DL3018
RUN apk add --update --no-cache \
        bash \
        libzip-dev \
        postgresql-dev \
        zip \
    &amp;&amp; docker-php-ext-install \
        bcmath \
        zip \
        pdo_pgsql

# Copy Symfony CLI binary from image
# _Note_: Avoid using Symfony CLI installer, use Docker image instead
# See: https://github.com/symfony-cli/symfony-cli/issues/195#issuecomment-1273269735
# _Note (Hadolint)_: False positive as `COPY` works with images too
# See: https://github.com/hadolint/hadolint/issues/197#issuecomment-1016595425
# hadolint ignore=DL3022
COPY --from=ghcr.io/symfony-cli/symfony-cli:v5 /usr/local/bin/symfony /usr/local/bin/symfony

# Copy Composer binary from composer image
# _Note (Hadolint)_: False positive as `COPY` works with images too
# See: https://github.com/hadolint/hadolint/issues/197#issuecomment-1016595425
# hadolint ignore=DL3022
COPY --from=composer:2 /usr/bin/composer /usr/bin/composer

WORKDIR /app

# Caching `composer install`, as long as composer.{json,lock} don't change.
COPY composer.json composer.lock ./
RUN composer install \
    --no-cache \
    --no-interaction \
    --no-plugins \
    --no-scripts \
    --optimize-autoloader

# Copy the remaining application files (excluding those listed in .dockerignore)
COPY . .
</code></pre>

<p>You can check the validity of your Dockerfile syntax here: <a href="https://hadolint.github.io/hadolint/">hadolint</a></p>

<p>Here's how to build the image, and then run the container:</p>

<blockquote>
  <p><strong>Note</strong>: <code>-v "$(PWD)":/app</code> mounts current directory for live code changes.</p>
</blockquote>

<pre><code class="console">docker build -t app .

# Run with interactive shell
docker run --rm -it -v "$(PWD)":/app app bash

# Run composer
docker run --rm -it -v "$(PWD)":/app app symfony composer install -o

# Run symfony's console
docker run --rm -it -v "$(PWD)":/app -e APP_ENV=prod app symfony console

# Run PHPUnit, phpstan, PHP CS Fixer
docker run --rm -it -v "$(PWD)":/app app symfony php vendor/bin/phpunit
docker run --rm -it -v "$(PWD)":/app app symfony php vendor/bin/phpstan analyze
docker run --rm -it -v "$(PWD)":/app app symfony php vendor/bin/php-cs-fixer check --verbose
docker run --rm -it -v "$(PWD)":/app app symfony php vendor/bin/php-cs-fixer fix --verbose

# Start Symfony CLI's web server
docker run --rm -it -v "$(PWD)":/app -p 8000:8000 app symfony server:start --port=8000 --host=0.0.0.0
</code></pre>

<h2 id="dockerignore">Dockerignore</h2>

<p>When using <code>COPY . .</code> in <code>Dockerfile</code>, it's useful to limit what's going to be copied, with a <code>.dockerignore</code>:</p>

<pre><code>## composer
vendor

## git
.git/

## friendsofphp/php-cs-fixer
.php-cs-fixer.php
.php-cs-fixer.cache

## phpstan/phpstan
phpstan.neon

## phpunit/phpunit
phpunit.xml
.phpunit.cache

## symfony/framework-bundle
.env.local
.env.local.php
.env.*.local
var/cache/
var/log/
</code></pre>

<h2 id="compose">Compose</h2>

<p>When the PHP application relies on other services,
such as a database (eg PostgreSQL), search engine (eg Elasticsearch), or message queue (eg RabbitMQ),
having a <code>compose.yaml</code> file will make the development experience much smoother
by handling services, networking, and volumes automatically:</p>

<pre><code class="yaml">services:
  app:
    build: .
    # Mount current directory into container for live code changes
    volumes:
      - .:/app
    # Database should be started first
    depends_on:
      - db
    ports:
      - "8000:8000"
    command: symfony serve --no-tls --port=8000 --listen-ip=0.0.0.0

  db:
    image: postgres:${POSTGRES_VERSION:-16}-alpine
    environment:
        POSTGRES_DB: ${POSTGRES_DB:-app}
        POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-ChangeMe}
        POSTGRES_USER: ${POSTGRES_USER:-app}
    # Persist database data between container restarts
    volumes:
      - db-data:/var/lib/postgresql/data:rw
    # Port mapping to avoid conflict with locally running PostgreSQL
    ports:
      - "5433:5432"

# Define the db-data volume used above
volumes:
  db-data:
</code></pre>

<p>Now usage commands will be a bit different:</p>

<pre><code class="console"># Build docker images
docker compose build --pull
# Start services (no logs)
docker compose up --detach
# Show live logs
docker compose logs --tail=0 --follow
# Stop services
docker compose down --remove-orphans

# Run with interactive shell
docker compose exec app bash

# Run composer
docker compose exec app symfony composer

# Run symfony's console
docker compose exec -e APP_ENV=prod app symfony console

# Run PHPUnit, phpstan, PHP CS Fixer
docker compose exec -e APP_ENV=prod app symfony php vendor/bin/phpunit
docker compose exec -e APP_ENV=prod app symfony php vendor/bin/phpstan analyze
docker compose exec -e APP_ENV=prod app symfony php vendor/bin/php-cs-fixer check --verbose
docker compose exec -e APP_ENV=prod app symfony php vendor/bin/php-cs-fixer fix --verbose
</code></pre>

<h2 id="going-further">Going further</h2>

<h3 id="sqlite">SQLite</h3>

<p>To setup SQLite, you'll need to modify <code>Dockerfile</code>:</p>

<pre><code>RUN apk add --update --no-cache \
    ...
    sqlite \
    &amp;&amp; docker-php-ext-install \
    ...
    pdo_sqlite
</code></pre>

<p>As well as <code>compose.yaml</code>:</p>

<pre><code class="yaml">services:
    app:
        ...
        volumes:
            ...
            # Mount SQLite database directory to persist data
            - sqlite-data:/app/var/data

volumes:
    ...
    sqlite-data:
</code></pre>

<p>This is assuming your SQLite database file is located in the projects' <code>var/data</code> folder.</p>

<p>Make sure to set up the following environment varaible in <code>.env</code>:</p>

<pre><code>DATABASE_URL="sqlite:///%kernel.project_dir%/var/data/database.sqlite"
</code></pre>

<h3 id="rabbitmq">RabbitMQ</h3>

<p>For RabbitMQ, modify <code>Dockerfile</code>:</p>

<pre><code>RUN apk add --update --no-cache \
    ...
    rabbitmq-c-dev \
    &amp;&amp; docker-php-ext-install \
    ...
    sockets \
    &amp;&amp; pecl install amqp \
    &amp;&amp; docker-php-ext-enable amqp
</code></pre>

<p>Also <code>compose.yaml</code>:</p>

<pre><code class="yaml">services:
    app:
        ...
        depends_on:
            ...
            - rabbitmq

    rabbitmq:
        image: rabbitmq:${RABBITMQ_VERSION:-3.13}-management-alpine
        environment:
            RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER:-app}
            RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD:-ChangeMe}
        # Persist RabbitMQ data between container restarts
        volumes:
            - rabbitmq-data:/var/lib/rabbitmq:rw
        ports:
            # Port mapping to avoid conflict with locally running RabbitMQ
            - "5673:5672"
            # Management UI port
            - "15673:15672"

volumes:
    ...
    rabbitmq-data:
</code></pre>

<p>Again, make sure to set up the following environment varaible in <code>.env</code>:</p>

<pre><code>RABBITMQ_URL="amqp://app:ChangeMe@rabbitmq:5672/"
</code></pre>

<p>The RabbitMQ management interface will be available at http://localhost:15673,
with the credentials defined in the environment variables.</p>

<h2 id="maintenance">Maintenance</h2>

<p>Here's a list of helpful commands to maintain the images and containers:</p>

<ul>
<li><code>docker images</code>: lists images

<ul>
<li><code>docker images --filter dangling=true</code>: lists untagged / unused images</li>
</ul></li>
<li><code>docker container ls</code>: lists running containers

<ul>
<li><code>docker container ls -a</code>: lists running and stopped containers</li>
</ul></li>
<li><code>docker system prune</code>: removes dangling containers, networks and images

<ul>
<li><code>docker system prune --volumes</code>: removes dangling containers, networks, volumes and images</li>
</ul></li>
<li><code>docker history &lt;image&gt;</code>: Inspects layers of an image</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>With this, we can finally write bugs once, and run them everywhere!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Strategy Pattern, Symfony and autowiring]]></title>
            <link href="/2024/08/16/strategy-pattern-symfony-autowiring.html"/>
            <updated>2024-08-16T00:00:00+01:00</updated>
            <id>/2024/08/16/strategy-pattern-symfony-autowiring.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Since Symfony 5.3</p>
  
  <p>Tag the "Strategy" Interface with the attribute <code>[#AutoconfigureTag]</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\Attribute\AutoconfigureTag;

#[AutoconfigureTag]
interface Strategy
{
    // Add your Strategy methods below, for example
    // (please use a more descriptive name than "algorithm"...):
    public function algorithm();

    // *IF* your Strategies need to be executed in a specific order,
    // then add a method that returns the priority (highest priority first, lowest priority last)
    // Note: it MUST be static
    public static function getDefaultPriority(): int;

    // *IF* your Strategies are executed conditionally,
    // then add a "predicate" method (eg named `supports()`):
    public function predicate($input): bool
}
</code></pre>
  
  <p>Inject the <code>iterable</code> that contains all tagged "Strategy" implementations
  in the "Context"'s constructor with the attribute <code>#[TaggedIterator(&lt;tag&gt;)]</code>:</p>

<pre><code class="php">&lt;?php

class Context
{
    public function __construct(
        // *IF* your Strategies need to be executed in a specific order,
        // then use the `defaultPriorityMethod` parameter and set it with the Strategy's static method name
        #[TaggedIterator(Strategy::class, defaultPriorityMethod: 'getDefaultPriority')]
        private iterable $strategies,
    ) {
    }

    public function operation($input)
    {
        foreach ($this-&gt;strategies() as $strategy) {
            // *IF* your Strategies need to be executed conditionally,
            // then add a if statement that verifies the Strategy's predicate method
            if ($strategy-&gt;predicate($input)) {
                $strategy-&gt;algorithm();

                // *IF* you only want the first matching Strategy to be executed,
                // then break the loop here
                break;
            }
        }
    }
}
</code></pre>
  
  <p>Set <code>autowire</code> and <code>autoconfigure</code> parameters to be <code>true</code> in the DIC configuration:</p>

<pre><code class="yaml">services:
    _defaults:
        autowire: true
        autoconfigure: true
</code></pre>
</blockquote>

<p>The Strategy Pattern can be really useful when you want to avoid multiple
conditionals, and/or when you want to add new repetitive chunks of logic
in a maintainable way.</p>

<p>Let's see how to use it in a Symfony application, and how autowiring can help
us configure it.</p>

<p>Note that the code snippets below will NOT be truncated, they'll always contain
the full code (so no things like <code>// rest of the class below</code> comments).</p>

<h2 id="use-case-example">Use Case Example</h2>

<p>Some classes are just bound to contain repeated chunks of similar logic:</p>

<pre><code class="php">&lt;?php

class EmailDailyReports
{
    public function __construct(
        private BuildSpreadsheet $buildSpreadsheet,
        private Mailer $mailer,
        private WriteSpreadsheet $writeSpreadsheet,
        private RetrieveDataForReportOne $retrieveDataForReportOne,
        private RetrieveDataForReportTwo $retrieveDataForReportTwo,
    ) {
    }

    public function send(\DateTime $startDate, \DateTime $endDate): void
    {
        $reportOneData = $this-&gt;retrieveDataForReportOne-&gt;fromDatabase($startDate, $endDate);
        $reportOneName = 'Report One';
        $reportOneSpreadsheet = $this-&gt;buildSpreadsheet-&gt;using($reportOneData, $reportOneName);
        $reportOneFilename = $this-&gt;writeSpreadsheet-&gt;save($reportOneSpreadsheet);

        $reportTwoData = $this-&gt;retrieveDataForReportTwo-&gt;fromDatabase($startDate, $endDate);
        $reportTwoName = 'Report Two';
        $reportTwoSpreadsheet = $this-&gt;buildSpreadsheet-&gt;using($reportTwoData, $reportTwoName);
        $reportTwoFilename = $this-&gt;writeSpreadsheet-&gt;save($reportTwoSpreadsheet);

        $email = (new Email())
            -&gt;from('sender@example.com')
            -&gt;to('recipient@example.com')
            -&gt;attachFromPath($reportOneFilename, $reportOneName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
            -&gt;attachFromPath($reportTwoFilename, $reportTwoName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
            -&gt;subject('Daily Reports')
            -&gt;text('Find reports in attached files');
        $this-&gt;mailer-&gt;send($email);
    }
}
</code></pre>

<p>This <code>EmailDailyReports</code> class builds spreadsheets and sends emails for reports.</p>

<p>The retrieval of the data for each report is delegated to a dedicated service.</p>

<p>This is fine as is, with currently only 2 reports to manage...
But what if we need to add 1 more report? 2 more reports? 30 more reports?</p>

<h2 id="strategy-pattern">Strategy Pattern</h2>

<p>This use case is the perfect candidate for the Strategy Pattern.</p>

<p><code>EmailDailyReports</code> would be considered the "Context" class,
and the services that retrieve the report data would be the "Strategies".</p>

<p>Let's refactor <code>EmailDailyReports</code> to implement this design pattern.</p>

<p>First we create a Strategy interface:</p>

<pre><code class="php">&lt;?php

interface RetrieveDataForReport
{
    public function fromDatabase(\DateTime $startDate, \DateTime $endDate): array;
    public function getName(): string;
}
</code></pre>

<p>Then we make sure the Strategy implementations both implement it
(<code>RetrieveDataForReportOne</code> and <code>RetrieveDataForReportTwo</code>).</p>

<p>Finally we refactor the Context class to be injected with a collection of
Strategies, and iterate through them:</p>

<pre><code class="php">&lt;?php

class EmailDailyReports
{
    public function __construct(
        private BuildSpreadsheet $buildSpreadsheet,
        private Mailer $mailer,
        private WriteSpreadsheet $writeSpreadsheet,
    ) {
    }

    public function send(\DateTime $startDate, \DateTime $endDate): void
    {
        $email = (new Email())
            -&gt;from('sender@example.com')
            -&gt;to('recipient@example.com')
            -&gt;subject('Daily Reports')
            -&gt;text('Find reports in attached files');

        foreach ($this-&gt;retrieveDataForReports as $retrieveDataForReport) {
            $reportData = $retrieveDataForReport-&gt;fromDatabase($startDate, $endDate);
            $reportName = $retrieveDataForReport-&gt;getReportName();
            $reportSpreadsheet = $this-&gt;buildSpreadsheet-&gt;using($reportData, $reportName);
            $reportFilename = $this-&gt;writeSpreadsheet-&gt;save($reportSpreadsheet);

            $email-&gt;attachFromPath($reportFilename, $reportName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        }

        $this-&gt;mailer-&gt;send($email);
    }

    private array $retrieveDataForReports = [];

    public function register(RetrieveDataForReport $retrieveDataForReport): void
    {
        $this-&gt;retrieveDataForReports[] = $retrieveDataForReport;
    }
}
</code></pre>

<p>If the order in which the reports are built is important,
then we need to add a bit of extra logic:</p>

<pre><code class="php">&lt;?php

class EmailDailyReports
{
    public function __construct(
        private BuildSpreadsheet $buildSpreadsheet,
        private Mailer $mailer,
        private WriteSpreadsheet $writeSpreadsheet,
    ) {
    }

    public function send(\DateTime $startDate, \DateTime $endDate): void
    {
        $email = (new Email())
            -&gt;from('sender@example.com')
            -&gt;to('recipient@example.com')
            -&gt;subject('Daily Reports')
            -&gt;text('Find reports in attached files');

        foreach ($this-&gt;getSortedRetrieveDataForReports() as $retrieveDataForReport) {
            $reportData = $retrieveDataForReport-&gt;fromDatabase($startDate, $endDate);
            $reportName = $retrieveDataForReport-&gt;getReportName();
            $reportSpreadsheet = $this-&gt;buildSpreadsheet-&gt;using($reportData, $reportName);
            $reportFilename = $this-&gt;writeSpreadsheet-&gt;save($reportSpreadsheet);

            $email-&gt;attachFromPath($reportFilename, $reportName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        }

        $this-&gt;mailer-&gt;send($email);
    }

    private const int DEFAULT_PRIORITY = 100;
    private const array NOT_SORTED = [];

    private array $unsortedRetrieveDataForReports = [];
    private array $sortedRetrieveDataForReports = self::NOT_SORTED;

    public function register(
        RetrieveDataForReport $retrieveDataForReport,
        int $priority = self::DEFAULT_PRIORITY,
    ): void {
        $this-&gt;unsortedRetrieveDataForReports[$priority][] = $retrieveDataForReport;
        $this-&gt;sortedRetrieveDataForReports = self::NOT_SORTED;
    }

    private function getSortedRetrieveDataForReports(): void
    {
        if (self::NOT_SORTED === $this-&gt;sortedRetrieveDataForReports)) {
            // Strategies with higher priority need to be executed before the ones with lower priority
            krsort($this-&gt;unsortedRetrieveDataForReports);

            // Flattens strategies by removing the "priority" dimension from the array
            $this-&gt;sortedRetrieveDataForReports = array_merge(...$this-&gt;unsortedRetrieveDataForReports);
        }

        return $this-&gt;sortedRetrieveDataForReports;
    }
}
</code></pre>

<p>Have you heard of the Symfony component EventDispatcher?
While it is a well known implementation of the Observer design pattern,
the way the EventListeners (strategies) are registered and executed in the
EventDispatcher (context) is very similar to this.</p>

<h2 id="configuring-di-in-symfony---yaml">Configuring DI in Symfony - YAML</h2>

<p>Speaking of Symfony, how would we configure the Dependency Injection Container
for this service? First, let's write the YAML configuration:</p>

<pre><code class="yaml">services:
    'EmailDailyReports':
        arguments:
            - '@BuildSpreadsheet'
            - '@Mailer'
            - '@WriteSpreadsheet'
        calls:
            - register:
                - '@RetrieveDataForReportOne'
                - 200
            - register:
                - '@RetrieveDataForReportTwo'
                - 100

    'BuildSpreadsheet': ~
    'Mailer': ~
    'WriteSpreadsheet': ~
    'RetrieveDataForReportOne': ~
    'RetrieveDataForReportTwo': ~
</code></pre>

<p>Note that we need to write the priorities here in the <code>EmailDailyReports</code>
service definition. The <code>calls</code> section is fine for now, as we only have two
Strategies.</p>

<p>But what if we need to add 1 more report? 2 more reports? 30 more reports?</p>

<h2 id="configuring-di-in-symfony---compiler-passes">Configuring DI in Symfony - Compiler Passes</h2>

<p>The entire <code>calls</code> section can be removed from the configuration,
by creating a CompilerPass:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Reference;

class RegisterRetrieveDataForReportsCompilerPass implements CompilerPassInterface
{ 
    public function process(ContainerBuilder $container): void
    {
        // Get Context service definition
        $emailDailyReports = $container-&gt;findDefinition(EmailDailyReports::class);

        // Get iterable of all the Strategy service definitions (they'll be tagged with the Strategy interface FQCN)
        $retrieveDataForReports = $container-&gt;findTaggedServiceIds(RetrieveDataForReport::class);

        foreach ($retrieveDataForReports as $id =&gt; $tags) {
            // In theory you can tag a service many times with the same tag,
            // but in our case here, there'll only be one tag
            foreach ($tags as $retrieveDataForReport) {
                // call the Setter Injection on the Context service definition
                $emailDailyReports-&gt;addMethodCall('register', [
                    new Reference($id),             
                    $retrieveDataForReport['priority'] ?? EmailDailyReports::DEFAULT_PRIORITY,
                ]);            
            }
        }
    }
}
</code></pre>

<p>Also, make sure to register the CompilerPass in the Bundle:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\HttpKernel\Bundle\Bundle;

class MyBundle extends Bundle
{ 
    public function build(ContainerBuilder $container): void
    {
        parent::build($container);      

        $container-&gt;addCompilerPass(new RegisterRetrieveDataForReportsCompilerPass());
    }
}
</code></pre>

<p>Note that now the priorities need to be defined in the tags of the
RetrieveDataForReport service definitions:</p>

<pre><code class="yaml">services:
    'EmailDailyReports':
        arguments:
            - '@BuildSpreadsheet'
            - '@Mailer'
            - '@WriteSpreadsheet'

    'BuildSpreadsheet': ~
    'Mailer': ~
    'WriteSpreadsheet': ~
    'RetrieveDataForReportOne':
        tags:
            - { name: 'RetrieveDataForReport', priority: 200 }
    'RetrieveDataForReportTwo':
        tags:
            - { name: 'RetrieveDataForReport', priority: 100 }
</code></pre>

<p>Defining manually the service definition for every classes in our project is
all fun and games, and having to set tags is fine for now, as we only have two
Strategies.</p>

<p>But what if we need to add 1 more report? 2 more reports? 30 more reports?</p>

<h2 id="configuring-di-in-symfony-5.3---taggediterator">Configuring DI in Symfony (5.3) - TaggedIterator</h2>

<p>Since <a href="https://github.com/symfony/symfony/pull/22295">Symfony 3.3</a>,
the Dependency Injection's autowiring will inject dependencies named after the
type of the service arguments.</p>

<p>This works great for the constructor of <code>EmailDailyReports</code> (note the
conspicuously missing <code>EmailDailyReports</code>, <code>BuildSpreadsheet</code>, <code>Mailer</code> and
<code>WriteSpreadsheet</code>):</p>

<pre><code class="yaml">services:
    _defaults:
        autowire: true

    'RetrieveDataForReportOne':
        tags:
            - { name: 'RetrieveDataForReport', priority: 200 }
    'RetrieveDataForReportTwo':
        tags:
            - { name: 'RetrieveDataForReport', priority: 100 }
</code></pre>

<p>By adding <code>_defaults.autowire: true</code>, we were able to remove 8 lines of configuration!</p>

<p>Then, since <a href="https://github.com/symfony/symfony/pull/39804">Symfony 5.3</a>,
it is possible to automatically tag all the implementations,
by using the <code>#[AutoconfigureTag]</code> attribute on the interface:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\Attribute\AutoconfigureTag;

#[AutoconfigureTag]
interface RetrieveDataForReport
{
    public function fromDatabase(\DateTime $startDate, \DateTime $endDate): array;
    public function getName(): string;
    public static function getDefaultPriority(): int;
}
</code></pre>

<p>This only works if <code>_defaults.autoconfigure</code> is set to <code>true</code> in the config
(note the conspicuously missing <code>RetrieveDataForReportOne</code> and <code>RetrieveDataForReportTwo</code>):</p>

<pre><code class="yaml">services:
    _defaults:
        autowire: true
        autoconfigure: true
</code></pre>

<p>You might have noticed that we've added a <code>public static function getDefaultPriority(): int</code>
method to our interface. Since the priorities configuration is gone from YAML,
the have to be returned by the implementations:</p>

<ul>
<li><code>RetrieveDataForReportOne::getDefaultPriority()</code> needs to return <code>200</code></li>
<li><code>RetrieveDataForReportTwo::getDefaultPriority()</code> needs to return <code>100</code></li>
</ul>

<p>Finally, since <a href="https://github.com/symfony/symfony/pull/40406">Symfony 5.3</a>,
it is also possible to inject an <code>iterator</code> containing all services that have a specific tag,
by using the <code>#[TaggedIterator]</code> attribute. Let's use it in the "Context" class:</p>

<pre><code class="php">&lt;?php

class EmailDailyReports
{
    public function __construct(
        private BuildSpreadsheet $buildSpreadsheet,
        private Mailer $mailer,
        private WriteSpreadsheet $writeSpreadsheet,
        #[TaggedIterator(RetrieveDataForReport::class, defaultPriorityMethod: 'getDefaultPriority')]
        private iterable $retrieveDataForReports,
    ) {
    }

    public function send(\DateTime $startDate, \DateTime $endDate): void
    {
        $email = (new Email())
            -&gt;from('sender@example.com')
            -&gt;to('recipient@example.com')
            -&gt;subject('Daily Reports')
            -&gt;text('Find reports in attached files');

        foreach ($this-&gt;retrieveDataForReports as $retrieveDataForReport) {
            $reportData = $retrieveDataForReport-&gt;fromDatabase($startDate, $endDate);
            $reportName = $retrieveDataForReport-&gt;getReportName();
            $reportSpreadsheet = $this-&gt;buildSpreadsheet-&gt;using($reportData, $reportName);
            $reportFilename = $this-&gt;writeSpreadsheet-&gt;save($reportSpreadsheet);

            $email-&gt;attachFromPath($reportFilename, $reportName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        }

        $this-&gt;mailer-&gt;send($email);
    }
}
</code></pre>

<p>This means we can remove the <code>CompilerPass</code> (and unregister it from the Bundle).</p>

<p>You'll also note that we've removed from <code>EmailDailyReports</code> the following methods:</p>

<ul>
<li><code>register()</code>: the "Strategies" are no longer injected one by one</li>
<li><code>getSortedRetrieveDataForReports()</code>: TaggedIterator supports sorting by priorities,
but it requires the "Strategies" to have a <strong>static</strong> method that returns the priority</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>To sum up:</p>

<ul>
<li>Tag the "Strategy" Interface with the attribute <code>[#AutoconfigureTag]</code></li>
<li>Inject the <code>iterable</code> that contains all tagged "Strategy" implementations
in the "Context"'s constructor with the attribute <code>#[TaggedIterator(&lt;tag&gt;)]</code></li>
<li>Set <code>autowire</code> and <code>autoconfigure</code> parameters to be <code>true</code> in the DIC configuration</li>
</ul>

<p>The use case doesn't demonstrate how to avoid multiple use statements,
but this can be done by adding a "predicate" method to the "Strategy":
this will allow the "Context" to only execute a sub set of the strategies.</p>

<p>It's even possible to only execute the first strategy,
by adding a <code>break</code> in the loop.</p>

<p>I've tried to synthesize as much information as possible at the top of this article,
in the ironically (yet aptly) named "TL;DR" section.</p>

<p>I hope this'll prove useful to you (it'll definitely be for me!).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PragmatiClean - Command Bus]]></title>
            <link href="/2017/09/20/pragmaticlean-command-bus.html"/>
            <updated>2017-09-20T00:00:00+01:00</updated>
            <id>/2017/09/20/pragmaticlean-command-bus.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Use Command Bus pattern in your controllers, but drop the bus.</p>
</blockquote>

<p>The Command Bus pattern relies on 3 types of classes:</p>

<p>The first one is the <em>Command</em>:</p>

<ul>
<li>its class name should describe the intended action in an imperative manner
(eg <code>SubmitNewQuote</code>, <code>AssignReviewers</code>, etc)</li>
<li>it is constructed using the input parameters
(eg a Request's query/post/header parameters, a Console's input argument/option, etc)</li>
<li>it applies "simple" validation on those parameters
(eg parameter type, missing required parameter, etc)</li>
</ul>

<p>Next is the <em>Command Handler</em>:</p>

<ul>
<li>it is dedicated to a single Command
and its class name is its Command's name suffixed with <code>Handler</code></li>
<li>it applies "complex" validation on the Command's parameters
(eg existence of referenced resource, existence of duplicates, etc)</li>
<li>it calls services to apply the actual logic,
reading it should feel like reading the steps of a use case</li>
<li>it shouldn't return anything, to allow asynchronous actions</li>
</ul>

<p>And Finally there's a <em>Command Bus</em> interface allowing us to build Middlewares:</p>

<ol>
<li>we can have a Command Bus that calls the appropriate Command Handler for the given Command</li>
<li>we can have a Command Bus that wraps the above one in a database transaction</li>
<li>we can have a Command Bus that wraps the above ones to log all incoming commands</li>
<li>we can have a Command Bus that wraps the above ones to check permissions</li>
<li>etc</li>
</ol>

<p>Middlewares can do any action we want before and/or after the wrapped Command Bus.
They can be nested in a specific order, allowing us a fine grained control over
how the Command will be handled.</p>

<h2 id="clean-code">Clean Code</h2>

<p>Command Bus can be described as a routing for the domain:
a Command (like a Request) is given to the Command Bus (like a Router)
which is going to call the appropriate Command Handler (like a Controller).</p>

<p>We can use Command Bus in our controller: create the Command using the
Request's inputs, and then take the code that would be in the Controller
and move it in the Command Handler.</p>

<p>This way our Domain logic is decoupled from the Framework. The idea of being
able to switch an application to a different framework might seem ludicrous
(when does that ever happen?), but the truth is that two major versions of
a single framework often feel like having two different frameworks
(eg symony1 V Symfony2) and in some cases it's even the case for minor versions
(eg Symfony 2.0 V Symfony 2.1).</p>

<h2 id="pragmatic-code">Pragmatic Code</h2>

<p>The main point of Command Bus is the possibility to create Middlewares, however
the same thing could be achieved with a good old Event Dispatcher, so let's
ditch the Bus.</p>

<p>The Routing thing should already be done for us by the framework, and it should
be true regardless of the framework or version upgrades. So we can safely inject
Command Handlers directly in Controllers.</p>

<p>Finally, most of the time applications aren't asynchronous. So when it's not
the case it should be OK for the Command Handler to return a value
(eg the created or updated resource).</p>

<h2 id="symfony-example">Symfony Example</h2>

<p>Let's put all this wisdom into practice by creating a Controller allowing us to
submit a code to reset a counter.</p>

<p>First we're going to create the Command, it should contain all the input
parameters, do a simple validation on it and have an
intention revealing name describing the action we'd like to do:</p>

<pre><code class="php">&lt;?php
// File: src/Dharma/Swan/SubmitCode.php;

namespace Dharma\Swan\Code;

class SubmitCode
{
    public $code;

    /**
     * @throws \DomainException If the required "code" parameter is missing
     * @throws \DomainException If the "code" parameter is not a string
     */
    public function __construct($code)
    {
        if (null === $code) {
            throw new \DomainException(
                'Missing required "code" parameter',
                422
            );
        }
        if (!is_string($code)) {
            throw new \DomainException(
                'Invalid "code" parameter: should be a string',
                422
            );
        }
        $this-&gt;code = (string) $code;
    }
}
</code></pre>

<blockquote>
  <p><em>Note 1</em>: Command class attributes are set in the constructor, and then read
  in the Command Handler. Since it's never used anywhere else, there's no point
  creating a getter or setter for it, we can just make those attributes public.</p>
  
  <p><em>Note 2</em>: Commands are going to check the parameters type, so there's no need
  to type hint the constructor arguments (we should allow wrong types so we can
  throw an exception with a helpful message).</p>
  
  <p><em>Note 3:</em> <code>DomainException</code> is the PHP standard exception for application
  errors (eg not found, forbidden, etc). Here we use the code <code>422</code> which is
  the HTTP status code for <code>UNPROCESSABLE ENTITY</code> ("validation failed").
  Our advice is to create custom Application Exceptions that extend
  <code>DomainException</code> and set the right code (eg <code>ValidationFailed</code> with code 422,
  <code>NotFound</code> with code 404, etc).</p>
</blockquote>

<p>The second step is to create the Command Handler. It needs to do more complex
validation, and the actual logic associated to the Command's intention:</p>

<pre><code class="php">&lt;?php
// File: src/Dharma/Swan/SubmitCodeHandler.php;

namespace Dharma\Swan;

use Dharma\Swan\Service\CheckCode;
use Dharma\Swan\Service\ResetCounter;

class SubmitCodeHandler
{
    private $checkCode;
    private $resetCounter;

    public function __construct(
        CheckCode $checkCode,
        ResetCounter $resetCounter
    ) {
        $this-&gt;checkCode = $checkCode;
        $this-&gt;resetCounter = $resetCounter;
    }

    /**
     * @throws \DomainException If the "code" parameter is not a valid code
     */
    public function handle(SubmitCode $submitCode): int
    {
        $this-&gt;checkCode-&gt;check(
            $submitCode-&gt;code
        );
        $newCount = $this-&gt;resetCounter-&gt;reset();

        return $newCount;
    }
}
</code></pre>

<blockquote>
  <p><em>Note 4</em>: Services with descriptive names are injected and used in the
  Command Handler, so that reading the <code>handle</code> methods feels like reading the
  steps of the current use case.</p>
  
  <p><em>Note 5</em>: The <code>CheckCode</code> service will throw a 442 exception if the code is
  invalid (eg if the code is not <code>4 8 15 16 23 42</code>).</p>
  
  <p><em>Note 6</em>: We've decided for <code>ResetCounter</code> to return the new count.
  For an asynchronous application, it wouldn't return anything, neither would
  the Command Handler.</p>
</blockquote>

<p>Finally we can use the Command and Command Handler in our Controller:</p>

<pre><code class="php">&lt;?php
// File: src/Dharma/Swan/Controller/SubmitCodeController.php;

namespace Dharma\Swan\Controller;

use Dharma\Swan\SubmitCode;
use Dharma\Swan\SubmitCodeHandler;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\Request;

class SubmitCodeController
{
    private $submitCodeHandler;

    public function __construct(SubmitCodeHandler $submitCodeHandler)
    {
        $this-&gt;submitCodeHandler = $submitCodeHandler;
    }

    /**
     * @throws \DomainException If the required "code" parameter is missing
     * @throws \DomainException If the "code" parameter is not a string
     * @throws \DomainException If the "code" parameter is not a valid code
     */
    public function submitCode(Request $request): Response
    {
        $newCount = $this-&gt;submitCodeHandler-&gt;handle(new SubmitCode(
            $request-&gt;request-&gt;get('code')
        ));

        return new Response(json_encode(['counter' =&gt; $newCount]), 200, [
            'Content-Type' =&gt; 'application/json',
        ]);
    }
}
</code></pre>

<blockquote>
  <p><em>Note 7</em>: Exceptions should be handled by event listeners, those should log
  important errors and create an appropriate response.</p>
  
  <p><em>Note 8</em>: Some controllers have more than one action meaning they'd be
  injected with more than one Command Handler, however only one will be called
  per Request. Since Symfony 3.3 <a href="https://symfony.com/blog/new-in-symfony-3-3-service-locators">Service Locators</a>
  can be injected so that the controller can only access the listed Command
  Handlers, and only one Command Handler will actually be instantiated.
  Before Symfony 3.3, the Container should be injected (same effect, but all
  services are accessible).</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>Command Bus allows us to decouple our application logic from the framework,
protecting us from Backward Compability Breaking changes.</p>

<p>However since the Bus can be replaced by Event Listeners, we can simply drop it
and inject the Command Handlers directly in Controllers. If our application
isn't asynchronous, then Command Handlers should be able to return values.</p>

<p>So our PragmatiClean Command Bus is simply a Command and Command Handler pair
for each Use Case in our application (so one pair per Controller action).</p>

<blockquote>
  <p>For more resources one the Command Bus design pattern, check these links:</p>
  
  <ul>
  <li><a href="http://shawnmc.cool/command-bus">CommandBus</a>
  by <a href="https://twitter.com/ShawnMcCool">Shawn McCool</a></li>
  <li><a href="https://www.reddit.com/r/PHP/comments/29a6qz/what_am_i_missing_with_this_whole_command_bus/">What am I missing with this whole command bus (reddit question)</a></li>
  <li><a href="http://php-and-symfony.matthiasnoback.nl/tags/SimpleBus/">A wave of command buses (series)</a>
  by <a href="https://twitter.com/matthiasnoback">Matthias Noback</a></li>
  <li><a href="https://speakerdeck.com/richardmiller/avoiding-the-mud">Avoid the Mud (slides)</a>
  by <a href="https://twitter.com/mr_r_miller">Richard Miller</a></li>
  <li><a href="http://verraes.net/2015/01/messaging-flavours/">Messaging Flavours</a>
  and <a href="http://verraes.net/2015/02/form-command-model-validation/">Form, Command, Model validation</a>
  and also <a href="http://verraes.net/2014/05/functional-foundation-for-cqrs-event-sourcing/">Functional Foundation for CQRS/ES</a>
  by <a href="https://twitter.com/mathiasverraes">Mathias Verraes</a></li>
  <li><a href="http://tactician.thephpleague.com/">Tactician</a>, a simple Command Bus library for PHP</li>
  <li><a href="http://www.udidahan.com/2009/12/09/clarified-cqrs/">Clarified CQRS</a>
  by <a href="https://twitter.com/UdiDahan">Udi Dahan</a></li>
  </ul>
  
  <p>Also here are some usage examples, with code and everything:</p>
  
  <ul>
  <li><a href="https://gnugat.github.io/2016/06/15/mars-rover-introduction.html">Mars Rover</a>:
  an application coded chapter after chapter, using this design pattern</li>
  <li><a href="https://gnugat.github.io/2016/03/24/ultimate-symfony-api-example.html">The Ultimate Developer Guide to Symfony</a>
  Examples on how to create an API endpoint, a full stack web page and a console command
  with Symfony and this design pattern</li>
  </ul>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PragmatiClean - introduction]]></title>
            <link href="/2017/09/13/pragmaticlean-introdution.html"/>
            <updated>2017-09-13T00:00:00+01:00</updated>
            <id>/2017/09/13/pragmaticlean-introdution.html</id>
            <content type="html"><![CDATA[<p>There are only 10 types of debates in the software world,
<a href="https://www.amazon.co.uk/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882">Clean Code</a>
v <a href="https://www.amazon.co.uk/Pragmatic-Programmer-Andrew-Hunt/dp/020161622X">Pragmatic Code</a>
and those which don't matter.</p>

<p>In this new series we'll see how to stop wasting time arguing which one is best
and start using both instead.</p>

<h2 id="what%27s-clean-code%3F">What's Clean Code?</h2>

<p>Clean Code is about writing for the long term, usually by structuring it with
the help of Design Patterns and Principles.</p>

<p>The assumption is that everything will change given enough time, be it code or
people, and so things should be easy to understand and easy to change.</p>

<p>The opposite of Clean Code would be "taking shortcuts" to get the job done,
which causes maintenance to become harder and harder over time.</p>

<h2 id="what%27s-pragmatic-code%3F">What's Pragmatic Code?</h2>

<p>Pragmatic Code is about writing for the short term, usually by selecting the
most simple and quickest way to achieve a task.</p>

<p>The assumption is that things need to be done as quickly as possible, and the
simplest solution is always the best.</p>

<p>The opposite of Pragmatic Code would be "over engineering" for the sake of it,
which wastes time, makes the code harder to maintain and also makes it less
efficient.</p>

<h2 id="what%27s-pragmaticlean-code%3F">What's PragmatiClean Code?</h2>

<p>As we can see both school seem diametrically opposed, hence the heated debates.</p>

<p>But both seem to be making good points, so why not try to adopt both?</p>

<p>Pragmatic Programmers don't resent structured code or even Design Patterns and
Principles, what they find aberrant is the over use of them and their misuse.</p>

<p>Clean Coders don't dislike simple solutions and they don't like spending more
time on a task than necessary, what they find abnormal is code that has become
too hard to maintain because it grew more and more out of control over time.</p>

<p>So let's <a href="https://xkcd.com/927/">develop one universal school of thought that covers both</a>:
PragmatiClean. We'll do so by going over the following Design Patterns/Principles
and give them a twist:</p>

<ul>
<li>Command Bus, by dropping the bus</li>
<li>Adapter to decouple from third part libraries, but only the ones that matter</li>
<li>Test Driven Development, by not testing everything</li>
<li>Command/Query Responsibility Segregation, by making it synchronous</li>
<li>Event Sourcing, by skipping the sourcing</li>
</ul>

<p>And to make all this learning applicable, we'll show some Symfony code!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Links from 2016]]></title>
            <link href="/2017/05/24/links-from-2016.html"/>
            <updated>2017-05-24T00:00:00+01:00</updated>
            <id>/2017/05/24/links-from-2016.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Links I tweeted during 2016</p>
</blockquote>

<p>Last year my interests seemed to have been split in three periods:</p>

<ol>
<li>beginning of the year: CQRS / ES and Mono Repo</li>
<li>middle of the year: Event Driven Architecture and async</li>
<li>end of the year: Artificial Intelligence</li>
</ol>

<p>I've also discovered two inspiring talks, I highly recommend you to watch them:</p>

<ul>
<li><a href="http://blog.testdouble.com/posts/2016-09-16-surgical-refactors-with-suture.html">Surgical Refactors</a>
by <a href="https://twitter.com/searls">Justin Searl</a>. It was a follow up of his also awesome previous talk:
<a href="http://blog.testdouble.com/posts/2016-05-09-make-ruby-great-again.html">Make Ruby Great Again</a></li>
<li><a href="https://the-composition.com/software-that-writes-and-evolves-software-953578a6fc36">Software That Writes And Evolves Software</a>
by <a href="https://medium.com/@jessitron">Jessica Kerr</a>, which was then followed by a couple of articles from <a href="https://the-composition.com/@springrod">Rod Johnson</a></li>
</ul>

<p>Apart from that, tons of links, as usual.</p>

<h2 id="cqrs-%2F-es-and-mono-repo">CQRS / ES and Mono Repo</h2>

<ul>
<li><a href="http://verraes.net/2013/12/fighting-bottlenecks-with-cqrs/">Fighting bottlenecks with CQRS</a></li>
<li><a href="http://blog.jonathanoliver.com/cqrs-sagas-with-event-sourcing-part-i-of-ii/">CQRS sagas with Event Sourcing</a></li>
<li><a href="http://blog.sapiensworks.com/post/2016/06/06/practical-event-sourcing-and-cqrs-benefits">Practical Event Sourcing and CQRS benefits</a></li>
<li><a href="http://verraes.net/2014/03/practical-event-sourcing/">Practical Event Sourcing</a></li>
<li><a href="http://gregoryszorc.com/blog/2014/09/09/on-monolithic-repositories/">On Monolithic Repositories</a></li>
<li><a href="https://qafoo.com/talks/15_10_symfony_live_berlin_monorepos.pdf">MonoRepos</a></li>
<li><a href="http://danluu.com/monorepo/">MonoRepo</a></li>
<li><a href="https://carlosbuenosvinos.com/working-at-the-same-time-in-a-project-and-its-dependencies-composer-and-path-type-repository/">Composer and MonoRepo</a></li>
<li><a href="http://www.drmaciver.com/2016/10/why-you-should-use-a-single-repository-for-all-your-companys-projects/">Reasons to use MonoRepos</a></li>
</ul>

<h2 id="generators-%2F-coroutines">Generators / Coroutines</h2>

<ul>
<li><a href="http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html">Cooperative multitasking using coroutines in PHP</a></li>
<li><a href="https://markbakeruk.net/2016/01/19/a-functional-guide-to-cat-herding-with-php-generators/">PHP Generators by example</a></li>
<li><a href="https://blog.pascal-martin.fr/post/php-generators-week.html">PHP Generators week</a></li>
</ul>

<h2 id="event-driven-architecture">Event Driven Architecture</h2>

<p>Because <a href="https://twitter.com/giveupalready/status/731034388406894593">PHP 7 will no wait faster for your database/remote/filesystem calls</a>:</p>

<ul>
<li><a href="https://www.quora.com/What-are-the-differences-between-parallel-concurrent-and-asynchronous-programming">What are the differences between parallel, concurrent and async</a></li>
<li><a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/">Understanding the NodeJs event loop</a></li>
<li><a href="http://stackoverflow.com/questions/14795145/how-the-single-threaded-non-blocking-io-model-works-in-node-js">How the single threaded non blocking I/O model work in NodeJs</a></li>
<li><a href="http://marcjschmidt.de/blog/2016/04/16/php-high-performance-reactphp-jarves-symfony-follow-up.html">PHP-PM follow up</a></li>
<li><a href="https://github.com/AndrewCarterUK/NoMoreLeaksBundle">NoMoreLeaksBundle</a></li>
<li><a href="https://speakerdeck.com/bitone/hunting-down-memory-leaks-with-php-meminfo">Hunting down memory leaks</a></li>
<li><a href="https://speakerdeck.com/clue/t3dd16-pushing-the-limits-with-react-php">Pushing the limits with ReactPHP</a></li>
<li><a href="https://www.reddit.com/r/PHP/comments/2uonkb/reactphp_eventdriven_programming_and_php_as_a/">ReactPHP, Event Driven programming and PHP</a></li>
</ul>

<h2 id="cache">Cache</h2>

<ul>
<li><a href="https://jakearchibald.com/2016/caching-best-practices/">Caching best practices</a></li>
<li><a href="https://www.nginx.com/blog/nginx-caching-guide/">nginx caching guide</a></li>
<li><a href="https://msol.io/blog/tech/youre-probably-wrong-about-caching/">you are probably wrong about caching</a></li>
<li><a href="https://tideways.io/profiler/blog/how-to-implementing-cache-tagging-with-apc-or-memcache-without-hurting-performance">how to implement cache tagging</a></li>
<li><a href="https://jakearchibald.com/2016/caching-best-practices/">caching best practices</a></li>
</ul>

<h2 id="performance">Performance</h2>

<ul>
<li><a href="https://blog.blackfire.io/php-7-performance-improvements-packed-arrays.html">PHP 7 perf improvements: packed arrays</a></li>
<li><a href="https://blog.blackfire.io/php-7-performance-improvements-ints-floats-free.html">PHP 7 perf improvements: ints and floats are free</a></li>
<li><a href="https://tideways.io/profiler/blog/php-session-garbage-collection-the-unknown-performance-bottleneck">PHP garbage collection as a perf bottleneck</a></li>
<li><a href="https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd">Efficient data structures for PHP 7</a></li>
</ul>

<h2 id="symfony">Symfony</h2>

<ul>
<li><a href="https://www.pmg.com/blog/symfony-no-app-dev/">No app.dev</a></li>
<li><a href="https://github.com/symfony/symfony/pull/10356">Double Progress Bar</a></li>
<li><a href="https://blog.fervo.se/blog/2016/02/07/bundle-deps/">Bundle dependencies are not needed</a></li>
</ul>

<h2 id="artificial-intelligence">Artificial Intelligence</h2>

<ul>
<li>"Feel Good" videos to understand Neural Networks:

<ul>
<li><a href="https://brohrer.github.io/deep_learning_demystified.html">Deep Learning demystified</a></li>
<li><a href="https://brohrer.github.io/how_convolutional_neural_networks_work.html">How convolutional neural networks work</a></li>
</ul></li>
<li>Coding a Neural Network from scratch:

<ul>
<li><a href="http://iamtrask.github.io/2015/07/12/basic-python-network/">In 8 lines of Python</a>:</li>
<li><a href="http://iamtrask.github.io/2015/07/27/python-network-part2/">Improving with Gradient Descent</a></li>
<li><a href="https://iamtrask.github.io/2015/07/28/dropout/">Improving with dropout</a></li>
</ul></li>
<li>The Ultimate Developer Guide to Neural Networks:

<ul>
<li><a href="http://neuralnetworksanddeeplearning.com/chap1.html">Recognizing handwritten digits</a></li>
<li><a href="http://neuralnetworksanddeeplearning.com/chap2.html">How backpropagation works</a></li>
<li><a href="http://neuralnetworksanddeeplearning.com/chap3.html">Optimizing backpropagation</a></li>
<li><a href="http://neuralnetworksanddeeplearning.com/chap4.html">Visual proof Neural Networks can compute any functions</a></li>
<li><a href="http://neuralnetworksanddeeplearning.com/chap5.html">Limits of Backpropagation</a></li>
<li><a href="http://neuralnetworksanddeeplearning.com/chap6.html">Deep Neural Networks</a></li>
</ul></li>
<li>Gentle introduction to the maths:

<ul>
<li><a href="https://theclevermachine.wordpress.com/2014/09/11/a-gentle-introduction-to-artificial-neural-networks/">Neural Networks</a></li>
<li><a href="https://theclevermachine.wordpress.com/2014/09/08/derivation-derivatives-for-common-neural-network-activation-functions/">Derivatives of Activation functions</a></li>
<li><a href="https://theclevermachine.wordpress.com/2014/09/06/derivation-error-backpropagation-gradient-descent-for-neural-networks/">Derivative of Error function</a></li>
</ul></li>
<li>Another introduction to the maths

<ul>
<li><a href="http://andrew.gibiansky.com/blog/machine-learning/machine-learning-the-basics/">The basics</a></li>
<li><a href="http://andrew.gibiansky.com/blog/machine-learning/machine-learning-neural-networks/">Neural Networks</a></li>
<li><a href="http://andrew.gibiansky.com/blog/machine-learning/convolutional-neural-networks/">Convolutional Neural Networks</a></li>
<li><a href="http://andrew.gibiansky.com/blog/machine-learning/recurrent-neural-networks/">Recurrent Neural Networks</a></li>
</ul></li>
<li><a href="http://dlacombejr.github.io/2016/11/13/deep-learning-for-regex.html">Replacing regex with Neural Networks</a></li>
<li>bits of maths:

<ul>
<li><a href="http://www.wikihow.com/Take-Derivatives">How to take Derivatives</a></li>
<li><a href="http://matrixmultiplication.xyz/">Matrix Multiplication</a></li>
</ul></li>
</ul>

<h2 id="tests">Tests</h2>

<ul>
<li><a href="http://blog.cleancoder.com/uncle-bob/2016/06/10/MutationTesting.html">Mutation Testing</a></li>
<li><a href="http://blog.eleven-labs.com/en/mutation-testing-check-quality-unit-tests/">Mutation Testing: checking Unit Test quality</a></li>
<li><a href="https://github.com/padraic/humbug">Humbug: Mutation Testing for PHP</a></li>
<li><a href="http://blog.kevingomez.fr/2016/10/23/digging-into-humbug/">Digging into Humbug</a></li>
<li><a href="http://blog.cleancoder.com/uncle-bob/2016/03/19/GivingUpOnTDD.html">Giving up on TDD</a></li>
<li><a href="http://blog.cleancoder.com/uncle-bob/2016/11/10/TDD-Doesnt-work.html">TDD does not work</a></li>
<li><a href="https://8thlight.com/blog/georgina-mcfadyen/2016/06/27/inside-out-tdd-vs-outside-in.html">Inside out TDD VS outside in</a></li>
<li><a href="https://www.maaikebrinkhof.nl/2016/03/repetition-in-testing/">Repetition in testing</a></li>
<li><a href="https://codeahoy.com/2016/04/16/do-not-misuse-code-coverage/">Do not misuse ode coverage</a></li>
<li><a href="https://medium.com/javascript-scene/the-outrageous-cost-of-skipping-tdd-code-reviews-57887064c412">The outrageous cost of skipping TDD and code reviews</a></li>
<li><a href="https://github.com/ciaranmcnulty/driving-design-through-examples/issues/2">Do stubs/mock make tests more fragile?</a></li>
<li><a href="https://martinfowler.com/articles/mocksArentStubs.html">Mocks are not Stubs</a></li>
<li><a href="https://github.com/gnugat/knowledge/commit/9a3ca3b033bcadc2731a90ab309837dffba37ad5#diff-42f16124359ffa9639380e5df80b612fL29">PHPUnit and propecy</a></li>
<li><a href="https://twitter.com/matthieunapoli/status/768388058823725056">Using UTF 8 spaces in test method names</a></li>
</ul>

<h2 id="better-code">Better Code</h2>

<ul>
<li><a href="https://www.ibuildings.nl/blog/2016/01/programming-guidelines-part-1-reducing-complexity">Reducing Complexity</a></li>
<li><a href="https://www.ibuildings.nl/blog/2016/01/programming-guidelines-part-2-getting-rid-null">Getting rid of NULL</a></li>
<li><a href="https://www.ibuildings.nl/blog/2016/02/programming-guidelines-part-3-life-and-death-objects">Life and Death of objects</a></li>
<li><a href="https://www.ibuildings.nl/blog/2016/02/programming-guidelines-part-4-messages">Messages</a></li>
<li><a href="https://qafoo.com/blog/083_never_use_null.html">Never use NULL</a></li>
<li><a href="https://code.joejag.com/2016/anti-if-the-missing-patterns.html">Anti-if: the missing patterns</a></li>
<li><a href="http://hamishdickson.github.io/scala/functional/programming/2016/06/05/you-dont-need-null.html">You do not need NULL</a></li>
<li><a href="http://monospacedmonologues.com/post/138532840924/naming-things">Naming things</a></li>
<li><a href="http://journal.stuffwithstuff.com/2016/06/16/long-names-are-long/">Long names are long</a></li>
<li><a href="https://martinfowler.com/bliki/ValueObject.html">Value Object</a></li>
<li><a href="http://tech.wizaplace.com/posts/organisation-du-code-par-modules-fonctionnels">Organisation du code par modules fonctionnels</a></li>
<li><a href="http://wouterj.nl/2016/12/repositories-are-just-collections/">Repositories are just collections</a></li>
<li><a href="http://tpierrain.blogspot.co.uk/2016/04/hexagonal-layers.html">Hexagonal Layers</a></li>
<li><a href="http://blog.cleancoder.com/uncle-bob/2016/05/01/TypeWars.html">Type Wars</a></li>
<li><a href="https://philsturgeon.uk/api/2016/05/03/put-vs-patch-vs-json-patch/">put VS patch VS json patch</a></li>
<li><a href="http://blog.cleancoder.com/uncle-bob/2016/01/04/ALittleArchitecture.html">A little architecture</a></li>
</ul>

<h2 id="tools">Tools</h2>

<ul>
<li><a href="https://github.com/php-http/httplug">httplug</a></li>
<li><a href="https://github.com/nikic/PHP-Parser/releases/tag/v3.0.0alpha1">PHP Parser v3</a></li>
<li><a href="http://memio.github.io/spec-gen/">spec-gen</a></li>
<li><a href="https://github.com/hirak/prestissimo">Prestissimo</a></li>
<li><a href="http://gnugat.github.io/micro-framework-bundle/">MicroFrameworkBundle</a></li>
<li><a href="http://peteris.rocks/blog/htop/">htop</a></li>
<li><a href="https://jenssegers.com/61/perceptual-image-hashes">Perceptual image hash</a></li>
<li><a href="https://benramsey.com/blog/2016/04/ramsey-uuid/">Ramsey UUID</a></li>
<li><a href="https://memio.github.io/PHP-Printer/">PHP Printer</a></li>
<li><a href="http://psysh.org/">Psysh</a></li>
</ul>

<h2 id="lead-%26-life">Lead &amp; Life</h2>

<ul>
<li><a href="https://www.thoughtworks.com/insights/blog/5-tips-being-effective-tech-lead">5 tips for being an effective tech lead</a></li>
<li><a href="http://ryanbigg.com/2016/04/hiring-juniors">Hiring juniors</a></li>
<li><a href="https://medium.com/@kellan/towards-an-understanding-of-technical-debt-ae0f97cc0553">Towards an understanding of technical debt</a></li>
<li><a href="https://medium.com/@djsmith42/how-to-interview-as-a-developer-candidate-b666734f12dd">How to interview as a developer candidate</a></li>
<li><a href="https://dannorth.net/2016/07/04/how-to-train-your-agile/">How to train your agile</a></li>
<li><a href="https://medium.com/@marlenac/follow-the-leader-de9f79e90e6">Follow the leader</a></li>
<li><a href="https://speakerdeck.com/mcpaccard/guerir-le-burnout-cest-possible-mix-it-2016">Guérir le burnout est possible</a></li>
<li><a href="https://medium.freecodecamp.com/being-a-developer-after-40-3c5dd112210c">Being a developer after 40</a></li>
</ul>

<h2 id="misc">Misc</h2>

<ul>
<li><a href="https://medium.com/@sdboyer/so-you-want-to-write-a-package-manager-4ae9c17d9527">So you want to write a package manager</a></li>
<li><a href="https://daniel.haxx.se/blog/2016/02/18/http-redirects/">HTTP redirects</a></li>
<li><a href="http://vimcasts.org/blog/2013/02/habit-breaking-habit-making/">habit breaking making</a></li>
<li><a href="https://sheerun.net/2014/03/21/how-to-boost-your-vim-productivity/">how to boost your vim productivity</a></li>
<li><a href="https://twitter.com/jxxf/status/742799938501890048">Git v2.9 and improved diff</a></li>
<li><a href="https://github.com/doctrine/doctrine2/pull/5932#issuecomment-233593524">bad YAML are bad</a></li>
<li><a href="https://blog.2ndquadrant.com/thoughts-on-ubers-list-of-postgres-limitations/">Thoughts on Uber list of Postgres limitations</a></li>
<li><a href="https://github.com/gnugat/knowledge/blob/master/cheat-sheets/postgresql.md#jsonb">Postgres JSONB cheat sheet</a></li>
<li><a href="http://annotatiomania.com/">Annotation Mania</a></li>
<li><a href="https://developer.happyr.com/always-use-caret-instead-of-tilde">Always use caret instead of tilde</a></li>
<li><a href="https://githubengineering.com/the-github-graphql-api/">The Github GraphQL API</a></li>
<li><a href="https://fgiesen.wordpress.com/2016/08/07/why-do-cpus-have-multiple-cache-levels/">Why do CPUs have multiple cache levels</a></li>
<li><a href="https://www.sitepoint.com/how-can-the-elk-stack-be-used-to-monitor-php-apps/">How can the ELK stack be used to monitor PHP apps</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Super Speed Symfony - nginx]]></title>
            <link href="/2016/04/20/super-speed-sf-nginx.html"/>
            <updated>2016-04-20T00:00:00+01:00</updated>
            <id>/2016/04/20/super-speed-sf-nginx.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Put a reverse proxy (for HTTP cache or load balancing purpose) in
  front of your application, to increase its performances.</p>
</blockquote>

<p>HTTP frameworks, such as <a href="https://symfony.com/">Symfony</a>, allow us to build
applications that have the <em>potential</em> to achieve Super Speed.</p>

<p>We've already seen a first way to do so (<a href="/2016/04/13/super-speed-sf-react-php.html">by turning it into a HTTP server</a>),
another way would be to put a reverse proxy in front of it.</p>

<p>In this article we'll take a Symfony application and demonstrate how to do so
using <a href="http://nginx.com/">nginx</a>.</p>

<blockquote>
  <p><strong>Note</strong>: those two ways can be combined, or used independently.</p>
</blockquote>

<h2 id="nginx-with-php-fpm">nginx with PHP-FPM</h2>

<p>The regular PHP application set up is with nginx and <a href="http://php-fpm.org/">PHP-FPM</a>:</p>

<pre><code>sudo apt-get install nginx php7.0-fpm
</code></pre>

<p>PHP-FPM is going to run our PHP application in a <a href="https://en.wikipedia.org/wiki/Shared_nothing_architecture">shared-nothing architecture</a>.
We might want it to be run with <a href="http://symfony.com/doc/current/book/installation.html#book-installation-permissions">the same user as the CLI one</a>
to avoid permissions issues:</p>

<pre><code>; /etc/php/7.0/fpm/pool.d/www.conf

; ...

user = foobar
group = foobar

; ...

listen.owner = foobar
listen.group = foobar

; ...
</code></pre>

<p>We should probably do the same for nginx:</p>

<pre><code># /etc/nginx/nginx.conf
user foobar foobar;

# ...
</code></pre>

<p>Now we should be ready to set up a virtual host for our application:</p>

<pre><code># /etc/nginx/sites-available/super-speed-nginx
server {
    listen 80;
    server_name super-speed-nginx.example.com;
    root /home/foobar/super-speed-nginx/web;

    location / {
        # try to serve file directly, fallback to app.php
        try_files $uri /app.php$is_args$args;
    }

    location ~ ^/app\.php(/|$) {
        fastcgi_pass unix:/run/php/php7.0-fpm.sock;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;

        # Prevents URIs that include the front controller. This will 404:
        # http://domain.tld/app.php/some-path
        # Remove the internal directive to allow URIs like this
        internal;
    }

    # Keep your nginx logs with the symfony ones
    error_log /home/foobar/super-speed-nginx/var/logs/nginx_error.log;
    access_log /home/foobar/super-speed-nginx/var/logs/nginx_access.log;
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>:</p>
  
  <ul>
  <li><code>fastcgi_pass</code>: the address of the FastCGI server, can be an IP and port (e.g. <code>127.0.0.1:9000</code> or a socket)</li>
  <li><code>fastcgi_split_path_info</code>: a regex capturing
  
  <ul>
  <li>the script name (here <code>(.+\.php)</code> is a file with the <code>.php</code> extension), used to set <code>$fastcgi_script_name</code></li>
  <li>the path info (here <code>(/.*)</code> is a URL like string), used to set <code>$fastcgi_path_info</code></li>
  </ul></li>
  <li><code>include</code>: includes a file (here <code>/etc/nginx/fastcgi_params</code>)</li>
  <li><code>fastcgi_param</code>: set a FastCGI parameter (check defaults values in <code>/etc/nginx/fastcgi_params</code>)</li>
  </ul>
</blockquote>

<p>Then we'll make sure it's enabled:</p>

<pre><code>sudo ln -s /etc/nginx/sites-available/super-speed-nginx /etc/nginx/sites-enabled/super-speed-nginx
</code></pre>

<p>The only thing missing is a Symfony application! Let's create one using the
<a href="https://github.com/symfony/symfony-standard">Standard Edition</a>:</p>

<pre><code>composer create-project symfony/framework-standard-edition super-speed-nginx
cd super-speed-nginx
SYMFONY_ENV=prod SYMFONY_DEBUG=0 composer install -o --no-dev
</code></pre>

<p>Finally, we can set up the domain name and restart nginx:</p>

<pre><code>echo '127.0.0.1 super-speed-nginx.example.com' | sudo tee --append /etc/hosts
sudo service nginx restart
</code></pre>

<p>Let's check if it works: <a href="http://super-speed-nginx.example.com/">http://super-speed-nginx.example.com/</a>.
If a helpful "Welcome" message is displayed, then everything is fine.</p>

<blockquote>
  <p><strong>Note</strong>: If it doesn't work, check the logs:</p>
  
  <ul>
  <li>application ones in <code>/home/foobar/super-speed-nginx/var/logs</code></li>
  <li>nginx ones in <code>/var/log/nginx</code></li>
  <li>PHP-FPM ones in <code>/var/log/php7.0-fpm.log</code></li>
  </ul>
</blockquote>

<p>Let's have a quick benchmark:</p>

<pre><code>curl 'http://super-speed-nginx.example.com/'
ab -t 10 -c 10 'http://super-speed-nginx.example.com/'
</code></pre>

<p>The result:</p>

<ul>
<li>Requests per second: 146.86 [#/sec] (mean)</li>
<li>Time per request: 68.091 [ms] (mean)</li>
<li>Time per request: 6.809 [ms] (mean, across all concurrent requests)</li>
</ul>

<h2 id="http-cache">HTTP cache</h2>

<p>Compared to <a href="https://httpd.apache.org/">Apache2</a>, nginx performs better at
serving static files and when under high traffic (<a href="https://www.nginx.com/blog/nginx-vs-apache-our-view/">see why</a>).</p>

<p>But our main interest here is in nginx's HTTP caching features.</p>

<p>Applications built with HTTP frameworks (e.g. Symfony) benefit from the HTTP cache
specification, all they need is to add some headers to their response:</p>

<ul>
<li><code>Cache-Control: max-age=60</code> will ask <em>caches</em> to keep a copy for 60 seconds after receiving the response</li>
<li><code>Expires: Fri, 30 Oct 1998 14:19:41 GMT</code> will ask <em>caches</em> to keep a copy of the response until the given date</li>
<li><code>Last-Modified: Tue, 8 Sep 2015 13:35:23 GMT</code> allows <em>caches</em> to keep a copy and check later in the background if there's a more recent "last modified" date</li>
<li><code>Etag: a3e455afd</code> allows <em>caches</em> to keep a copy and check later in the background if there's a different "etag" (<em>e</em>ntity <em>tag</em>)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: For more information about those headers, check this <a href="/2015/11/26/http-cache.html">HTTP cache article</a>.</p>
</blockquote>

<p>Since nginx sits between clients (e.g. browsers) and the application, it can act
as the <em>cache</em>:</p>

<ul>
<li>if the request doesn't match any copies, ask the application to create a response and make a copy of it (that's a MISS scenario)</li>
<li>if the request matches a fresh copy return it, the application does nothing here (that's a HIT scenario)</li>
<li>if the request matches a stale copy return it, and in the background ask the application to create a response to replace the copy with a fresh one (that's an UPDATING scenario, only if configured)</li>
</ul>

<p>It can even serve stale data when the application is failing (e.g. 500 errors)!</p>

<p>To make use of this feature, we first need to set up nginx:</p>

<pre><code># /etc/nginx/nginx.conf

# ...

http {
    proxy_cache_path /home/foobar/super-speed-nginx/var/nginx levels=1:2 keys_zone=super-speed-nginx:10m max_size=10g inactive=60m use_temp_path=off;

    # ...
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>:</p>
  
  <ul>
  <li><code>levels</code>: sets up the directory depth in the cache folder, <code>2</code> is recommended
  as putting all files in one directory could slow it down</li>
  <li><code>keys_zone</code>: sets up an in memory store for cache keys, to avoid avoid fetching
  them from the disk (cache name associated to the memory size to use)</li>
  <li><code>max-size</code>: sets up the maximum disk size of the cache, when this limit is
  reached least used copies are removed</li>
  <li><code>inactive</code>: sets up the time after which an unused copy can be removed</li>
  <li><code>use_temp_path</code>: enables / disables writing cached copies to a temporary path
  before they're moved to the permanent one, <code>off</code> is recommended to avoid
  unecessary filesystem operations</li>
  </ul>
</blockquote>

<p>Then we need to edit the virtual host by changing the port from <code>80</code> to something
else (e.g. <code>8042</code>) and add a "cache server" in front of it (the cache server will
listen to port <code>80</code>, it's the one exposed to clients):</p>

<pre><code># /etc/nginx/sites-available/super-speed-nginx
server {
    listen 80;
    server_name super-speed-nginx.example.com;

    location / {
        proxy_pass http://super-speed-nginx.example.com:8042;

        proxy_cache super-speed-nginx;
        proxy_cache_key "$scheme://$host$request_uri";
        proxy_cache_lock on;
        proxy_cache_use_stale updating error timeout http_500 http_502 http_503 http_504;
        add_header X-Cache $upstream_cache_status;
    }

    # Keep your nginx logs with the symfony ones
    error_log /home/foobar/super-speed-nginx/var/logs/nginx_cache_error.log;
    access_log /home/foobar/super-speed-nginx/var/logs/nginx_cache_access.log;
}

server {
    listen 8042;
    server_name super-speed-nginx.example.com;
    root /home/foobar/super-speed-nginx/web;

    location / {
        # try to serve file directly, fallback to app.php
        try_files $uri /app.php$is_args$args;
    }

    location ~ ^/app\.php(/|$) {
        fastcgi_pass unix:/run/php/php7.0-fpm.sock;
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;

        # Prevents URIs that include the front controller. This will 404:
        # http://domain.tld/app.php/some-path
        # Remove the internal directive to allow URIs like this
        internal;
    }

    # Keep your nginx logs with the symfony ones
    error_log /home/foobar/super-speed-nginx/var/logs/nginx_error.log;
    access_log /home/foobar/super-speed-nginx/var/logs/nginx_access.log;
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>:</p>
  
  <ul>
  <li><code>proxy_pass</code>: the address of the server we'd like to forward the requests to</li>
  <li><code>proxy_cache</code>: sets up the name of the cache, it echoes the one used in <code>keys_zone</code></li>
  <li><code>proxy_cache_key</code>: key used to store the copy (the result is converted to md5)</li>
  <li><code>proxy_cache_lock</code>: enables / disables concurent cache writing for a given key</li>
  <li><code>proxy_cache_use_stale</code>: sets up usage of a stale copy
  
  <ul>
  <li><code>updating</code> when the copy is being refreshed</li>
  <li><code>error</code>, <code>timeout</code>, <code>http_5**</code> when the application fails</li>
  </ul></li>
  <li><code>add_header</code>: adds a header to the HTTP Response
  (e.g. the value of <code>$upstream_cache_status</code> which could be <code>MISS</code>, <code>HIT</code>, <code>EXPIRED</code>, etc)</li>
  </ul>
</blockquote>

<p>Now it's the turn of our application. By default Symfony set a
<code>Cache-Control: no-cache</code> header to all responses. Let's change it:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/DefaultController.php

namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Cache;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;

class DefaultController extends Controller
{
    /**
     * @Route("/", name="homepage")
     * @Cache(maxage="20", public=true)
     */
    public function indexAction(Request $request)
    {
        // replace this example code with whatever you need
        return $this-&gt;render('default/index.html.twig', [
            'base_dir' =&gt; realpath($this-&gt;getParameter('kernel.root_dir').'/..'),
        ]);
    }
}
</code></pre>

<p>To apply those changes, restart nginx and clear symfony cache:</p>

<pre><code>sudo service nginx restart
bin/console cache:clear -e=prod --no-debug
</code></pre>

<p>Now we can check the Response's headers:</p>

<pre><code>curl -I 'http://super-speed-nginx.example.com/'
curl -I 'http://super-speed-nginx.example.com/'
</code></pre>

<p>The first one should contain a <code>X-Cache</code> header set to <code>MISS</code>, while the second
one should be set to <code>HIT</code>.</p>

<p>Let's have a quick benchmark:</p>

<pre><code>curl 'http://super-speed-nginx.example.com/'
ab -t 10 -c 10 'http://super-speed-nginx.example.com/'
</code></pre>

<p>The result:</p>

<ul>
<li>Requests per second: 21994.33 [#/sec] (mean)</li>
<li>Time per request: 0.455 [ms] (mean)</li>
<li>Time per request: 0.045 [ms] (mean, across all concurrent requests)</li>
</ul>

<p>That's around <strong>140</strong> times faster than without cache.</p>

<h2 id="load-balancing">Load balancing</h2>

<p>In the above examples, we've seen some usage of <code>proxy_pass</code> in nginx. It allows
the proxy to forward the request to an "upstream" server (e.g. PHP-FPM).</p>

<p>By providing many upstream servers for one <code>proxy_pass</code>, we enable nginx's load
balancing which can be useful with the ReactPHP set up from the previous article
for example:</p>

<pre><code># /etc/nginx/sites-available/super-speed-nginx
upstream backend  {
    server 127.0.0.1:5500 max_fails=1 fail_timeout=5s;
    server 127.0.0.1:5501 max_fails=1 fail_timeout=5s;
    server 127.0.0.1:5502 max_fails=1 fail_timeout=5s;
    server 127.0.0.1:5503 max_fails=1 fail_timeout=5s;
}

server {
    root /home/foobar/bench-sf-standard/web/;
    server_name localhost;

    location / {
        try_files $uri @backend;
    }

    location @backend {
        proxy_pass http://backend;
        proxy_next_upstream http_502 timeout error;
        proxy_connect_timeout 1;
        proxy_send_timeout 5;
        proxy_read_timeout 5;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>:</p>
  
  <ul>
  <li><code>proxy_next_upstream</code>: conditions to satisfy in order to forward the request to another server (here errors and timeouts)</li>
  <li><code>proxy_connect_timeout</code>: maximum time when trying to connect to an upstream server</li>
  <li><code>proxy_send_timeout</code>: maximum time when trying to send data to an upstream server</li>
  <li><code>proxy_read_timeout</code>: maximum time when trying to read data from an upstream server</li>
  </ul>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>With a reverse proxy such as nginx, we can decrease the number of calls to our
applications by:</p>

<ul>
<li>enabling HTTP caching (add a HTTP header to responses, use ~50 lines of configuration)</li>
<li>enabling load balancing (use ~30 lines of configuration)</li>
</ul>

<p>This results in a drastic reduction of response time from the point of view of
the client.</p>

<p>Resources:</p>

<ul>
<li><a href="https://www.nginx.com/resources/wiki/start/topics/examples/phpfcgi/">nginx, PHP FastCGI Example</a></li>
<li><a href="https://www.nginx.com/blog/nginx-caching-guide/">nginx a guide to caching</a></li>
<li><a href="https://www.nginx.com/blog/benefits-of-microcaching-nginx/">The Benefits of Microcaching with nginx</a></li>
<li><a href="https://speakerdeck.com/thijsferyn/varnish-or-nginx-symfony-live">Varnish or nginx?</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Super Speed Symfony - ReactPHP]]></title>
            <link href="/2016/04/13/super-speed-sf-react-php.html"/>
            <updated>2016-04-13T00:00:00+01:00</updated>
            <id>/2016/04/13/super-speed-sf-react-php.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Run your application as a HTTP server to increase its performances.</p>
</blockquote>

<p>HTTP frameworks, such as <a href="https://symfony.com/">Symfony</a>, allow us to build
applications that have the <em>potential</em> to achieve Super Speed.</p>

<p>A first way to make use of it is to run our application as a HTTP server.
In this article we'll take a Symfony application and demonstrate how to run it
as HTTP server using <a href="http://reactphp.org/">ReactPHP</a>.</p>

<h2 id="reactphp-http-server">ReactPHP HTTP server</h2>

<p>We're going to use ReactPHP's <a href="https://github.com/reactphp/http">HTTP component</a>:</p>

<pre><code>composer require react/http:^0.5@dev
</code></pre>

<p>It helps us build HTTP servers:</p>

<pre><code class="php">#!/usr/bin/env php
&lt;?php
// bin/react.php

require __DIR__.'/../vendor/autoload.php';

$loop = React\EventLoop\Factory::create();
$socket = new React\Socket\Server($loop);
$http = new React\Http\Server($socket);

$callback = function ($request, $response) {
};

$http-&gt;on('request', $callback);
$socket-&gt;listen(1337);
$loop-&gt;run();
</code></pre>

<p>Starting from the last line, we have:</p>

<ul>
<li><code>$loop-&gt;run()</code>: makes our HTTP server run inside an infinite loop (that's how long running processes work)</li>
<li><code>$socket-&gt;listen(1337)</code>: opens a socket by listening to a port (that's how servers work)</li>
<li><code>$http-&gt;on('request', $callback)</code>: for each HTTP Request received, executes the given callback</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: HTTP servers usually use the <code>80</code> port, but nothing prevents us from
  using a different one. Since there might be some HTTP servers already running
  on our computers (e.g. Apache or nginx), we'll use <code>1337</code> in our examples to
  avoid conflicts.</p>
</blockquote>

<h2 id="hello-world-example">Hello World example</h2>

<p>The application logic has to be written in the callback. For example, here's how
to write a <code>Hello World!</code>:</p>

<pre><code class="php">#!/usr/bin/env php
&lt;?php
// bin/react.php

require __DIR__.'/../vendor/autoload.php';

$loop = React\EventLoop\Factory::create();
$socket = new React\Socket\Server($loop);
$http = new React\Http\Server($socket);

$callback = function ($request, $response) {
    $statusCode = 200;
    $headers = array(
        'Content-Type: text/plain'
    );
    $content = 'Hello World!';

    $response-&gt;writeHead($statusCode, $headers);
    $response-&gt;end($content);
};

$http-&gt;on('request', $callback);
$socket-&gt;listen(1337);
$loop-&gt;run();
</code></pre>

<p>If we run it now:</p>

<pre><code>php bin/react.php
</code></pre>

<p>Then we can visit the page at <a href="http://localhost:1337/">http://localhost:1337/</a>,
and see a <code>Hello World!</code> message: it works!</p>

<h2 id="symfony-example">Symfony example</h2>

<p>Let's recreate the same project, but using the Symfony Standard Edition:</p>

<pre><code>composer create-project symfony/framework-standard-edition super-speed
cd super-speed
composer require react/http:^0.5@dev --ignore-platform-reqs
</code></pre>

<p>Since Symfony is a HTTP framework, wrapping it inside the callback is quite
natural. We only need to:</p>

<ol>
<li>convert the ReactPHP request to a Symfony one</li>
<li>call a <code>HttpKernelInterface</code> implementation to get a Symfony response</li>
<li>convert the Symfony response to a ReactPHP one</li>
</ol>

<p>As we can see, this is quite straightforward:</p>

<pre><code class="php">#!/usr/bin/env php
&lt;?php
// bin/react.php

require __DIR__.'/../app/autoload.php';

$kernel = new AppKernel('prod', false);
$callback = function ($request, $response) use ($kernel) {
    $method = $request-&gt;getMethod();
    $headers = $request-&gt;getHeaders();
    $query = $request-&gt;getQuery();
    $content = $request-&gt;getBody();
    $post = array();
    if (in_array(strtoupper($method), array('POST', 'PUT', 'DELETE', 'PATCH')) &amp;&amp;
        isset($headers['Content-Type']) &amp;&amp; (0 === strpos($headers['Content-Type'], 'application/x-www-form-urlencoded'))
    ) {
        parse_str($content, $post);
    }
    $sfRequest = new Symfony\Component\HttpFoundation\Request(
        $query,
        $post,
        array(),
        array(), // To get the cookies, we'll need to parse the headers
        $request-&gt;getFiles(),
        array(), // Server is partially filled a few lines below
        $content
    );
    $sfRequest-&gt;setMethod($method);
    $sfRequest-&gt;headers-&gt;replace($headers);
    $sfRequest-&gt;server-&gt;set('REQUEST_URI', $request-&gt;getPath());
    if (isset($headers['Host'])) {
        $sfRequest-&gt;server-&gt;set('SERVER_NAME', explode(':', $headers['Host'])[0]);
    }
    $sfResponse = $kernel-&gt;handle($sfRequest);

    $response-&gt;writeHead(
        $sfResponse-&gt;getStatusCode(),
        $sfResponse-&gt;headers-&gt;all()
    );
    $response-&gt;end($sfResponse-&gt;getContent());
    $kernel-&gt;terminate($request, $response);
};

$loop = React\EventLoop\Factory::create();
$socket = new React\Socket\Server($loop);
$http = new React\Http\Server($socket);

$http-&gt;on('request', $callback);
$socket-&gt;listen(1337);
$loop-&gt;run();
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Request conversion code from React to Symfony has been borrowed from
  <a href="https://github.com/M6Web/PhpProcessManagerBundle/blob/dcb7d971250ec504821dca040e6e2effbdb5adc5/Bridge/HttpKernel.php#L102">M6Web PhpProcessManagerBundle</a>.</p>
</blockquote>

<p>And as easy as that, we can run it:</p>

<pre><code>php bin/react.php
</code></pre>

<p>Finally we can visit the page at <a href="http://localhost:1337/">http://localhost:1337/</a>,
and see a helpful <code>Welcome</code> message: it works!</p>

<h2 id="benchmarking-and-profiling">Benchmarking and Profiling</h2>

<p>It's now time to check if we've achieved our goal: did we improve performances?</p>

<h3 id="regular-version">Regular version</h3>

<p>In order to find out, we can first benchmark the regular Symfony application:</p>

<pre><code>SYMFONY_ENV=prod SYMFONY_DEBUG=0 composer install -o --no-dev --ignore-platform-reqs
php -S localhost:1337 -t web&amp;
curl 'http://localhost:1337/app.php/'
ab -c 1 -t 10 'http://localhost:1337/app.php/'
</code></pre>

<p>We get the following results:</p>

<ul>
<li>Requests per second: 273.76 #/sec</li>
<li>Time per request: 3.653 ms</li>
</ul>

<p>We can also profile the application using <a href="http://blackfire.io/">Blackfire</a> to
discover bottlenecks:</p>

<pre><code>blackfire curl 'http://localhost:1337/app.php/'
killall -9 php
</code></pre>

<p>We get the following results:</p>

<ul>
<li>Wall Time: 12.5ms</li>
<li>CPU Time: 11.4ms</li>
<li>I/O Time: 1.09ms</li>
<li>Memory: 2.2MB</li>
</ul>

<p>Let's have a look at the graph:</p>

<iframe width="960px" height="960px" frameborder="0" allowfullscreen src="https://blackfire.io/profiles/53f653ad-1770-4c89-93c4-1ff758b2b29e/embed"></iframe>

<p>As expected from an empty application without any logic, we can clearly see that
autoloading is the number 1 bottleneck, with the Dependency Injection Container
being its main caller (for which the EventDispatcher is the main caller).</p>

<h3 id="reactphp-version">ReactPHP version</h3>

<p>Before we continue our benchmarks for the ReactPHP version of our application,
we'll need to modify it a bit in order to support Blackfire:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// bin/react.php

require __DIR__.'/../app/autoload.php';

$kernel = new AppKernel('prod', false);
$callback = function ($request, $response) use ($kernel) {
    $method = $request-&gt;getMethod();
    $headers = $request-&gt;getHeaders();
    $enableProfiling = isset($headers['X-Blackfire-Query']);
    if ($enableProfiling) {
        $blackfire = new Blackfire\Client();
        $probe = $blackfire-&gt;createProbe();
    }
    $query = $request-&gt;getQuery();
    $content = $request-&gt;getBody();
    $post = array();
    if (in_array(strtoupper($method), array('POST', 'PUT', 'DELETE', 'PATCH')) &amp;&amp;
        isset($headers['Content-Type']) &amp;&amp; (0 === strpos($headers['Content-Type'], 'application/x-www-form-urlencoded'))
    ) {
        parse_str($content, $post);
    }
    $sfRequest = new Symfony\Component\HttpFoundation\Request(
        $query,
        $post,
        array(),
        array(), // To get the cookies, we'll need to parse the headers
        $request-&gt;getFiles(),
        array(), // Server is partially filled a few lines below
        $content
    );
    $sfRequest-&gt;setMethod($method);
    $sfRequest-&gt;headers-&gt;replace($headers);
    $sfRequest-&gt;server-&gt;set('REQUEST_URI', $request-&gt;getPath());
    if (isset($headers['Host'])) {
        $sfRequest-&gt;server-&gt;set('SERVER_NAME', explode(':', $headers['Host'])[0]);
    }
    $sfResponse = $kernel-&gt;handle($sfRequest);

    $response-&gt;writeHead(
        $sfResponse-&gt;getStatusCode(),
        $sfResponse-&gt;headers-&gt;all()
    );
    $response-&gt;end($sfResponse-&gt;getContent());
    $kernel-&gt;terminate($request, $response);
    if ($enableProfiling) {
        $blackfire-&gt;endProbe($probe);
    }
};

$loop = React\EventLoop\Factory::create();
$socket = new React\Socket\Server($loop);
$http = new React\Http\Server($socket);

$http-&gt;on('request', $callback);
$socket-&gt;listen(1337);
$loop-&gt;run();
</code></pre>

<p>This requires Blackfire's SDK:</p>

<pre><code>SYMFONY_ENV=prod SYMFONY_DEBUG=0 composer require -o --update-no-dev --ignore-platform-reqs 'blackfire/php-sdk'
</code></pre>

<p>Now let's run the benchmarks:</p>

<pre><code>php bin/react.php&amp;
curl 'http://localhost:1337/'
ab -c 1 -t 10 'http://localhost:1337/'
</code></pre>

<p>We get the following results:</p>

<ul>
<li>Requests per second: 2098.17 #/sec</li>
<li>Time per request: 0.477 ms</li>
</ul>

<p>Finally we can profile it:</p>

<pre><code>curl -H 'X-Blackfire-Query: enable' 'http://localhost:1337/'
killall -9 php
</code></pre>

<p>We get the following results:</p>

<ul>
<li>Wall Time: 1.51ms</li>
<li>CPU Time: 1.51ms</li>
<li>I/O Time: 0.001ms</li>
<li>Memory: 0.105MB</li>
</ul>

<p>Let's have a look at the graph:</p>

<iframe width="960px" height="960px" frameborder="0" allowfullscreen src="https://blackfire.io/profiles/2ca1084f-ce66-4073-b2b8-4a82ed7e4c76/embed"></iframe>

<p>This time we can see that most of the time is spent in event listeners, which is
expected since that's the only lace in our empty application where there's any
logic.</p>

<h3 id="comparison">Comparison</h3>

<p>There's no denial, we've made use of our <em>potential</em> to achieve Super Speed: by
converting our application into a HTTP server using ReactPHP we improved our
Symfony application by <strong>8</strong>!</p>

<h2 id="alternatives-to-reactphp">Alternatives to ReactPHP</h2>

<p>After running some silly benchmarks, we've picked ReactPHP as it was seemingly
yielding better results:</p>

<p><img src="/images/super-speed-sf-react-php-graph.png" alt="ReactPHP is faster than Aerys which is faster than IcicleIO which is faster than PHP FastCGI" /></p>

<p>However since we don't actually make use of the <em>true</em> potential of any of those
projects, it's worth mentioning them and their differences:</p>

<ul>
<li><a href="http://phpfastcgi.github.io">PHPFastCGI</a> aims at building a long running FastCGI application, rather than a HTTP server
(see <a href="http://andrewcarteruk.github.io/slides/breaking-boundaries-with-fastcgi/">Breaking Boundaries with FastCGI</a>)</li>
<li><a href="http://icicle.io/">IcicleIO</a> Icicle is a library for writing asynchronous code using synchronous coding techniques,
it's powered by Generators/Coroutines</li>
<li><a href="http://amphp.org/">Amp</a> is a non-blocking concurrency framework
(see <a href="http://blog.kelunik.com/2015/09/20/getting-started-with-amp.html">Getting started with Amp</a>)

<ul>
<li>its Application Server component, <a href="http://amphp.org/docs/aerys/">Aerys</a>, also supports HTTP/2
(see <a href="http://blog.kelunik.com/2015/10/21/getting-started-with-aerys.html">Getting started with Aerys</a>)</li>
</ul></li>
</ul>

<p>Not mentioned in the graph, there's also:</p>

<ul>
<li><a href="http://appserver.io/">appserver.io</a> a full Application Server, powered by threads
(see <a href="http://www.sitepoint.com/appserver-a-production-ready-php-based-server/">Appserver – a Production-Ready PHP-Based Server</a>)

<ul>
<li>benchmarks showed it was actually slower than vanilla Symfony, which might be due to configuration issues</li>
</ul></li>
<li><a href="https://github.com/php-pm/php-pm">PHP-PM</a>, manages ReactPHP processes
(see <a href="http://marcjschmidt.de/blog/2014/02/08/php-high-performance.html">Bring High Performance Into Your PHP App</a>)

<ul>
<li>benchmarks showed it wasn't much faster than vanilla Symfony, which might be due to configuration issues</li>
</ul></li>
<li><a href="https://github.com/M6Web/PhpProcessManagerBundle">M6Web PHP process manager Bundle</a>,
provides your Symfony application as a ReactPHP server via a command

<ul>
<li>benchmarks showed it was a bit slower than vanilla ReactPHP</li>
</ul></li>
</ul>

<blockquote>
  <p><strong>Note</strong>: To check the benchmarks, have a look at <a href="https://github.com/gnugat-examples/bench-sf-standard">Bench Symfony Standard</a>.
  Each project has its own branch with the set up used and the benchmarks results.</p>
</blockquote>

<h2 id="why-does-reactphp-improve-performances%3F">Why does ReactPHP improve performances?</h2>

<p>To understand how turning our application into a HTTP server can increase
performances, we have to take a look how the alternative works. In a regular
stack (e.g. "Apache / mod_php" or "nginx / PHP-FPM"), for each HTTP request:</p>

<ol>
<li>a HTTP server (e.g. Apache, nginx, etc) receives the Request</li>
<li>it starts a new PHP process, <a href="http://php.net/manual/en/language.variables.superglobals.php">variable super globals</a>,
(e.g. <code>$_GET</code>, <code>$_POST</code>, etc) are created using data from the Request</li>
<li>the PHP process executes our code and produces an output</li>
<li>the HTTP server uses the output to create a Response, and <strong>terminates the PHP process</strong></li>
</ol>

<p>Amongst the advantages this brings, we can list not having to worry (too much) about:</p>

<ul>
<li>memory consumption: each new process starts with a fresh empty memory which is freed once it exits (memory leaks can be ignored)</li>
<li>fatal errors: a process crashing won't affect other processes (but if they encounter the same error they'll also crash)</li>
<li>statefullness: static and global variables are not shared between processes</li>
<li>code updates: each new process starts with the new code</li>
</ul>

<p>Killing the PHP process once the Response is sent means that nothing is shared
between two Requests (hence the name "shared-nothing" architecture).</p>

<p>One of the biggest disadvantages of such a set up is low performance., because
creating a PHP process for each HTTP Requests means adding a bootstraping footprint
which includes:</p>

<ul>
<li>starting a process</li>
<li>starting PHP (loading configuration, starting extensions, etc)</li>
<li>starting our application (loading configuration, initializing services, autoloading, etc)</li>
</ul>

<p>With ReactPHP we keep our application alive between requests so we only execute
this bootstrap once when starting the server: the footprint is absent from Requests.</p>

<p>However now the tables are turned: we're vulnerable to memory consumption, fatal error,
statefulness and code update worries.</p>

<h2 id="making-reactphp-production-ready">Making ReactPHP production ready</h2>

<p>So turning our application into a HTTP server means that way have to be mindful
developers: we have to make it stateless and we need to restart the server for
each updates.</p>

<p>Regarding fatal errors and memory consumption, there is a simple strategy to we
can use to mitigate their impact: automatically restart the server once it's stopped.</p>

<p>That's usually a feature included in load balancers (for example in PHP-PM, Aerys
and appserver.io), but we can also rely on <a href="http://supervisord.org/">Supervisord</a>.</p>

<p>On Debian based distributions it can easily be installed:</p>

<pre><code>sudo apt-get install -y supervisor
</code></pre>

<p>Here's a configuration example (create a <code>*.conf</code> file in <code>/etc/supervisord/conf.d</code>):</p>

<pre><code>[program:bench-sf-standard]
command=php bin/react.php
environment=PORT=55%(process_num)02d
process_name=%(program_name)s-%(process_num)d
numprocs=4
directory=/home/foobar/bench-sf-standard
umask=022
user=foobar
stdout_logfile=/var/log/supervisord/%(program_name)s-%(process_num)d.log              ; stdout log path, NONE for none; default AUTO
stderr_logfile=/var/log/supervisord/%(program_name)s-%(process_num)d-error.log        ; stderr log path, NONE for none; default AUTO
autostart=true
autorestart=true
startretries=3
</code></pre>

<p>It will:</p>

<ul>
<li>run 4 ReactPHP servers on ports <code>5500</code>, <code>5501</code>, <code>5502</code> and <code>5503</code></li>
<li>it restarts them automatically when they crash (will try a maximum of 3 times, then give up)</li>
</ul>

<p>Here's a nice resource for it: <a href="https://serversforhackers.com/monitoring-processes-with-supervisord">Monitoring Processes with Supervisord</a>.</p>

<p>While PHP itself doesn't leak memory, our application might. The more memory a PHP
application uses, the slower it will get, until it reaches the limit and crashes.
As a safeguard, we can:</p>

<ul>
<li>stop the server after X requests (put a counter in the callback and once the server stops, Supervisord will restart a new one)</li>
<li>stop the server once a given memory limit is reached (then supervisord will restart a new one)</li>
</ul>

<p>But a better way would be to actually <a href="https://speakerdeck.com/bitone/hunting-down-memory-leaks-with-php-meminfo">hunt down memoy leaks, for example with PHP meminfo</a>.</p>

<p>We also need to know a bit more about the tools we use such as Doctrine ORM or
Monolog to avoid pitfalls (or use <a href="https://github.com/LongRunning/LongRunning#longrunning">the LongRunning library</a>
to clean those automatically for us).</p>

<h2 id="conclusion">Conclusion</h2>

<p>It only takes ~50 lines to turn our application into a HTTP server, ReactPHP is
indeed a powerful library.</p>

<p>In fact we haven't even used its main features and still managed to greatly
improve performances! But these will be the subject of a different article.</p>

<blockquote>
  <p><strong>Note</strong>: Read-only APIs are a good candidate for such a set up.</p>
</blockquote>

<p>In the next blog post, we'll have a look at a different way (not that we can't
combine both) to achieve the Super Speed potential of our applications built
with HTTP frameworks like Symfony.</p>

<p>In the meantime, here's some resources about turning our applications into HTTP
applications:</p>

<ul>
<li><a href="http://phpfastcgi.github.io/general/2015/08/21/things-to-consider-using-phpfastcgi.html">Things to consider when developing an application with PHPFastCGI</a></li>
<li><a href="https://www.symfony.fi/entry/running-symfony-applications-with-php-pm">Running Symofny applications with PHP-PM or PHPFastCGI</a></li>
<li><a href="https://www.youtube.com/watch?v=gpNbmEnRLBU">Fabien Potencier's take on PHP</a></li>
<li><a href="http://marcjschmidt.de/blog/2016/04/16/php-high-performance-reactphp-jarves-symfony-follow-up.html">PHP High-Performance - Follow Up with Symfony/Jarves.io and PHP-PM</a></li>
<li><a href="https://mwop.net/blog/2016-04-17-react2psr7.html">Serve PSR-7 Middleware Via React</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - CLI Example]]></title>
            <link href="/2016/04/06/ultimate-symfony-cli-example.html"/>
            <updated>2016-04-06T00:00:00+01:00</updated>
            <id>/2016/04/06/ultimate-symfony-cli-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Practice makes Better.</p>
</blockquote>

<p>In this guide we've explored the main standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>We've also seen how HttpKernel enabled reusable code with <a href="/2016/03/09/ultimate-symfony-bundle.html">Bundles</a>,
and the different ways to organize our application <a href="/2016/03/16/ultimate-symfony-skeleton.html">tree directory</a>.</p>

<p>Finally we've started to put all this knowledge in practice by creating a
"fortune" project with:</p>

<ul>
<li><a href="/2016/03/24/ultimate-symfony-api-example.html">an endpoint that allows us to submit new fortunes</a>.</li>
<li><a href="/2016/03/30/ultimate-symfony-web-example.html">a page that lists all fortunes</a>.</li>
</ul>

<p>In this article, we're going to continue the "fortune" project by creating a
command that prints the last fortune.</p>

<blockquote>
  <p><strong>Note</strong>: To start with the same code, use the following repository:</p>

<pre><code>git clone https://github.com/gnugat-examples/fortune.git
cd fortune
composer install -o --ignore-platform-reqs
git checkout web-example
git checkout -b cli-example
</code></pre>
</blockquote>

<h2 id="create-the-command">Create the Command</h2>

<p>The CLI equivalent of a web Controller is a Command. We're first going to create
a functional test:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Command/PrintLastFortuneCommandTest.php

namespace Tests\AppBundle\Command;

use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Tester\ApplicationTester;

class PrintLastFortuneCommandTest extends \PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $kernel = new \AppKernel('test', false);
        $application = new Application($kernel);
        $application-&gt;setAutoExit(false);
        $this-&gt;app = new ApplicationTester($application);
    }

    /**
     * @test
     */
    public function it_prints_last_fortune()
    {
        $input = array(
            'print-last-fortune',
        );

        $exitCode = $this-&gt;app-&gt;run($input);

        self::assertSame(0, $exitCode, $this-&gt;app-&gt;getDisplay());
    }
}
</code></pre>

<p>Successful commands always return <code>0</code> as an exit code, which is what we're going
to check in this test. Let's run the suite:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>They fail, telling us to create the actual code for the command:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Command/PrintLastFortuneCommand.php

namespace AppBundle\Command;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class PrintLastFortuneCommand extends Command
{
    protected function configure()
    {
        $this-&gt;setName('print-last-fortune');
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
    }
}
</code></pre>

<p>Since Symfony looks automatically for classes that extend <code>Command</code> in the
<code>Command</code> directory of each registered bundle, our command is now available:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>The test suite is now green. We can run it using the console:</p>

<pre><code>bin/console print-last-fortune
</code></pre>

<p>We should successfully get an empty line.</p>

<h2 id="create-the-logic">Create the logic</h2>

<p>In order to get something else than an empty line, we need to create a new use
case. It's purpose will be to convey intent (print the last fortune) and
to validate the input parameters:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Service/PrintLastFortuneTest.php

namespace Tests\AppBundle\Service;

use AppBundle\Service\PrintLastFortune;

class PrintLastFortuneTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @test
     */
    public function it_has_no_parameters()
    {
        $printLastFortune = new PrintLastFortune();
    }
}
</code></pre>

<p>Well, currently we don't have any input parameters. But if we get a new requirement
that does need input parameters, we'll be ready to validate them. For now we can
run the tests:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>They fail because we need to create the actual class:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/PrintLastFortune.php

namespace AppBundle\Service;

class PrintLastFortune
{
}
</code></pre>

<p>This should fix the issue:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>Now let's create Handler that will list all fortunes:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Service/PrintLastFortuneHandlerTest.php

namespace Tests\AppBundle\Service;

use AppBundle\Service\FindLastFortune;
use AppBundle\Service\PrintLastFortune;
use AppBundle\Service\PrintLastFortuneHandler;

class PrintLastFortuneHandlerTest extends \PHPUnit_Framework_TestCase
{
    const CONTENT = 'Why do witches burn?';

    private $findLastFortune;
    private $printLastFortuneHandler;

    protected function setUp()
    {
        $this-&gt;findLastFortune = $this-&gt;prophesize(FindLastFortune::class);
        $this-&gt;printLastFortuneHandler = new PrintLastFortuneHandler(
            $this-&gt;findLastFortune-&gt;reveal()
        );
    }

    /**
     * @test
     */
    public function it_prints_last_fortune()
    {
        $printLastFortune = new PrintLastFortune();
        $lastFortune = array(
            'content' =&gt; self::CONTENT,
        );

        $this-&gt;findLastFortune-&gt;findLast()-&gt;willReturn($lastFortune);

        self::assertSame($lastFortune, $this-&gt;printLastFortuneHandler-&gt;handle($printLastFortune));
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>They're telling us to create <code>PrintLastFortuneHandler</code>:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/PrintLastFortuneHandler.php

namespace AppBundle\Service;

class PrintLastFortuneHandler
{
    private $findLastFortune;

    public function __construct(FindLastFortune $findLastFortune)
    {
        $this-&gt;findLastFortune = $findLastFortune;
    }

    public function handle(PrintLastFortune $printLastFortune)
    {
        return $this-&gt;findLastFortune-&gt;findLast();
    }
}
</code></pre>

<p>This should fix this specific error:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>Now our tests are telling us to create <code>FindLastFortune</code>:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/FindLastFortune.php

namespace AppBundle\Service;

interface FindLastFortune
{
    public function findLast();
}
</code></pre>

<p>Let's see if it did the trick:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>Yes it did! To sum up what we've done in this section:</p>

<ul>
<li>we've created a <code>PrintLastFortune</code> use case which could be validating input parameter,
for now it's empty and only serve us to convey intention (use case: print last fortunes)</li>
<li>we've create a <code>PrintLastFortuneHandler</code> class that calls services which will
do the actual logic</li>
<li>we've created a <code>FindLastFortune</code> interface, its implementations will find the
last fortune</li>
</ul>

<h2 id="wiring">Wiring</h2>

<p>We're going to use Doctrine DBAL to actually find all fortunes from a database.
This can be done by creating an implementation of <code>FindLastFortune</code>:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/Bridge/DoctrineDbalFindLastFortune.php

namespace AppBundle\Service\Bridge;

use AppBundle\Service\FindLastFortune;
use Doctrine\DBAL\Driver\Connection;

class DoctrineDbalFindLastFortune implements FindLastFortune
{
    private $connection;

    public function __construct(Connection $connection)
    {
        $this-&gt;connection = $connection;
    }

    public function findLast()
    {
        $queryBuilder = $this-&gt;connection-&gt;createQueryBuilder();
        $queryBuilder-&gt;select('*');
        $queryBuilder-&gt;from('fortune');
        $queryBuilder-&gt;orderBy('id', 'DESC');
        $queryBuilder-&gt;setMaxResults(1);
        $sql = $queryBuilder-&gt;getSql();
        $parameters = $queryBuilder-&gt;getParameters();
        $statement = $this-&gt;connection-&gt;prepare($sql);
        $statement-&gt;execute($parameters);

        return $statement-&gt;fetch();
    }
}
</code></pre>

<p>This was the last class we needed to write. We can now use <code>PrintLastFortune</code>
in our command:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Command/PrintLastFortuneCommand.php

namespace AppBundle\Command;

use AppBundle\Service\PrintLastFortune;
use AppBundle\Service\PrintLastFortuneHandler;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class PrintLastFortuneCommand extends Command
{
    private $printLastFortuneHandler;

    public function __construct(PrintLastFortuneHandler $printLastFortuneHandler)
    {
        $this-&gt;printLastFortuneHandler = $printLastFortuneHandler;

        parent::__construct();
    }

    protected function configure()
    {
        $this-&gt;setName('print-last-fortune');
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $printLastFortune = new PrintLastFortune();

        $lastFortune = $this-&gt;printLastFortuneHandler-&gt;handle($printLastFortune);

        $output-&gt;writeln($lastFortune['content']);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: In the command, we extract Input parameters and options to put them
  in <code>PrintLastFortune</code> which is going to validate them. We then simply call
  <code>PrintLastFortuneHandler</code> to take care of the logic associated to <code>PrintLastFortune</code>.</p>
</blockquote>

<p>Now all that's left to do is wire everything together using Dependency Injection:</p>

<pre><code># app/config/services.yml

services:
    # Commands
    app.print_last_fortune_command:
        class: 'AppBundle\Command\PrintLastFortuneCommand'
        arguments:
            - '@app.print_last_fortune_handler'
        tags:
            - { name: console.command }

    # Controllers
    app.api.fortune_controller:
        class: 'AppBundle\Controller\Api\FortuneController'
        arguments:
            - '@app.submit_new_fortune_handler'

    app.fortune_controller:
        class: 'AppBundle\Controller\FortuneController'
        arguments:
            - '@app.list_all_fortunes_handler'
            - '@twig'

    # Handlers
    app.list_all_fortunes_handler:
        class: 'AppBundle\Service\ListAllFortunesHandler'
        arguments:
            - '@app.find_all_fortunes'

    app.print_last_fortune_handler:
        class: 'AppBundle\Service\PrintLastFortuneHandler'
        arguments:
            - '@app.find_last_fortune'

    app.submit_new_fortune_handler:
        class: 'AppBundle\Service\SubmitNewFortuneHandler'
        arguments:
            - '@app.save_new_fortune'

    # Services
    app.find_all_fortunes:
        alias: app.bridge.doctrine_dbal_find_all_fortunes

    app.bridge.doctrine_dbal_find_all_fortunes:
        class: 'AppBundle\Service\Bridge\DoctrineDbalFindAllFortunes'
        arguments:
            - '@database_connection'

    app.find_last_fortune:
        alias: app.bridge.doctrine_dbal_find_last_fortune

    app.bridge.doctrine_dbal_find_last_fortune:
        class: 'AppBundle\Service\Bridge\DoctrineDbalFindLastFortune'
        arguments:
            - '@database_connection'

    app.save_new_fortune:
        alias: app.bridge.doctrine_dbal_save_new_fortune

    app.bridge.doctrine_dbal_save_new_fortune:
        class: 'AppBundle\Service\Bridge\DoctrineDbalSaveNewFortune'
        arguments:
            - '@database_connection'

    # Listeners
    app.json_request_content_listener:
        class: 'AppBundle\EventListener\JsonRequestContentListener'
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.exception_listener:
        class: 'AppBundle\EventListener\ExceptionListener'
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException }
</code></pre>

<p>Let's run the tests:</p>

<pre><code>rm -rf var/cache/*
./bin/console doctrine:database:drop --force
./bin/console doctrine:database:create
bin/console doctrine:query:sql 'CREATE TABLE fortune (id SERIAL, content TEXT);'
vendor/bin/phpunit
</code></pre>

<p>All green! Let's add some fortunes:</p>

<pre><code>php -S localhost:2501 -t web
curl -i -X POST localhost:2501/app.php/api/v1/fortunes -H 'Content-Type: application/json' -d '{"content":"I am sorry to have kept you waiting, but I am afraid my walk has become rather sillier recently"}'
curl -i -X POST localhost:2501/app.php/api/v1/fortunes -H 'Content-Type: application/json' -d '{"content":"Well you cannot expect to wield supreme executive power just because some watery tart threw a sword at you."}'
curl -i -X POST localhost:2501/app.php/api/v1/fortunes -H 'Content-Type: application/json' -d '{"content":"All right... all right... but apart from better sanitation, the medicine, education, wine, public order, irrigation, roads, a fresh water system, and public health ... what have the Romans ever done for us?"}'
</code></pre>

<p>We can now check our command:</p>

<pre><code>bin/console print-last-fortune
</code></pre>

<p>This time instead of an empty line, we do get the last fortune.</p>

<h2 id="conclusion">Conclusion</h2>

<p>To create a new command, we need to:</p>

<ul>
<li>create a Command class</li>
<li>register the command as a service, with a <code>console.command</code> tag</li>
</ul>

<p>The command's logic is then up to us, it doesn't have to be done in a "Symfony"
way. For example we can:</p>

<ul>
<li>extract Input parameters and put them in a class that validates them</li>
<li>pass the class to a handler that will call services to do the actual logic</li>
<li>define our services as interfaces, and then create implementations to integrate
them with third party libraries</li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Web Example]]></title>
            <link href="/2016/03/30/ultimate-symfony-web-example.html"/>
            <updated>2016-03-30T00:00:00+01:00</updated>
            <id>/2016/03/30/ultimate-symfony-web-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Practice makes Better.</p>
</blockquote>

<p>In this guide we've explored the main standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>We've also seen how HttpKernel enabled reusable code with <a href="/2016/03/09/ultimate-symfony-bundle.html">Bundles</a>,
and the different ways to organize our application <a href="/2016/03/16/ultimate-symfony-skeleton.html">tree directory</a>.</p>

<p>Finally we've started to put all this knowledge in practice by creating a
"fortune" project with <a href="/2016/03/24/ultimate-symfony-api-example.html">an endpoint that allows us to submit new fortunes</a>.</p>

<p>In this article, we're going to continue the "fortune" project by creating a page
that lists all fortunes.</p>

<p>In the next article we'll also create for this application <a href="/2016/04/06/ultimate-symfony-cli-example.html">a command that prints the last fortune</a>.</p>

<blockquote>
  <p><strong>Note</strong>: To start with the same code, use the following repository:</p>

<pre><code>git clone https://github.com/gnugat-examples/fortune.git
cd fortune
composer install -o --ignore-platform-reqs
git checkout api-example
git chekcout -b web-example
</code></pre>
</blockquote>

<h2 id="create-the-controller">Create the Controller</h2>

<p>We'll first start by writing a functional test for our new endpoint:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Controller/FortuneControllerTest.php

namespace Tests\AppBundle\Controller;

use Symfony\Component\HttpFoundation\Request;

class FortuneControllerTest extends \PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', false);
    }

    /**
     * @test
     */
    public function it_lists_all_fortunes()
    {
        $request = Request::create('/');

        $response = $this-&gt;app-&gt;handle($request);

        self::assertSame(200, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }
}
</code></pre>

<p>Just like for our endpoint, we're only interested in checking the status code
of the response (<code>200</code> is successful response).</p>

<p>Let's run the tests:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>They fail, with a <code>404 NOT FOUND</code> response. That's because we don't have any
controllers, so let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/FortuneController.php

namespace AppBundle\Controller;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class FortuneController
{
    public function listAll(Request $request)
    {
        return new Response('', 200);
    }
}
</code></pre>

<p>After creating a controller, the next step is to configure its route:</p>

<pre><code># app/config/routing.yml

submit_new_fortunes_endpoint:
    path: /api/v1/fortunes
    defaults:
        _controller: app.api.fortune_controller:submit
    methods:
        - POST

list_all_fortunes_page:
    path: /
    defaults:
        _controller: app.fortune_controller:listAll
    methods:
        - GET
</code></pre>

<p>In this configuration, <code>_controller</code> is set to call the <code>listAll</code> method of the
<code>app.fortune_controller</code> service. Here's how to define this service:</p>

<pre><code># app/config/services.yml

services:
    # Controllers
    app.api.fortune_controller:
        class: 'AppBundle\Controller\Api\FortuneController'
        arguments:
            - '@app.submit_new_fortune_handler'

    app.fortune_controller:
        class: 'AppBundle\Controller\FortuneController'

    # Handlers
    app.submit_new_fortune_handler:
        class: 'AppBundle\Service\SubmitNewFortuneHandler'
        arguments:
            - '@app.save_new_fortune'

    # Services
    app.save_new_fortune:
        alias: app.bridge.doctrine_dbal_save_new_fortune

    app.bridge.doctrine_dbal_save_new_fortune:
        class: 'AppBundle\Service\Bridge\DoctrineDbalSaveNewFortune'
        arguments:
            - '@database_connection'

    # Listeners
    app.json_request_content_listener:
        class: 'AppBundle\EventListener\JsonRequestContentListener'
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.exception_listener:
        class: 'AppBundle\EventListener\ExceptionListener'
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException }
</code></pre>

<p>Now let's try again our tests:</p>

<pre><code>rm -rf var/cache/test
vendor/bin/phpunit
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Everytime the configuration changes, we need to remove the cache.</p>
</blockquote>

<p>The test suite is now green. Let's start the server:</p>

<pre><code>rm -rf var/cache/prod
php -S localhost:2501 -t web
</code></pre>

<p>We can now visit our page: <a href="http://localhost:2501/app.php/">http://localhost:2501/app.php/</a></p>

<p>We should successfully get a blank page.</p>

<h2 id="create-the-logic">Create the logic</h2>

<p>So now we have an empty page. Let's fix it by creating a use case to list all
fortunes:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Service/ListAllFortunesTest.php

namespace Tests\AppBundle\Service;

use AppBundle\Service\ListAllFortunes;

class ListAllFortunesTest extends \PHPUnit_Framework_TestCase
{
    /**
     * @test
     */
    public function it_has_no_parameters()
    {
        $listAllFortunes = new ListAllFortunes();
    }
}
</code></pre>

<p>We can now run the tests:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>They fail because we need to create the actual class:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/ListAllFortunes.php

namespace AppBundle\Service;

class ListAllFortunes
{
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Currently the use case class has no parameters to validate.
  If new requirements come up with the need for some parameters, we're going
  to be able to check them here.</p>
</blockquote>

<p>This should fix the issue:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>Now let's create Handler that will list all fortunes:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Service/ListAllFortunesHandlerTest.php

namespace Tests\AppBundle\Service;

use AppBundle\Service\FindAllFortunes;
use AppBundle\Service\ListAllFortunes;
use AppBundle\Service\ListAllFortunesHandler;

class ListAllFortunesHandlerTest extends \PHPUnit_Framework_TestCase
{
    const CONTENT = "It's just a flesh wound.";

    private $listAllFortunesHandler;
    private $findAllFortunes;

    protected function setUp()
    {
        $this-&gt;findAllFortunes = $this-&gt;prophesize(FindAllFortunes::class);
        $this-&gt;listAllFortunesHandler = new ListAllFortunesHandler(
            $this-&gt;findAllFortunes-&gt;reveal()
        );
    }

    /**
     * @test
     */
    public function it_submits_new_fortunes()
    {
        $listAllFortunes = new ListAllFortunes();

        $this-&gt;findAllFortunes-&gt;findAll()-&gt;shouldBeCalled();

        $this-&gt;listAllFortunesHandler-&gt;handle($listAllFortunes);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>They're telling us to create <code>ListAllFortunesHandler</code>:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/ListAllFortunesHandler.php

namespace AppBundle\Service;

class ListAllFortunesHandler
{
    private $findAllFortunes;

    public function __construct(FindAllFortunes $findAllFortunes)
    {
        $this-&gt;findAllFortunes = $findAllFortunes;
    }

    public function handle(ListAllFortunes $listAllFortunes)
    {
        return $this-&gt;findAllFortunes-&gt;findAll();
    }
}
</code></pre>

<p>This should fix this specific error:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>Now our tests are telling us to create <code>FindAllFortunes</code>:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/FindAllFortunes.php

namespace AppBundle\Service;

interface FindAllFortunes
{
    public function findAll();
}
</code></pre>

<p>Let's see if it did the trick:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>Yes it did! To sum up what we've done in this section:</p>

<ul>
<li>we've created a <code>ListAllFortunes</code> use case which could be validating input parameter,
for now it's empty and only serve us to convey intention (use case: list all fortunes)</li>
<li>we've create a <code>ListAllFortunesHandler</code> class that call services which will
do the actual logic</li>
<li>we've created a <code>FindAllFortunes</code> interface, its implementations will find all
fortunes</li>
</ul>

<h2 id="wiring">Wiring</h2>

<p>We're going to use Doctrine DBAL to actually find all fortunes from a database.
This can be done by creating an implementation of <code>FindAllFortunes</code>:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/Bridge/DoctrineDbalFindAllFortunes.php

namespace AppBundle\Service\Bridge;

use AppBundle\Service\FindAllFortunes;
use Doctrine\DBAL\Driver\Connection;

class DoctrineDbalFindAllFortunes implements FindAllFortunes
{
    private $connection;

    public function __construct(Connection $connection)
    {
        $this-&gt;connection = $connection;
    }

    public function findAll()
    {
        $queryBuilder = $this-&gt;connection-&gt;createQueryBuilder();
        $queryBuilder-&gt;select('*');
        $queryBuilder-&gt;from('fortune');
        $sql = $queryBuilder-&gt;getSql();
        $parameters = $queryBuilder-&gt;getParameters();
        $statement = $this-&gt;connection-&gt;prepare($sql);
        $statement-&gt;execute($parameters);

        return $statement-&gt;fetchAll();
    }
}
</code></pre>

<p>This was the last class we needed to write. We can now use <code>ListAllFortunes</code>
in our controller:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/FortuneController.php

namespace AppBundle\Controller;

use AppBundle\Service\ListAllFortunes;
use AppBundle\Service\ListAllFortunesHandler;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class FortuneController
{
    private $listAllFortunesHandler;

    public function __construct(ListAllFortunesHandler $listAllFortunesHandler)
    {
        $this-&gt;listAllFortunesHandler = $listAllFortunesHandler;
    }

    public function listAll(Request $request)
    {
        $listAllFortunes = new ListAllFortunes(
        );
        $fortunes = $this-&gt;listAllFortunesHandler-&gt;handle($listAllFortunes);

        return new Response('', 200);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: In the controller, we extract Request (input) parameters and put them
  in <code>ListAllFortunes</code> which is going to validate them. We then simply call
  <code>ListAllFortunesHandler</code> to take care of the logic associated to <code>ListAllFortunes</code>.</p>
</blockquote>

<p>Now all that's left to do is wire everything together using Dependency Injection:</p>

<pre><code># app/config/services.yml

services:
    # Controllers
    app.api.fortune_controller:
        class: 'AppBundle\Controller\Api\FortuneController'
        arguments:
            - '@app.submit_new_fortune_handler'

    app.fortune_controller:
        class: 'AppBundle\Controller\FortuneController'
        arguments:
            - '@app.list_all_fortunes_handler'

    # Handlers
    app.list_all_fortunes_handler:
        class: 'AppBundle\Service\ListAllFortunesHandler'
        arguments:
            - '@app.find_all_fortunes'

    app.submit_new_fortune_handler:
        class: 'AppBundle\Service\SubmitNewFortuneHandler'
        arguments:
            - '@app.save_new_fortune'

    # Services
    app.find_all_fortunes:
        alias: app.bridge.doctrine_dbal_find_all_fortunes

    app.bridge.doctrine_dbal_find_all_fortunes:
        class: 'AppBundle\Service\Bridge\DoctrineDbalFindAllFortunes'
        arguments:
            - '@database_connection'

    app.save_new_fortune:
        alias: app.bridge.doctrine_dbal_save_new_fortune

    app.bridge.doctrine_dbal_save_new_fortune:
        class: 'AppBundle\Service\Bridge\DoctrineDbalSaveNewFortune'
        arguments:
            - '@database_connection'

    # Listeners
    app.json_request_content_listener:
        class: 'AppBundle\EventListener\JsonRequestContentListener'
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.exception_listener:
        class: 'AppBundle\EventListener\ExceptionListener'
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException }
</code></pre>

<p>Let's run the tests:</p>

<pre><code>./bin/console doctrine:database:drop --force
./bin/console doctrine:database:create
bin/console doctrine:query:sql 'CREATE TABLE fortune (content TEXT);'
rm -rf var/cache/test
vendor/bin/phpunit
</code></pre>

<p>All green!</p>

<h2 id="view">View</h2>

<p>If we start the server and check the page, it's going to be blank. That's because
in our controlller we create a Response with empty content. Let's improve this situation:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/FortuneController.php

namespace AppBundle\Controller;

use AppBundle\Service\ListAllFortunes;
use AppBundle\Service\ListAllFortunesHandler;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class FortuneController
{
    private $listAllFortunesHandler;

    public function __construct(ListAllFortunesHandler $listAllFortunesHandler)
    {
        $this-&gt;listAllFortunesHandler = $listAllFortunesHandler;
    }

    public function listAll(Request $request)
    {
        $listAllFortunes = new ListAllFortunes(
        );
        $fortunes = $this-&gt;listAllFortunesHandler-&gt;handle($listAllFortunes);
        $fortunesHtml = '';
        foreach ($fortunes as $fortune) {
            $fortunesHtml .= "&lt;li&gt;{$fortune['content']}&lt;/li&gt;\n";
        }
        $html =&lt;&lt;&lt;HTML
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Fortunes&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;ul&gt;
        $fortunesHtml
    &lt;/ul&gt;
&lt;/body&gt;
HTML
        ;

        return new Response($html, 200);
    }
}
</code></pre>

<p>Let's start the server:</p>

<pre><code>rm -rf var/cache/prod
php -S localhost:2501 -t web
</code></pre>

<p>In order to see a list of fortunes, we first need to submit some! We can use our
endpoint for this purpose:</p>

<pre><code>curl -i -X POST localhost:2501/app.php/api/v1/fortunes -H 'Content-Type: application/json' -d '{"content":"I came here to have an argument!"}'
curl -i -X POST localhost:2501/app.php/api/v1/fortunes -H 'Content-Type: application/json' -d '{"content":"Has not got as much spam in it as spam egg sausage and spam, has it?"}'
curl -i -X POST localhost:2501/app.php/api/v1/fortunes -H 'Content-Type: application/json' -d '{"content":"The Castle of aaarrrrggh"}'
</code></pre>

<p>We can now visit our page: <a href="http://localhost:2501/app.php/">http://localhost:2501/app.php/</a></p>

<p>While it seems a bit plain (a bit of CSS, javascript and more HTML wouldn't be
too much), we do see a list of all fortunes.</p>

<p>Controllers shouldn't contain any "view" logic, let's push it to a template using
<a href="http://twig.sensiolabs.org/">Twig</a>:</p>

<p></p>

<pre><code>{# app/Resources/views/list-all-fortunes.html.twig #}
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;Fortunes&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;ul&gt;
        {% for fortune in fortunes %}
        &lt;li&gt;{{ fortune.content }}&lt;/li&gt;
        {% endfor %}
    &lt;/ul&gt;
&lt;/body&gt;
</code></pre>

<p></p>

<p>We now need to use Twig in the controller:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/FortuneController.php

namespace AppBundle\Controller;

use AppBundle\Service\ListAllFortunes;
use AppBundle\Service\ListAllFortunesHandler;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class FortuneController
{
    private $listAllFortunesHandler;
    private $twig;

    public function __construct(
        ListAllFortunesHandler $listAllFortunesHandler,
        \Twig_Environment $twig
    ) {
        $this-&gt;listAllFortunesHandler = $listAllFortunesHandler;
        $this-&gt;twig = $twig;
    }

    public function listAll(Request $request)
    {
        $listAllFortunes = new ListAllFortunes(
        );
        $fortunes = $this-&gt;listAllFortunesHandler-&gt;handle($listAllFortunes);
        $html = $this-&gt;twig-&gt;render('::list-all-fortunes.html.twig', array(
            'fortunes' =&gt; $fortunes,
        ));

        return new Response($html, 200);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: The first argument of <code>render</code> is the "path" to the view. This path
  contains 3 parts, separated by colons (<code>:</code>):</p>
  
  <ul>
  <li>the first part is the bundle name (by default it's <code>AppBundle</code> so we don't need to provide it)</li>
  <li>the second one is the directory from <code>Resources/views</code> (in our case it's at the root so we don't need to provide it)</li>
  <li>the template file name</li>
  </ul>
  
  <p>Some other path example: <code>FortuneBundle:Fortunes/List:all.html.twig</code>, etc.</p>
  
  <p>The second argument is an array which associates Twig variable names to their values,
  in our case we're going to have access to a <code>fortunes</code> variable in our template,
  which is going to be the content of the <code>$fortunes</code> variable from our controller.</p>
</blockquote>

<p>In order to get Twig injected in our controller, we'll update it's service configuration:</p>

<pre><code># app/config/services.yml

services:
    # Controllers
    app.api.fortune_controller:
        class: 'AppBundle\Controller\Api\FortuneController'
        arguments:
            - '@app.submit_new_fortune_handler'

    app.fortune_controller:
        class: 'AppBundle\Controller\FortuneController'
        arguments:
            - '@app.list_all_fortunes_handler'
            - '@twig'

    # Handlers
    app.list_all_fortunes_handler:
        class: 'AppBundle\Service\ListAllFortunesHandler'
        arguments:
            - '@app.find_all_fortunes'

    app.submit_new_fortune_handler:
        class: 'AppBundle\Service\SubmitNewFortuneHandler'
        arguments:
            - '@app.save_new_fortune'

    # Services
    app.find_all_fortunes:
        alias: app.bridge.doctrine_dbal_find_all_fortunes

    app.bridge.doctrine_dbal_find_all_fortunes:
        class: 'AppBundle\Service\Bridge\DoctrineDbalFindAllFortunes'
        arguments:
            - '@database_connection'

    app.save_new_fortune:
        alias: app.bridge.doctrine_dbal_save_new_fortune

    app.bridge.doctrine_dbal_save_new_fortune:
        class: 'AppBundle\Service\Bridge\DoctrineDbalSaveNewFortune'
        arguments:
            - '@database_connection'

    # Listeners
    app.json_request_content_listener:
        class: 'AppBundle\EventListener\JsonRequestContentListener'
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.exception_listener:
        class: 'AppBundle\EventListener\ExceptionListener'
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException }
</code></pre>

<p>Since we changed the configuration, we'll need to clear the cache:</p>

<pre><code>rm -rf var/cache/prod
</code></pre>

<p>Finally we can visit again our page: <a href="http://localhost:2501/app.php/">http://localhost:2501/app.php/</a>.</p>

<p>Let's run our test suite one last time:</p>

<pre><code>rm -rf var/cache/test
vendor/bin/phpunit
</code></pre>

<p>Everything is still green!</p>

<h2 id="conclusion">Conclusion</h2>

<p>To create a new page, we need to:</p>

<ul>
<li>create a Controller class</li>
<li>configure its routing</li>
<li>register the controller as a service</li>
</ul>

<p>The page's logic is then up to us, it doesn't have to be done in a "Symfony"
way. For example we can:</p>

<ul>
<li>extract Request parameters and put them in a class that validates them</li>
<li>pass the class to a handler that will call services to do the actual logic</li>
<li>define our services as interfaces, and then create implementations to integrate
them with third party libraries</li>
</ul>

<p>Finally to display the result we need to create a template file and call a
templating engine, such as Twig, from our controller.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - API Example]]></title>
            <link href="/2016/03/24/ultimate-symfony-api-example.html"/>
            <updated>2016-03-24T00:00:00+00:00</updated>
            <id>/2016/03/24/ultimate-symfony-api-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Practice makes Better.</p>
</blockquote>

<p>In this guide we've explored the main standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>We've also seen how HttpKernel enabled reusable code with <a href="/2016/03/09/ultimate-symfony-bundle.html">Bundles</a>,
and the different ways to organize our application <a href="/2016/03/16/ultimate-symfony-skeleton.html">tree directory</a>.</p>

<p>In this article, we're going to put all this knowledge in practice by creating a
"fortune" project with an endpoint that allows us to submit new fortunes.</p>

<p>In the next articles we'll also create for this application:</p>

<ul>
<li><a href="/2016/03/30/ultimate-symfony-web-example.html">a page that lists all fortunes</a></li>
<li><a href="/2016/04/06/ultimate-symfony-cli-example.html">a command that prints the last fortune</a></li>
</ul>

<h2 id="create-the-project">Create the project</h2>

<p>The first step is to create our project. For this example we'll use the
<a href="https://github.com/symfony/symfony-standard">Standard Edition</a>:</p>

<pre><code>composer create-project symfony/framework-standard-edition fortune
</code></pre>

<p>This will ask us some configuration questions (e.g. database credentials), allowing
us to set up everything in one step.</p>

<blockquote>
  <p><strong>Note</strong>: Nothing prevents us from adding new libraries (e.g. <a href="https://github.com/beberlei/assert">Assert</a>),
  replacing the ones provided by default (e.g. replacing <a href="http://www.doctrine-project.org/projects/orm.html">Doctrine</a>
  with <a href="http://www.pomm-project.org/">Pomm</a>) or remove the ones we don't need
  (e.g. <a href="http://swiftmailer.org/">Swiftmailer</a> if we don't need emailing).</p>
</blockquote>

<p>To begin with a clean slate we'll need to remove some things:</p>

<pre><code>cd fortune
echo '' &gt;&gt; app/config/routing.yml
rm -rf src/AppBundle/Controller/* tests/AppBundle/Controller/* app/Resources/views/*
</code></pre>

<p>Then we're going to install PHPUnit locally:</p>

<pre><code>composer require --dev phpunit/phpunit:5.2 --ignore-platform-reqs
</code></pre>

<p>We're now ready to begin.</p>

<h2 id="create-the-controller">Create the Controller</h2>

<p>We'll first start by writing a functional test for our new endpoint:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Controller/Api/FortuneControllerTest.php

namespace Tests\AppBundle\Controller\Api;

use Symfony\Component\HttpFoundation\Request;

class FortuneControllerTest extends \PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', false);
    }

    /**
     * @test
     */
    public function it_cannot_submit_fortunes_without_content()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
        );
        $request = Request::create('/api/v1/fortunes', 'POST', array(), array(), array(), $headers, json_encode(array(
        )));

        $response = $this-&gt;app-&gt;handle($request);

        self::assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    /**
     * @test
     */
    public function it_cannot_submit_fortunes_with_non_string_content()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
        );
        $request = Request::create('/api/v1/fortunes', 'POST', array(), array(), array(), $headers, json_encode(array(
            'content' =&gt; 42,
        )));

        $response = $this-&gt;app-&gt;handle($request);

        self::assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    /**
     * @test
     */
    public function it_submits_new_fortunes()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
        );
        $request = Request::create('/api/v1/fortunes', 'POST', array(), array(), array(), $headers, json_encode(array(
            'content' =&gt; 'Hello',
        )));

        $response = $this-&gt;app-&gt;handle($request);

        self::assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }
}
</code></pre>

<p>With functional tests, we're only interested in making sure all components play
well together, so checking the response status code (<code>201</code> is succesfully created,
<code>422</code> is a validation error) is sufficient.</p>

<blockquote>
  <p><strong>Note</strong>: <code>400 BAD REQUEST</code> is only used if there's a syntax error in the Request
  (e.g. invalid JSON).</p>
</blockquote>

<p>Let's run the tests:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>They fail, with a <code>404 NOT FOUND</code> response. That's because we don't have any
controllers, so let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/Api/FortuneController.php

namespace AppBundle\Controller\Api;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class FortuneController
{
    public function submit(Request $request)
    {
        return new Response('', 201);
    }
}
</code></pre>

<p>Having a controller is no good without routing configuration:</p>

<pre><code># app/config/routing.yml

submit_new_fortunes_endpoint:
    path: /api/v1/fortunes
    defaults:
        _controller: app.api.fortune_controller:submit
    methods:
        - POST
</code></pre>

<p>In this configuration, <code>_controller</code> is set to call the <code>submit</code> method of the
<code>app.api.fortune_controller</code> service. Here's how to define this service:</p>

<pre><code># app/config/services.yml

services:
    app.api.fortune_controller:
        class: 'AppBundle\Controller\Api\FortuneController'
</code></pre>

<p>Now let's try again our tests:</p>

<pre><code>rm -rf var/cache/test
vendor/bin/phpunit
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We need to remove the cache to take into account the new configuration.</p>
</blockquote>

<p>The last test (happy scenario) pass! We'll have to fix the first two ones (unhappy
scenario) later.</p>

<p>We can now call directly our endpoint:</p>

<pre><code>php -S localhost:2501 -t web &amp;
curl -i -X POST localhost:2501/app.php/api/v1/fortunes -H 'Content-Type: application/json' -d '{"content":"Nobody expects the spanish inquisition!"}'
killall -9 php
</code></pre>

<p>We should successfully get a <code>201 CREATED</code>.</p>

<h2 id="create-the-logic">Create the logic</h2>

<p>So now we have an endpoint that does nothing. Let's fix it by creating the logic.
Our first step will be to write a unit test for a class that will do a basic
validation of the input:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Service/SubmitNewFortuneTest.php

namespace Tests\AppBundle\Service;

use AppBundle\Service\SubmitNewFortune;

class SubmitNewFortuneTest extends \PHPUnit_Framework_TestCase
{
    const CONTENT = "Look, matey, I know a dead parrot when I see one, and I'm looking at one right now.";

    /**
     * @test
     */
    public function it_has_a_content()
    {
        $submitNewFortune = new SubmitNewFortune(self::CONTENT);

        self::assertSame(self::CONTENT, $submitNewFortune-&gt;content);
    }

    /**
     * @test
     */
    public function it_fails_if_the_content_is_missing()
    {
        $this-&gt;expectException(\DomainException::class);

        new SubmitNewFortune(null);
    }

    /**
     * @test
     */
    public function it_fails_if_the_content_is_not_a_string()
    {
        $this-&gt;expectException(\DomainException::class);

        new SubmitNewFortune(42);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: You need PHPUnit 5.2 to be able to use <code>expectException</code>.</p>
</blockquote>

<p>Our <code>SubmitNewFortune</code> will check that we submitted a stringy content. Let's run
the tests:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<blockquote>
  <p><strong>Note</strong>: If we had used <a href="/2015/08/03/phpspec.html">phpspec</a> to write our unit
  tests, it would have created an empty <code>SubmitNewFortune</code> class for us.
  There's nothing wrong with using <a href="/2015/09/23/phpunit-with-phpspec.html">both PHPUnit and phpspec</a>,
  (the first for functional tests and the second for unit tests).</p>
</blockquote>

<p>The tests fail because the actual class doesn't exist yet. We need to write it:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/SubmitNewFortune.php

namespace AppBundle\Service;

class SubmitNewFortune
{
    public $content;

    public function __construct($content)
    {
        if (null === $content) {
            throw new \DomainException('Missing required "content" parameter', 422);
        }
        if (false === is_string($content)) {
            throw new \DomainException('Invalid "content" parameter: it must be a string', 422);
        }
        $this-&gt;content = $content;
    }
}
</code></pre>

<p>Let's run the tests again:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>This time they pass.</p>

<p>Validating the input parameters isn't enough, we now need to execute some logic
to actually submit new quotes. This can be done in a class that handles <code>SubmitNewFortune</code>:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Service/SubmitNewFortuneHandlerTest.php

namespace Tests\AppBundle\Service;

use AppBundle\Service\SaveNewFortune;
use AppBundle\Service\SubmitNewFortune;
use AppBundle\Service\SubmitNewFortuneHandler;

class SubmitNewFortuneHandlerTest extends \PHPUnit_Framework_TestCase
{
    const CONTENT = "It's just a flesh wound.";

    private $submitNewFortuneHandler;
    private $saveNewFortune;

    protected function setUp()
    {
        $this-&gt;saveNewFortune = $this-&gt;prophesize(SaveNewFortune::class);
        $this-&gt;submitNewFortuneHandler = new SubmitNewFortuneHandler(
            $this-&gt;saveNewFortune-&gt;reveal()
        );
    }

    /**
     * @test
     */
    public function it_submits_new_fortunes()
    {
        $submitNewFortune = new SubmitNewFortune(self::CONTENT);

        $this-&gt;saveNewFortune-&gt;save(array(
            'content' =&gt; self::CONTENT
        ))-&gt;shouldBeCalled();

        $this-&gt;submitNewFortuneHandler-&gt;handle($submitNewFortune);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>They're telling us to create <code>SubmitNewFortuneHandler</code>:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/SubmitNewFortuneHandler.php

namespace AppBundle\Service;

class SubmitNewFortuneHandler
{
    private $saveNewFortune;

    public function __construct(SaveNewFortune $saveNewFortune)
    {
        $this-&gt;saveNewFortune = $saveNewFortune;
    }

    public function handle(SubmitNewFortune $submitNewFortune)
    {
        $newFortune = array(
            'content' =&gt; $submitNewFortune-&gt;content,
        );

        $this-&gt;saveNewFortune-&gt;save($newFortune);
    }
}
</code></pre>

<p>This should fix this specific error:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>Now our tests are telling us to create <code>SaveNewFortune</code>:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/SaveNewFortune.php

namespace AppBundle\Service;

interface SaveNewFortune
{
    public function save(array $newFortune);
}
</code></pre>

<p>Let's see if it did the trick:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>Yes it did! To sum up what we've done in this section:</p>

<ul>
<li>we've created a <code>SubmitNewFortune</code> class that contains all input parameters
to submit a new fortune, and it validates them</li>
<li>we've create a <code>SubmitNewFortuneHandler</code> class that uses parameters from
<code>SubmitNewFortune</code> to call services which will do the actual logic</li>
<li>we've created a <code>SaveNewFortune</code> interface, its implementations will save new
fortunes</li>
</ul>

<h2 id="wiring">Wiring</h2>

<p>We're going to use Doctrine DBAL to actually save new fortunes in a database.
This can be done by creating an implementation of <code>SaveNewFortune</code>:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/Bridge/DoctrineDbalSaveNewFortune.php

namespace AppBundle\Service\Bridge;

use AppBundle\Service\SaveNewFortune;
use Doctrine\DBAL\Driver\Connection;

class DoctrineDbalSaveNewFortune implements SaveNewFortune
{
    private $connection;

    public function __construct(Connection $connection)
    {
        $this-&gt;connection = $connection;
    }

    public function save(array $newFortune)
    {
        $queryBuilder = $this-&gt;connection-&gt;createQueryBuilder();
        $queryBuilder-&gt;insert('fortune');
        $queryBuilder-&gt;setValue('content', '?');
        $queryBuilder-&gt;setParameter(0, $newFortune['content']);
        $sql = $queryBuilder-&gt;getSql();
        $parameters = $queryBuilder-&gt;getParameters();
        $statement = $this-&gt;connection-&gt;prepare($sql);
        $statement-&gt;execute($parameters);
    }
}
</code></pre>

<p>This was the last class we needed to write. We can now use <code>SubmitNewFortune</code>
in our controller:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/Api/FortuneController.php

namespace AppBundle\Controller\Api;

use AppBundle\Service\SubmitNewFortune;
use AppBundle\Service\SubmitNewFortuneHandler;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class FortuneController
{
    private $submitNewFortuneHandler;

    public function __construct(SubmitNewFortuneHandler $submitNewFortuneHandler)
    {
        $this-&gt;submitNewFortuneHandler = $submitNewFortuneHandler;
    }

    public function submit(Request $request)
    {
        $submitNewFortune = new SubmitNewFortune(
            $request-&gt;request-&gt;get('content')
        );
        $this-&gt;submitNewFortuneHandler-&gt;handle($submitNewFortune);

        return new Response('', 201);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: In the controller, we extract Request (input) parameters and put them
  in <code>SubmitNewFortune</code> which is going to validate them. We then simply call
  <code>SubmitNewFortuneHandler</code> to take care of the logic associated to <code>SubmitNewFortune</code>.</p>
</blockquote>

<p>Now all that's left to do is wire everything together using Dependency Injection:</p>

<pre><code># app/config/services.yml

services:
    app.api.fortune_controller:
        class: 'AppBundle\Controller\Api\FortuneController'
        arguments:
            - '@app.submit_new_fortune_handler'

    app.submit_new_fortune_handler:
        class: 'AppBundle\Service\SubmitNewFortuneHandler'
        arguments:
            - '@app.save_new_fortune'

    app.save_new_fortune:
        alias: app.bridge.doctrine_dbal_save_new_fortune

    app.bridge.doctrine_dbal_save_new_fortune:
        class: 'AppBundle\Service\Bridge\DoctrineDbalSaveNewFortune'
        arguments:
            - '@database_connection'
</code></pre>

<p>Let's run the tests:</p>

<pre><code>rm -rf var/cache/test
vendor/bin/phpunit
</code></pre>

<p>They currently fail with <code>500 INTERNAL SERVER ERROR</code>. To get an idea of what's
going on, we need to have a look at our logs:</p>

<pre><code>grep CRITICAL var/logs/test.log | tail -n 1 # Get the last line containing "CRITICAL", which is often cause by 500
</code></pre>

<p>This is what we got:</p>

<pre><code>[2016-03-24 19:31:32] request.CRITICAL: Uncaught PHP Exception DomainException: "Missing required "content" parameter" at /home/foobar/fortune/src/AppBundle/Service/SubmitNewFortune.php line 13 {"exception":"[object] (DomainException(code: 422): Missing required \"content\" parameter at /home/foobar/fortune/src/AppBundle/Service/SubmitNewFortune.php:13)"} []
</code></pre>

<p>It looks like we don't get any data in the <code>request</code> attribute from <code>Request</code>.
That's because PHP doesn't populate <code>$_POST</code> when we send JSON data. We can fix
it by creating an <code>EventListener</code> that will prepare the Request for us:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/JsonRequestContentListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

/**
 * PHP does not populate $_POST with the data submitted via a JSON Request,
 * causing an empty $request-&gt;request.
 *
 * This listener fixes this.
 */
class JsonRequestContentListener
{
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('PATCH', 'POST', 'PUT'), true);
        $isJson = (1 === preg_match('#application/json#', $request-&gt;headers-&gt;get('Content-Type')));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new Response('{"error":"Invalid or malformed JSON"}', 400, array('Content-Type' =&gt; 'application/json')));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>Our listener needs to be registered in the Dependency Injection Container:</p>

<pre><code># app/config/services.yml

services:
    app.api.fortune_controller:
        class: 'AppBundle\Controller\Api\FortuneController'
        arguments:
            - '@app.submit_new_fortune_handler'

    app.submit_new_fortune_handler:
        class: 'AppBundle\Service\SubmitNewFortuneHandler'
        arguments:
            - '@app.save_new_fortune'

    app.save_new_fortune:
        alias: app.bridge.doctrine_dbal_save_new_fortune

    app.bridge.doctrine_dbal_save_new_fortune:
        class: 'AppBundle\Service\Bridge\DoctrineDbalSaveNewFortune'
        arguments:
            - '@database_connection'

    app.json_request_content_listener:
        class: 'AppBundle\EventListener\JsonRequestContentListener'
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<p>This should fix our error:</p>

<pre><code>rm -rf var/cache/test
vendor/bin/phpunit
grep CRITICAL var/logs/test.log | tail -n 1
</code></pre>

<p>We still get a <code>500</code>, but this time for the following reason:</p>

<pre><code>[2016-03-24 19:36:09] request.CRITICAL: Uncaught PHP Exception Doctrine\DBAL\Exception\ConnectionException: "An exception occured in driver: SQLSTATE[08006] [7] FATAL:  database "fortune" does not exist" at /home/foobar/fortune/vendor/doctrine/dbal/lib/Doctrine/DBAL/Driver/AbstractPostgreSQLDriver.php line 85 {"exception":"[object] (Doctrine\\DBAL\\Exception\\ConnectionException(code: 0): An exception occured in driver: SQLSTATE[08006] [7] FATAL:  database \"fortune\" does not exist at /home/foobar/fortune/vendor/doctrine/dbal/lib/Doctrine/DBAL/Driver/AbstractPostgreSQLDriver.php:85, Doctrine\\DBAL\\Driver\\PDOException(code: 7): SQLSTATE[08006] [7] FATAL:  database \"fortune\" does not exist at /home/foobar/fortune/vendor/doctrine/dbal/lib/Doctrine/DBAL/Driver/PDOConnection.php:47, PDOException(code: 7): SQLSTATE[08006] [7] FATAL:  database \"fortune\" does not exist at /home/foobar/fortune/vendor/doctrine/dbal/lib/Doctrine/DBAL/Driver/PDOConnection.php:43)"} []
</code></pre>

<p>The database doesn't exist. It can be created with the following command, provided by Doctrine:</p>

<pre><code>bin/console doctrine:database:create
</code></pre>

<p>Let's take this opportunity to also create the table:</p>

<pre><code>bin/console doctrine:query:sql 'CREATE TABLE fortune (content TEXT);'
</code></pre>

<p>Let's re-run the tests:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>Hooray! We can now submit new fortunes by calling our endpoint:</p>

<pre><code>rm -rf var/cache/prod
php -S localhost:2501 -t web &amp;
curl -i -X POST localhost:2501/app.php/api/v1/fortunes -H 'Content-Type: application/json' -d '{"content":"What... is the air-speed velocity of an unladen swallow?"}'
killall -9 php
</code></pre>

<p>We can see our fortunes in the database:</p>

<pre><code>bin/console doctrine:query:sql 'SELECT * FROM fortune;'
</code></pre>

<p>We still have two failing tests though. That's because we don't catch our <code>DomainExceptions</code>.
This can be fixed in an <code>EventListener</code>:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/ExceptionListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;

class ExceptionListener
{
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof \DomainException) {
            return;
        }
        $event-&gt;setResponse(new Response(json_encode(array(
            'error' =&gt; $exception-&gt;getMessage(),
        )), $exception-&gt;getCode(), array('Content-Type' =&gt; 'application/json')));
    }
}
</code></pre>

<p>It then needs to be registered as a service:</p>

<pre><code># app/config/services.yml

services:
    app.api.fortune_controller:
        class: 'AppBundle\Controller\Api\FortuneController'
        arguments:
            - '@app.submit_new_fortune_handler'

    app.submit_new_fortune_handler:
        class: 'AppBundle\Service\SubmitNewFortuneHandler'
        arguments:
            - '@app.save_new_fortune'

    app.save_new_fortune:
        alias: app.bridge.doctrine_dbal_save_new_fortune

    app.bridge.doctrine_dbal_save_new_fortune:
        class: 'AppBundle\Service\Bridge\DoctrineDbalSaveNewFortune'
        arguments:
            - '@database_connection'

    app.json_request_content_listener:
        class: 'AppBundle\EventListener\JsonRequestContentListener'
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.exception_listener:
        class: 'AppBundle\EventListener\ExceptionListener'
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException }
</code></pre>

<p>Finally we run the tests:</p>

<pre><code>rm -rf var/cache/test
vendor/bin/phpunit
</code></pre>

<p>All green!</p>

<h2 id="conclusion">Conclusion</h2>

<p>To create a new endpoint, we need to:</p>

<ul>
<li>create a Controller class</li>
<li>configure its routing</li>
<li>register the controller as a service</li>
</ul>

<p>We might need to create some event listeners (to populate <code>$request-&gt;request</code>
when receiving JSON content, or to convert exceptions to responses).</p>

<p>The endpoint's logic is then up to us, it doesn't have to be done in a "Symfony"
way. For example we can:</p>

<ul>
<li>extract Request parameters and put them in a class that validates them</li>
<li>pass the class to a handler that will call services to do the actual logic</li>
<li>define our services as interfaces, and then create implementations to integrate
them with third party libraries</li>
</ul>

<p>You can find the code on Github: <a href="https://github.com/gnugat-examples/fortune/tree/api-example">Fortune - API example</a></p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Skeleton]]></title>
            <link href="/2016/03/16/ultimate-symfony-skeleton.html"/>
            <updated>2016-03-16T00:00:00+00:00</updated>
            <id>/2016/03/16/ultimate-symfony-skeleton.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Start by putting everything in <code>AppBundle</code> until we have a better
  idea of what the project looks like and how to organize it.</p>
</blockquote>

<p>In this guide we've explored the main standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>We've also seen how HttpKernel enabled reusable code with <a href="/2016/03/09/ultimate-symfony-bundle.html">Bundles</a>.</p>

<p>In this article, we're going to have a closer look at how to organise our applications
directory tree.</p>

<p>Finally in the next articles we'll finish by putting all this knowledge in practice by creating a
"fortune" project with:</p>

<ul>
<li><a href="/2016/03/24/ultimate-symfony-api-example.html">an endpoint that allows us to submit new fortunes</a></li>
<li><a href="/2016/03/30/ultimate-symfony-web-example.html">a page that lists all fortunes</a></li>
<li><a href="/2016/04/06/ultimate-symfony-cli-example.html">a command that prints the last fortune</a></li>
</ul>

<h2 id="editions">Editions</h2>

<p>Deciding how our project directory is organized is up to us, but for consistency
and convenience we usually use "Editions" to bootstrap new projects:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition our-project
cd our-project
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Here we've decided to use the <a href="https://github.com/gnugat/symfony-empty-edition">Symfony Empty Edition</a>
  which follows the "add what you need" philosophy (it only contains the strict minimum).</p>
  
  <p>If we're rather fond of the "solve 80% of use cases" philosophy we can go for
  <a href="https://github.com/symfony/symfony-standard">Standard Edition</a>
  which includes many tools commonly used to build full-stack websites.</p>
  
  <p>To find more distributions, <a href="http://symfony.com/distributions">check the official website</a>.</p>
</blockquote>

<p>The directory tree looks like this:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── autoload.php
│   └── config
│       ├── config_dev.yml
│       ├── config_prod.yml
│       ├── config_test.yml
│       ├── config.yml
│       └── parameters.yml.dist
├── bin
│   └── console
├── composer.json
├── src
│   └── AppBundle
│       └── AppBundle.php
├── var
│   ├── cache
│   └── logs
└── web
    ├── app.php
    ├── favicon.ico
    └── robots.txt
</code></pre>

<p>Each folder in the root directory has a purpose:</p>

<ul>
<li><code>app</code>: configuration</li>
<li><code>bin</code>: scripts, binaries</li>
<li><code>src</code>: our code</li>
<li><code>var</code>: temporary files</li>
<li><code>web</code>: public directory exposed via the web server (<code>app.php</code> is the front controller)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: Classes that wouldn't be used in production can be put outside of
  <code>src</code> (e.g. tests could be put in <code>tests</code>, fixtures in <code>fixtures</code>, etc). They
  should be configured in <code>composer.json</code> as follow:</p>

<pre><code>{
    "autoload-dev": {
        "psr-4": {
            "Gnugat\\Toasty\\Fixtures\\": "fixtures",
            "Gnugat\\Toasty\\Tests\\": "tests"
        }
    }
}
</code></pre>
  
  <p>This way, when running Composer's <code>install</code> command in development we get our
  tests/fixtures classes autoloaded, and when running the same command with <code>--no-dev</code>
  option in production we don't.</p>
</blockquote>

<h2 id="appbundle">AppBundle</h2>

<p>Once we have an empty skeleton, we can start organizing our code by puting all
new classes in <code>src/AppBundle</code>, as advised by the <a href="http://symfony.com/doc/current/best_practices/business-logic.html">official best practice</a>.</p>

<p>Symfony specific classes can be put in the following directories:</p>

<ul>
<li><code>src/AppBundle/Command</code>, for Console Commands</li>
<li><code>src/AppBundle/Controller</code> for HttpKernel Controllers</li>
<li><code>src/AppBundle/DependencyInjection</code>, for <code>CompilerPassInterface</code> and <code>ExtensionInterface</code> implementations</li>
<li><code>src/AppBundle/EventListener</code>, for EventDispatcher Listeners</li>
</ul>

<p>Our project specific classes can be put the <code>src/AppBundle/Service</code> directory.</p>

<p>The number of classes in will grow overtime, at some point we'll have an itch to
organize them in a better way: we can group them by entity.</p>

<p>Regarding configuration, we can organize it this way:</p>

<ul>
<li><code>app/config/routings/</code>, contains Router configuration</li>
<li><code>app/config/services/</code>, contains Dependency Injection configuration</li>
</ul>

<p>The directory tree looks like this:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── autoload.php
│   └── config
│       ├── config_dev.yml
│       ├── config_prod.yml
│       ├── config_test.yml
│       ├── config.yml
│       ├── parameters.yml.dist
│       ├── routings
│       └── services
├── bin
│   └── console
├── composer.json
├── composer.lock
├── src
│   └── AppBundle
│       ├── AppBundle.php
│       ├── Command
│       ├── Controller
│       ├── DependencyInjection
│       │   └── CompilerPass
│       ├── EventListener
│       └── Service
├── var
│   ├── cache
│   └── logs
└── web
    ├── app.php
    ├── favicon.ico
    └── robots.txt
</code></pre>

<h2 id="decoupling-from-framework">Decoupling from framework</h2>

<p>Starting by putting everything in <code>AppBundle</code> is fine until we have a better idea
of what the project looks like and how to organize it.</p>

<p>As suggested in the <a href="http://symfony.com/doc/current/best_practices/business-logic.html">official best practice</a>,
we can move our "business logic" (everything in <code>src/AppBundle/Service</code>) to a new
<code>src/&lt;vendor&gt;/&lt;project&gt;</code> directory.</p>

<blockquote>
  <p><strong>Note</strong>: Replace <code>&lt;vendor&gt;</code> by the organization/author (e.g. <code>Gnugat</code>)
  and <code>&lt;project&gt;</code> by the project name (e.g. <code>Toasty</code>).</p>
</blockquote>

<p>The directory tree looks like this:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── autoload.php
│   └── config
│       ├── config_dev.yml
│       ├── config_prod.yml
│       ├── config_test.yml
│       ├── config.yml
│       ├── parameters.yml.dist
│       ├── routings
│       └── services
├── bin
│   └── console
├── composer.json
├── composer.lock
├── src
│   ├── AppBundle
│   │   ├── AppBundle.php
│   │   ├── Command
│   │   ├── Controller
│   │   ├── DependencyInjection
│   │   │   └── CompilerPass
│   │   └── EventListener
│   └── &lt;vendor&gt;
│       └── &lt;project&gt;
├── var
│   ├── cache
│   └── logs
└── web
    ├── app.php
    ├── favicon.ico
    └── robots.txt
</code></pre>

<p>By leaving Symfony related classes in <code>src/AppBundle</code> and our "business logic"
in <code>src/&lt;vendor&gt;/&lt;project&gt;</code>, it becomes easier to <a href="/2015/09/30/decouple-from-frameworks.html">decouple from the framework</a>.</p>

<h2 id="decouple-from-libraries">Decouple from libraries</h2>

<p>Building on "decoupling from frameworks", we might also want to <a href="http://localhost:8000/2015/10/12/decouple-from-libraries.html">decouple from libraires</a>.
To do so our "business logic" classes should rely on interfaces, and their implementation
would use libraries.</p>

<p>At this point we can get three different categories of classes:</p>

<ul>
<li><code>Domain</code> ones, classes that reflect our business logic</li>
<li><code>Component</code> ones, classes that don't have a direct link to our project and could be reused as libraries</li>
<li><code>Bridge</code> ones, classes that map our Domain to Component (or third party libraries)</li>
</ul>

<p>By organizing our directory tree with those categories, it could looks like this:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── autoload.php
│   └── config
│       ├── config_dev.yml
│       ├── config_prod.yml
│       ├── config_test.yml
│       ├── config.yml
│       ├── parameters.yml.dist
│       ├── routings
│       └── services
├── bin
│   └── console
├── composer.json
├── composer.lock
├── src
│   ├── AppBundle
│   │   ├── AppBundle.php
│   │   ├── Command
│   │   ├── Controller
│   │   ├── DependencyInjection
│   │   │   └── CompilerPass
│   │   └── EventListener
│   └── &lt;vendor&gt;
│       └── &lt;project&gt;
│           ├── Bridge
│           ├── Component
│           └── Domain
├── var
│   ├── cache
│   └── logs
└── web
    ├── app.php
    ├── favicon.ico
    └── robots.txt
</code></pre>

<p>The issue with the previous organization is that classes in <code>Bridge</code> are now away
from their interface. Wouldn't it better to keep related classes close?</p>

<p>Here's an alternative organization, where we move <code>Bridge</code> to be in <code>Domain</code>:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── autoload.php
│   └── config
│       ├── config_dev.yml
│       ├── config_prod.yml
│       ├── config_test.yml
│       ├── config.yml
│       ├── parameters.yml.dist
│       ├── routings
│       └── services
├── bin
│   └── console
├── composer.json
├── composer.lock
├── src
│   ├── AppBundle
│   │   ├── AppBundle.php
│   │   ├── Command
│   │   ├── Controller
│   │   ├── DependencyInjection
│   │   │   └── CompilerPass
│   │   └── EventListener
│   └── &lt;vendor&gt;
│       └── &lt;project&gt;
│           ├── Component
│           └── Domain
│               └── Bridge
├── var
│   ├── cache
│   └── logs
└── web
    ├── app.php
    ├── favicon.ico
    └── robots.txt
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <code>Components</code> could also need their own bridges. Also, a "Bundle" is
  a kind of bridge: it maps a library to Symfony.</p>
</blockquote>

<h2 id="monolithic-repository">Monolithic Repository</h2>

<p>There's a possibility that our application grows out of proportion and we decide
it'd be better to split it into smaller applications.</p>

<p>For example if we have an application that creates resources through a backend
and then provides them through an API for other applications, we could split it
in two: <code>backend</code> (note that <code>backend</code> could also be split in two:
<code>backend-api</code> and <code>backend-ui</code>) and <code>api</code>.</p>

<p>The problem is that those two applications would share a lot of logic, so splitting
them in different repositories could become cumbersome to maintain. A good indicator
to know if they need to be in the same repository: when we create a new version,
do we need to release them together?</p>

<p>In that case it might be worth keeping those two applications in the same repository,
this practice being called "Monolithic Repository".</p>

<p>For our project, it would mean:</p>

<ul>
<li>creating an <code>apps</code> directory where we would put small symfony applications,
similar to the first directory tree we've seen</li>
<li>creating a <code>packages</code> directory where we would put the previous content of <code>src/&lt;vendor&gt;/&lt;project&gt;</code>,
with each component in their own directory (to enable us to use them selectively in each apps)</li>
</ul>

<p>Here's an overview:</p>

<pre><code>.
├── apps
│   └── &lt;app&gt;
│       ├── app
│       │   ├── AppKernel.php
│       │   ├── autoload.php
│       │   └── config
│       │       ├── config_dev.yml
│       │       ├── config_prod.yml
│       │       ├── config_test.yml
│       │       ├── config.yml
│       │       ├── parameters.yml.dist
│       │       ├── routings
│       │       └── services
│       ├── bin
│       │   └── console
│       ├── composer.json
│       ├── composer.lock
│       ├── src
│       │   └── AppBundle
│       │       ├── AppBundle.php
│       │       ├── Command
│       │       ├── Controller
│       │       ├── DependencyInjection
│       │       │   └── CompilerPass
│       │       └── EventListener
│       ├── var
│       │   ├── cache
│       │   └── logs
│       └── web
│           ├── app.php
│           ├── favicon.ico
│           └── robots.txt
└── packages
    └── &lt;package&gt;
        ├── composer.json
        └── src
</code></pre>

<blockquote>
  <p><strong>Note</strong>: More information about Monolithic Repository:</p>
  
  <ul>
  <li><a href="http://gregoryszorc.com/blog/2014/09/09/on-monolithic-repositories/">On monolithic repositories</a></li>
  <li><a href="http://danluu.com/monorepo/">Advantages of monolithic version control</a></li>
  <li><a href="http://sroze.io/2015/09/14/managing-monolith-repositories-with-composers-path-repository/">Managing monolithic repositories with composer’s path repository</a></li>
  <li><a href="https://qafoo.com/talks/15_10_symfony_live_berlin_monorepos.pdf">Working with a single, big, scary version control repository</a></li>
  <li><a href="http://www.whitewashing.de/2015/04/11/monolithic_repositories_with_php_and_composer.html">Monolithic Repositories with PHP and Composer</a></li>
  <li><a href="http://tech.mybuilder.com/why-we-created-conductor/">Conductor: A return to monolith</a></li>
  </ul>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>There are many ways to organize our application directory tree, and it's difficult
to pick one when we don't have a clear idea on their impact or on what our project
should look like.</p>

<p>The best way to tackle this is to first start small (everything in <code>src/AppBundle</code>),
and then move gradually files around. It's also important to make sure that change
is possible.</p>

<p>Here are some alternative ways of organizing the project directory tree:</p>

<ul>
<li><a href="http://programmingarehard.com/2015/03/04/structing-my-application.html/">Structuring my application</a>
by <a href="http://twitter.com/dadamssg">David Adams</a></li>
<li><a href="http://verraes.net/2011/10/code-folder-structure/">Code Folder Structure</a>
by <a href="http://twitter.com/mathiasverraes">Mathias Verraes</a></li>
<li><a href="http://williamdurand.fr/2013/08/07/ddd-with-symfony2-folder-structure-and-code-first/">DDD with Symfony2: Folder Structure And Code First</a>
by <a href="http://williamdurand.fr/">William Durand</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Bundle]]></title>
            <link href="/2016/03/09/ultimate-symfony-bundle.html"/>
            <updated>2016-03-09T00:00:00+00:00</updated>
            <id>/2016/03/09/ultimate-symfony-bundle.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Configure services from a third party library in a Bundle.</p>
</blockquote>

<p>In this guide we've explored the main standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>In this article, we're going to have a closer look at how HttpKernel enables reusable code.</p>

<p>Then in the next article we'll see the different ways to organize our application
<a href="/2016/03/16/ultimate-symfony-skeleton.html">tree directory</a>.</p>

<p>Finally we'll finish by putting all this knowledge in practice by creating a
"fortune" project with:</p>

<ul>
<li><a href="/2016/03/24/ultimate-symfony-api-example.html">an endpoint that allows us to submit new fortunes</a></li>
<li><a href="/2016/03/30/ultimate-symfony-web-example.html">a page that lists all fortunes</a></li>
<li><a href="/2016/04/06/ultimate-symfony-cli-example.html">a command that prints the last fortune</a></li>
</ul>

<h2 id="httpkernel-vs-kernel">HttpKernel vs Kernel</h2>

<p>The HttpKernel component provides two implementations for <code>HttpKernelInterface</code>.</p>

<p>The first one, <code>HttpKernel</code>, relies on Event Dispatcher and Routing to execute
the appropriate controller for the given Request.</p>

<p>And the second one, <code>Kernel</code>, relies on Dependency Injection and <code>HttpKernel</code>:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpKernel;

use Symfony\Component\HttpFoundation\Request;

class Kernel implements HttpKernelInterface
{
    public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
    {
        if (false === $this-&gt;booted) {
            $this-&gt;boot();
        }

        return $this-&gt;container-&gt;get('http_kernel')-&gt;handle($request, $type, $catch);
    }

    public function boot()
    {
        // Initializes the container
    }

    abstract public function registerBundles();
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For brevity's sake, <code>Kernel</code> has been heavily truncated.</p>
</blockquote>

<p>Initialization of the container includes:</p>

<ol>
<li>retrieving all "bundles"</li>
<li>creating a <code>ContainerBuilder</code></li>
<li>for each bundles:

<ol>
<li>registering its <code>ExtensionInterface</code> implementations in the container</li>
<li>registering its <code>CompilerPassInterface</code> implementations in the container</li>
</ol></li>
<li>dumping the container in an optimized implementation</li>
</ol>

<p>Once the container is initialized, <code>Kernel</code> expects it to contain a <code>http_kernel</code>
service to which it will delegate the actual HTTP work.</p>

<h2 id="bundle">Bundle</h2>

<p>A bundle is a package that contains <code>ExtensionInterface</code> and <code>CompilerPassInterface</code>
implementations, to configure a Dependency Injection container. It can be summed
up by this interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpKernel\Bundle;

use Symfony\Component\DependencyInjection\ContainerBuilder;

interface BundleInterface
{
    // Adds CompilerPassInterface implementations to the container
    public function build(ContainerBuilder $container);

    // Returs an ExtensionInterface implementation, which will be registered in the container
    public function getContainerExtension();
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Once again, this interface has been truncated for brevity's sake.</p>
</blockquote>

<p>Bundles are usually created for one of the following purposes:</p>

<ul>
<li>define a third party library's classes as Dependency Injection services (e.g.
<a href="https://github.com/thephpleague/tactician-bundle">TacticianBundle</a>
for <a href="https://tactician.thephpleague.com/">Tactician</a>
which provides a <a href="http://shawnmc.cool/command-bus">CommandBus</a>,
<a href="https://github.com/symfony/monolog-bundle">MonologBundle</a>
for <a href="https://github.com/Seldaek/monolog">Monolog</a>
which provides a <a href="http://www.php-fig.org/psr/psr-3/">PSR-3</a> compliant logger,
etc)</li>
<li>define an application's classes as Dependency Injection services (usually named AppBundle)</li>
<li>create a framework (e.g.
user management with <a href="https://github.com/FriendsOfSymfony/FOSUserBundle">FOSUserBundle</a>,
admin generator with <a href="https://sonata-project.org/bundles/admin/2-3/doc/index.html">SonataAdminBundle</a>,
etc)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: the last category is considered bad practice, as explained in the
  following, articles:</p>
  
  <ul>
  <li><a href="http://jolicode.com/blog/do-not-use-fosuserbundle">composer require technical-debt-bundle</a>.</li>
  <li><a href="http://elnur.pro/use-only-infrastructural-bundles-in-symfony/">Use only infrastructural bundles in Symfony2, by Elnur Abdurrakhimov</a></li>
  <li><a href="http://stackoverflow.com/questions/9999433/should-everything-really-be-a-bundle-in-symfony-2-x/10001019#10001019">Should everything really be a bundle in Symfony2?</a></li>
  <li><a href="http://danielribeiro.org/blog/yes-you-can-have-low-coupling-in-a-symfony-standard-edition-application/">Yes, you can have low coupling in a Symfony2 application</a></li>
  <li><a href="http://elnur.pro/symfony-without-bundles/">Symfony2 without bundles, by Elnur Abdurrakhimov, by Daniel Ribeiro</a></li>
  <li><a href="http://php-and-symfony.matthiasnoback.nl/2013/10/symfony2-some-things-i-dont-like-about-bundles/">Symfony2 some things I dont like about bundles, by Matthias Noback</a></li>
  <li><a href="http://php-and-symfony.matthiasnoback.nl/2013/10/symfony2-console-commands-as-services-why/">Symfony2 console commands as services why, by Matthias Noback</a></li>
  <li><a href="http://www.slideshare.net/matthiasnoback/high-quality-symfony-bundles-tutorial-dutch-php-conference-2014">Naked bundles, slides by Matthias Noback</a></li>
  </ul>
</blockquote>

<p>Bundles follow <a href="http://symfony.com/doc/current/cookbook/bundles/best_practices.html">by convention</a>
the following directory tree:</p>

<pre><code>.
├── Command
├── Controller
├── DependencyInjection
│   └── CompilerPass
├── EventListener
├── Resources
│   └── config
│       └── services
│           └── some_definitions.yml
├── Tests
└── VendorProjectBundle.php
</code></pre>

<h2 id="nanoframeworkbundle-example">NanoFrameworkBundle example</h2>

<p>Since HttpKernel component is a third party library, we're going to create a
bundle to provide its classes as Dependency Injection services. This is also a
good opportunity to have a look at how a Symfony application works behind the hood.</p>

<p>NanoFrameworkBundle's purpose is to provides a <code>http_kernel</code> service that can be
used by <code>Kernel</code>. First let's create a directory:</p>

<pre><code>mkdir nano-framework-bundle
cd nano-framework-bundle
</code></pre>

<p>Then we can create an implementation of <code>BundleInterface</code>:</p>

<pre><code class="php">&lt;?php
// VendorNanoFrameworkBundle.php

namespace Vendor\NanoFrameworkBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;

class VendorNanoFrameworkBundle extends Bundle
{
}
</code></pre>

<h3 id="bundle-extension">Bundle extension</h3>

<p>To be able to load Dependency Injection configuration, we'll create an
implementation of <code>ExtensionInterface</code>:</p>

<pre><code class="php">&lt;?php
// DependencyInjection/VendorNanoFrameworkExtension.php

namespace Vendor\NanoFrameworkBundle\DependencyInjection;

use Symfony\Component\Config\FileLocator;
use Symfony\Component\Config\Loader\LoaderResolver;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\DirectoryLoader;
use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;
use Symfony\Component\HttpKernel\DependencyInjection\Extension;

class VendorNanoFrameworkExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $fileLocator = new FileLocator(__DIR__.'/../Resources/config');
        $loader = new DirectoryLoader($container, $fileLocator);
        $loader-&gt;setResolver(new LoaderResolver(array(
            new YamlFileLoader($container, $fileLocator),
            $loader,
        )));
        $loader-&gt;load('services/');
    }
}
</code></pre>

<p>Once done, we can create the configuration:</p>

<pre><code># Resources/config/services/http_kernel.yml
services:
    http_kernel:
        class: Symfony\Component\HttpKernel\HttpKernel
        arguments:
            - "@event_dispatcher"
            - "@controller_resolver"
            - "@request_stack"

    event_dispatcher:
        class: Symfony\Component\EventDispatcher\EventDispatcher

    controller_resolver:
        class: Symfony\Component\HttpKernel\Controller\ControllerResolver
        public: false

    request_stack:
        class: Symfony\Component\HttpFoundation\RequestStack
</code></pre>

<h3 id="bundle-compiler-pass">Bundle compiler pass</h3>

<p>In order to register event listeners in EventDispatcher in a way that doesn't
require us to edit <code>Resources/config/services/http_kernel.yml</code>, we're going to
create an implementation of <code>CompilerInterface</code>:</p>

<pre><code class="php">&lt;?php
// DependencyInjection/CompilerPass/AddListenersPass.php

namespace Vendor\NanoFrameworkBundle\DependencyInjection;

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
use Symfony\Component\DependencyInjection\Reference;

class AddListenersPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        $eventDispatcher = $container-&gt;findDefinition('event_dispatcher');
        $eventListeners = $container-&gt;findTaggedServiceIds('kernel.event_listener');
        foreach ($eventListeners as $id =&gt; $events) {
            foreach ($events as $event) {
                $eventDispatcher-&gt;addMethodCall('addListener', array(
                    $event['event'],
                    array(new Reference($id), $event['method']),
                    isset($event['priority']) ? $event['priority'] : 0;
                ));
            }
        }
    }
}
</code></pre>

<p>With this, we only need to add a tag with:</p>

<ul>
<li>a <code>kernel.event_listener</code> name</li>
<li>an event to listen to (e.g. <code>kernel.request</code>)</li>
<li>a method to call (e.g. <code>onKernelRequest</code>)</li>
<li>optionally a priority (default to <code>0</code>, the greater the sooner it will be executed)</li>
</ul>

<p>To complete the step, we need to register it in our bundle:</p>

<pre><code class="php">&lt;?php
// VendorNanoFrameworkBundle.php

namespace Vendor\NanoFrameworkBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;
use Vendor\NanoFrameworkBundle\DependencyInjection\CompilerPass\AddListenersPass;

class VendorNanoFrameworkBundle extends Bundle
{
    public function build(ContainerBuilder $container)
    {
        parent::build($container);

        $container-&gt;addCompilerPass(new AddListenersPass());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: While <code>CompilerPassInterface</code> implementations need to be registered
  explicitly, there is no need to do anything for <code>ExtensionInterface</code> implementations
  as <code>Bundle</code> contains a method able to locate it, based on the following conventions:</p>
  
  <ul>
  <li>it needs to be in <code>DependencyInjection</code> directory</li>
  <li>it needs to be named after the bundle name (replace <code>Bundle</code> suffix by <code>Extension</code>)</li>
  <li>it needs to implement <code>ExtensionInterface</code></li>
  </ul>
</blockquote>

<h3 id="more-configuration">More configuration</h3>

<p>HttpKernel relies on event listeners for the routing, in order to enable it we
need to add the following configuration:</p>

<pre><code># Resources/config/services/routing.yml
services:
    router_listener:
        class: Symfony\Component\HttpKernel\EventListener\RouterListener
        arguments:
            - "@router"
            - "@request_stack"
            - "@router.request_context"
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest, priority: 32 }

    router:
        class: Symfony\Component\Routing\Router
        public: false
        arguments:
            - "@routing.loader"
            - "%kernel.root_dir%/config/routings"
            - "%router.options%"
            - "@router.request_context"
        calls:
            - [setConfigCacheFactory, ["@config_cache_factory"]]

    routing.loader:
        class: Symfony\Component\Config\Loader\DelegatingLoader
        public: false
        arguments:
            - "@routing.resolver"

    routing.resolver:
        class: Symfony\Component\Config\Loader\LoaderResolver
        public: false
        calls:
            - [addLoader, ["@routing.loader.yml"]]

    router.request_context:
        class: Symfony\Component\Routing\RequestContext
        public: false

    config_cache_factory:
        class: Symfony\Component\Config\ResourceCheckerConfigCacheFactory
        public: false

    routing.loader.yml:
        class: Symfony\Component\Routing\Loader\YamlFileLoader
        public: false
        arguments:
            - "@file_locator"
</code></pre>

<h2 id="usage">Usage</h2>

<p>Since <code>Kernel</code> is an abstract class, we need to create an implementation (usually
called AppKernel):</p>

<pre><code class="php">&lt;?php
// Tests/app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Vendor\NanoFrameworkBundle\VendorNanoFrameworkBundle(),
        );
    }

    public function getRootDir()
    {
        return __DIR__;
    }

    public function getCacheDir()
    {
        return dirname(__DIR__).'/var/cache/'.$this-&gt;getEnvironment();
    }

    public function getLogDir()
    {
        return dirname(__DIR__).'/var/logs';
    }
}
</code></pre>

<p>Finally we need to create a "Front Controller" (a fancy name for <code>index.php</code>):</p>

<pre><code class="php">&lt;?php
// Tests/web/index.php

&lt;?php

use Symfony\Component\HttpFoundation\Request;

$kernel = new AppKernel('prod', false);
$request = Request::createFromGlobals();
$response = $kernel-&gt;handle($request);
$response-&gt;send();
$kernel-&gt;terminate($request, $response);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Bundles enable us to define classes as Dependency Injection services, for our
applications and third part libraries in a reusable way.</p>

<p>In the example above we've created a bundle that provides a <code>http_kernel</code> service,
which can then be used to create Symfony applications. Here are some existing
bundles that do it for us:</p>

<ul>
<li><a href="https://github.com/symfony/framework-bundle">FrameworkBundle</a>, the official one
provided by Symfony. It comes with many services out of the box, mainly targeted
at full stack applications (it follows a "solve 80% of use cases" philosohpy)</li>
<li><a href="http://gnugat.github.io/micro-framework-bundle/">MicroFrameworkBundle</a>, an unofficial
one. It comes with the bare minimum (it follows a "add what you need" philosohpy)</li>
</ul>

<p>There are many bundles available, you can find them by checking
<a href="https://packagist.org/search/?q=symfony-bundle">symfony-bundle in Packagist</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Console]]></title>
            <link href="/2016/03/02/ultimate-symfony-console.html"/>
            <updated>2016-03-02T00:00:00+00:00</updated>
            <id>/2016/03/02/ultimate-symfony-console.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: <code>$statusCode = $application-&gt;run($input);</code></p>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
</ul>

<p>We're now about to check the last one: Console.</p>

<p>In the next articles we'll also see how HttpKernel enables reusable code with <a href="/2016/03/09/ultimate-symfony-bundle.html">Bundles</a>,
and the different ways to organize our application <a href="/2016/03/16/ultimate-symfony-skeleton.html">tree directory</a>.</p>

<p>Finally we'll finish by putting all this knowledge in practice by creating a
"fortune" project with:</p>

<ul>
<li><a href="/2016/03/24/ultimate-symfony-api-example.html">an endpoint that allows us to submit new fortunes</a></li>
<li><a href="/2016/03/30/ultimate-symfony-web-example.html">a page that lists all fortunes</a></li>
<li><a href="/2016/04/06/ultimate-symfony-cli-example.html">a command that prints the last fortune</a></li>
</ul>

<h2 id="application">Application</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/console/introduction.html">Console component</a>
which allows us to create CLI commands. Its main class is <code>Application</code>:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Command\Command;

class Application
{
    public function __construct($name = 'UNKNOWN', $version = 'UNKNOWN');

    public function add(Command $command);
    public function setDefaultCommand($commandName);
    public function run(InputInterface $input = null, OutputInterface $output = null);

    public function setAutoExit($boolean);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: This snippet is a truncated version. Please note that <code>Application</code>
  is (unfortunately) not an interface.</p>
</blockquote>

<p>We can create it as follow:</p>

<pre><code class="php">&lt;?php
// /tmp/console.php

use Symfony\Component\Console\Application;
use Symfony\Component\Console\Input\ArgvInput;

$application = new Application('My Application', 'v4.2.3');
$application-&gt;add($command);
$application-&gt;setDefaultCommand($command-&gt;getName());

$application-&gt;run(new ArgvInput());
</code></pre>

<p>Which can then be used as follow:</p>

<pre><code>php /tmp/console.php
</code></pre>

<blockquote>
  <p><strong>Note</strong>: After running the command, <code>Application</code> will automatically stop
  using <code>exit</code>.
  As it can sometimes be inconvenient (for example in tests), we can disable it
  with this line: <code>$application-&gt;setAutoExit(false);</code></p>
</blockquote>

<p>Out of the box, <code>Application</code> has two commands:</p>

<ul>
<li><code>list</code>, list all available commands (it's the default command if <code>setDefaultCommand</code> hasn't been used)</li>
<li><code>help</code>, displays a description with available arguments and options for the current command</li>
</ul>

<h2 id="command">Command</h2>

<p>In order for <code>Application</code> to be useful, we need to create commands. This can be
done by extending <code>Command</code>:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Command;

use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

class Command
{
    public function run(InputInterface $input, OutputInterface $output);
    // Called by run
    protected function execute(InputInterface $input, OutputInterface $output);
    protected function interact(InputInterface $input, OutputInterface $output);

    protected function configure();
    // To be called in configure
    public function setName($name);
    public function addArgument($name, $mode = null, $description = '', $default = null);
    public function addOption($name, $shortcut = null, $mode = null, $description = '', $default = null);
    public function setDescription($description);
    public function setHelp($help);
    public function setAliases($aliases);
}
</code></pre>

<p>We can configure the command (name, arguments, options, description, etc) in the
<code>configure</code> method, we can define more options to be asked interractively in
the <code>interact</code> method (e.g. <code>Are you sure? (Y/n)</code>) and finally we can write the
command logic in the <code>execute</code> method.</p>

<p>Commands are to Console what Controllers are to HttpKernel: their responsibility
is to extract input parameters, pass them to a service and then put the service's
returned value in the output.</p>

<h2 id="input">Input</h2>

<p>Input parameters are wrapped in the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Input;

interface InputInterface
{
    public function getArgument($name);
    public function getOption($name);
}
</code></pre>

<p>Out of the box we have the following implementations:</p>

<ul>
<li><code>ArgvInput</code>: wraps CLI arguments comming from <code>$_SERVER['argv']</code></li>
<li><code>ArrayInput</code>: define arguments using an array, which is useful for tests</li>
</ul>

<p><code>Application</code> will take care of validating <code>InputInterface</code> parameters against
the <code>Command</code> configuration (e.g. if required arguments present).</p>

<h2 id="output">Output</h2>

<p>While <code>InputInterface</code> can be seen as a value object, <code>OutputInterface</code> should
be seen as a service able to send informations to a stream:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Output;

abstract class Output implements OutputInterface
{
    public function writeln($messages, $type = self::OUTPUT_NORMAL);
}
</code></pre>

<p>The <code>writeln</code> method allows us to write a new line (with a newline character at
the end). If the given message is an array, it will print each elements on a new
line.</p>

<p>The given message can contain tags (e.g. <code>Arthur &lt;info&gt;Dent&lt;/info&gt;</code>), which can
be used to format it. Out of the box it will color the followings:</p>

<ul>
<li>green text for informative messages (usage example: <code>&lt;info&gt;Arthur Dent&lt;/info&gt;</code>)</li>
<li>yellow text for comments (usage example: <code>&lt;comment&gt;Tricia McMillan&lt;/comment&gt;</code>)</li>
<li>black text on a cyan background for questions (usage example: <code>&lt;question&gt;Ford Prefect&lt;/question&gt;</code>)</li>
<li>white text on a red background for errors (usage example: <code>&lt;error&gt;Marvin&lt;/error&gt;</code>)</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>The Console component allows us to create CLI applications. Its Commands are a
thin layer which gathers the input and call services. Those services can then
output messages to the user.</p>

<blockquote>
  <p><strong>Note</strong>: Since Symfony follows a <a href="https://github.com/symfony/symfony-docs/issues/4265">Console Output Formating Style Guide</a>,
  the Console component provides the following helper class:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Console\Style;

use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Question\Question;

class SymfonyStyle
{
    public function __construct(InputInterface $input, OutputInterface $output);

    public function block($messages, $type = null, $style = null, $prefix = ' ', $padding = false);
    public function title($message);
    public function section($message);
    public function listing(array $elements);
    public function text($message);

    public function comment($message);
    public function success($message);
    public function error($message);
    public function warning($message);
    public function note($message);
    public function caution($message);

    public function table(array $headers, array $rows);

    public function ask($question, $default = null, $validator = null);
    public function askHidden($question, $validator = null);
    public function confirm($question, $default = true);
    public function choice($question, array $choices, $default = null);
    public function askQuestion(Question $question);

    public function progressStart($max = 0);
    public function progressAdvance($step = 1);
    public function progressFinish();
    public function createProgressBar($max = 0);

    public function writeln($messages, $type = self::OUTPUT_NORMAL);
    public function write($messages, $newline = false, $type = self::OUTPUT_NORMAL);
    public function newLine($count = 1);
}
</code></pre>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Dependency Injection]]></title>
            <link href="/2016/02/24/ultimate-symfony-dependency-injection.html"/>
            <updated>2016-02-24T00:00:00+00:00</updated>
            <id>/2016/02/24/ultimate-symfony-dependency-injection.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: Make Dependency Injection easy by moving class construction in
  configuration files.</p>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
</ul>

<p>We're now about to check Dependency Injection, then the next article we'll have
a look at <a href="/2016/03/02/ultimate-symfony-console.html">Console</a>.</p>

<p>We'll also see how HttpKernel enables reusable code with <a href="/2016/03/09/ultimate-symfony-bundle.html">Bundles</a>,
and the different ways to organize our application <a href="/2016/03/16/ultimate-symfony-skeleton.html">tree directory</a>.</p>

<p>Finally we'll finish by putting all this knowledge in practice by creating a
"fortune" project with:</p>

<ul>
<li><a href="/2016/03/24/ultimate-symfony-api-example.html">an endpoint that allows us to submit new fortunes</a></li>
<li><a href="/2016/03/30/ultimate-symfony-web-example.html">a page that lists all fortunes</a></li>
<li><a href="/2016/04/06/ultimate-symfony-cli-example.html">a command that prints the last fortune</a></li>
</ul>

<h2 id="introduction-to-the-design-pattern">Introduction to the design pattern</h2>

<p>When first creating a class, we tend to keep it small and tidy. Then overtime it
can grow out of control and the next thing we know it became this multi thousand
line monster:</p>

<pre><code class="php">&lt;?php

class CheckApiStatus
{
    public function check($url)
    {
        $curl = curl_init();
        curl_setopt_array($curl, array(
            CUROPT_RETURNTRANSFER =&gt; true,
            CURLOPT_HEADER =&gt; true,
            CUROPT_URL =&gt; $url,
        ));
        $response = curl_exec($curl);
        $headerSize = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
        $statusCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);
        curl_close($curl);
        $headers = array_map(function($line) {
            return explode(': ', trim($line));
        }, explode("\n", substr($response, 0, $size)));
        array_pop($headers);array_pop($headers);array_shift($headers);
        $body = substr($response, $headerSize);

        return 200 &gt;= $statusCode &amp;&amp; $statusCode &lt; 400;
    }
}
</code></pre>

<p>A nice way to shrink it back to an acceptable level is to identify the many
"responsibilities" it bears and split those in sub classes. This process is called
refactoring:</p>

<pre><code class="php">&lt;?php

class Request
{
    private $uri;

    public function __construct($uri)
    {
        $this-&gt;uri;
    }

    public function getUri()
    {
        return $this-&gt;uri;
    }
}

class Response
{
    private $statusCode;
    private $headers;
    private $body;

    public function __construct($statusCode, $headers, $body)
    {
        $this-&gt;statusCode = $statusCode;
        $this-&gt;headers = $headers;
        $this-&gt;body = $body;
    }

    public function getStatusCode()
    {
        return $this-&gt;statusCode;
    }

    public function getHeaders()
    {
        return $this-&gt;headers;
    }

    public function getBody()
    {
        return $this-&gt;body;
    }
}

interface HttpClient
{
    /**
     * @return Response
     */
    public function sendRequest(Request $request);
}

class CurlHttpClient implements HttpClient
{
    public function sendRequest(Request $request)
    {
        $curl = curl_init();
        curl_setopt_array($curl, array(
            CUROPT_RETURNTRANSFER =&gt; true,
            CURLOPT_HEADER =&gt; true,
            CUROPT_URL =&gt; $request-&gt;getUri(),
        ));
        $response = curl_exec($curl);
        $headerSize = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
        $statusCode = curl_getinfo($curl, CURLINFO_HTTP_CODE);
        curl_close($curl);
        $headers = array_map(function($line) {
            return explode(': ', trim($line));
        }, explode("\n", substr($response, 0, $size)));
        array_pop($headers);array_pop($headers);array_shift($headers);
        $body = substr($response, $headerSize);
        $body = substr($response, $headerSize);

        return new Response($statusCode, $headers, $body);
    }
}

class CheckApiStatus
{
    public function check($url)
    {
        $httpClient = new CurlHttpClient();
        $statusCode = $httpClient-&gt;sendRequest(new Request($url))-&gt;getStatusCode();

        return 200 &gt;= $statusCode &amp;&amp; $statusCode &lt; 400;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: for more refactoring examples, check:</p>
  
  <ul>
  <li><a href="http://martinfowler.com/articles/refactoring-external-service.html">Refactoring external service</a> by Martin Fowler</li>
  <li><a href="http://verraes.net/2013/09/extract-till-you-drop/">Extract till you drop</a> by Mathias Verreas</li>
  <li>Refactoring the cat API
  <a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-1/">part 1</a>
  <a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-2/">part 2</a>
  <a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-3/">part 3</a>
  by Matthias Noback</li>
  </ul>
</blockquote>

<p>Our original class then has to call those sub classes to "delegate" the work. But
how does it access those sub classes? Should it instantiate them in its methods?
A better place could be the constructor, where the instances are stored in the class
properties so it can be shared between two calls.</p>

<p>Or even better we can instantiate them out of the class, and then pass them as
arguments to the original class constructor, so we can share it with other classes:</p>

<pre><code class="php">&lt;?php

class CheckApiStatus
{
    private $httpClient;

    public function __construct(HttpClient $httpClient)
    {
        $this-&gt;httpClient = $httpClient;
    }

    public function check($url)
    {
        $statusCode = $this-&gt;httpClient-&gt;sendRequest(new Request($url))-&gt;getStatusCode();

        return 200 &gt;= $statusCode &amp;&amp; $statusCode &lt; 400;
    }
}

$httpClient = new CurlHttpClient();
$checkApiStatus = new CheckApiStatus($httpClient);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Now <code>CheckApiStatus</code> is decoupled from the remote request logic.</p>
  
  <p>The refactoring steps might seem like producing more code just for the "beauty"
  of principles, but it actually enables us to completly remove it: by using <a href="http://www.php-fig.org/psr/psr-7/">PSR-7</a>
  interfaces instead of our own we can easily switch to <a href="http://docs.guzzlephp.org/en/latest/">Guzzle</a>
  or any HTTP client library.</p>
</blockquote>

<p>And that's what <a href="http://www.martinfowler.com/articles/injection.html">Dependency Injection</a>
is all about: taking parameters (also known as dependencies) our class (also known as service)
needs and pass them as arguments (also known as injection), to allow more decoupling.</p>

<p>The downside of this design pattern is that we now have a cascade of instantiations.</p>

<blockquote>
  <p><strong>Note</strong>: Classes can be shared if they are stateless which means calling a method
  shouldn't change their attributes.</p>
</blockquote>

<h2 id="the-component">The component</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/dependency-injection/introduction.html">Dependency Injection component</a>
which allows us to set up how our classes are constructed:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Reference;

$container = new ContainerBuilder();

$container
    -&gt;register('http_client','CurlHttpClient')
;
$container
    -&gt;register('check_api_status', 'CheckApiStatus')
    -&gt;addArgument(new Reference('http_client'))
;

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<p>It can even be set up using configuration:</p>

<pre><code># /tmp/services/api.yml
services:
    http_client:
        class: CurlHttpClient

    check_api_status:
        class: CheckApiStatus
        arguments:
            - '@http_client'
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Some string values must be escaped using single quotes because YAML
  has a list of <a href="http://stackoverflow.com/a/22235064">reserved characters</a>, including:
  <code>@</code>, <code>%</code>, <code>\</code>, <code>-</code>, <code>:</code> <code>[</code>, <code>]</code>, <code>{</code> and <code>}</code>.</p>
</blockquote>

<p>Here's how we can load this configuration:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Config\FileLocator;
use Symfony\Component\Config\Loader\LoaderResolver;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\DirectoryLoader;
use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;

$container = new ContainerBuilder();

// Load recursively all YAML configuration files in services directories
$fileLocator = new FileLocator(__DIR__);
$loader = new DirectoryLoader($container, $fileLocator);
$loader-&gt;setResolver(new LoaderResolver(array(
    new YamlFileLoader($container, $fileLocator),
    $loader,
)));
$loader-&gt;load('/services/');

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<p>Calling methods on a created service to complete its initialization is possible:</p>

<pre><code>services:
    my_event_listener:
        class: MyEventListener

    event_dispatcher:
        class: 'Symfony\Component\EventDispatcher\EventDispatcher'
        calls:
            - [ addListener, [ kernel.request, '@my_event_listener', 42 ] ]
</code></pre>

<blockquote>
  <p><strong>Note</strong>: There's a better way to add listeners to the EventDispatcher, keep
  reading to find out how.</p>
</blockquote>

<p>Finally it might be useful to create aliases:</p>

<pre><code>services:
    http_client:
        alias: curl_http_client

    curl_http_client:
        class: CurlHttpClient

    check_api_status:
        class: checkApiStatus
        arguments:
            - "@http_client"
</code></pre>

<p>In the example above <code>http_client</code> is set to be <code>curl_http_client</code>, it could be
changed later to use another implementation of <code>HttpClient</code>.</p>

<h2 id="parameters">Parameters</h2>

<p>In addition to class instances, we can also inject parameters:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Parameter;
use Symfony\Component\DependencyInjection\Reference;

$container = new ContainerBuilder();

$container-&gt;setParameter('username', 'arthur.dent@example.com');
$container-&gt;setParameter('password', 42);

$container
    -&gt;register('http_client','CurlHttpClient')
;
$container
    -&gt;register('check_api_status', 'CheckApiStatus')
    -&gt;addArgument(new Reference('http_client'))
    -&gt;addArgument(new Parameter('username'))
    -&gt;addArgument(new Parameter('password'))
;

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For the example's sake we're pretending that <code>CheckApiStatus</code>'s constructor
  now takes 3 arguments.</p>
</blockquote>

<p>Here's the equivalent in YAML:</p>

<pre><code># /tmp/services/api.yml
parameters:
    username: 'arthur.dent@example.com'
    password: 42

services:
    http_client:
        class: CurlHttpClient

    check_api_status:
        class: CheckApiStatus
        arguments:
            - '@http_client'
            - '%username%'
            - '%password%'
</code></pre>

<blockquote>
  <p><strong>Note</strong>: services are prefixed with <code>@</code>, and parameters are surrounded with <code>%</code>.</p>
</blockquote>

<p>The value of a parameter can be anything:</p>

<ul>
<li>null (<code>~</code>)</li>
<li>a boolean (<code>true</code> or <code>false</code>)</li>
<li>an integer (e.g. <code>42</code>)</li>
<li>a float (e.g. <code>44.23</code>)</li>
<li>a string (e.g. <code>hello world</code>, or escaped <code>'arthur.dent@example.com'</code>)</li>
<li>an array (e.g. <code>[ apples, oranges ]</code>)</li>
<li>an associative array (e.g. <code>{ first_name: Arthur, last_name: Dent }</code>)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: The examples above for arrays are inline ones. They could also be on many lines:</p>

<pre><code>parameters:
    fruits:
        - apples
        - oranges

    identity:
        first_name: Arthur
        last_name: Dent

    # We can even have multi dimension arrays:
    five_a_day:
        -
            - apples
            - oranges
        -
            - carrots
</code></pre>
</blockquote>

<h2 id="extension">Extension</h2>

<p>By creating a class that extends <code>Extension</code>, we can provide reusable Dependency
Injection configuration:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Config\FileLocator;
use Symfony\Component\Config\Loader\LoaderResolver;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\DirectoryLoader;
use Symfony\Component\DependencyInjection\Loader\YamlFileLoader;
use Symfony\Component\HttpKernel\DependencyInjection\Extension;

class AppExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $fileLocator = new FileLocator(__DIR__);
        $loader = new DirectoryLoader($container, $fileLocator);
        $loader-&gt;setResolver(new LoaderResolver(array(
            new YamlFileLoader($container, $fileLocator),
            $loader,
        )));
        $loader-&gt;load('/services/');
    }
}

$container = new ContainerBuilder();
$appExtension = new AppExtension();
$appExtension-&gt;load(array(), $container);

$checkApiStatus = $container-&gt;get('check_api_status');
</code></pre>

<h2 id="compilerpass-and-tags">CompilerPass and tags</h2>

<p>The <code>Container</code> implementation provides a <code>compile</code> method that resolves parameters
(replace <code>%parameter%</code> placeholders by the parameter value) and freezes them
(calling <code>setParameter</code> will result in an exception).</p>

<p>The <code>ContainerBuilder</code> implementations also has a <code>compile</code> method which is going
to execute all registered <code>CompilerPassInterface</code> implementations.</p>

<p>For example, we can retrieve all services "tagged" <code>kernel.event_listener</code> and
add them to the <code>EventDispatcher</code> with the following one:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
use Symfony\Component\DependencyInjection\Reference;

class EventListenerCompilerPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        if (false === $container-&gt;hasDefinition('event_dispatcher')) {
            return;
        }
        $eventDispatcher = $container-&gt;getDefinition('event_dispatcher');
        $taggedServices = $container-&gt;findTaggedServiceIds('kernel.event_listener');
        foreach ($taggedServices as $id =&gt; $attributes) {
            $eventDispatcher-&gt;addMethodCall('addListener', array(
                $attributes['event'],
                array(new Reference($id), $attributes['method']),
                $attributes['priority'],
            ));
        }
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: The EventDispatcher component already provides a <code>RegisterListenersPass</code>.</p>
</blockquote>

<p>The configuration for a "tagged" service looks like this:</p>

<pre><code>services:
    my_event_listener:
        class MyEventListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest, priority: 42 }
</code></pre>

<blockquote>
  <p><strong>Note</strong>: With this, it is no longer required to call <code>addListener</code> in <code>event_dispatcher</code>'s
  configuration.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>By providing a configurable way to define service construction, the DependencyInjection
component allows us to use the design pattern of the same name in our projects.</p>

<p>The HttpKernel component provides two <code>HttpKernelInterface</code> implementations:</p>

<ul>
<li><code>HttpKernel</code> which does the HTTP logic</li>
<li><code>Kernel</code> which sets up a DependencyInjection container and then use <code>HttpKernel</code></li>
</ul>

<p>Just like for the Routing component, there's a <code>PhpDumper</code> which can generate an
implementation of <code>ContainerInterface</code> with all configuration in an optimized way.
It might look like this:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\Container;
use Symfony\Component\DependencyInjection\Exception\InvalidArgumentException;
use Symfony\Component\DependencyInjection\Exception\LogicException;
use Symfony\Component\DependencyInjection\Exception\RuntimeException;
use Symfony\Component\DependencyInjection\ParameterBag\FrozenParameterBag;

class appDevDebugProjectContainer extends Container
{
    private $parameters;
    private $targetDirs = array();

    public function __construct()
    {
        $dir = __DIR__;
        for ($i = 1; $i &lt;= 5; ++$i) {
            $this-&gt;targetDirs[$i] = $dir = dirname($dir);
        }
        $this-&gt;parameters = $this-&gt;getDefaultParameters();

        $this-&gt;services = array();
        $this-&gt;methodMap = array(
            'http_client' =&gt; 'getHttpClientService',
            'check_api_status' =&gt; 'getCheckApiStatusService',
        );
        $this-&gt;aliases = array(
        );
    }

    public function compile()
    {
        throw new LogicException('You cannot compile a dumped frozen container.');
    }

    protected function getHttpClientService()
    {
        return $this-&gt;services['http_client'] = new \CurlHttpClient();
    }

    protected function getCheckApiStatusService()
    {
        return $this-&gt;services['check_api_status'] = new \CheckApiStatus($this-&gt;get('http_client'), 'arthur.dent@example.com', 42);
    }

    public function getParameter($name)
    {
        $name = strtolower($name);
        if (!(isset($this-&gt;parameters[$name]) || array_key_exists($name, $this-&gt;parameters))) {
            throw new InvalidArgumentException(sprintf('The parameter "%s" must be defined.', $name));
        }

        return $this-&gt;parameters[$name];
    }

    public function hasParameter($name)
    {
        $name = strtolower($name);

        return isset($this-&gt;parameters[$name]) || array_key_exists($name, $this-&gt;parameters);
    }

    public function setParameter($name, $value)
    {
        throw new LogicException('Impossible to call set() on a frozen ParameterBag.');
    }

    public function getParameterBag()
    {
        if (null === $this-&gt;parameterBag) {
            $this-&gt;parameterBag = new FrozenParameterBag($this-&gt;parameters);
        }

        return $this-&gt;parameterBag;
    }

    protected function getDefaultParameters()
    {
        return array(
            'username' =&gt; 'arthur.dent@example.com',
            'password' =&gt; 42,
        );
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Dependencies that are used by only one service can be marked as "private"
  they'll be hard coded in the service instantiation (but they won't be available
  anymore from <code>$container-&gt;get()</code>).</p>
  
  <p>In our example we could mark <code>http_client</code> as private, so the dumped Container
  wouldn't have a <code>getHttpClientService</code> method:</p>

<pre><code>service:
    http_client:
        class: CurlHttpClient
        public: false
</code></pre>
</blockquote>

<p>It is also worth noting that services are by default only initialized once and on demand,
so the number of services doesn't impact the performances of the application.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Routing]]></title>
            <link href="/2016/02/17/ultimate-symfony-routing.html"/>
            <updated>2016-02-17T00:00:00+00:00</updated>
            <id>/2016/02/17/ultimate-symfony-routing.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>:</p>

<pre><code class="php">$parameters = $urlMatcher-&gt;match($request-&gt;getPathInfo());

$request-&gt;attributes-&gt;add(array('_controller' =&gt; $parameters['_controller']);
$request-&gt;attributes-&gt;add(array('_route' =&gt; $parameters['_route']);
unset($parameters['_controller'], $parameters['_route']);
$request-&gt;attributes-&gt;add(array('_route_params' =&gt; $parameters);
</code></pre>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
</ul>

<p>We're now about to check Routing and YAML, then in the next articles we'll have a look at:</p>

<ul>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>We'll also see how HttpKernel enables reusable code with <a href="/2016/03/09/ultimate-symfony-bundle.html">Bundles</a>,
and the different ways to organize our application <a href="/2016/03/16/ultimate-symfony-skeleton.html">tree directory</a>.</p>

<p>Finally we'll finish by putting all this knowledge in practice by creating a
"fortune" project with:</p>

<ul>
<li><a href="/2016/03/24/ultimate-symfony-api-example.html">an endpoint that allows us to submit new fortunes</a></li>
<li><a href="/2016/03/30/ultimate-symfony-web-example.html">a page that lists all fortunes</a></li>
<li><a href="/2016/04/06/ultimate-symfony-cli-example.html">a command that prints the last fortune</a></li>
</ul>

<h2 id="routing">Routing</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/routing/introduction.html">Routing component</a>
which allows us, for a HTTP request/URL, to execute a specific function (also known as "Controller").</p>

<blockquote>
  <p><strong>Note</strong>: Controllers must be a <a href="http://php.net/manual/en/language.types.callable.php">callable</a>,
  for example:</p>
  
  <ul>
  <li>an anonymous function: <code>$controller = function (Request $request) { return new Response() };</code>.</li>
  <li>an array with an instance of a class and a method name:
  <code>$controller = array($controller, 'searchArticles');</code>.</li>
  <li>a fully qualified classname with a static method name:
  <code>$controller = 'Vendor\Project\Controller\ArticleController::searchArticles'</code>.</li>
  </ul>
  
  <p>Controllers can take a Request argument and should return a Response instance.</p>
</blockquote>

<p>It revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\Routing\Matcher;

use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;

interface UrlMatcherInterface
{
    /**
     * @param string $pathinfo
     *
     * @return array Route parameters (also contains `_route`)
     *
     * @throws ResourceNotFoundException
     * @throws MethodNotAllowedException
     */
    public function match($pathinfo);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For brevity the interface has been stripped from <code>RequestContextAwareInterface</code>.</p>
</blockquote>

<p>In actual applications we don't need to implement it as the component provides
a nice implementation that works with <code>RouteCollection</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\Route;

$collection = new RouteCollection();
$collection-&gt;add('search_articles', new Route('/v1/articles', array(
    '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::search',
), array(), array(), '', array(), array('GET', 'HEAD')));

$collection-&gt;add('edit_article', new Route('/v1/articles/{id}', array(
    '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',
), array(), array(), '', array(), array('PUT')));
</code></pre>

<p><code>RouteCollection</code> allows us to configure which Request will match our controllers:
via URL patterns and Request method. It also allows us to specify parts of the URLs
as URI parameters (e.g. <code>id</code> in the above snippet).</p>

<p>Building route configuration by interacting with PHP code can be tedious, so the
Routing component supports alternative configuration formats: annotations, XML, YAML, etc.</p>

<blockquote>
  <p><strong>Tip</strong>: have a look at <code>Symfony\Component\Routing\Loader\YamlFileLoader</code>.</p>
</blockquote>

<h2 id="yaml">YAML</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/yaml/introduction.html">YAML component</a>
which allows us to convert YAML configuration into PHP arrays (and vice versa).</p>

<p>For example the following YAML file:</p>

<pre><code># /tmp/routing.yml
search_articles:
    path: /api/articles
    defaults:
        _controller: 'Vendor\Project\Controller\ArticleController::search'
    methods:
        - GET
        - HEAD

edit_article:
    path: '/api/articles/{id}'
    defaults:
        _controller: 'Vendor\Project\Controller\ArticleController::edit'
    methods:
        - PUT
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Some string values must be escaped using single quotes because the YAML
  has a list of <a href="http://stackoverflow.com/a/22235064">reserved characters</a>, including:
  <code>@</code>, <code>%</code>, <code>\</code>, <code>-</code>, <code>:</code> <code>[</code>, <code>]</code>, <code>{</code> and <code>}</code>.</p>
</blockquote>

<p>Can be converted using:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Yaml\Yaml;

$routing = Yaml::parse(file_get_contents('/tmp/routing.yml'));
</code></pre>

<p>This will result in the equivalent of the following array:</p>

<pre><code class="php">&lt;?php

$routing = array(
    'search_articles' =&gt; array(
        'path' =&gt; '/api/articles',
        'defaults' =&gt; array(
            '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::search',
        ),
        'methods' =&gt; array(
            'GET',
            'HEAD',
        ),
    ),
    'edit_article' =&gt; array(
        'path' =&gt; '/api/articles/{id}',
        'defaults' =&gt; array(
            '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',
        ),
        'methods' =&gt; array(
            'PUT',
        ),
    ),
);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: the Routing component uses another component to then build <code>RouteCollection</code>
  from this array: the <a href="http://symfony.com/doc/current/components/config/introduction.html">Config component</a>
  which is out of the scope of this guide.</p>
</blockquote>

<p>There's also <code>$yaml = Yaml::dump($array);</code> that converts a PHP array into a YAML
string.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Routing component allows us to define which Controllers should be executed
for the given Request, and the Yaml component allows us to configure it in a simple way.</p>

<p>HttpKernel provides a <code>RouterListener</code> which makes use of <code>UrlMatcher</code> when the
Request is received to find a corresponding controller.</p>

<blockquote>
  <p><strong>Note</strong>: <code>Request-&gt;attributes</code> is used to store information about the current
  Request such as the matched route, the controller, etc. It's used internally
  by Symfony but we could also store our own values in it.</p>
</blockquote>

<p>Some might be concerned with performance: reading the configuration from the
filesystem may slow down the application.</p>

<p>Don't panic! There's a <code>PhpMatcherDumper</code> class which can generate an implementation
of <code>UrlMatcherInterface</code> with all configuration in an optimized way. It might look
like this:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\Routing\Exception\MethodNotAllowedException;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\RequestContext;

class appDevUrlMatcher extends Symfony\Bundle\FrameworkBundle\Routing\RedirectableUrlMatcher
{
    public function __construct(RequestContext $context)
    {
        $this-&gt;context = $context;
    }

    public function match($pathinfo)
    {
        $allow = array();
        $pathinfo = rawurldecode($pathinfo);
        $context = $this-&gt;context;

        // edit_article
        if (preg_match('#^/v1/articles/(?P&lt;id&gt;[^/]++)$#s', $pathinfo, $matches)) {
            if ($this-&gt;context-&gt;getMethod() != 'PUT') {
                $allow[] = 'PUT';
                goto not_edit_article;
            }

            return $this-&gt;mergeDefaults(array_replace($matches, array('_route' =&gt; 'edit_article')), array (  '_controller' =&gt; 'Vendor\Project\Controller\ArticleController::edit',));
        }
        not_edit_article:

        // search_articles
        if ($pathinfo === '/v1/articles') {
            if (!in_array($this-&gt;context-&gt;getMethod(), array('GET', 'HEAD'))) {
                $allow = array_merge($allow, array('GET', 'HEAD'));
                goto not_search_articles;
            }

            return array (  '_controller' =&gt; 'app.article_controller:search',  '_route' =&gt; 'Vendor\Project\Controller\ArticleController::search',);
        }
        not_search_articles:

        throw 0 &lt; count($allow) ? new MethodNotAllowedException(array_unique($allow)) : new ResourceNotFoundException();
    }
}
</code></pre>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - Event Dispatcher]]></title>
            <link href="/2016/02/10/ultimate-symfony-event-dispatcher.html"/>
            <updated>2016-02-10T00:00:00+00:00</updated>
            <id>/2016/02/10/ultimate-symfony-event-dispatcher.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>:</p>

<pre><code class="php">$eventDispatcher-&gt;addListener($eventName, $listener1, $priority);
$eventDispatcher-&gt;addListener($eventName, $listener2, $priority - 1);
$eventDispatcher-&gt;dispatch($eventName); // Calls $listener1, then $listener2
</code></pre>
</blockquote>

<p>In this guide we explore the standalone libraries (also known as "Components")
provided by <a href="http://symfony.com">Symfony</a> to help us build applications.</p>

<p>We've already seen:</p>

<ul>
<li><a href="/2016/02/03/ultimate-symfony-http-kernel.html">HTTP Kernel and HTTP Foundation</a></li>
</ul>

<p>We're now about to check Event Dispatcher, then in the next articles we'll have a look at:</p>

<ul>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>We'll also see how HttpKernel enables reusable code with <a href="/2016/03/09/ultimate-symfony-bundle.html">Bundles</a>,
and the different ways to organize our application <a href="/2016/03/16/ultimate-symfony-skeleton.html">tree directory</a>.</p>

<p>Finally we'll finish by putting all this knowledge in practice by creating a
"fortune" project with:</p>

<ul>
<li><a href="/2016/03/24/ultimate-symfony-api-example.html">an endpoint that allows us to submit new fortunes</a></li>
<li><a href="/2016/03/30/ultimate-symfony-web-example.html">a page that lists all fortunes</a></li>
<li><a href="/2016/04/06/ultimate-symfony-cli-example.html">a command that prints the last fortune</a></li>
</ul>

<h2 id="event-dispatcher">Event Dispatcher</h2>

<p>Symfony provides an <a href="http://symfony.com/doc/current/components/event_dispatcher/introduction.html">EventDispatcher component</a>
which allows the execution of registered function at key points in our applications.</p>

<p>It revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\EventDispatcher;

interface EventDispatcherInterface
{
    /**
     * @param string   $eventName
     * @param callable $listener
     * @param int      $priority  High priority listeners will be executed first
     */
    public function addListener($eventName, $listener, $priority = 0);

    /**
     * @param string $eventName
     * @param Event  $event
     */
    public function dispatch($eventName, Event $event = null);
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: This snippet is a truncated version, the actual interface has methods
  to add/remove/get/check listeners and subscribers (which are "auto-configured" listeners).</p>
</blockquote>

<p>An implementation is provided out of the box and can be used as follow:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\EventDispatcher\EventDispatcher;

$eventDispatcher = new EventDispatcher();

$eventDispatcher-&gt;addListener('something_happened', function () {
    echo "Log it\n";
}, 1);
$eventDispatcher-&gt;addListener('something_happened', function () {
    echo "Save it\n";
}, 2);

$eventDispatcher-&gt;dispatch('something_happened');
</code></pre>

<p>This will output:</p>

<pre><code>Save it
Log it
</code></pre>

<p>Since the second listener had a higher priority, it got executed first.</p>

<blockquote>
  <p><strong>Note</strong>: Listeners must be a <a href="http://php.net/manual/en/language.types.callable.php">callable</a>,
  for example:</p>
  
  <ul>
  <li>an anonymous function: <code>$listener = function (Event $event) {};</code>.</li>
  <li>an array with an instance of a class and a method name:
  <code>$listener = array($service, 'method');</code>.</li>
  <li>a fully qualified classname with a static method name:
  <code>$listener = 'Vendor\Project\Service::staticMethod'</code>.</li>
  </ul>
</blockquote>

<p>If we want to provide some context to the listeners (parameters, etc) we can
create a sub-class of <code>Event</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\EventDispatcher\Event;
use Symfony\Component\EventDispatcher\EventDispatcher;

class SomethingHappenedEvent extends Event
{
    private $who;
    private $what;
    private $when;

    public function __construct($who, $what)
    {
        $this-&gt;who = $who;
        $this-&gt;what = $what;
        $this-&gt;when = new \DateTime();
    }

    public function who()
    {
        return $this-&gt;who;
    }

    public function what()
    {
        return $this-&gt;what;
    }

    public function when()
    {
        return $this-&gt;when;
    }
}

$eventDispatcher = new EventDispatcher();

$eventDispatcher-&gt;addListener('something_happened', function (SomethingHappenedEvent $event) {
    echo "{$event-&gt;who()} was {$event-&gt;what()} at {$event-&gt;when()-&gt;format('Y/m/d H:i:s')}\n";
});

$eventDispatcher-&gt;dispatch('something_happened', new SomethingHappenedEvent('Arthur', 'hitchhiking'));
</code></pre>

<h2 id="httpkernel-example">HttpKernel example</h2>

<p>The HttpKernel component we've seen in <a href="/2016/02/03/ultimate-symfony-http-kernel.html">the previous article</a>
provides a <code>Kernel</code> abstract class that heavily relies on EventDispatcher.</p>

<p>For each key steps of its execution, it dispatches the following events:</p>

<ol>
<li><code>kernel.request</code>: gets a <code>Request</code></li>
<li><code>kernel.controller</code>: executes a callable (also known as "Controller")</li>
<li><code>kernel.view</code>: converts the Controller's returned value into a <code>Response</code> (if necessary)</li>
<li><code>kernel.response</code>: returns a <code>Response</code></li>
</ol>

<p>And in case of error:</p>

<ul>
<li><code>kernel.exception</code>: handles errors</li>
</ul>

<p>Just before returning the <code>Response</code>, <code>HttpKernel</code> dispatches one last event:</p>

<ul>
<li><code>kernel.finish_request</code>: clean ups, sending emails, etc</li>
</ul>

<p>After the <code>Response</code> has been displayed, we can dispatch:</p>

<ul>
<li><code>kernel.terminate</code>: same as <code>kernel.finish_request</code>, except it won't slow down
the rendering of request if FastCGI is enabled</li>
</ul>

<h3 id="kernel-request">Kernel Request</h3>

<p>Listeners that registered for <code>kernel.request</code> can modify the Request object.</p>

<p>Out of the box there's a <code>RouterListener</code> registered which sets the following
parameters in <code>Request-&gt;attributes</code>:</p>

<ul>
<li><code>_route</code>: the route name that matched the Request</li>
<li><code>_controller</code>: a callable that will handle the Request and return a Response</li>
<li><code>_route_parameters</code>: query parameters extracted from the Request</li>
</ul>

<p>An example of a custom Listener could be one that decodes JSON content and sets
it in <code>Request-&gt;request</code>:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

/**
 * PHP does not populate $_POST with the data submitted via a JSON Request,
 * causing an empty $request-&gt;request.
 *
 * This listener fixes this.
 */
class JsonRequestContentListener
{
    /**
     * @param GetResponseEvent $event
     */
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('PATCH', 'POST', 'PUT'), true);
        $isJson = (1 === preg_match('#application/json#', $request-&gt;headers-&gt;get('Content-Type')));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new Response('{"error":"Invalid or malformed JSON"}', 400, array('Content-Type' =&gt; 'application/json')));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>Another example would be to start a database transaction:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use PommProject\Foundation\QueryManager\QueryManagerInterface;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class StartTransactionListener
{
    /**
     * @var QueryManagerInterface
     */
    private $queryManager;

    /**
     * @param QueryManagerInterface $queryManager
     */
    public function __construct(QueryManagerInterface $queryManager)
    {
        $this-&gt;queryManager = $queryManager;
    }

    /**
     * @param GetResponseEvent $event
     */
    public function onKernelRequest(GetResponseEvent $event)
    {
        $this-&gt;queryManager-&gt;query('START TRANSACTION');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <a href="http://pomm-project.org">Pomm</a> is used here as an example.</p>
</blockquote>

<h3 id="kernel-controller">Kernel Controller</h3>

<p>Listeners that registered for <code>kernel.controller</code> can modify the Request object.</p>

<p>This can be useful when we'd like to change the Controller.</p>

<p>For example <code>SensioFrameworkExtraBundle</code> has a <code>ControllerListener</code> that parses
the controller annotations at this point.</p>

<h3 id="kernel-view">Kernel View</h3>

<p>Listeners that registered for <code>kernel.view</code> can modify the Response object.</p>

<p>For example <code>SensioFrameworkExtraBundle</code> has a <code>TemplateListener</code> that uses <code>@Template</code>
annotation: controllers only need to return an array and the listener will create
a response using <a href="http://twig.sensiolabs.org/">Twig</a> (it will pass the array as
Twig parameters).</p>

<h3 id="kernel-response">Kernel Response</h3>

<p>Listeners that registered for <code>kernel.response</code> can modify the Response object.</p>

<p>Out of the box there's a <code>ResponseListener</code> regitered which sets some Response
headers according to the Request's one.</p>

<h3 id="kernel-terminate">Kernel Terminate</h3>

<p>Listeners that registered for <code>kernel.terminate</code> can execute actions after the
Response has been served (if our web server uses FastCGI).</p>

<p>An example of a custom Listener could be one that rollsback a database transaction,
when running in test environment:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener\Pomm;

use PommProject\Foundation\QueryManager\QueryManagerInterface;
use Symfony\Component\HttpKernel\Event\PostResponseEvent;

class RollbackListener
{
    /**
     * @var QueryManagerInterface
     */
    private $queryManager;

    /**
     * @param QueryManagerInterface $queryManager
     */
    public function __construct(QueryManagerInterface $queryManager)
    {
        $this-&gt;queryManager = $queryManager;
    }

    /**
     * @param PostResponseEvent $event
     */
    public function onKernelTerminate(PostResponseEvent $event)
    {
        $this-&gt;queryManager-&gt;query('ROLLBACK');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We'll se later how to register this listener only for test environment.</p>
</blockquote>

<h3 id="kernel-exception">Kernel Exception</h3>

<p>Listeners that registered for <code>kernel.exception</code> can catch an exception and generate
an appropriate Response object.</p>

<p>An example of a custom Listener could be one that logs debug information and generates
a 500 Response:</p>

<pre><code class="php">&lt;?php

namespace AppBundle\EventListener;

use Psr\Log\LoggerInterface;
use Ramsey\Uuid\Uuid;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;

class ExceptionListener
{
    /**
     * @var LoggerInterface
     */
    private $logger;

    /**
     * @param LoggerInterface $logger
     */
    public function __construct(LoggerInterface $logger)
    {
        $this-&gt;logger = $logger;
    }

    /**
     * @param GetResponseForExceptionEvent $event
     */
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        $token = Uuid::uuid4()-&gt;toString();
        $this-&gt;logger-&gt;critical(
            'Caught PHP Exception {class}: "{message}" at {file} line {line}',
            array(
                'class' =&gt; get_class($exception),
                'message' =&gt; $exception-&gt;getMessage(),
                'file' =&gt; $exception-&gt;getFile(),
                'line' =&gt; $exception-&gt;getLine()
                'exception' =&gt; $exception,
                'token' =&gt; $token
            )
        );
        $event-&gt;setResponse(new Response(
            json_encode(array(
                'error' =&gt; 'An error occured, if it keeps happening please contact an administrator and provide the following token: '.$token,
            )),
            500,
            array('Content-Type' =&gt; 'application/json'))
        );
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <a href="https://benramsey.com/projects/ramsey-uuid/">Ramsey UUID</a> is used
  here to provide a unique token that can be referred to.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>EventDispatcher is another example of a simple yet powerful Symfony component.
HttpKernel uses it to configure a standard "Symfony application", but also to
allow us to change its behaviour.</p>

<p>In this article we've seen the basics and how it works behind the hood when used
by HttpKernel, but we could create our own event and dispatch it to make our
own code "Open for extension, but Close to modification"
(<a href="https://blog.8thlight.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html">Open/Close principle</a>).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[The Ultimate Developer Guide to Symfony - HTTP Kernel]]></title>
            <link href="/2016/02/03/ultimate-symfony-http-kernel.html"/>
            <updated>2016-02-03T00:00:00+00:00</updated>
            <id>/2016/02/03/ultimate-symfony-http-kernel.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><strong>TL;DR</strong>: <code>$response = $httpKernel-&gt;handle($request);</code></p>
</blockquote>

<p><a href="http://symfony.com">Symfony</a> provides many standalone libraries (also known as
"Components") that help us build applications.</p>

<p>In this guide we'll see the main ones that allow us to build an application:</p>

<ul>
<li>HTTP Kernel and HTTP Foundation</li>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24/ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
<li><a href="/2016/03/02/ultimate-symfony-console.html">Console</a></li>
</ul>

<p>We'll also see how HttpKernel enables reusable code with <a href="/2016/03/09/ultimate-symfony-bundle.html">Bundles</a>,
and the different ways to organize our application <a href="/2016/03/16/ultimate-symfony-skeleton.html">tree directory</a>.</p>

<p>Finally we'll finish by putting all this knowledge in practice by creating a
"fortune" project with:</p>

<ul>
<li><a href="/2016/03/24/ultimate-symfony-api-example.html">an endpoint that allows us to submit new fortunes</a></li>
<li><a href="/2016/03/30/ultimate-symfony-web-example.html">a page that lists all fortunes</a></li>
<li><a href="/2016/04/06/ultimate-symfony-cli-example.html">a command that prints the last fortune</a></li>
</ul>

<h2 id="http-kernel">HTTP kernel</h2>

<p>Symfony provides a <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html">HttpKernel component</a>
which follows the HTTP protocol: it converts a <code>Request</code> into a <code>Response</code>.</p>

<p>It all revolves around the following interface:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpKernel;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

interface HttpKernelInterface
{
    const MASTER_REQUEST = 1;
    const SUB_REQUEST = 2;

    /**
     * @param Request $request
     * @param int     $type
     * @param bool    $catch   Whether to catch exceptions or not
     *
     * @return Response
     */
    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true);
}
</code></pre>

<h2 id="httpfoundation">HttpFoundation</h2>

<p>HttpKernel relies on the <a href="http://symfony.com/doc/current/components/http_foundation/introduction.html">HttpFoundation component</a>
which mainly provides:</p>

<ul>
<li><code>Request</code>: wraps <code>$_GET</code>, <code>$_POST</code>, <code>$_COOKIE</code>, <code>$_FILES</code> and <code>$_SERVER</code></li>
<li><code>Response</code>: wraps <code>header()</code> and <code>setcookie()</code>, but also displays the content</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: Global variables have the drawback to be possibly accessed by many
  functions, causing their state to be unpredictable (hence bugs happen and they
  are hard to find/understand).</p>
  
  <p>With HttpFoundation, <a href="http://php.net/manual/en/language.variables.superglobals.php">PHP super globals</a>
  shouldn't be accessed directly, but rather via the objects that wraps them
  (e.g. <code>Request</code>) which are passed around (those objects are not global).</p>
</blockquote>

<p>Here's a typical usage:</p>

<pre><code class="php">$request = Request::createFromGlobals();
$response = $httpKernel-&gt;handle($request);
$reponse-&gt;send();
</code></pre>

<p>In the above example, <code>Request</code> will be initialized using PHP super globals.
Sometimes it can be useful to build it with our own provided values (e.g. for tests):</p>

<pre><code class="php">$uri = '/v1/items';
$method = 'POST';
$parameters = array(); // GET or POST parameters, usually left unused (use uri and content instead)
$cookies = array();
$files = array();
$headers = array('CONTENT_TYPE' =&gt; 'application/json');
$content = json_encode(array('name' =&gt; 'Arthur Dent'));

$request = Request::create($uri, $method, $getOrPostParameters, $cookies, $files, $headers, $content);
</code></pre>

<p>In our application, we'll mainly extract its parameters:</p>

<pre><code class="php">$getParameter = $request-&gt;query-&gt;get('description'); // e.g. from URI `/?description=hitchhicker`
$postParameter = $request-&gt;request-&gt;get('name'); // e.g. from content `name=Arthur`
$header = $request-&gt;headers-&gt;get('Content-Type'); // e.g. from headers `Content-Type: application/x-www-form-urlencoded`

$customParameter = $request-&gt;attributes-&gt;get('_route'); // We'll see more about it in the next article
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Those public properties are instances of <code>Symfony\Component\HttpFoundation\ParameterBag</code>,
  except <code>headers</code> which is an instance of <code>Symfony\Component\HttpFoundation\HeaderBag</code>.</p>
</blockquote>

<p>In our application we'll mainly build <code>Response</code>:</p>

<pre><code class="php">$content = json_encode(array('name' =&gt; 'Arthur Dent'));
$status = 201;
$headers = array('Content-Type' =&gt; 'application/json');

$response = new Reponse($content, $status, $headers);
</code></pre>

<p>HttpFoundation also wraps <code>$_SESSION</code> in a convenient <code>Session</code> object. This one
is however out of the scope of this series, to find more about it have a look at
<a href="/2014/04/23/sf2-sessions-introduction.html">Symfony Session Introduction</a>.</p>

<h2 id="example">Example</h2>

<p>Let's create a small Hello World example:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class HelloWorldHttpKernel implements HttpKernelInterface
{
    public function handle(Request $request, $type = self::MASTER_REQUEST, $catch = true)
    {
        $name = $request-&gt;query-&gt;get('name', 'World');

        return new Response("Hello $name!", 200);
    }
}

$httpKernel = new HelloWorldHttpKernel();

$request = Request::createFromGlobals();
$response = $httpKernel-&gt;handle($request);
$response-&gt;send();
</code></pre>

<p>So we can get the following:</p>

<ul>
<li>for <code>/</code> URL, we get <code>Hello World!</code></li>
<li>for <code>/?name=Arthur</code> URL, we get <code>Hello Arthur!</code></li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Symfony provides a simple yet powerful component allowing us to follow the HTTP
protocol.</p>

<p>In this article we've seen the basics and how it works behind the hood, but in
an actual application we don't necessarily need to create our own implementation
of <code>HttpKernelInterface</code>.</p>

<p>Indeed there's a <code>Symfony\Component\HttpKernel\Kernel</code> abstract class that can
be used out of the box. It provides many features that we'll explore in the next
articles:</p>

<ul>
<li><a href="/2016/02/10/ultimate-symfony-event-dispatcher.html">Event Dispatcher</a></li>
<li><a href="/2016/02/17/ultimate-symfony-routing.html">Routing and YAML</a></li>
<li><a href="/2016/02/24.ultimate-symfony-dependency-injection.html">Dependency Injection</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Links from 2015]]></title>
            <link href="/2016/01/27/links-from-2015.html"/>
            <updated>2016-01-27T00:00:00+00:00</updated>
            <id>/2016/01/27/links-from-2015.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Links I tweeted during 2015</p>
</blockquote>

<p>It's funny how old principles are still useful today. In 2015, the most important
ones I've learned are the following:</p>

<ul>
<li>Command/Query Responsibility Segregation (CQRS): separate the "read" logic from
the "write" logic</li>
<li>Event Sourcing (ES): recording every action done for analytics and rollback
purpose</li>
<li>Command Bus: store and validate input in a Command object, pass it to a
Command Bus middleware that will find and execute the appropriate
Command Handler which will execture the logic</li>
<li>Framework / Library agnosticism: decouple from vendors to be able to
change/upgrade them without friction</li>
<li>microservices: reduce the scope of an API, organize them into a communicating network</li>
<li>Monolithic Repository: store related applications in the same git repository</li>
</ul>

<p>It was a year full of links, so here they are!</p>

<h2 id="articles-highlight">Articles Highlight</h2>

<ul>
<li><a href="http://blog.confluent.io/2015/05/27/using-logs-to-build-a-solid-data-infrastructure-or-why-dual-writes-are-a-bad-idea/">Using logs to build a solid data infrastructure, or why dual writes are a bad idea</a></li>
<li><a href="https://codeascraft.com/2015/07/29/targeting-broad-queries-in-search/">Targeting broad queries in search</a></li>
</ul>

<h2 id="tools-highlight">Tools Highlight</h2>

<ul>
<li><a href="http://docs.puli.io/en/latest/">Puli</a>:

<ul>
<li><a href="http://webmozarts.com/2015/01/12/puli-1-0-beta-released/">1.0-beta release</a></li>
<li>Slides: <a href="https://speakerdeck.com/webmozart/puli-phps-next-package-revolution">Pulis, PHP next package revolution</a></li>
<li><a href="http://webmozarts.com/2015/01/14/resource-discovery-with-puli/">Resource discovery</a></li>
<li><a href="http://webmozarts.com/2015/03/20/managing-web-resources-with-puli/">Managing web resources</a></li>
</ul></li>
<li>Refactoring Browser:

<ul>
<li><a href="http://martinfowler.com/articles/refactoringRubicon.html">Refactoring Rubicon</a></li>
<li><a href="https://github.com/QafooLabs/php-refactoring-browser">Qafoo PHP RefactoringBrowser</a></li>
</ul></li>
<li><a href="https://github.com/padraic/humbug">Humbug</a>:

<ul>
<li><a href="http://blog.astrumfutura.com/2015/01/lies-damned-lies-and-code-coverage-towards-mutation-testing/">Code Coverage lies, toward mutation testing</a></li>
<li><a href="http://blog.astrumfutura.com/2015/04/introduction-to-humbug-a-mutation-testing-framework-for-php/">Introduction to Humbug, a mutation testing framework for PHP</a></li>
<li><a href="http://davedevelopment.co.uk/2015/01/07/probing-test-suite-quality-with-mutation-testing.html">Probing test suite quality with mutation testing</a></li>
</ul></li>
<li><a href="https://tactician.thephpleague.com/">Tactician, the PHP Command Bus</a>:

<ul>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/a-wave-of-command-buses/">A wave of Command Buses</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/responsibilities-of-the-command-bus/">Responsibilities of the Command Bus</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/from-commands-to-events/">From Commands to Events</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/some-questions-about-the-command-bus/">Command Bus FAQ</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/collecting-events-and-the-events-aware-command-bus/">Collecting events and the EventsAware Command Bus</a></li>
<li><a href="http://verraes.net/2015/01/messaging-flavours/">Messaging Flavours</a></li>
<li><a href="http://verraes.net/2015/02/form-command-model-validation/">Form Command model validation</a></li>
<li><a href="http://boldradius.com/blog-post/VSQCySkAACcA4k5J/easy-scalability-with-akka">CQRS vs CRUD performances and scalability</a></li>
</ul></li>
<li><a href="http://lnav.org/">The log file navigator</a></li>
<li><a href="https://github.com/ramsey/uuid">UUID</a>:

<ul>
<li><a href="https://philsturgeon.uk/http/2015/09/03/auto-incrementing-to-destruction/">auto incrementing to destruction</a></li>
<li><a href="https://www.clever-cloud.com/blog/engineering/2015/05/20/Why-Auto-Increment-Is-A-Terrible-Idea">Why auto incrementing is a terrible idea</a></li>
</ul></li>
<li>Pomm:

<ul>
<li><a href="http://www.pomm-project.org/news/pomm-2-0-0-is-out.html">Pomm 2.0 is out</a></li>
<li><a href="http://www.pomm-project.org/news/a-short-focus-on-pomm-s-foundation.html">A short focus on Pomm Foundation</a></li>
</ul></li>
</ul>

<h2 id="interesting-talks">Interesting Talks</h2>

<ul>
<li>Monolithic Repository:

<ul>
<li><a href="https://qafoo.com/talks/15_08_froscon_monorepos.pdf">Monolithic Repository</a></li>
<li><a href="http://www.slideshare.net/StenHiedel/symfony-uk-meetup-21-may">How to manage multiple Composer packages within a single respository</a></li>
<li>see also article: <a href="http://sroze.io/2015/09/14/managing-monolith-repositories-with-composers-path-repository/">Managing monolith repositories with composers path repository</a></li>
</ul></li>
<li>Doctrine:

<ul>
<li><a href="https://qafoo.com/talks/15_09_symfony_live_london_doctrine2_to_use_or_not_to_use.pdf">Doctrine: to use or not to use</a></li>
<li><a href="http://ocramius.github.io/blog/doctrine-orm-optimization-hydration/">Doctrine ORM optimization hydration</a></li>
</ul></li>
<li>PHP Interoperability:

<ul>
<li><a href="https://speakerdeck.com/michaelcullum/php-fig-the-psrs-you-dont-know-about">PHP FIG, the PSRs you do not know about</a></li>
<li><a href="http://mnapoli.fr/presentations/psr-0-12/">PSR 0 to 12</a></li>
<li><a href="http://talks.ppi.io/20150513-phpsw">The PHP Interoperability Framework</a></li>
</ul></li>
<li>Desgin:

<ul>
<li><a href="http://www.slideshare.net/mobile/CiaranMcNulty/why-your-test-suite-sucks">Why your test suite sucks</a></li>
<li><a href="https://speakerdeck.com/jakzal/embracing-change">Embracing change</a></li>
<li><a href="http://www.slideshare.net/mobile/CiaranMcNulty/driving-design-through-examples">Driving design through examples</a></li>
<li><a href="http://www.slideshare.net/NicolPignatelli/brownfield-domain-driven-design-48240538">Brownfield Domain Driven Desgin</a></li>
<li><a href="http://www.slideshare.net/matthiasnoback/the-quest-for-global-design-principles">The quest for global design principles</a></li>
<li><a href="http://www.slideshare.net/matthiasnoback/hexagonal-architecture-messageoriented-software-design">Hexagonal architecture, message oriented software design</a></li>
<li><a href="http://moquet.net/talks/phptour-2015">CQRS and Event Sourcing</a></li>
</ul></li>
<li><a href="https://speakerdeck.com/odolbeau/symfony2-killed-me">Symfony killed me</a></li>
<li><a href="https://speakerdeck.com/odolbeau/logs-hunting">Logs hunting</a></li>
<li><a href="http://www.slideshare.net/cakper/2014-0821-symfony-uk-meetup-scaling-symfony2-apps-with-rabbit-mq">Scaling Symofny apps with RabbitMq</a></li>
<li><a href="http://andrewcarteruk.github.io/slides/breaking-boundaries-with-fastcgi-symfony/#/">Breaking boundaries with FastCGI Symfony</a></li>
<li>in french: <a href="https://speakerdeck.com/lyrixx/symfony-live-2015-paris-monitorer-sa-prod">Monitorer sa prod</a></li>
</ul>

<h2 id="tests%3A">Tests:</h2>

<ul>
<li>Test Driven Desing (TDD):

<ul>
<li><a href="http://codurance.com/2015/05/12/does-tdd-lead-to-good-design/">Does TDD lead to good design?</a></li>
<li><a href="https://medium.com/@davidihunt/tdd-and-complexity-1bbd5ca51ee7">TDD and complexity</a></li>
</ul></li>
<li><a href="http://verraes.net/2015/01/economy-of-tests/">Economy of tests</a></li>
<li><a href="http://blog.8thlight.com/dariusz-pasciak/2015/01/12/your-test-suite-is-useless.html">Your test suite is useless</a></li>
<li><a href="https://sites.google.com/site/unclebobconsultingllc/specs-vs-tests">Specs VS Tests</a></li>
<li><a href="http://googletesting.blogspot.co.uk/2015/04/just-say-no-to-more-end-to-end-tests.html">Just say no to more end to end tests</a></li>
<li><a href="http://elnur.pro/testing-is-not-a-choice/">Testing is not a choice</a></li>
<li><a href="http://tech.mybuilder.com/coupling-tests/">Coupling tests</a></li>
<li><a href="https://developer.atlassian.com/blog/2015/05/open-letter-from-an-ignored-test/">Open letter from an ignored test</a></li>
<li><a href="https://cucumber.io/blog/2015/03/24/single-source-of-truth">Single source of truth</a></li>
<li><a href="http://dannorth.net/introducing-bdd/">Introducing BDD</a></li>
<li><a href="http://martinfowler.com/articles/nonDeterminism.html">Eradicating Non-Determinism in Tests</a></li>
</ul>

<h2 id="php-interoperability">PHP Interoperability</h2>

<ul>
<li>PSR 7:

<ul>
<li><a href="https://mwop.net/blog/2015-01-08-on-http-middleware-and-psr-7.html">On HTTP middleware and PSR 7</a></li>
<li><a href="https://mwop.net/blog/2015-01-26-psr-7-by-example.html">PSR 7 by example</a></li>
<li><a href="http://srcmvn.com/blog/2015/02/18/psr-7-and-the-future-of-php/">PSR 7 and the future of PHP</a></li>
<li><a href="http://evertpot.com/psr-7-issues/">PSR 7 issues</a></li>
<li><a href="http://symfony.com/blog/psr-7-support-in-symfony-is-here">PSR 7 support in Symfony is here</a></li>
<li><a href="http://dunglas.fr/2015/06/using-psr-7-in-symfony">Using PSR 7 in Symfony</a></li>
<li><a href="http://blog.madewithlove.be/post/http-client-for-sdks/">HTTP client for SDKs</a></li>
</ul></li>
<li><a href="http://mouf-php.com/psr7-container-interop-equals-cross-framework-module-system">PSR 7 Container Interop = cross framework module system</a></li>
<li><a href="http://mouf-php.com/psr-11-use-cases">PSR 11 use cases</a></li>
<li><a href="http://www.thecodingmachine.com/psr-11-performance-impact-of-the-delegate-lookup-feature/">PSR 11, performance impact of the delegate look-up feature</a></li>
<li><a href="http://blog.phpdeveloper.org/2015/05/22/php-security-psr-9psr-10/">PHP Security PSR 9 and 10</a></li>
<li><a href="https://www.acquia.com/blog/psr-what-shared-standards-bright-future">PSR-What? Shared Standards for a Bright Future</a></li>
</ul>

<h2 id="pet-projects">Pet projects</h2>

<ul>
<li><a href="https://github.com/gnugat/redaktilo/releases/tag/v1.7.0">Redaktilo 1.7</a></li>
<li><a href="https://gist.github.com/gnugat/492a192f9f57c00098b1">Stack middleware to rollback database transactions</a></li>
<li><a href="http://memio.github.io/memio/">Memio</a>:

<ul>
<li><a href="https://github.com/ciaranmcnulty/phpspec-typehintedmethods">its origin</a></li>
<li><a href="https://github.com/memio/spec-gen">SpecGen</a></li>
</ul></li>
<li>Symfony Micro Framework:

<ul>
<li><a href="https://github.com/gnugat/symfony-empty-edition">Symfony Empty Edition</a></li>
<li><a href="https://github.com/gnugat/micro-framework-bundle">MicroFrameworkBundle</a></li>
</ul></li>
</ul>

<h2 id="design-patterns">Design Patterns</h2>

<ul>
<li><a href="http://shawnmc.cool/the-repository-pattern">The Repository pattern</a></li>
<li><a href="http://enterprisecraftsmanship.com/2015/04/13/dto-vs-value-object-vs-poco">DTO vs Value Object vs POCO</a></li>
<li><a href="http://engineering.peertransfer.com/blog/decoupling-logic-architecture-repositories">Decoupling architecture and domain with repositories</a></li>
<li><a href="http://rob.conery.io/2014/03/04/repositories-and-unitofwork-are-not-a-good-idea/">Repositories On Top UnitOfWork Are Not a Good Idea</a></li>
</ul>

<h2 id="microservice">microservice</h2>

<ul>
<li><a href="http://martinfowler.com/bliki/MicroservicePremium.html">Microservice Premium</a></li>
<li><a href="http://martinfowler.com/bliki/MonolithFirst.html">Monolith First</a></li>
<li><a href="http://martinfowler.com/articles/dont-start-monolith.html">Don't start with a monolith</a></li>
<li><a href="http://capgemini.github.io/architecture/is-rest-best-microservices">Is REST best microservices</a></li>
<li><a href="http://martinfowler.com/articles/microservice-trade-offs.html">Microservices trade offs</a></li>
<li><a href="http://blog.christianposta.com/microservices/youre-not-going-to-do-microservices/">You're not going to do microservices</a></li>
</ul>

<h2 id="refactoring">Refactoring</h2>

<ul>
<li><a href="http://martinfowler.com/articles/refactoring-external-service.html">Refactoring external service</a></li>
<li>Refactoring the cat API client:

<ul>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-1/">part 1</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-2/">part 2</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/07/refactoring-the-cat-api-client-part-3/">part 3</a></li>
</ul></li>
</ul>

<h2 id="keep-it-simple">Keep it Simple</h2>

<ul>
<li><a href="http://97things.oreilly.com/wiki/index.php/Simplicity_before_generality,_use_before_reuse">Simplicity before generality, use before reuse</a></li>
<li><a href="http://blog.ircmaxell.com/2015/03/thoughts-on-design-of-apis.html">Thoughts on design of APIs</a></li>
<li><a href="http://verraes.net/2014/08/dry-is-about-knowledge/">DRY is about knowledge</a></li>
</ul>

<h2 id="oop">OOP</h2>

<ul>
<li><a href="https://www.thoughtworks.com/insights/blog/composition-vs-inheritance-how-choose">Composition VS inheritance, how to choose</a></li>
<li><a href="http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en">The meaning of Object Oriented Programming</a></li>
</ul>

<h2 id="git">Git</h2>

<ul>
<li><a href="https://akrabat.com/the-beginners-guide-to-rebasing-your-pr/">The beginners guide to rebasing your PR</a></li>
<li><a href="http://jeffkreeftmeijer.com/2010/the-magical-and-not-harmful-rebase/">The magical and not harmful rebase</a></li>
<li><a href="http://blog.rjkip.nl/2015/08/28/gits-interactive-patch-mode/">Git's interractive patch mode</a></li>
<li><a href="http://blog.8thlight.com/makis-otman/2015/07/08/git-disciplined.html">Git disciplined</a></li>
<li><a href="http://zachholman.com/posts/git-commit-history/">Utter Disregard for Git Commit History</a></li>
</ul>

<h2 id="security">Security</h2>

<ul>
<li><a href="http://www.antirez.com/news/96">A few things about Redis security</a></li>
<li><a href="http://blog.slaks.net/2015-10-13/web-authentication-arms-race-a-tale-of-two-security-experts/">The Web Authentication Arms Race – A Tale of Two Security Experts</a></li>
<li><a href="https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence">Secure authentication PHP with long term persistence</a></li>
</ul>

<h2 id="postgresql">PostgreSQL</h2>

<ul>
<li>What PostgreSQL has over other Open Source SQL databases:

<ul>
<li><a href="https://www.compose.io/articles/what-postgresql-has-over-other-open-source-sql-databases/">part 1</a></li>
<li><a href="https://www.compose.io/articles/what-postgresql-has-over-other-open-source-sql-databases-part-ii/">part 2</a></li>
</ul></li>
<li><a href="http://rob.conery.io/2014/05/29/a-better-id-generator-for-postgresql/">A better ID generator for PostgreSQL</a></li>
<li><a href="http://hashrocket.com/blog/posts/faster-json-generation-with-postgresql">Faster JSON generation with PostgreSQL</a></li>
<li><a href="http://developer.olery.com/blog/goodbye-mongodb-hello-postgresql/">Goodbye MongoDB, hello PostgreSQL</a></li>
</ul>

<h2 id="rest">REST</h2>

<ul>
<li><a href="http://www.nurkiewicz.com/2015/07/restful-considered-harmful.html">RESTful considered harmful</a></li>
<li><a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">Best practices for a pragmatic RESTful API</a></li>
</ul>

<h2 id="performance">Performance</h2>

<ul>
<li><a href="https://tideways.io/profiler/blog/5-doctrine-orm-performance-traps-you-should-avoid">5 Doctrine ORM performance traps you should avoid</a></li>
<li><a href="https://tideways.io/profiler/blog/essential-macro-optimizations-to-improve-php-performance">Essential macro optimizations to improve PHP performance</a></li>
<li><a href="https://tideways.io/profiler/blog/5-ways-to-optimize-symfony-baseline-performance">5 ways to optimize Symfony baseline performance</a></li>
<li><a href="http://marcjschmidt.de/blog/2014/02/08/php-high-performance.html">PHP high performance</a></li>
<li><a href="http://phpfastcgi.github.io/general/2015/11/04/introducing-phpfastcgi.html">Intproducting PHP FastCGI</a></li>
<li><a href="http://blog.kevingomez.fr/til/2015/07/26/why-is-uniqid-slow/">Why is uniqid slow?</a></li>
</ul>

<h2 id="agile">Agile</h2>

<ul>
<li><a href="http://jelrik.me/blog/2015/10/17/transform-your-standup/">Transform your stand up</a></li>
<li><a href="http://blog.8thlight.com/malcolm-newsome/2015/01/15/they-wont-be-interested.html">They won't be interrested</a></li>
<li><a href="http://blog.cleancoder.com/uncle-bob/2015/04/15/DoesOrganizationMatter.html">Does organization matter</a></li>
<li><a href="http://benjiweber.co.uk/blog/2015/04/17/modern-extreme-programming/">Modern extreme programming</a></li>
<li><a href="http://frankneff.ch/business/2015/04/21/if-pragmatism-raises-technical-debt-call-it-oversimplification/">If pragmatism raises technical debt, call it over simplification</a></li>
<li><a href="http://www.mountaingoatsoftware.com/blog/dont-blindly-follow">Don't blindly follow</a></li>
<li><a href="http://mattbriggs.net/blog/2015/06/01/the-role-of-a-senior-developer/">The role of a senior developer</a></li>
<li><a href="http://blog.toolshed.com/2015/05/the-failure-of-agile.html">The failure of agile</a></li>
<li><a href="http://mikehadlow.blogspot.fr/2014/06/heisenberg-developers.html">Heisenberg developers</a></li>
</ul>

<h2 id="ddd">DDD</h2>

<ul>
<li><a href="http://weronikalabaj.com/to-ddd-or-not-to-ddd-what-to-do-if-your-domain-is-boring/">To DDD or not to DDD, what to do if your domain is boring</a></li>
<li><a href="https://lostechies.com/gabrielschenker/2015/04/16/ddd-revisited/">DDD revisited</a></li>
<li><a href="http://codebetter.com/iancooper/2011/07/15/why-crud-might-be-what-they-want-but-may-not-be-what-they-need/">Why CRUD might be what they want but not what they need</a></li>
</ul>

<h2 id="symfony">Symfony</h2>

<ul>
<li><a href="http://jolicode.com/blog/do-not-use-fosuserbundle">Do not use FOSUserBundle</a></li>
<li><a href="http://mmoreram.github.io/blog/2015/08/20/re-thinking-event-listeners/">Re-thinking event listeners</a></li>
<li><a href="http://thorpesystems.com/blog/tagging-symfony-services">Tagging Symfony services</a></li>
<li><a href="https://www.pmg.com/blog/symfony-from-scratch/">Symfony from scratch</a></li>
<li><a href="http://programmingarehard.com/2015/03/04/structing-my-application.html">Structuring my application</a></li>
<li><a href="http://mmoreram.com/blog/2015/11/20/your-packages-dependencies/">Your package dependencies</a></li>
</ul>

<h2 id="misc">Misc</h2>

<ul>
<li><a href="http://kukuruku.co/hub/programming/do-not-learn-frameworks-learn-the-architecture">Do not learn frameworks, lean the architecture</a></li>
<li><a href="http://blog.8thlight.com/uncle-bob/2015/08/06/let-the-magic-die.html">Let the magic die</a></li>
<li><a href="http://www.levelofindirection.com/journal/2015/5/1/naming-is-hard-or-is-it.html">Naming is hard, or is it?</a></li>
<li><a href="http://www.freeklijten.nl/home/2015/06/24/Setter-anxiety">Setter anxiety</a></li>
<li><a href="http://blog.codinghorror.com/doing-terrible-things-to-your-code/">Doing terrible things to your code</a></li>
<li><a href="http://www.stilldrinking.org/programming-sucks">Programming sucks</a></li>
<li><a href="http://evertpot.com/switching-to-generators/">Switching to generators</a></li>
<li><a href="http://www.vertabelo.com/blog/technical-articles/orms-under-the-hood">ORMs under the hood</a></li>
<li><a href="http://blog.pivotal.io/pivotal-labs/labs/hexagonal-rails-and-the-ludicrous-terminal-application">Hexagonal</a></li>
<li><a href="http://burnout.io/">Burnout</a></li>
<li><a href="http://rosstuck.com/formatting-exception-messages/">Formatting exception messages</a></li>
<li><a href="http://mnapoli.fr/approaching-coding-style-rationally/">Approaching coding style rationally</a></li>
<li><a href="http://blog.frankdejonge.nl/pipelines-immutability-and-privates/">Pipelines, imutability and privates</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Micro Framework]]></title>
            <link href="/2015/12/23/symfony-micro-framework.html"/>
            <updated>2015-12-23T00:00:00+00:00</updated>
            <id>/2015/12/23/symfony-micro-framework.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TD;DR</strong>: <a href="http://symfony.com">Symfony</a> has always been able to be used as a micro
  framework.
  For more "add what you need" micro-framework like spirit, use the <a href="http://github.com/gnugat/symfony-empty-edition">Empty Edition</a>
  and the <a href="http://github.com/gnugat/micro-framework-bundle">MicroFrameworkBundle</a>.</p>
</blockquote>

<p>There are many definitions out there to qualify a framework as being "micro", among
them the following criterias often appear:</p>

<ul>
<li>small API (usage of framework's code in your application)</li>
<li>few Lines Of Code (LOC)</li>
<li>few dependencies (how many third party libraries are used)</li>
<li>small footprint (framework loading time)</li>
</ul>

<p>Is Symfony a micro framework as well? Let's find out.</p>

<blockquote>
  <p><strong>Note</strong>: To know more about how to determine if a framework is micro, read
  <a href="https://igor.io/archive.html">Igor Wiedler</a> article: <a href="https://igor.io/2013/09/02/how-heavy-is-silex.html">How heavy is Silex?</a>.</p>
</blockquote>

<h2 id="measuring">Measuring</h2>

<p>While "Hello World" examples rarely reflect real world applications, it's going
to be good enough to serve the purpose of this article: getting a good measure of
Symfony's API, LOC, dependencies and footprint.</p>

<p>Since dependencies and footprint are easy to measure, we're going to rely on it.
However, all benchmarks are relative to the computer that executes them, so we need
a point of reference: a flat PHP "Hello World" application:</p>

<pre><code class="php">&lt;?php
// index.php

echo 'Hello World';
</code></pre>

<p>Let's run the benchmark:</p>

<pre><code>php -S localhost:2501 &amp;
ab -c 10 -t 10 'http://localhost:2501/index.php'
killall php
</code></pre>

<p>Result: <strong>6 915.03</strong> Requests per second.</p>

<h2 id="standard-edition">Standard Edition</h2>

<p>To get the Standard Edition, we can use composer:</p>

<pre><code>composer create-project symfony/framework-standard-edition
cd framework-standard-edition
</code></pre>

<p>Since the standard edition follows a "solve 80% of use cases out of the box" philosohpy,
it's almost ready, we just need to tweak the given controller:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/DefaultController.php

namespace AppBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class DefaultController extends Controller
{
    /**
     * @Route("/", name="homepage")
     */
    public function indexAction(Request $request)
    {
        return new Response('Hello World');
    }
}
</code></pre>

<p>Let's run the benchmark:</p>

<pre><code>SYMFONY_ENV=prod composer update -o --no-dev
php -S localhost:2502 -t web &amp;
ab -c 10 -t 10 'http://localhost:2502/app.php'
killall php
</code></pre>

<p>Result: <strong>134.23</strong> Requests per second.</p>

<p>We're also going to list the dependencies:</p>

<pre><code>tree -d -L 2 vendor/ | grep '   ' | wc -l
tree -d -L 2 vendor/ | grep '    ' | wc -l
</code></pre>

<p>We get 28 + 1, to which we need to substitute <code>symfony</code> with all the
packages it replaces (44): 72.</p>

<p>So to sum up:</p>

<ul>
<li>API: 1 step to add a new route</li>
<li>footprint: 52x slower than flat PHP</li>
<li>size: 72 dependencies</li>
</ul>

<h2 id="empty-edition">Empty Edition</h2>

<p>As stated above the Standard Edition has a "solve 80% of use cases out of the box"
philosophy, so it comes with many dependencies that might not fit our use. Micro
framework usually follow a "add what you need philosophy", which is exactly what
the Empty Edition is all about.</p>

<p>Let's see if we can get more micro with it:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition
cd symfony-empty-edition
</code></pre>

<p>The first step is to create a controller:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/HelloController.php

namespace AppBundle\Controller;

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class HelloController
{
    public function world(Request $request)
    {
        return new Response('Hello World');
    }
}
</code></pre>

<p>Then we register it as a service:</p>

<pre><code># app/config/services/controller.yml
services:
    app.hello_controller:
        class: AppBundle\Controller\HelloController
</code></pre>

<p>Finally we register the route:</p>

<pre><code># app/config/routings/app.yml
hello_world:
    path: /
    defaults:
        _controller: app.hello_controller:world
    methods:
        - GET
</code></pre>

<p>Let's run the benchmark:</p>

<pre><code>composer update -o --no-dev
php -S localhost:2503 -t web &amp;
ab -c 10 -t 10 'http://localhost:2503/app.php'
killall php
</code></pre>

<p>Result: <strong>524.53</strong> Requests per second.</p>

<p>We're also going to list the dependencies:</p>

<pre><code>tree -d -L 2 vendor/ | grep '   ' | wc -l
tree -d -L 2 vendor/ | grep '    ' | wc -l
</code></pre>

<p>We get 6 + 23 = 29.</p>

<p>So to sum up:</p>

<ul>
<li>API: 3 steps to add a new route</li>
<li>footprint: 13x slower than flat PHP</li>
<li>size: 29 dependencies</li>
</ul>

<h2 id="micro-framework-bundle">Micro Framework Bundle</h2>

<p>By reducing the number of dependencies, we also drastically reduced the framework
footprint. This is not surprising as:</p>

<ul>
<li>we've reduced the number of classes to autoload</li>
<li>we've reduced the number of configuration (parameters and service definition) to set up</li>
<li>we've reduced the bootload time of the Dependency Injection Container (less services to instantiate)</li>
<li>we've reduced the number of event listeners called</li>
</ul>

<p>Can we go further? Certainly: the FrameworkBundle also follows a
"solve 80% of use cases out of the box" (includes Forms, Security, Templating, Translation, Assets, annotations, etc).</p>

<p>By using a MicroFrameworkBundle that would provide the strict minimum and follow
the micro framework philosophy of "add what you need" we can surely reduce further
the number of dependencies. Hence <code>gnugat/micro-framework-bundle</code>:</p>

<pre><code>composer require 'gnugat/micro-framework-bundle'
composer remove 'symfony/framework-bundle'
</code></pre>

<p>Then we need to swap the bundle in the registration:</p>

<pre><code class="php">&lt;?php
// app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Gnugat\MicroFrameworkBundle\GnugatMicroFrameworkBundle(),
            new AppBundle\AppBundle(),
        );
    }

    public function getRootDir()
    {
        return __DIR__;
    }

    public function getCacheDir()
    {
        return dirname(__DIR__).'/var/cache/'.$this-&gt;environment;
    }

    public function getLogDir()
    {
        return dirname(__DIR__).'/var/logs';
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load($this-&gt;rootDir.'/config/config_'.$this-&gt;environment.'.yml');
    }
}
</code></pre>

<p>Finally we can get rid of some configuration:</p>

<pre><code># app/config/config.yml
imports:
    - { resource: parameters.yml }
    - { resource: services/ }
</code></pre>

<p>Let's benchmark our trimmed application:</p>

<pre><code>rm -rf var/*
composer update -o --no-dev
php -S localhost:2504 -t web &amp;
ab -c 10 -t 10 'http://localhost:2504/app.php'
killall php
</code></pre>

<p>Result: <strong>872.83</strong> Requests per second.</p>

<p>We're also going to list the dependencies:</p>

<pre><code>tree -d -L 2 vendor/ | grep '   ' | wc -l
tree -d -L 2 vendor/ | grep '    ' | wc -l
</code></pre>

<p>We get 3 + 13 = 16.</p>

<p>So to sum up:</p>

<ul>
<li>API: 3 steps to add a new route</li>
<li>footprint: 8x slower than flat PHP</li>
<li>size: 13 dependencies</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Symfony has always been able to be used as a micro framework bundle.</p>

<p>The <a href="https://github.com/symfony/symfony-standard">Standard Edition</a> and the
<a href="https://github.com/symfony/symfony/tree/master/src/Symfony/Bundle/FrameworkBundle">FrameworkBundle</a>
follow a "solve 80% of use cases out of the box" philosohpy, which is better for new comers.</p>

<p>However for experimented developers who're looking for a "add what you need" philosophy,
which is what micro-framework usually follow, using the <a href="http://github.com/gnugat/symfony-empty-edition">Empty Edition</a>
and <a href="http://github.com/gnugat/micro-framework-bundle">MicroFrameworkBundle</a> can
be a viable alternative (they are slimer in term of dependencies and faster).</p>

<blockquote>
  <p><strong>Note</strong>: At the time of writing, MicroFrameworkBundle is still under development
  (version <code>0.1.0</code>). Use it at your own risk and contribute to it :) .</p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Decouple from Frameworks]]></title>
            <link href="/2015/09/30/decouple-from-frameworks.html"/>
            <updated>2015-09-30T00:00:00+01:00</updated>
            <id>/2015/09/30/decouple-from-frameworks.html</id>
            <content type="html"><![CDATA[<p>Frameworks solve infrastructure problems, for example how to create a HTTP or CLI application.
While necessary, those concerns don't add any value to your project: the business
need will not be fulfilled by creating an empty application.</p>

<p>As always, different responsibilities mean also different reasons to change: frameworks
have a history of Backward Compatibility (BC) breaks and they do so regardless of your
project.</p>

<p>Take for example <a href="http://symfony.com/">Symfony</a>: it only started to follow <a href="http://semver.org/">Semantic Versioning</a>
from version 2.3. The upgrade to version 3 has been made easier by allowing developers
to know what was deprecated, but the removal of those features still means a lot of
work in your application.
The arrival of the <a href="http://www.php-fig.org/psr/psr-7/">new standard PSR-7</a> brings
a lot of questions on the future of Symfony: for now it <a href="http://symfony.com/blog/psr-7-support-in-symfony-is-here">allows to choose</a>
between <code>symfony/http-foundation</code> and <code>psr/http-message</code>, but if Symfony doesn't
want to fall back behind (<a href="http://framework.zend.com/blog/announcing-the-zend-framework-3-roadmap.html">Zend 3 is fully based on PSR-7</a>)
it might have to introduce another big BC break (event listeners with the Request
and Response <a href="http://evertpot.com/psr-7-issues/">are not possible the way they are now with PSR-7</a>).</p>

<p>Migrating Symfony applications (from symfony1, from symfony 2.0, etc) is so hard
that it is a business on its own.</p>

<p>Does that mean that we shouldn't use any frameworks? Should we just don't care and
embrace fully frameworks?</p>

<p>This article will explain how to avoid both extremes, by decoupling from the framework.
It can be done by restricting the framework to its infrastructure responsibilities
(HTTP, CLI), by only using its entry points (Controller, Command) and by using
the Command Bus pattern.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>We're going to build part of a <a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a>
application for our example, more precisely we're going to build an endpoint allowing us to
submit quotes.</p>

<p>To do so, we'll bootstrap a symfony application using the <a href="https://github.com/gnugat/symfony-empty-edition">Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition fortune
cd fortune
</code></pre>

<p>We'll need to install our test frameworks:</p>

<pre><code>composer require --dev phpunit/phpunit
composer require --dev phpspec/phpspec
</code></pre>

<p>Then add them to our test script:</p>

<pre><code>#!/usr/bin/env sh

# bin/test.sh

echo ''
echo '// Building test environment'

rm -rf app/cache/test app/logs/*test.log
composer --quiet --no-interaction install --optimize-autoloader  &gt; /dev/null
php app/console --env=test --quiet cache:clear

echo ''
echo ' [OK] Test environment built'
echo ''

vendor/bin/phpspec --format=dot &amp;&amp; vendor/bin/phpunit
</code></pre>

<p>Finally we'll configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="app/bootstrap.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="System Tests"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="request-listener">Request listener</h2>

<p>Our endpoint will receive JSON encoded content. PHP does not populate <code>$_POST</code> with
this data, causing an empty <code>$request-&gt;request</code>. We can create an event listener
to fix this issue:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/JsonRequestListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class JsonRequestListener
{
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('PATCH', 'POST', 'PUT'), true);
        $isJson = (1 === preg_match('#application/json#', $request-&gt;headers-&gt;get('Content-Type')));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new Response('{"error":"Invalid or malformed JSON"}', 400, array('Content-Type' =&gt; 'application/json')));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>This logic is infrastructure related, so it makes sense to keep it in <code>AppBundle</code>.</p>

<p>To enable it, configure it in the Dependency Injection Container:</p>

<pre><code># app/config/services/event_listener.yml

services:
    app.json_request_listener:
        class: AppBundle\EventListener\JsonRequestListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<p>We also need to make sure files in <code>app/config/services</code> are imported:</p>

<pre><code class="php">&lt;?php
// app/config/importer.php

use Symfony\Component\Finder\Finder;

$finder = new Finder();
$files = $finder-&gt;files()-&gt;name('*.yml')-&gt;in(__DIR__.'/services');
foreach ($files as $file) {
    $loader-&gt;import($file-&gt;getRealpath());
}
</code></pre>

<h2 id="controller">Controller</h2>

<p>Our first step will be to describe how the endpoint should work, with a test:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Controller/QuoteControllerTest.php

namespace tests\AppBundle\Controller;

use AppKernel;
use PHPUnit_Framework_TestCase;
use Symfony\Component\HttpFoundation\Request;

class QuoteControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new AppKernel('test', false);
        $this-&gt;app-&gt;boot();
    }

    /**
     * @test
     */
    public function it_submits_a_new_quote()
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $request = Request::create('/v1/quotes', 'POST', array(), array(), array(), $headers, json_encode(array(
            'quote' =&gt; 'Nobody expects the spanish inquisition',
        )));

        $response = $this-&gt;app-&gt;handle($request);

        self::assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Testing only the status code is called "Smoke Testing" and is a very
  efficient way to check if the application is broken.
  Testing the content would be tedious and would make our test fragile as it might change often.</p>
</blockquote>

<p>Let's run it:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>The tests fail because the controller doesn't exist. Let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/QuoteController.php

namespace AppBundle\Controller;

use Acme\Fortune\Quote\SubmitNewQuote;
use Acme\Fortune\Quote\SubmitNewQuoteHandler;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class QuoteController
{
    private $submitNewQuoteHandler;

    public function __construct(SubmitNewQuoteHandler $submitNewQuoteHandler)
    {
        $this-&gt;submitNewQuoteHandler = $submitNewQuoteHandler;
    }

    public function submitNewAction(Request $request)
    {
        $sumbitNewQuote = new SubmitNewQuote(
            $request-&gt;request-&gt;get('quote')
        );
        $newQuote = $this-&gt;submitNewQuoteHandler-&gt;handle($sumbitNewQuote);

        return new Response(json_encode($newQuote), 201, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>Now we need to configure the controller as a service:</p>

<pre><code># app/config/services/controller.yml

services:
    app.quote_controller:
        class: AppBundle\Controller\QuoteController
        arguments:
            - "@app.submit_new_quote_handler"
</code></pre>

<p>Then we need to configure the route:</p>

<pre><code># app/config/routings/quote.yml

submit_new_quote:
    path: /v1/quotes
    defaults:
        _controller: app.quote_controller:submitNew
    methods:
        - POST
</code></pre>

<p>This file needs to be imported:</p>

<pre><code># app/config/routing.yml

quote:
    resource: routings/quote.yml
</code></pre>

<p>Finally we can run the test again:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>It now fails for a different reason: <code>SubmitNewQuote</code> and its handler class don't exist.</p>

<h2 id="command-from-commandbus">Command (from CommandBus)</h2>

<p><code>SubmitNewQuote</code> is a Data Transfer Object (DTO): its responsibility is to wrap
input parameters in a well named class (in this case a class that describes the action intended).
It's also the best place to do some basic validation on the input parameters.</p>

<blockquote>
  <p><strong>Note</strong>: In the Command Bus pattern, <code>SubmitNewQuote</code> would be a Command (different from the CLI Command).</p>
</blockquote>

<p>We'll write a test for this, but first we'll bootstrap the test class:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\Fortune\Quote\SubmitNewQuote'
</code></pre>

<p>Now we can decribe the different validation rules:</p>

<pre><code class="php">&lt;?php
// spec/Acme/Fortune/Quote/SubmitNewQuoteSpec.php

namespace spec\Acme\Fortune\Quote;

use PhpSpec\ObjectBehavior;

class SubmitNewQuoteSpec extends ObjectBehavior
{
    const QUOTE = 'Nobody expects the spanish inquisition';

    function it_fails_if_required_quote_parameter_is_missing()
    {
        $this-&gt;beConstructedWith(null);

        $this-&gt;shouldThrow('Acme\Fortune\Exception\ValidationFailedException')-&gt;duringInstantiation();
    }

    function it_fails_if_quote_parameter_is_empty()
    {
        $this-&gt;beConstructedWith('');

        $this-&gt;shouldThrow('Acme\Fortune\Exception\ValidationFailedException')-&gt;duringInstantiation();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Since this class has nothing to do with Symfony, we don't put it in <code>AppBundle</code>.
  By keeping it in its own namespace, we protect it from framework directory tree changes,
  for example before <code>AppBundle</code> the norm was <code>Acme\FortuneBundle</code>. We also allow ourselves
  to move it to another framework (e.g. Laravel, Zend, etc).</p>
</blockquote>

<p>Let's run the tests:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>It fails because the exception doesn't exist yet:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Exception/ValidationFailedException.php

namespace Acme\Fortune\Exception;

class ValidationFailedException extends FortuneException
{
}
</code></pre>

<p>We're making it a sub type of <code>FortuneException</code>: that way we can catch all exceptions
related to our code (all other exceptions can be considered as Internal Server Errors).</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Exception/FortuneException.php

namespace Acme\Fortune\Exception;

use DomainException;

class FortuneException extends DomainException
{
}
</code></pre>

<p>Now we need to create the Command:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Quote/SubmitNewQuote.php

namespace Acme\Fortune\Quote;

use Acme\Fortune\Exception\ValidationFailedException;

class SubmitNewQuote
{
    public function __construct($quote)
    {
        if (null === $quote) {
            throw new ValidationFailedException('Missing required "quote" parameter');
        }
        if ('' === $quote) {
            throw new ValidationFailedException('Invalid "quote" parameter: must not be empty');
        }
        $this-&gt;quote = (string) $quote;
    }
}
</code></pre>

<p>Running the tests again:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>Everything seems fine.</p>

<h2 id="exception-listener">Exception listener</h2>

<p>Instead of catching exceptions in our controllers we can create an event listener:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/FortuneExceptionListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class FortuneExceptionListener
{
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof FortuneException) {
            return;
        }
        $content = json_encode(array('error' =&gt; $exception-&gt;getMessage()));
        $statusCode = Response::HTTP_UNPROCESSABLE_ENTITY;
        $event-&gt;setResponse(new Response($content, $statusCode, array('Content-Type' =&gt; 'application/json')));
    }
}
</code></pre>

<p>This lowers the risk of forgetting to catch an exception and it also keeps our controller slim.</p>

<p>Let's enable it in the DIC:</p>

<pre><code># app/config/services/event_listener.yml

services:
    app.fortune_exception_listener:
        class: AppBundle\EventListener\FortuneExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException }

    app.json_request_listener:
        class: AppBundle\EventListener\JsonRequestListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<h2 id="command-handler">Command Handler</h2>

<p><code>SubmitNewQuoteHandler</code>'s responsibility is to validate <code>SubmitNewQuote</code> data against
business rules (e.g. no quote duplicates, author must exist, etc) and to call the
appropriate services to process it.
Reading its code feels like reading the details of a use case:</p>

<blockquote>
  <p>To handle the submission of a new quote,
  we need to generate a unique identifier
  and then we need to save the new quote.</p>
</blockquote>

<p>Let's bootstrap its test:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\Fortune\Quote\SubmitNewQuoteHandler'
</code></pre>

<p>Then edit the test:</p>

<pre><code class="php">&lt;?php
// spec/Acme/Fortune/Quote/SubmitNewQuoteHandlerSpec.php

namespace spec\Acme\Fortune\Quote;

use Acme\Fortune\Quote\SubmitNewQuote;
use Acme\Fortune\Quote\Service\SaveNewQuote;
use Acme\Fortune\Quote\Service\UniqueIdentifierGenerator;
use PhpSpec\ObjectBehavior;

class SubmitNewQuoteHandlerSpec extends ObjectBehavior
{
    const ID = '921410e8-eb98-4f99-ba98-055d46980511';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    function let(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $this-&gt;beConstructedWith($saveNewQuote, $uniqueIdentifierGenerator);
    }

    function it_saves_new_quote(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $submitNewQuote = new SubmitNewQuote(self::QUOTE);
        $quote = array(
            'id' =&gt; self::ID,
            'quote' =&gt; self::QUOTE,
        );

        $uniqueIdentifierGenerator-&gt;generate()-&gt;willReturn(self::ID);
        $saveNewQuote-&gt;save($quote)-&gt;shouldBeCalled();

        $this-&gt;handle($submitNewQuote)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>After generating interfaces for <code>SaveNewQuote</code> and <code>UniqueIdentifierGenerator</code>
and after bootstrapping the code for <code>SubmitNewQuoteHandler</code>, the test will fail
because we need to complete it:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Quote/SubmitNewQuoteHandler.php

namespace Acme\Fortune\Quote;

use Acme\Fortune\Quote\Service\SaveNewQuote;
use Acme\Fortune\Quote\Service\UniqueIdentifierGenerator;

class SubmitNewQuoteHandler
{
    private $saveNewQuote;
    private $uniqueIdentifierGenerator;

    public function __construct(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $this-&gt;saveNewQuote = $saveNewQuote;
        $this-&gt;uniqueIdentifierGenerator = $uniqueIdentifierGenerator;
    }

    public function handle(SubmitNewQuote $sumbitNewQuote)
    {
        $quote = array(
            'id' =&gt; $this-&gt;uniqueIdentifierGenerator-&gt;generate(),
            'quote' =&gt; $sumbitNewQuote-&gt;quote,
        );
        $this-&gt;saveNewQuote-&gt;save($quote);

        return $quote;
    }
}
</code></pre>

<p>Now we can configure the service:</p>

<pre><code class="php"># app/config/services/quote.yml

services:
    app.submit_new_quote_handler:
        class: Acme\Fortune\Quote\SubmitNewQuoteHandler
        arguments:
            - "@app.save_new_quote"
            - "@app.unique_identifier_generator"
</code></pre>

<p>Finally can run the tests one last time:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>Allmost green!</p>

<p>They fail because <code>app.save_new_quote</code> and <code>app.unique_identifier_generator</code> don't
exist yet. They will be the topic of another article ;) .</p>

<h2 id="conclusion">Conclusion</h2>

<p>By restricting frameworks to their entry points (Controllers, Commands, etc) and
using the Command Bus to define our project entry points (domain boundaries) we
are able to decouple from the framework, allowing us to restrict the impact of BC breaks.</p>

<p>Of course, all projects are different and this solution might not be possible everywhere.
RAD development is a robust solution for web agencies, especially if they are chosen
to bootstrap a project as fast as possible and then need to pass the project over
to their customer after a short period.</p>

<p>On the other hand some companies are creating projects they will have to maintain
for decades and those are also in need of delivering a first version early.
Decoupling from the framework isn't something that slows down development, and there
are ways to still release early (e.g. define Minimum Valuable Product and deliver
small features iterations by iterations).</p>

<blockquote>
  <p><strong>Note</strong>: There are a couple of bundles that provides Symfony with a Command Bus, among them:</p>
  
  <ul>
  <li><a href="/2015/09/09/tactician.html">Tactician</a></li>
  <li><a href="/2015/08/04/simple-bus.html">SimpleBus</a></li>
  </ul>
</blockquote>

<p>If you're interrested on the subject, here's some resources:</p>

<ul>
<li>The framework as an implementation detail
(<a href="http://www.slideshare.net/marcello.duarte/the-framework-as-an-implementation-detail">slides</a>
and <a href="https://www.youtube.com/watch?v=0L_9NutiJlc">video</a>),
by <a href="http://marcelloduarte.net/">Marcello Duarte</a>
and <a href="http://everzet.com/">Konstantin Kudryashov</a></li>
<li><a href="https://blog.8thlight.com/uncle-bob/2014/05/11/FrameworkBound.html">Framework bound</a>,
by <a href="https://sites.google.com/site/unclebobconsultingllc/">Robert Cecil Martin</a></li>
<li><a href="http://kristopherwilson.com/2013/11/27/decoupling-the-framework/">Decoupling the Framework</a>,
by <a href="https://twitter.com/mrkrstphr">Kristopher Wilson</a></li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Differently - part 3: Conclusion]]></title>
            <link href="/2015/08/02/sf-differently-part-3-conclusion.html"/>
            <updated>2015-08-02T00:00:00+01:00</updated>
            <id>/2015/08/02/sf-differently-part-3-conclusion.html</id>
            <content type="html"><![CDATA[<p>This series isn't really working for me, so I've decided to conclude it prematurely.
Have a look at the first ones:</p>

<ol>
<li><a href="/2015/06/03/sf-differently-part-1-introduction.html">Introduction</a></li>
<li><a href="/2015/06/10/sf-differently-part-2-bootstrap.html">Bootstrap</a></li>
</ol>

<p>In this article we'll see a series of optimizations with their impact. Then we'll
conclude that Caching is actually better, let's see those figures!</p>

<h2 id="tools">Tools</h2>

<p>The application is built with the Symfony Standard Edition and Doctrine ORM's QueryBuilder.
Composer's configuration has been tweaked to use PSR-4 and to not autoload tests.
Also Composer has been run with the <code>--optimize-autoloader</code> option.</p>

<p>Tests are done using <a href="https://httpd.apache.org/docs/2.2/programs/ab.html">ab</a>
(with 10 concurrent clients for 10 seconds), on a different server than the application's
one.</p>

<p>Also, we're using PHP 5.5 and Symfony 2.7.</p>

<h2 id="optimizations">Optimizations</h2>

<p>The application would initially serve: <strong>22 requests / seconds</strong>.</p>

<p>By removing unused dependencies, we get <strong>23 requests / seconds</strong>.</p>

<blockquote>
  <p>Note</p>
  
  <p>Removed:</p>
  
  <ul>
  <li>AsseticBundle</li>
  <li>SensioDistributionBundle (only from <code>AppKernel</code>, the dependency is kept to generate <code>app/bootstrap.php.cache</code>)</li>
  <li>SensioGeneratorBundle</li>
  <li>SwiftmailerBundle</li>
  <li>TwigBundle</li>
  <li>WebProfilerBundle</li>
  </ul>
  
  <p>Also, the following components have been disabled:</p>
  
  <ul>
  <li>Form</li>
  <li>Validation</li>
  </ul>
</blockquote>

<p>By switching from Doctrine ORM's Query Builder to Doctrine DBAL's one: <strong>28 requests / seconds</strong>.</p>

<p>By <a href="http://labs.octivi.com/mastering-symfony2-performance-internals/">adding classes to compile</a>:
<strong>29 requests / seconds</strong>.</p>

<p>By defining controllers as services: <strong>30 requests / seconds</strong>.</p>

<p>This sums up to an increase of 36%.</p>

<h2 id="how-about-using-http-cache%3F">How about using HTTP cache?</h2>

<p>By setting a 10 seconds HTTP cache (using <a href="http://foshttpcachebundle.readthedocs.org/en/latest/">FOSCacheBundle</a>),
on top of the previous optimizations , we get <strong>160 requests / seconds</strong> (an increase of 430%).</p>

<p>And that's by using Symfony's built in reverse proxy, imagine what we could get with varnish!</p>

<h2 id="conclusion">Conclusion</h2>

<p>While optimizations are fun, they don't bring much value. The main bottlenecks
are usually the autoloading, database/network transactions and the number of functions
called.</p>

<p>On the other hand, using a reverse proxy is quite simple and does pay off!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Differently - part 2: Bootstrap]]></title>
            <link href="/2015/06/10/sf-differently-part-2-bootstrap.html"/>
            <updated>2015-06-10T00:00:00+01:00</updated>
            <id>/2015/06/10/sf-differently-part-2-bootstrap.html</id>
            <content type="html"><![CDATA[<p>This is the second article of the <a href="https://symfony.com">Symfony</a> Differently series,
Have a look at the first one: <a href="/2015/06/03/sf-differently-part-1-introduction.html">Introduction</a>.</p>

<p>Our goal in this post is to bootstrap an application to then create a search endpoint for items.
We've decided to use Symfony for a single reason: our company Acme used it since the begining
and the API developers team has Symfony and PHP skills.</p>

<blockquote>
  <p><strong>Note</strong>: Most frameworks have a good community support, a strong documentation,
  similar features and many developers available on the market. We'll see the
  importance of a framework performances in the following articles, but the point
  here is that the choice should mainly rely on skills we have internally
  (and the ones we can acquire).</p>
</blockquote>

<h2 id="symfony-standard-edition">Symfony Standard Edition</h2>

<p>The first step is to use <a href="http://getcomposer.com/">Composer</a>:</p>

<pre><code>composer create-project symfony/framework-standard-edition items
</code></pre>

<p>This will create a directory structure for our project, download a set of third
party libraries and ask us to set a bunch of configuration parameters. In this
series we'll use a Postgres database, so we need to edit <code>app/config/config.yml</code>:</p>

<pre><code># ...

# Doctrine Configuration
doctrine:
    dbal:
        driver: pdo_pgsql

# ...
</code></pre>

<p>Once finished we'll save our work using Git:</p>

<pre><code>cd items
git init
git add -A
git ci -m 'Created a standard Symfony application'
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We can also use the <a href="http://symfony.com/doc/current/book/installation.html#installing-the-symfony-installer">Symfony Installer</a>
  to create new projects.</p>
</blockquote>

<h2 id="configuring-apache">Configuring Apache</h2>

<p>For the same reason we chose Symfony we've decided to use Apache for our web servers
(it's the one used for all previous projects).</p>

<blockquote>
  <p><strong>Note</strong>: By providing Nginx trainings and recruiting devops used to, it Acme
  could change its technology stack. The only rule when switching to another
  technology is to stick to it in order to avoid having too many different technologies.</p>
</blockquote>

<p>We need to create a virtual host first by creating the <code>/etc/apache2/sites-available/items.conf</code>
file:</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerName items.local

    DocumentRoot /home/foobar/items/web

    ErrorLog "/home/foobar/items/app/logs/apache_errors.log"
    CustomLog "/home/foobar/items/app/logs/apache_accesses.log" common

    &lt;Directory /home/foobar/items/web&gt;
        Options Indexes FollowSymLinks MultiViews
        AllowOverride all
        Require all granted
        Order allow,deny
        allow from all
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</code></pre>

<p>Apache will require access to the logs and cache directories, as well as our user.
The easiest way to avoid permission issues is to change Apache's user and group
to ours in <code>/etc/apache2/envvars</code>:</p>

<pre><code>export APACHE_RUN_USER=foobar
export APACHE_RUN_GROUP=foobar
</code></pre>

<p>We'll aslo need to add the hostname to our <code>/etc/hosts</code> file:</p>

<pre><code>echo '127.0.0.1 items.local' | sudo tee -a /etc/hosts
</code></pre>

<p>Finally we have to enable the website and reload Apache to take the configuration into account:</p>

<pre><code>sudo a2ensite items
sudo service apache2 reload
</code></pre>

<p>We now should be able to see the message "Homepage" when browsing http://items.local/app_dev.php/app/example</p>

<h2 id="tests">Tests</h2>

<p>A nice tweak to do is to move tests in a separate directory, allowing Composer to only
autoload test class in development environments. This can be done by changing <code>composer.json</code>
as follow:</p>

<pre><code>{
    "name": "acme/items",
    "license": "private",
    "type": "project",
    "description": "Specific APIs for items",
    "autoload": {
        "psr-4": { "AppBundle\\": "src/AppBundle" }
    },
    "autoload-dev": {
        "psr-4": { "AppBundle\\Tests\\": "tests/" }
    },
    "require": {
        "php": "&gt;=5.3.3",
        "symfony/symfony": "~2.7@beta",
        "doctrine/orm": "~2.2,&gt;=2.2.3,&lt;2.5",
        "doctrine/dbal": "&lt;2.5",
        "doctrine/doctrine-bundle": "~1.4",
        "symfony/assetic-bundle": "~2.3",
        "symfony/swiftmailer-bundle": "~2.3",
        "symfony/monolog-bundle": "~2.4",
        "sensio/distribution-bundle": "~3.0,&gt;=3.0.12",
        "sensio/framework-extra-bundle": "~3.0,&gt;=3.0.2",
        "incenteev/composer-parameter-handler": "~2.0"
    },
    "require-dev": {
        "sensio/generator-bundle": "~2.3"
    },
    "scripts": {
        "post-install-cmd": [
            "Incenteev\\ParameterHandler\\ScriptHandler::buildParameters",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::buildBootstrap",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::clearCache",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installAssets",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installRequirementsFile",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::removeSymfonyStandardFiles",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::prepareDeploymentTarget"
        ],
        "post-update-cmd": [
            "Incenteev\\ParameterHandler\\ScriptHandler::buildParameters",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::buildBootstrap",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::clearCache",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installAssets",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installRequirementsFile",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::removeSymfonyStandardFiles",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::prepareDeploymentTarget"
        ]
    },
    "extra": {
        "symfony-app-dir": "app",
        "symfony-web-dir": "web",
        "symfony-assets-install": "relative",
        "incenteev-parameters": {
            "file": "app/config/parameters.yml"
        }
    }
}
</code></pre>

<p>Since we've decided to move vendor binaries back to <code>vendor/bin</code>, we can un-ignore
the <code>bin</code> directory by editing <code>.gitignore</code>:</p>

<pre><code>/web/bundles/
/app/bootstrap.php.cache
/app/cache/*
/app/config/parameters.yml
/app/logs/*
!app/cache/.gitkeep
!app/logs/.gitkeep
/app/phpunit.xml
/build/
/vendor/
/composer.phar
</code></pre>

<p>To make it official, we need to run the following commands:</p>

<pre><code>rm -rf bin
composer update
</code></pre>

<blockquote>
  <p><strong>Note</strong>: In production, we'll need to run <code>composer install --no-dev --optimize-autoloader</code></p>
</blockquote>

<p>Our system/functional tests will involve database queries which can make the test suite
unreliable. To fix this, we'll create a "middleware" that wraps our <code>AppKernel</code> in a
database transaction and rolls it back after each requests:</p>

<p>To do so, we can create the following <code>app/RollbackKernel.php</code>:</p>

<pre><code class="php">&lt;?php
// File: app/RollbackKernel.php

use Doctrine\DBAL\Connection;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\HttpKernelInterface;

class RollbackKernel implements HttpKernelInterface
{
    private $app;
    private $connection;

    public function __construct(HttpKernelInterface $app, Connection $connection)
    {
        $this-&gt;app = $app;
        $this-&gt;connection = $connection;
    }

    public static function make()
    {
        $kernel = new \AppKernel('test', false);
        $kernel-&gt;boot();
        $connection = $kernel-&gt;getContainer()-&gt;get('doctrine.dbal.default_connection');

        return new self($kernel, $connection);
    }

    public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
    {
        $this-&gt;connection-&gt;beginTransaction();
        $response = $this-&gt;app-&gt;handle($request, $type, $catch);
        $this-&gt;connection-&gt;rollback();

        return $response;
    }
}
</code></pre>

<p>To be able to use <code>RollbackKernel</code> in our tests we need to make it available by
creating the following <code>app/bootstrap_test.php</code>:</p>

<pre><code class="php">&lt;?php
// File: app/bootstrap_test.php

require __DIR__.'/bootstrap.php.cache';
require __DIR__.'/AppKernel.php';
require __DIR__.'/RollBackKernel.php';
</code></pre>

<p>Then we can configure PHPUnit to use it by editing <code>app/phpunit.xml.dist</code>:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="bootstrap_test.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="Functional Tests"&gt;
            &lt;directory&gt;../tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<p>Finally we'll install <a href="http://phpspec.net/">phpspec</a> with <a href="http://memio.github.io/spec-gen">SpecGen</a>
for our unit tests:</p>

<pre><code>composer require --dev phpunit/phpunit:~4.6 phpspec/phpspec:~2.2 memio/spec-gen:~0.3
echo 'extensions:' &gt; phpspec.yml
echo '  - Memio\SpecGen\MemioSpecGenExtension' &gt;&gt; phpspec.yml
</code></pre>

<p>And now we're ready to test our application! Let's save our work:</p>

<pre><code>git add -A
git commit -m 'Prepared application for tests'
</code></pre>

<h2 id="scripts">Scripts</h2>

<p>There's 3 common tasks we'll be doing as developers with our application:</p>

<ul>
<li>build it for our development environment</li>
<li>test it locally or in a Continuous Integration environment</li>
<li>deploy it to production</li>
</ul>

<p>In order to automate those in a simple way, we've decided to create 3 scripts:
<code>bin/build.sh</code>, <code>bin/deploy.sh</code> and <code>bin/test.sh</code>, but for this series we'll only
take care of <code>build</code> and <code>test</code>.</p>

<p>The build steps should reinitialize the database and Symfony's cache, for this
we'll need Doctrine Fixtures and Doctrine Migrations:</p>

<pre><code>composer require doctrine/doctrine-fixtures-bundle:~2.2
composer require doctrine/migrations:~1.0@alpha
composer require doctrine/doctrine-migrations-bundle:~1.0
</code></pre>

<p>Then we have to register them in <code>app/AppKernel.php</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
            new AppBundle\AppBundle(),
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            $bundles[] = new Doctrine\Bundle\FixturesBundle\DoctrineFixturesBundle();
            $bundles[] = new Doctrine\Bundle\MigrationsBundle\DoctrineMigrationsBundle();
            $bundles[] = new Symfony\Bundle\DebugBundle\DebugBundle();
            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            $bundles[] = new Sensio\Bundle\DistributionBundle\SensioDistributionBundle();
            $bundles[] = new Sensio\Bundle\GeneratorBundle\SensioGeneratorBundle();
        }

        return $bundles;
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load($this-&gt;getRootDir().'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>Now we can write the following <code>bin/build.sh</code> script:</p>

<pre><code>#!/usr/bin/env sh

echo ''
echo '// Building development environment'


rm -rf app/cache/* app/logs/*

composer --quiet --no-interaction install --optimize-autoloader &gt; /dev/null

php app/console --quiet doctrine:database:drop --force &gt; /dev/null 2&gt;&amp;1
php app/console --quiet doctrine:database:create
php app/console --no-interaction --quiet doctrine:migrations:migrate
php app/console --no-interaction --quiet doctrine:fixtures:load --fixtures=src

echo ''
echo ' [OK] Development environment built'
echo ''
</code></pre>

<p>The test steps should be similar, in addition they will run the test suites and
check for coding standards. We can install PHP CS Fixer for this:</p>

<pre><code>composer require --dev fabpot/php-cs-fixer:~1.6
</code></pre>

<p>Here's the <code>bin/test.sh</code> script:</p>

<pre><code>#!/usr/bin/env sh

echo ''
echo '// Building test environment'

rm -rf app/cache/test app/logs/*test.log

composer --quiet --no-interaction install --optimize-autoloader  &gt; /dev/null
php app/console --env=test --quiet cache:clear


php app/console --env=test --no-debug --quiet doctrine:database:drop --force &gt; /dev/null 2&gt;&amp;1
php app/console --env=test --no-debug --quiet doctrine:database:create
php app/console --env=test --no-debug --no-interaction --quiet doctrine:migrations:migrate
php app/console --env=test --no-debug --no-interaction --quiet doctrine:fixtures:load --fixtures=src

echo ''
echo ' [OK] Test environment built'
echo ''

vendor/bin/phpunit -c app &amp;&amp; vendor/bin/phpspec --no-interaction run --format=dot &amp;&amp; vendor/bin/php-cs-fixer fix --dry-run --config=sf23 .
</code></pre>

<p>With this we can start the tickets assigned to us, we can commit the changes:</p>

<pre><code>chmod +x bin/*.sh
git add -A
git commit -m 'Created build and test scripts'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Acme's technology stack is composed of Apache2, PostgreSQL, Symfony, PHPUnit and phpspec.
In order to ake sure that anyone in the team or any new comers can maintain this new
application in the future, we've chosen to stay consistent with the rest.</p>

<p>In the next article, we'll create the search items endpoint in a pragmatic way.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Differently - part 1: Introduction]]></title>
            <link href="/2015/06/03/sf-differently-part-1-introduction.html"/>
            <updated>2015-06-03T00:00:00+01:00</updated>
            <id>/2015/06/03/sf-differently-part-1-introduction.html</id>
            <content type="html"><![CDATA[<p><a href="https://symfony.com">Symfony</a> is an amazing HTTP framework which powers
<a href="http://labs.octivi.com/handling-1-billion-requests-a-week-with-symfony2/">high traffic websites</a>.
Performance shouldn't be a concern when first creating a website, because between
the time it is launched and the time it actually has a high traffic many things
that we didn't expect in the first days will happen:</p>

<ul>
<li>requirements will change</li>
<li>user behavior will change</li>
<li>even the team can change</li>
</ul>

<p>Optimizing applications has an impact over maintenance, and making it harder to change
right from the begining might not be the best option. However when the need of performance
actually arises, we need to tackle it.</p>

<p>This series of articles is about this specific moment, and how to tackle it in a pragmatic way.</p>

<blockquote>
  <p><strong>Spoiler Alert</strong>: It will feature a section where we optimize our application step by step,
  with a monitoring of the impact on performance. We'll see that those don't make a big
  difference, which is why those concerns shouldn't be addressed from day 1.</p>
</blockquote>

<p>First, let's have a look at the big picture. Please note that the approach we use
here is only one amongst many (every need is different, it might not be the best in every situations).</p>

<h2 id="the-project">The project</h2>

<p>For our examples, we'll pretend to be the Acme Company which powers half the planet
in almost every aspect of our lives. Performance isn't just a concern, it has become
a reality.</p>

<blockquote>
  <p><strong>Note</strong>: Those examples are all made up, but they're based on real experience.</p>
</blockquote>

<p>We've analysed our market and we'd like to have the following new feature:</p>

<pre><code>As a customer, I'd like to buy an item
</code></pre>

<p>During a meeting, we've come up with the following example:</p>

<pre><code>Given a "fruit" category
When I pick a "banana"
Then it should be ordered
</code></pre>

<h2 id="the-team">The team</h2>

<p>In the first days of Acme, we only had a few developers which were full stack. It
worked quite well but we've grown so much that we had to recruit more specialized
profiles with a frontend team and an API one: it allowed us to parallelize the work.</p>

<h2 id="the-architecture">The architecture</h2>

<p>Frontend applications that live in the customer's browser have been chosen because:</p>

<ul>
<li>they are extremely responsive</li>
<li>they provide a richer User eXperience</li>
<li>they have a lower server consumption</li>
</ul>

<p>In the early days of Acme there was a single big application, but with the number
of customer growing and asking features specific to their need, it failed us hard
costing us Money, Customers and Developers.
Now each frontend applications talk to a dedicated API.</p>

<p>The dedicated APIs mix and match data coming from another layer of specific APIs.
Those basically provide Create Read Update Delete and Search (CRUDS) access to
their own data storage.</p>

<blockquote>
  <p><strong>Note</strong>: We've decided to have two layers of APIs in order to avoid mixing
  features specific to a customer in an endpoint used by everyone.</p>
</blockquote>

<p>From the Use Stories, we've identified two types of data: <code>item</code> related ones
and <code>order</code> related one.
We've decided to create the following applications:</p>

<ul>
<li><code>acme/order-items-front</code>, the frontend application</li>
<li><code>acme/order-items-api</code> the dedicated API</li>
<li><code>acme/items</code>, an API specific to the <code>item</code> and <code>item_category</code> tables</li>
<li><code>acme/orders</code>, an API specific to the <code>order</code> table</li>
</ul>

<p><img src="http://yuml.me/c0591d90" alt="Diagram" /></p>

<p>In this series, we'll focus on the creation of the Search endpoint in <code>acme/items</code>.</p>

<h2 id="the-task">The task</h2>

<p>The Search endpoint should allow:</p>

<ul>
<li>pagination of items, using <code>page</code> and <code>per_page</code> parameters</li>
<li>filtering of items, using column name with value for parameters</li>
<li>ordering items, using a <code>sort</code> parameter</li>
</ul>

<p>In this series, we'll focus on paginating items.</p>

<p>Here's a valid <code>Request</code> sample:</p>

<pre><code>GET /v1/items?page=2&amp;per_page=1 HTTP/1.1
</code></pre>

<p>It should return a <code>Response</code> similar to:</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/json

{"data":[{"id":42,"name":"banana","category_id":23}],"page":{"current_page":2,"per_page":1,"total_elements":2,"total_pages":2}}
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Our Acme mega corporation needs a new feature and we've decided to implement it
by creating a frontend, its dedicated API which mix and match data coming from two
new specific APIs.</p>

<p>The choice of this architecture has been made because it solved issues encountered
in Acme's past, when we had a single big application.</p>

<p>In the next article we'll bootstrap a Symfony application to create an endpoint to search
for items.</p>

<p>In the mean time if you're interrested in creating APIs in a pragmatic way you can
read <a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">the following article</a>.
If you're wondering why Acme didn't use this approach from the begining you might
want to read <a href="http://martinfowler.com/bliki/MonolithFirst.html">the following article</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 3.3: Consuming, remote calls]]></title>
            <link href="/2015/03/25/sf-ws-part-3-3-consuming-remote.html"/>
            <updated>2015-03-25T00:00:00+00:00</updated>
            <id>/2015/03/25/sf-ws-part-3-3-consuming-remote.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the seventh article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the six first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
<li><a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">2.3 Creation, refactoring</a></li>
<li><a href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html">3.1 Consuming, RequestHandler</a></li>
<li><a href="/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html">3.2 Consuming, Guzzle</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-cs">following repository</a>.</p>

<p>In the previous article, we've created a Guzzle RequestHandler: we are now able
to make remote calls using a third party library, but without the cost of coupling
ourselves to it. If Guzzle 6 is released we'll have to change only one class, instead
of everywhere in our application.</p>

<p>In this article, we'll create the actual remote calls.</p>

<h2 id="credential-configuration">Credential configuration</h2>

<p>The web service we want to call requires us to authenticate. Those credentials
shouldn't be hardcoded, we'll create new parameters for them (same goes for the URL):</p>

<pre><code># File: app/config/parameters.yml.dist
    ws_url: http://example.com
    ws_username: username
    ws_password: ~
</code></pre>

<p>We can then set those values in the actual parameter file:</p>

<pre><code># File: app/config/parameters.yml
    ws_url: "http://ws.local/app_dev.php"
    ws_username: spanish_inquisition
    ws_password: "NobodyExpectsIt!"
</code></pre>

<p>Note that because our password contains a character which is reserved in YAML (<code>!</code>),
we need to put the value between double quotes (same goes for <code>%</code> and <code>@</code>).</p>

<p>Let's commit this:</p>

<pre><code>git add -A
git commit -m 'Added credentials configuration'
</code></pre>

<h2 id="profile-gateway">Profile Gateway</h2>

<p>We can create a <a href="http://martinfowler.com/eaaCatalog/gateway.html">Gateway</a>
specialized in calling the profile web service:</p>

<pre><code>./bin/phpspec describe 'AppBundle\Profile\ProfileGateway'
</code></pre>

<p>Usually we categorize our Symfony applications by Pattern: we'd create a <code>Gateway</code>
directory with all the Gateway service. However this can become quite cubersome
when the application grows, services are usually linked to a model meaning that
we'd have to jump from the <code>Model</code> (or <code>Entity</code>) directory to the <code>Gateway</code> one,
then go to the <code>Factory</code> directory, etc...</p>

<p>Here we've chosen an alternative: group services by model. All <code>Profile</code> services
can be found in the same directory.</p>

<p>Let's write the Gateway's specification:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/Profile/ProfileGatewaySpec.php

namespace spec\AppBundle\Profile;

use AppBundle\RequestHandler\RequestHandler;
use AppBundle\RequestHandler\Response;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class ProfileGatewaySpec extends ObjectBehavior
{
    const URL = 'http://example.com';
    const USERNAME = 'spanish inquisition';
    const PASSWORD = 'nobody expects it';

    const ID = 42;
    const NAME = 'Arthur';

    function let(RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($requestHandler, self::URL, self::USERNAME, self::PASSWORD);
    }

    function it_creates_profiles(RequestHandler $requestHandler, Response $response)
    {
        $profile = array(
            'id' =&gt; self::ID,
            'name' =&gt; self::NAME,
        );

        $request = Argument::type('AppBundle\RequestHandler\Request');
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $response-&gt;getBody()-&gt;willReturn($profile);

        $this-&gt;create(self::NAME)-&gt;shouldBe($profile);
    }
}
</code></pre>

<p>We can now generate the code's skeleton:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>It constructs a <code>Request</code> object, gives it to <code>RequestHandler</code> and then returns the
<code>Response</code>'s body:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Profile/ProfileGateway.php

namespace AppBundle\Profile;

use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;

class ProfileGateway
{
    private $requestHandler;
    private $url;
    private $username;
    private $password;

    public function __construct(RequestHandler $requestHandler, $url, $username, $password)
    {
        $this-&gt;requestHandler = $requestHandler;
        $this-&gt;username = $username;
        $this-&gt;password = $password;
    }

    public function create($name)
    {
        $request = new Request('POST', $this-&gt;url.'/api/v1/profiles');
        $request-&gt;setHeader('Authorization', 'Basic '.base64_encode($this-&gt;username.':'.$this-&gt;password));
        $request-&gt;setHeader('Content-Type', 'application/json');
        $request-&gt;setBody(json_encode(array('name' =&gt; $name)));

        $response = $this-&gt;requestHandler-&gt;handle($request);

        return $response-&gt;getBody();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Managing URLs can become quite tricky when the number of routes grows.
  Sometimes we'll want HTTPS, sometimes HTTP. Sometimes we'll want the first version
  of the API, sometimes the pre production one. And what should we do when we'll
  need query parameters?</p>
  
  <p>Usually I don't bother with those until the need is actually there, then I create
  a <code>UrlGenerator</code> which works a bit like Symfony's one and relies on a configuration array.</p>
</blockquote>

<p>Let's check our tests:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green!</p>

<pre><code>git add -A
git commit -m 'Created ProfileGateway'
</code></pre>

<h2 id="create-profile-command">Create Profile Command</h2>

<p>Our application happens to be a Command Line Interface (CLI). We want to write a
command to create profiles, and as usual we'll begin with a test:</p>

<pre><code class="php">&lt;?php
// File: tests/Command/CreateProfileCommandTest.php

namespace AppBundle\Tests\Command;

use PHPUnit_Framework_TestCase;
use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Output\NullOutput;
use Symfony\Component\Console\Input\ArrayInput;

class CreateProfileCommandTest extends PHPUnit_Framework_TestCase
{
    private $app;
    private $output;

    protected function setUp()
    {
        $kernel = new \AppKernel('test', false);
        $this-&gt;app = new Application($kernel);
        $this-&gt;app-&gt;setAutoExit(false);
        $this-&gt;output = new NullOutput();
    }

    public function testItRunsSuccessfully()
    {
        $input = new ArrayInput(array(
            'commandName' =&gt; 'app:profile:create',
            'name' =&gt; 'Igor',
        ));

        $exitCode = $this-&gt;app-&gt;run($input, $this-&gt;output);

        $this-&gt;assertSame(0, $exitCode);
    }
}
</code></pre>

<p>Let's make this test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Command/CreateProfileCommand.php

namespace AppBundle\Command;

use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class CreateProfileCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this-&gt;setName('app:profile:create');
        $this-&gt;setDescription('Create a new profile');

        $this-&gt;addArgument('name', InputArgument::REQUIRED);
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $profileGateway = $this-&gt;getContainer()-&gt;get('app.profile_gateway');

        $profile = $profileGateway-&gt;create($input-&gt;getArgument('name'));

        $output-&gt;writeln(sprintf('Profile #%s "%s" created', $profile['id'], $profile['name']));
    }
}
</code></pre>

<p>We'll need to define <code>ProfileGateway</code> as a service:</p>

<pre><code># File: app/config/services.yml
imports:
    - { resource: services/request_handler.yml }

services:
    app.profile_gateway:
        class: AppBundle\Profile\ProfileGateway
        arguments:
            - "@app.request_handler"
            - "%ws_url%"
            - "%ws_username%"
            - "%ws_password%"
</code></pre>

<p>By having a look <code>ProfileGateway</code> we can spot a mistake, the initialization or URL
is missing from the constructor:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Profile/ProfileGateway.php

    public function __construct(RequestHandler $requestHandler, $url, $username, $password)
    {
        $this-&gt;requestHandler = $requestHandler;
        $this-&gt;username = $username;
        $this-&gt;password = $password;
        $this-&gt;url = $url;
    }
</code></pre>

<p>Another mistake lies in <code>JsonResponseListener</code>, each Guzzle header is an array:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Listener/JsonResponseListener.php

        $contentType = $response-&gt;getHeader('Content-Type');
        if (false === strpos($contentType[0], 'application/json')) {
            return;
        }
</code></pre>

<p>With these fixes, the test should pass:</p>

<pre><code>phpunit -c app
</code></pre>

<blockquote>
  <p><strong>Note</strong>: if we get a <code>You have requested a non-existent service "app.profile_gateway"</code>
  error, we might need to clear the cache for test environment: <code>php app/console cache:clear --env=test</code>.</p>
  
  <p><strong>Note</strong>: if we get a Guzzle exception, we need to check that the previous application installed
  ("ws.local"), and that its database is created:</p>

<pre><code>cd ../ws
php app/console doctrine:database:create
php app/console doctrine:schema:create
cd ../cs
</code></pre>
</blockquote>

<p>We can now save our work:</p>

<pre><code>git add -A
git commit -m 'Created CreateProfileCommand'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We have now an application that consumes a web service. We have decoupled it from
third party libraries using RequestHandler and isolated the endpoint logic in a
Gateway class.</p>

<p>There's a lot to say about the test we wrote: it makes a network call which is slow, unreliable
and it isn't immutable. If we try to run again our test, it will fail!
To fix this we have many possibilities:</p>

<ul>
<li>mock the endpoints, it will make the tests faster and immutable but if the endpoints change our tests will still pass</li>
<li>cleanup the created profile by aking another network call, it will make the test even slower</li>
</ul>

<p>At this point it depends on how confident we are in the web services and what we want to test.</p>

<p>We should also write more test on edge cases: what happens with the wrong credentials?
What happens if the endpoints cannot be reached (request timeout, connection timeout, etc)?
What happens when we try to create a profile which already exists?</p>

<p>As it happens, this is also the conclusion of this series on managing Web Services in a
Symfony environment. There's a lot more to say for example about caching remote resources
in a local database, about self discovering APIs and about micro services, but I feel
those should each have their own series of article :) .</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 3.2: Consuming, Guzzle]]></title>
            <link href="/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html"/>
            <updated>2015-03-18T00:00:00+00:00</updated>
            <id>/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the sixth article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the five first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
<li><a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">2.3 Creation, refactoring</a></li>
<li><a href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html">3.1 Consuming, RequestHandler</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-cs">following repository</a>.</p>

<p>In the previous article, we've bootstrapped an application with a RequestHandler,
allowing us to be decoupled from the third part library we'll choose to request
remote endpoints.</p>

<p>In this article, we'll create a Guzzle 5 implementation.</p>

<h2 id="guzzle-request-handler">Guzzle Request Handler</h2>

<p>As usual, we first describe the class we want to create:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Middleware\GuzzleRequestHandler'
</code></pre>

<p>Our Guzzle implementation will translate our <code>Request</code> into a guzzle one, and a
guzzle response into our <code>Response</code>:</p>

<pre><code class="php">&lt;?php
// spec/AppBundle/RequestHandler/Middleware/GuzzleRequestHandlerSpec.php

namespace spec\AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Request;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Message\RequestInterface;
use GuzzleHttp\Message\ResponseInterface;
use GuzzleHttp\Stream\StreamInterface;
use PhpSpec\ObjectBehavior;

class GuzzleRequestHandlerSpec extends ObjectBehavior
{
    const VERB = 'POST';
    const URI = '/api/v1/profiles';

    const HEADER_NAME = 'Content-Type';
    const HEADER_VALUE = 'application/json';

    const BODY = '{"username":"King Arthur"}';

    function let(ClientInterface $client)
    {
        $this-&gt;beConstructedWith($client);
    }

    function it_is_a_request_handler()
    {
        $this-&gt;shouldImplement('AppBundle\RequestHandler\RequestHandler');
    }

    function it_uses_guzzle_to_do_the_actual_request(
        ClientInterface $client,
        RequestInterface $guzzleRequest,
        ResponseInterface $guzzleResponse,
        StreamInterface $stream
    )
    {
        $request = new Request(self::VERB, self::URI);
        $request-&gt;setHeader(self::HEADER_NAME, self::HEADER_VALUE);
        $request-&gt;setBody(self::BODY);

        $client-&gt;createRequest(self::VERB, self::URI, array(
            'headers' =&gt; array(self::HEADER_NAME =&gt; self::HEADER_VALUE),
            'body' =&gt; self::BODY,
        ))-&gt;willReturn($guzzleRequest);
        $client-&gt;send($guzzleRequest)-&gt;willReturn($guzzleResponse);
        $guzzleResponse-&gt;getStatusCode()-&gt;willReturn(201);
        $guzzleResponse-&gt;getHeaders()-&gt;willReturn(array('Content-Type' =&gt; 'application/json'));
        $guzzleResponse-&gt;getBody()-&gt;willReturn($stream);
        $stream-&gt;__toString()-&gt;willReturn('{"id":42,"username":"King Arthur"}');

        $this-&gt;handle($request)-&gt;shouldHaveType('AppBundle\RequestHandler\Response');
    }
}
</code></pre>

<p>Time to boostrap this implementation:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And to actually write it:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Middleware/GuzzleRequestHandler.php

namespace AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;
use AppBundle\RequestHandler\Response;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Message\RequestInterface;
use GuzzleHttp\Message\ResponseInterface;
use GuzzleHttp\Stream\StreamInterface;

class GuzzleRequestHandler implements RequestHandler
{
    private $client;

    public function __construct(ClientInterface $client)
    {
        $this-&gt;client = $client;
    }

    public function handle(Request $request)
    {
        $guzzleRequest = $this-&gt;client-&gt;createRequest($request-&gt;getVerb(), $request-&gt;getUri(), array(
            'headers' =&gt; $request-&gt;getHeaders(),
            'body' =&gt; $request-&gt;getBody(),
        ));
        $guzzleResponse = $this-&gt;client-&gt;send($guzzleRequest);
        $response = new Response($guzzleResponse-&gt;getStatusCode());
        $response-&gt;setHeaders($guzzleResponse-&gt;getHeaders());
        $response-&gt;setBody($guzzleResponse-&gt;getBody()-&gt;__toString());

        return $response;
    }
}
</code></pre>

<p>Let's check it:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Brilliant!</p>

<pre><code>git add -A
git commit -m 'Created GuzzleRequestHandler'
</code></pre>

<h2 id="event-middleware">Event Middleware</h2>

<p>In the future we'd like to be able to hook in the <code>RequestHandler</code>'s workflow,
for example if the Response's body is in JSON, convert it into an array.</p>

<p>This kind of thing can be done by sending events, in our case when a Response is received:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/ReceivedResponse.php

namespace AppBundle\RequestHandler\Event;

use AppBundle\RequestHandler\Response;
use Symfony\Component\EventDispatcher\Event;

class ReceivedResponse extends Event
{
    private $response;

    public function __construct(Response $response)
    {
        $this-&gt;response = $response;
    }

    public function getResponse()
    {
        return $this-&gt;response;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: This is a simple Data Transfer Object (DTO), it doesn't contain any
  logic and never will. This means that we don't have to write any tests for it.</p>
</blockquote>

<p>We could add an <code>EventDispatcher</code> in <code>GuzzleRequestHandler</code>, or we could create
a middleware: a RequestHandler that dispatches events and then calls another RequestHandler
(e.g. <code>GuzzleRequestHandler</code>):</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Middleware\EventRequestHandler'
</code></pre>

<p>This way if we want to throw away <code>GuzzleRequestHandler</code> and replace it with something
else, we don't have to write again the dispatching code. Here's the specification:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/RequestHandler/Middleware/EventRequestHandlerSpec.php

namespace spec\AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;
use AppBundle\RequestHandler\Response;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;

class EventRequestHandlerSpec extends ObjectBehavior
{
    function let(EventDispatcherInterface $eventDispatcher, RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($eventDispatcher, $requestHandler);
    }

    function it_is_a_request_handler()
    {
        $this-&gt;shouldImplement('AppBundle\RequestHandler\RequestHandler');
    }

    function it_dispatches_events(
        EventDispatcherInterface $eventDispatcher,
        Request $request,
        RequestHandler $requestHandler,
        Response $response
    )
    {
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $receivedResponse = Argument::type('AppBundle\RequestHandler\Event\ReceivedResponse');
        $eventDispatcher-&gt;dispatch('request_handler.received_response', $receivedResponse)-&gt;shouldBeCalled();

        $this-&gt;handle($request)-&gt;shouldBe($response);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We could improve this middleware by dispatching an event before giving
  the request to the RequestHandler. We could also catch exceptions coming from
  the RequestHandler and dispatch an event.</p>
</blockquote>

<p>Time to bootstrap the code:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And to make the test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Middleware/EventRequestHandler.php

namespace AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Event\ReceivedResponse;
use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;

class EventRequestHandler implements RequestHandler
{
    private $eventDispatcher;
    private $requestHandler;

    public function __construct(EventDispatcherInterface $eventDispatcher, RequestHandler $requestHandler)
    {
        $this-&gt;eventDispatcher = $eventDispatcher;
        $this-&gt;requestHandler = $requestHandler;
    }

    public function handle(Request $request)
    {
        $response = $this-&gt;requestHandler-&gt;handle($request);
        $this-&gt;eventDispatcher-&gt;dispatch('request_handler.received_response', new ReceivedResponse($response));

        return $response;
    }
}
</code></pre>

<p>Did we succeed?</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Yes, we did:</p>

<pre><code>git add -A
git commit -m 'Created EventRequestHandler'
</code></pre>

<h2 id="json-response-listener">Json Response Listener</h2>

<p>When a Response contains a JSON body, we need to:</p>

<ul>
<li>check the content type</li>
<li>decode the body</li>
<li>check that the JSON syntax is valid</li>
</ul>

<p>With this in mind, we can describe the listerner:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Listener\JsonResponseListener'
</code></pre>

<p>Now we can write the specification:</p>

<pre><code class="php">&lt;?php
// src: spec/AppBundle/RequestHandler/Listener/JsonResponseListenerSpec.php

namespace spec\AppBundle\RequestHandler\Listener;

use AppBundle\RequestHandler\Event\ReceivedResponse;
use AppBundle\RequestHandler\Response;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class JsonResponseListenerSpec extends ObjectBehavior
{
    function it_handles_json_response(ReceivedResponse $receivedResponse, Response $response)
    {
        $receivedResponse-&gt;getResponse()-&gt;willReturn($response);
        $response-&gt;getHeader('Content-Type')-&gt;willReturn('application/json');
        $response-&gt;getBody()-&gt;willReturn('{"data":[]}');
        $response-&gt;setBody(array('data' =&gt; array()))-&gt;shouldBeCalled();

        $this-&gt;onReceivedResponse($receivedResponse);
    }

    function it_does_not_handle_non_json_response(ReceivedResponse $receivedResponse, Response $response)
    {
        $receivedResponse-&gt;getResponse()-&gt;willReturn($response);
        $response-&gt;getHeader('Content-Type')-&gt;willReturn('text/html');
        $response-&gt;getBody()-&gt;shouldNotBeCalled();

        $this-&gt;onReceivedResponse($receivedResponse);
    }

    function it_fails_to_handle_invalid_json(ReceivedResponse $receivedResponse, Response $response)
    {
        $receivedResponse-&gt;getResponse()-&gt;willReturn($response);
        $response-&gt;getHeader('Content-Type')-&gt;willReturn('application/json');
        $response-&gt;getBody()-&gt;willReturn('{"data":[');

        $exception = 'Exception';
        $this-&gt;shouldThrow($exception)-&gt;duringOnReceivedResponse($receivedResponse);
    }
}
</code></pre>

<p>Time to implement the code:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Listener/JsonResponseListener.php

namespace AppBundle\RequestHandler\Listener;

use AppBundle\RequestHandler\Event\ReceivedResponse;
use Exception;

class JsonResponseListener
{
    public function onReceivedResponse(ReceivedResponse $receivedResponse)
    {
        $response = $receivedResponse-&gt;getResponse();
        $contentType = $response-&gt;getHeader('Content-Type');
        if (false === strpos($response-&gt;getHeader('Content-Type'), 'application/json')) {
            return;
        }
        $body = $response-&gt;getBody();
        $json = json_decode($body, true);
        if (json_last_error()) {
            throw new Exception("Invalid JSON: $body");
        }
        $response-&gt;setBody($json);
    }
}
</code></pre>

<p>Is it enough to make the tests pass?</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Yes, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created JsonResponseListener'
</code></pre>

<h2 id="creating-services">Creating services</h2>

<p>In order to be able to use this code in our Symfony application, we need to
define those classes as services. Since we'll have a lot of definitions, we'll
create a <code>services</code> directory:</p>

<pre><code>mkdir app/config/services
</code></pre>

<p>We'll update <code>services.yml</code> to include our new file:</p>

<pre><code># File: app/config/services.yml
imports:
    - { resource: services/request_handler.yml }
</code></pre>

<p>And finally we'll create the <code>request_handler.yml</code> file:</p>

<pre><code>touch app/config/services/request_handler.yml
</code></pre>

<p>The first service we'll define is Guzzle:</p>

<pre><code>#file: app/config/services/request_handler.yml
services:
    guzzle.client:
        class: GuzzleHttp\Client
</code></pre>

<p>This allows us to define the GuzzleRequestHandler:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.guzzle_request_handler:
        class: AppBundle\RequestHandler\Middleware\GuzzleRequestHandler
        arguments:
            - "@guzzle.client"
</code></pre>

<p>We want to wrap each of these GuzzleRequestHandler calls with events, so we define
EventRequestHandler like this:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.event_request_handler:
        class: AppBundle\RequestHandler\Middleware\EventRequestHandler
        arguments:
            - "@event_dispatcher"
            - "@app.guzzle_request_handler"
</code></pre>

<p>In the future we might add more middlewares (e.g. RetryRequestHandler, StopwatchRequestHandler, etc),
so we want to avoid using a service that points directly to an implementation. We
can define an alias:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.request_handler:
        alias: app.event_request_handler
</code></pre>

<p>Finally, we want to define our listener:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.request_handler.json_response_listener:
        class: AppBundle\RequestHandler\Listener\JsonResponseListener
        tags:
            - { name: kernel.event_listener, event: request_handler.received_response, method: onReceivedResponse }
</code></pre>

<p>And that's it!</p>

<pre><code>git add -A
git commit -m 'Defined RequestHandler as a service'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We can now send remote request using Guzzle, without coupling ourself to the library.
We even implemented an EventRequestHandler to allow extension points, it also provides
us an example on how to write more RequestHandler middlewares.</p>

<p>In the next article we'll start using RequestHandler in a specific kind of service:
Gateways.</p>

<h3 id="http-adapter">HTTP Adapter</h3>

<p>You might be interested in <a href="https://github.com/egeloen/ivory-http-adapter">Ivory HttpAdapter</a>,
a library very similar to our RequestHandler: it sends remote request through a
given client (it supports many of them). It also provides events to hook into its workflow!</p>

<p>Personnaly, I'd rather create my own RequestHandler, as my purpose is to decouple
the application from an external library like Guzzle: using a third party library
to do so seems a bit ironic.
As you can see there's little effort involved, and it has the advantage of providing
the strict minimum the application needs.</p>

<h3 id="psr-7">PSR-7</h3>

<p><a href="https://github.com/php-fig/fig-standards/blob/master/proposed/http-message.md">PSR-7</a>
is a standard currently under review: it defines how frameworks should ideally
implement the HTTP protocole.</p>

<p>Since it's not yet accepted, it is subject to change so I wouldn't recommend to follow it yet.
Our RequestHandler kind of implement the HTTP protocole, but I'd rather not make
it PSR-7 compliant, as it requires the implementation of many features we don't
really need.</p>

<p>To get a balanced opinion on the matter, I'd recommend you to read:</p>

<ul>
<li><a href="https://mwop.net/blog/2015-01-26-psr-7-by-example.html">PSR-7 By Example</a></li>
<li><a href="http://evertpot.com/psr-7-issues/">PSR-7 is imminent, and here's my issues with it.</a></li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 3.1: Consuming, RequestHandler]]></title>
            <link href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html"/>
            <updated>2015-03-11T00:00:00+00:00</updated>
            <id>/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fifth article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the four first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
<li><a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">2.3 Creation, refactoring</a></li>
</ul>

<p>Our purpose in this third section is to create an application that consumes the
<a href="https://github.com/gnugat-examples/sf-ws">previously created web services</a>.</p>

<p>But for now, we'll just bootstrap it, and start to create a RequestHandler!</p>

<h2 id="installation">Installation</h2>

<p>We will follow the exact same steps as in <a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">the chapter 2.1</a>:</p>

<ol>
<li>Installing the standard edition</li>
<li>Twitching for tests</li>
</ol>

<p>Instead of calling our application <code>ws</code>, we'll call it <code>cs</code> (like Consuming Service).</p>

<h2 id="making-remote-calls-with-guzzle">Making remote calls with Guzzle</h2>

<p>Is the application boostrapped yet? If it is, then we can continue.</p>

<p>In order to consume web services, we need to be able to make remote requests. PHP
provides some native functions for this (<code>file_get_contents</code>, <code>stream_socket_client</code>,
<code>fopen</code>, etc) and we can find many libraries as well (<a href="https://github.com/kriswallsmith/Buzz">Buzz</a>,
<a href="http://phphttpclient.com/">HTTP Full</a>, <a href="http://reactphp.org/">React</a>, etc).</p>

<p>For this series, we'll use <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>:</p>

<pre><code>composer require guzzlehttp/guzzle:~5.0
</code></pre>

<p>Let's commit it for now:</p>

<pre><code>git add -A
git commit -m 'Installed Guzzle'
</code></pre>

<h2 id="creating-a-request-handler">Creating a Request Handler</h2>

<p>Sometimes we need to decouple our application from the third party libraries it depends on.</p>

<p>For example let's say that we were using Guzzle 4, but we'd like to use Amazon Web Service (AWS)
S3 in our project. The issue? It's version 2 depends on Guzzle 3 and its version 3
depends on Guzzle 5. We now need to upgrade our usage of Guzzle everywhere in our
application.</p>

<p><a href="http://knowyourmeme.com/photos/141710-true-story"><img src="http://i0.kym-cdn.com/photos/images/newsfeed/000/141/710/7nTnr.png?1309357850" alt="True story" /></a></p>

<p>To minimize this, we can centralize the usage of Guzzle in one single file. In order
to be able to do so, we'll create a RequestHandler:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/RequestHandler.php

namespace AppBundle\RequestHandler;

interface RequestHandler
{
    // @return Response
    public function handle(Request $request);
}
</code></pre>

<p>In our application we can rely on this interface: we own it and it has few chances to change.
We'll now create an object that describes the request to send:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Request'
</code></pre>

<p>A minimalistic raw HTTP request looks like the following:</p>

<pre><code>GET /api/v1/profiles HTTP/1.1
</code></pre>

<p>Since we don't really care about the protocol's version we can define the constructor
with two arguments:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/RequestSpec.php

    function it_has_a_verb_and_an_uri()
    {
        $this-&gt;beConstructedWith('GET', '/api/v1/profiles');

        $this-&gt;getVerb()-&gt;shouldBe('GET');
        $this-&gt;getUri()-&gt;shouldBe('/api/v1/profiles');
    }
</code></pre>

<p>Running the specifications will bootstrap the class for us:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>We can now make the test pass by writing the code:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Request.php

namespace AppBundle\RequestHandler;

class Request
{
    private $verb;
    private $uri;

    public function __construct($verb, $uri)
    {
        $this-&gt;verb = $verb;
        $this-&gt;uri = $uri;
    }

    public function getVerb()
    {
        return $this-&gt;verb;
    }

    public function getUri()
    {
        return $this-&gt;uri;
    }
}
</code></pre>

<p>Let's check if it's enough for now:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created Request'
</code></pre>

<h2 id="request-headers">Request headers</h2>

<p>A request usually has headers:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/RequestSpec.php

    function it_can_have_headers()
    {
        $this-&gt;beConstructedWith('GET', '/api/v1/profiles');
        $this-&gt;setHeader('Content-Type', 'application/json');

        $this-&gt;getHeaders()-&gt;shouldBe(array('Content-Type' =&gt; 'application/json'));
    }
</code></pre>

<p>Let's boostrap them:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And complete the code:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Request.php

    private $headers = array();

    public function setHeader($name, $value)
    {
        $this-&gt;headers[$name] = $value;
    }

    public function getHeaders()
    {
        return $this-&gt;headers;
    }
</code></pre>

<p>This makes the test pass:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>That's worth a commit:</p>

<pre><code>git add -A
git commit -m 'Added headers to Request'
</code></pre>

<h2 id="request-body">Request body</h2>

<p>The last addition to our request will be the possibility to add a body:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/RequestSpec.php

    function it_can_have_a_body()
    {
        $this-&gt;beConstructedWith('GET', '/api/v1/profiles');
        $this-&gt;setBody('{"wound":"just a flesh one"}');

        $this-&gt;getBody()-&gt;shouldBe('{"wound":"just a flesh one"}');
    }
</code></pre>

<p>As usual we bootstrap it:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And then we complete it:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Request.php

    private $body;

    public function setBody($body)
    {
        $this-&gt;body = $body;
    }

    public function getBody()
    {
        return $this-&gt;body;
    }
</code></pre>

<p>Let's make our console green:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Let's make our console grin:</p>

<pre><code>git add -A
git commit -m 'Added body to Request'
</code></pre>

<h2 id="creating-a-response">Creating a Response</h2>

<p><code>RequestHandler</code> should return a <code>Response</code> object:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Response'
</code></pre>

<p>A minimalistic raw HTTP response looks like the following:</p>

<pre><code>HTTP/1.1 204 NO CONTENT
</code></pre>

<p>Since we don't care about both the protocol's version and the reason, we can
define the constructor with a single argument:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/ResponseSpec.php

    function it_has_a_status_code()
    {
        $this-&gt;beConstructedWith(204);

        $this-&gt;getStatusCode()-&gt;shouldBe(204);
    }
</code></pre>

<p>Running the specifications will bootstrap the class for us:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>We can now make the test pass by writing the code:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Response.php

namespace AppBundle\RequestHandler;

class Response
{
    private $statusCode;

    public function __construct($statusCode)
    {
        $this-&gt;statusCode = $statusCode;
    }

    public function getStatusCode()
    {
        return $this-&gt;statusCode;
    }
}
</code></pre>

<p>Let's check if it's enough for now:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created Response'
</code></pre>

<h2 id="response-headers">Response headers</h2>

<p>A response can also have headers:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/ResponseSpec.php

    function it_can_have_headers()
    {
        $this-&gt;beConstructedWith(204);
        $this-&gt;setHeaders(array('Content-Type' =&gt; 'application/json'));

        $this-&gt;getHeader('Content-Type')-&gt;shouldBe('application/json');
    }
</code></pre>

<p>Let's boostrap them:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And complete the code:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Response.php

    private $headers = array();

    public function setHeaders(array $headers)
    {
        $this-&gt;headers = $headers;
    }

    public function getHeader($name)
    {
        return (isset($this-&gt;headers[$name]) ? $this-&gt;headers[$name] : null);
    }
</code></pre>

<p>This makes the test pass:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>That's worth a commit:</p>

<pre><code>git add -A
git commit -m 'Added headers to Response'
</code></pre>

<h2 id="response-body">Response body</h2>

<p>Last but not least, the response's body:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/ResponseSpec.php

    function it_can_have_a_body()
    {
        $this-&gt;beConstructedWith(200);
        $this-&gt;setBody('{"wound":"just a flesh one"}');

        $this-&gt;getBody()-&gt;shouldBe('{"wound":"just a flesh one"}');
    }
</code></pre>

<p>As usual we bootstrap it:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And then we complete it:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Response.php

    private $body;

    public function setBody($body)
    {
        $this-&gt;body = $body;
    }

    public function getBody()
    {
        return $this-&gt;body;
    }
</code></pre>

<p>Let's make our console green:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Let's make our console grin:</p>

<pre><code>git add -A
git commit -m 'Added body to Response'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We've bootstrapped an application, and created a RequestHandler which will help us
to avoid coupling with Guzzle. In the <a href="/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html">next article</a>,
we'll talk about middleware and start to create some RequestHandler
implementations (yes, more than one!).</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 2.3: Creation, refactoring]]></title>
            <link href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html"/>
            <updated>2015-03-04T00:00:00+00:00</updated>
            <id>/2015/03/04/sf-ws-part-2-3-creation-refactoring.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fourth article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the three first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-ws">following repository</a>.</p>

<p>In the previous post we've created a first endpoint by taking a few shortcuts.
As we wouldn't want to get technical debt, we're going to refactor it.</p>

<h2 id="the-controller-responsibility">The controller responsibility</h2>

<p>In order to <a href="https://speakerdeck.com/richardmiller/avoiding-the-mud">avoid the mud</a>,
we need to remove the logic from the controller. But which logic?</p>

<p>In <a href="https://symfony.com">Symfony</a>, controllers receive a Request and return a Response
(this follows the HTTP protocol). It is also the glue between the framework and our application.</p>

<p>From this we can assume that its responsibility is to:</p>

<ol>
<li>extract the parameters from the Request</li>
<li>give it to our application</li>
<li>get a result and build the Response with it</li>
</ol>

<p>The request's parameters could be legion, we woudln't like to have a method with too many arguments.
A way to solve this would be to create a Data Transfer Object (DTO): we would put all those parameters
in it and give it to the appropriate service.</p>

<h2 id="command-bus">Command Bus</h2>

<p>The Command Bus pattern is very fitting for this purpose: the DTO is called a Command, its name should
communicate our intention (in our example <code>CreateProfile</code>). It also has the responsibility of
validating user's input (for example converting IDs into integers).</p>

<p>Each Command is associated to only one CommandHandler service which do the actual logic.</p>

<p>Finally, there's the CommandBus: it finds the appropriate CommandHandler for the given Command
and executes it. It also executes some routines before and after the call (for example we can flush doctrine
after each commands).</p>

<blockquote>
  <p><strong>Note</strong>: CommandHandlers don't return anything.</p>
</blockquote>

<p>If you want to find out more on the Command Bus pattern, I'd recommend you to
have a look at this series by Matthias Noback:</p>

<ol>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/a-wave-of-command-buses/">a wave of command buses</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/responsibilities-of-the-command-bus/">responsibilities of the command bus</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/from-commands-to-events/">from commands to events</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/some-questions-about-the-command-bus/">some questions about the command bus</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/collecting-events-and-the-events-aware-command-bus/">collectiong events and the event dispatching comand bus</a></li>
</ol>

<p>Since commands are all about sending a message, you can also read Mathias Verraes article on
<a href="http://verraes.net/2015/01/messaging-flavours">Messaging flavours</a>. He also wrote a nice
article on <a href="http://verraes.net/2015/02/form-command-model-validation/">Form, Command and Model validation</a>.</p>

<h2 id="simplebus">SimpleBus</h2>

<p><a href="http://simplebus.github.io/MessageBus">SimpleBus</a> is a small library that fits our purpose:</p>

<pre><code>composer require simple-bus/doctrine-orm-bridge
composer require simple-bus/symfony-bridge
</code></pre>

<blockquote>
  <p><strong>Note</strong>: It requires at least PHP 5.4.</p>
</blockquote>

<p>You need to register the bundle in our application's kernel:</p>

<pre><code class="php">&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
            new SimpleBus\SymfonyBridge\SimpleBusCommandBusBundle(),
            new SimpleBus\SymfonyBridge\SimpleBusEventBusBundle(),
            new SimpleBus\SymfonyBridge\DoctrineOrmBridgeBundle(),
            new AppBundle\AppBundle(),
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            $bundles[] = new Symfony\Bundle\DebugBundle\DebugBundle();
            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            $bundles[] = new Sensio\Bundle\DistributionBundle\SensioDistributionBundle();
            $bundles[] = new Sensio\Bundle\GeneratorBundle\SensioGeneratorBundle();
        }

        return $bundles;
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>Let's commit this installation:</p>

<pre><code>git add -A
git commit -m 'Installed SimpleBus'
</code></pre>

<h2 id="create-profile">Create Profile</h2>

<p>We didn't create a <code>ProfileRepository</code> earlier, but we're going to need it now:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Entity/ProfileRepository.php

namespace AppBundle\Entity;

use Doctrine\ORM\EntityRepository;

class ProfileRepository extends EntityRepository
{
}
</code></pre>

<p>We should name the Command after the action we want to do. In our case we want
to create a profile:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle\CommandBus/CreateProfile.php

namespace AppBundle\CommandBus;

use SimpleBus\Message\Message;

class CreateProfile implements Message
{
    public $name;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }
}
</code></pre>

<p>We then need a CommandHandler to do the actual creation. Since there will be some logic,
let's create a specification:</p>

<pre><code>./bin/phpspec describe 'AppBundle\CommandBus\CreateProfileHandler'
</code></pre>

<p>And now we can describe it:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/CommandBus/CreateProfileHandlerSpec.php

namespace spec\AppBundle\CommandBus;

use AppBundle\CommandBus\CreateProfile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class CreateProfileHandlerSpec extends ObjectBehavior
{
    const NAME = 'John Cleese';

    function let(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;beConstructedWith($objectManager, $profileRepository);
    }

    function it_creates_a_profile(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $profileRepository-&gt;findOneBy(array('name' =&gt; self::NAME))-&gt;willReturn(null);
        $createdProfile = Argument::type('AppBundle\Entity\Profile');
        $objectManager-&gt;persist($createdProfile)-&gt;shouldBeCalled();

        $this-&gt;handle(new CreateProfile(self::NAME));
    }
}
</code></pre>

<p>This allows us to generate the code's skeleton:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And to finally write the code to make the test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/CommandBus/CreateProfileHandler.php

namespace AppBundle\CommandBus;

use AppBundle\Entity\Profile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use SimpleBus\Message\Handler\MessageHandler;
use SimpleBus\Message\Message;

class CreateProfileHandler implements MessageHandler
{
    private $objectManager;
    private $profileRepository;

    public function __construct(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;objectManager = $objectManager;
        $this-&gt;profileRepository = $profileRepository;
    }

    public function handle(Message $message)
    {
        $profile = $this-&gt;profileRepository-&gt;findOneBy(array('name' =&gt; $message-&gt;name));
        $newProfile = new Profile($message-&gt;name);
        $this-&gt;objectManager-&gt;persist($newProfile);
    }
}
</code></pre>

<p>Let's check the tests:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created CreateProfileHandler'
</code></pre>

<h2 id="name-duplication">Name duplication</h2>

<p>Domain validation (e.g. name duplication check) should be handled by the CommandHandler
(previously it was done in the controller):</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/CommandBus/CreateProfileHandlerSpec.php

namespace spec\AppBundle\CommandBus;

use AppBundle\CommandBus\CreateProfile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class CreateProfileHandlerSpec extends ObjectBehavior
{
    const NAME = 'John Cleese';

    function let(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;beConstructedWith($objectManager, $profileRepository);
    }

    function it_creates_a_profile(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $profileRepository-&gt;findOneBy(array('name' =&gt; self::NAME))-&gt;willReturn(null);
        $createdProfile = Argument::type('AppBundle\Entity\Profile');
        $objectManager-&gt;persist($createdProfile)-&gt;shouldBeCalled();

        $this-&gt;handle(new CreateProfile(self::NAME));
    }

    function it_cannot_create_the_profile_if_the_name_has_already_been_registered(ProfileRepository $profileRepository)
    {
        $profile = Argument::type('AppBundle\Entity\Profile');
        $profileRepository-&gt;findOneBy(array('name' =&gt; self::NAME))-&gt;willReturn($profile);

        $domainException = '\DomainException';
        $this-&gt;shouldThrow($domainException)-&gt;duringHandle(new CreateProfile(self::NAME));
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We try to be as descriptive as necessary in the test methods (a bad example
  would have been <code>testThrowsDomainException</code>).</p>
</blockquote>

<p>Here's the code to make the test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/CommandBus/CreateProfileHandler.php

namespace AppBundle\CommandBus;

use AppBundle\Entity\Profile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use SimpleBus\Message\Handler\MessageHandler;
use SimpleBus\Message\Message;

class CreateProfileHandler implements MessageHandler
{
    private $objectManager;
    private $profileRepository;

    public function __construct(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;objectManager = $objectManager;
        $this-&gt;profileRepository = $profileRepository;
    }

    public function handle(Message $message)
    {
        $profile = $this-&gt;profileRepository-&gt;findOneBy(array('name' =&gt; $message-&gt;name));
        if (null !== $profile) {
            throw new \DomainException(sprintf('The name "%s" is already taken', $message-&gt;name));
        }
        $newProfile = new Profile($message-&gt;name);
        $this-&gt;objectManager-&gt;persist($newProfile);
    }
}
</code></pre>

<p>Let's check the tests:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>They pass!</p>

<pre><code>git add -A
git commit -m 'Added check on name duplication'
</code></pre>

<h2 id="input-validation">Input validation</h2>

<p>Input validation (e.g. presence of name parameter) should be done in the Command
(previously it was done in the controller):</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle\CommandBus/CreateProfile.php

namespace AppBundle\CommandBus;

use SimpleBus\Message\Message;

class CreateProfile implements Message
{
    public $name;

    public function __construct($name)
    {
        if (null === $name) {
            throw new \DomainException('The "name" parameter is missing from the request\'s body');
        }
        $this-&gt;name = $name;
    }
}
</code></pre>

<p>Let's commit it:</p>

<pre><code>git add -A
git commit -m 'Added check on name presence in the request'
</code></pre>

<h2 id="domainexceptionlistener">DomainExceptionListener</h2>

<p>Our Command and CommandHandler both throw a DomainException, we can catch it in an
exception listener and create a nice response:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/EventListener/DomainExceptionListener.php

namespace AppBundle\EventListener;

use DomainException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;

class DomainExceptionListener
{
    /**
     * @param GetResponseForExceptionEvent $event
     */
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof DomainException) {
            return;
        }
        $error = $exception-&gt;getMessage();
        $event-&gt;setResponse(new JsonResponse(array('error' =&gt; $error), 422));
    }
}
</code></pre>

<p>It needs to be registerd in the Dependency Injection Container:</p>

<pre><code># File: app/config/services.yml
services:
    app.submit_json_listener:
        class: AppBundle\EventListener\SubmitJsonListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.forbidden_exception_listener:
        class: AppBundle\EventListener\ForbiddenExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }

    app.domain_exception_listener:
        class: AppBundle\EventListener\DomainExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }
</code></pre>

<p>We can save it:</p>

<pre><code>git add -A
git commit -m 'Created DomainExceptionListener'
</code></pre>

<h2 id="using-the-command">Using the command</h2>

<p>Now that our CommandHandler is ready, we'll define it as a service with its repository:</p>

<pre><code># File: app/config/services.yml
services:
    app.submit_json_listener:
        class: AppBundle\EventListener\SubmitJsonListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.forbidden_exception_listener:
        class: AppBundle\EventListener\ForbiddenExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }

    app.domain_exception_listener:
        class: AppBundle\EventListener\DomainExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }

    app.profile_repository:
        class: AppBundle\Entity\ProfileRepository
        factory_service: doctrine.orm.default_entity_manager
        factory_method: getRepository
        arguments: ['AppBundle:Profile']

    app.create_profile_handler:
        class: AppBundle\CommandBus\CreateProfileHandler
        arguments:
            - "@doctrine.orm.entity_manager"
            - "@app.profile_repository"
        tags:
            - { name: command_handler, handles: AppBundle\CommandBus\CreateProfile }
</code></pre>

<p>And call it in the controller:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use AppBundle\CommandBus\CreateProfile;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $name = $request-&gt;request-&gt;get('name');

        $this-&gt;get('command_bus')-&gt;handle(new CreateProfile($name));
        $createdProfile = $this-&gt;get('app.profile_repository')-&gt;findOneBy(array('name' =&gt; $name));

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Since the CommandHandler doesn't return anything, we need to call the repository
  to get the created profile.</p>
</blockquote>

<p>As it happens, we've forgotten to set <code>ProfileRepository</code> in <code>Profile</code>'s <code>Entity</code> annotation.
Let's fix it now:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Entity/Profile.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Table(name="profile")
 * @ORM\Entity(repositoryClass="AppBundle\Entity\ProfileRepository")
 */
class Profile
{
    /**
     * @ORM\Column(name="id", type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    private $id;

    /**
     * @ORM\Column(name="name", type="string", unique=true)
     */
    private $name;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }

    public function toArray()
    {
        return array(
            'id' =&gt; $this-&gt;id,
            'name' =&gt; $this-&gt;name,
        );
    }
}
</code></pre>

<p>Did we break anything?</p>

<pre><code>make test
</code></pre>

<p>No, all tests are super green!</p>

<pre><code>git add -A
git commit -m 'Used CreateProfileHandler in controller'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Technical debt is something we should be able to manage. When the time comes to refactor,
design patterns can be a helpful tool.</p>

<p>CommandBus is a nice pattern which allows us to remove imperative logic from the controllers.
It's easy to write unit test for CommandHandlers, and they can be reused
(creating a profile is surely something we can need elsewhere in our application).</p>

<p>This article concludes the second part of this series on web services in a Symfony environment.
In the <a href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html">next one</a>,
we'll start a new application which consumes the one we just created.</p>

<blockquote>
  <p><strong>Note</strong>: The web service we described also had a removal endpoint. Since there's not much else
  to learn, it won't be created in this series.</p>
</blockquote>

<h3 id="going-further">Going further</h3>

<p>A lot of things can be improved in the current application, here's some tips for those
who'd like to practice:</p>

<ul>
<li>name duplication is actually a "Conflict" type of error, not "Unprocessable Entity"</li>
<li>we could use Symfony's validation component (use <code>validator</code> in the CommandHandler and set annotations in the Command)</li>
<li>we could create a CommandBus that always validate the Command using Symfony's validation component</li>
<li>we can create our own DomainException to avoid catching ones that could be thrown by third party libraries</li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 2.2: Creation, the pragmatic way]]></title>
            <link href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html"/>
            <updated>2015-01-28T00:00:00+00:00</updated>
            <id>/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the third article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the two first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-ws">following repository</a>.</p>

<p>In this post we'll see how to create profiles:</p>

<ul>
<li><a href="#creating-the-controller">The controller</a></li>
<li><a href="#the-profile-entity">The profile entity</a></li>
<li><a href="#linking-with-the-database">Linking with the database</a></li>
<li><a href="#managing-errors">Managing errors</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="creating-the-controller">Creating the controller</h2>

<p>First things first, we'll write a functional test:</p>

<pre><code class="php">&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends \PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', false);
        $this-&gt;app-&gt;boot();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }
}
</code></pre>

<p>The test should fail, because the route hasn't been found (<code>404 NOT FOUND</code>):</p>

<pre><code>phpunit -c app
</code></pre>

<p>Flabergast! The test fails with a <code>PHP Fatal error:  Class 'AppKernel' not found</code>!
Let's fix this by adding the forgotten PHP tag opening in the bootstrap file:</p>

<pre><code class="php">&lt;?php
// File: app/bootstrap.php

require __DIR__.'/bootstrap.php.cache';
require __DIR__.'/AppKernel.php';
</code></pre>

<p>Let's check how the tests react:</p>

<pre><code>phpunit -c app
</code></pre>

<p>Another failure: the database doesn't exist. We need to create it for the test
environment:</p>

<pre><code>php app/console doctrine:database:create --env=test
</code></pre>

<p>Let's run the tests once again:</p>

<pre><code>phpunit -c app
</code></pre>

<p>This time the test fails for the right reason: the page doesn't exist.
To fix this, we'll create an empty controller:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $name = $request-&gt;request-&gt;get('name');
        $createdProfile = array();

        return new JsonResponse($createdProfile, 201);
    }
}
</code></pre>

<p>This should make the test pass:</p>

<pre><code>phpunit -c app
</code></pre>

<p>If an error occurs (404 not found), then it might be because of the cache:</p>

<pre><code>php app/console cache:clear --env=test
phpunit -c app
</code></pre>

<p>Running tests is becoming cumbersome, let's make it easy using a Makefile:</p>

<pre><code># Makefile
test:
    php app/console cache:clear --env=test
    php app/console doctrine:database:create --env=test
    phpunit -c app
    php app/console doctrine:database:drop --force --env=test
</code></pre>

<blockquote>
  <p><strong>Note</strong>: mind the tabs, make doesn't support space indentation.</p>
</blockquote>

<p>In order for this to work we'll need to drop the database (because it already exists):</p>

<pre><code>php app/console doctrine:database:drop --force --env=test
</code></pre>

<p>Tests can now be run using:</p>

<pre><code>make test
</code></pre>

<p>Everything's fine, we can commit our work:</p>

<pre><code>git add -A
git commit -m 'Created profile creation endpoint'
</code></pre>

<h2 id="the-profile-entity">The profile entity</h2>

<p>At this point, we'll need to store the profile in a database. For this purpose,
we'll use MySQL and Doctrine, so we'll need to create a profile entity.</p>

<p>We'll first generate a skeleton of its specification using <a href="http://phpspec.net">phpspec</a>:</p>

<pre><code>./bin/phpspec describe 'AppBundle\Entity\Profile'
</code></pre>

<p>Then we'll edit the specification:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/Entity/ProfileSpec.php

namespace spec\AppBundle\Entity;

use PhpSpec\ObjectBehavior;

class ProfileSpec extends ObjectBehavior
{
    const NAME = 'Arthur Dent';

    function let()
    {
        $this-&gt;beConstructedWith(self::NAME);
    }

    function it_can_be_converted_to_array()
    {
        $this-&gt;toArray()-&gt;shouldBe(array(
            'id' =&gt; null,
            'name' =&gt; self::NAME,
        ));
    }
}
</code></pre>

<p>Since we're happy with this step, we'll generate a skeleton of the code:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Of course we need to edit it:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Entity/Profile.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Table(name="profile")
 * @ORM\Entity
 */
class Profile
{
    /**
     * @ORM\Column(name="id", type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    private $id;

    /**
     * @ORM\Column(name="name", type="string", unique=true)
     */
    private $name;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }

    public function toArray()
    {
        return array(
            'id' =&gt; $this-&gt;id,
            'name' =&gt; $this-&gt;name,
        );
    }
}
</code></pre>

<p>Let's check if it satisfies our specification:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>It does! With this we can generate our database:</p>

<pre><code>php app/console doctrine:database:create
php app/console doctrine:schema:create
</code></pre>

<p>Let's update our Makefile:</p>

<pre><code># Makefile
prod:
    php app/console cache:clear --env=prod
    php app/console doctrine:database:create --env=prod
    php app/console doctrine:schema:create --env=prod

dev:
    php app/console cache:clear --env=dev
    php app/console doctrine:database:create --env=dev
    php app/console doctrine:schema:create --env=dev

test:
    php app/console cache:clear --env=test
    php app/console doctrine:database:create --env=test
    php app/console doctrine:schema:create --env=test
    phpunit -c app
    bin/phpspec run
    php app/console doctrine:database:drop --force --env=test
</code></pre>

<p>This allows us to also run phpspec for tests. Installing a project should be as
simple as:</p>

<pre><code>make
</code></pre>

<p>And for development we can use:</p>

<pre><code>make dev
</code></pre>

<blockquote>
  <p><strong>Note</strong>: trying to run a second time <code>make</code> or <code>make dev</code> will fail as the
  database already exists. We'll need to run respectively
  <code>php app/console doctrine:database:drop --force --env=prod</code> and
  <code>php app/console doctrine:database:drop --force --env=dev</code>, but we should really
  run those commands only once.</p>
</blockquote>

<p>It is time to commit our progress:</p>

<pre><code>git add -A
git commit -m 'Created Profile entity'
</code></pre>

<h2 id="linking-with-the-database">Linking with the database</h2>

<p>The only thing missing in our application is the actual creation of the profile.
Before doing anything with the code, we'll need to update our functional test:
we don't want the data to be actually persisted, as it would make the test fail
on a second run:</p>

<pre><code>&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends \PHPUnit_Framework_TestCase
{
    private $app;
    private $em;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', true);
        $this-&gt;app-&gt;boot();

        $this-&gt;em = $this-&gt;app-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');
        $this-&gt;em-&gt;beginTransaction();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    protected function tearDown()
    {
        $this-&gt;em-&gt;rollback();
        $this-&gt;em-&gt;close();
    }
}
</code></pre>

<p>Let's update the controller:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use AppBundle\Entity\Profile;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $em = $this-&gt;get('doctrine.orm.entity_manager');

        $createdProfile = new Profile($request-&gt;request-&gt;get('name'));
        $em-&gt;persist($createdProfile);
        $em-&gt;flush();

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<p>Time to run the tests:</p>

<pre><code>make test
</code></pre>

<p>All green! We can commit:</p>

<pre><code>git add -A
git commit -m 'Saved created profile in database'
</code></pre>

<h2 id="managing-errors">Managing errors</h2>

<p>Our endpoint should return an error if the "name" parameter is missing. Let's add
a functional test for this:</p>

<pre><code>&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;
    private $em;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', true);
        $this-&gt;app-&gt;boot();

        $this-&gt;em = $this-&gt;app-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');
        $this-&gt;em-&gt;beginTransaction();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    public function testItFailsIfNameIsMissing()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('no-name' =&gt; ''));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    protected function tearDown()
    {
        $this-&gt;em-&gt;rollback();
        $this-&gt;em-&gt;close();
    }
}
</code></pre>

<p>It should make our tests fail:</p>

<pre><code>make test
</code></pre>

<p>We can make this test pass by adding a simple check:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $em = $this-&gt;get('doctrine.orm.entity_manager');

        $name = $request-&gt;request-&gt;get('name');
        if (null === $name) {
            return new JsonResponse(array('error' =&gt; 'The "name" parameter is missing from the request\'s body'), 422);
        }
        $createdProfile = new Profile($name);
        $em-&gt;persist($createdProfile);
        $em-&gt;flush();

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<p>Let's see:</p>

<pre><code>php app/console doctrine:database:drop --force --env=test
make test
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Because our last test failed, the database hasn't been removed, so we
  need to do it manually.</p>
</blockquote>

<p>Looks nice! Our endpoint should also fail when a profile with the same name
already exist:</p>

<pre><code>&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;
    private $em;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', true);
        $this-&gt;app-&gt;boot();

        $this-&gt;em = $this-&gt;app-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');
        $this-&gt;em-&gt;beginTransaction();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    public function testItFailsIfNameIsMissing()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('no-name' =&gt; ''));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    public function testItFailsIfNameAlreadyExists()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Provençal le Gaulois'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $this-&gt;app-&gt;handle($request);
        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    protected function tearDown()
    {
        $this-&gt;em-&gt;rollback();
        $this-&gt;em-&gt;close();
    }
}
</code></pre>

<p>Our tests should be broken again:</p>

<pre><code>make test
</code></pre>

<p>Another check can fix this awful situation:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $em = $this-&gt;get('doctrine.orm.entity_manager');

        $name = $request-&gt;request-&gt;get('name');
        if (null === $name) {
            return new JsonResponse(array('error' =&gt; 'The "name" parameter is missing from the request\'s body'), 422);
        }
        if (null !== $em-&gt;getRepository('AppBundle:Profile')-&gt;findOneByName($name)) {
            return new JsonResponse(array('error' =&gt; 'The name "'.$name.'" is already taken'), 422);
        }
        $createdProfile = new Profile($name);
        $em-&gt;persist($createdProfile);
        $em-&gt;flush();

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<p>Are we there yet?</p>

<pre><code>php app/console doctrine:database:drop --force --env=test
make test
</code></pre>

<p>Yes we are. Here's our last commit for this time:</p>

<pre><code>git add -A
git commit -m 'Added error checks'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Creating an endpoint with Symfony is pretty straighfoward: it all comes down to
HTTP knowledge.</p>

<p>Our codebase is very small due to the simplicity of our examples, but in a real
life application we'll need to add more complexity as new requirements appear.</p>

<p>The pragmatic approach is good for now, but at some point we'll need to refactor
our code by creating some services, each with their specific responsibilities,
to prevent our application from becoming a <a href="https://speakerdeck.com/richardmiller/atm">big ball of mud</a>
where everything is hard to read, impossible to test and expensive to change.</p>

<p>This will the subject of <a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">the next article</a>.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 2.1: Creation bootstrap]]></title>
            <link href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html"/>
            <updated>2015-01-21T00:00:00+00:00</updated>
            <id>/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the second article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the first one:
<a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a>.</p>

<p>In this post we'll create an empty application and prepare it:</p>

<ul>
<li><a href="#installing-the-standard-edition">Installing the standard edition</a></li>
<li><a href="#twitching-for-tests">Twitching for tests</a></li>
<li><a href="#patching-for-json-submit">Patching for JSON submit</a></li>
<li><a href="#setting-up-the-authentication">Setting up the authentication</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="installing-the-standard-edition">Installing the standard edition</h2>

<p>First of all, we need to create an empty Symfony application:</p>

<pre><code>composer create-project symfony/framework-standard-edition ws
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Take the time to configure a MySQL database, we'll need it later.</p>
</blockquote>

<p>Next we'll configure an Apache's virtual host (should be in <code>/etc/apache2/sites-available/ws.conf</code>):</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerName ws.local

    DocumentRoot /home/foobar/ws/web

    ErrorLog "/home/foobar/ws/app/logs/apache_errors.log"
    CustomLog "/home/foobar/ws/app/logs/apache_accesses.log" common

    &lt;Directory /home/foobar/ws/web&gt;
        Options Indexes FollowSymLinks MultiViews
        AllowOverride None
        Require all granted
        Order allow,deny
        allow from all
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</code></pre>

<p>Apache will require access to the logs and cache directories, as well as your
user. The easiest way to do so is to change Apache's user and group to yours in
<code>/etc/apache2/envvars</code>:</p>

<pre><code>export APACHE_RUN_USER=foobar
export APACHE_RUN_GROUP=foobar
</code></pre>

<p>In order for this to work we'll update our <code>/etc/hosts</code> file:</p>

<pre><code>echo '127.0.0.1 ws.local' | sudo tee -a /etc/hosts
</code></pre>

<p>And finally we'll restart the web server:</p>

<pre><code>sudo service apache2 restart
</code></pre>

<p>We should be able to see "Homepage" when browsing http://ws.local/app_dev.php/app/example</p>

<p>Let's commit our work:</p>

<pre><code>git init
git add -A
git ci -m 'Created a standard Symfony application'
</code></pre>

<h2 id="twitching-for-tests">Twitching for tests</h2>

<p>As explained in <a href="/2014/11/15/sf2-quick-functional-tests.html">this article</a>,
we'll twitch the standard edition a little bit in order to make tests more explicit.</p>

<p>First we create a bootstraping file:</p>

<pre><code class="php">&lt;?php
// File: app/bootstrap.php

require __DIR__.'/bootstrap.php.cache';
require __DIR__.'/AppKernel.php';
</code></pre>

<p>Then we configure PHPUnit to use it:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- http://phpunit.de/manual/4.1/en/appendixes.configuration.html --&gt;
&lt;phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
         backupGlobals="false"
         colors="true"
         bootstrap="bootstrap.php"
&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="Project Test Suite"&gt;
            &lt;directory&gt;../tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<p>We've decided to put our tests in a separate <code>tests</code> directory, allowing us to
decalre an autoload mapping specific for development. To fully optimize our
autoloading, we'll also define our <code>src/AppBundle</code> folder as a path for the
<code>AppBundle</code> namespace, using PSR-4:</p>

<pre><code>{
    "name": "symfony/framework-standard-edition",
    "license": "MIT",
    "type": "project",
    "description": "The \"Symfony Standard Edition\" distribution",
    "autoload": {
        "psr-4": { "AppBundle\\": "src/AppBundle" }
    },
    "autoload-dev": {
        "psr-4": { "AppBundle\\Tests\\": "tests" }
    },
    "require": {
        "php": "&gt;=5.3.3",
        "symfony/symfony": "2.6.*",
        "doctrine/orm": "~2.2,&gt;=2.2.3",
        "doctrine/doctrine-bundle": "~1.2",
        "twig/extensions": "~1.0",
        "symfony/assetic-bundle": "~2.3",
        "symfony/swiftmailer-bundle": "~2.3",
        "symfony/monolog-bundle": "~2.4",
        "sensio/distribution-bundle": "~3.0.12",
        "sensio/framework-extra-bundle": "~3.0",
        "incenteev/composer-parameter-handler": "~2.0"
    },
    "require-dev": {
        "sensio/generator-bundle": "~2.3"
    },
    "scripts": {
        "post-root-package-install": [
            "SymfonyStandard\\Composer::hookRootPackageInstall"
        ],
        "post-install-cmd": [
            "Incenteev\\ParameterHandler\\ScriptHandler::buildParameters",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::buildBootstrap",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::clearCache",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installAssets",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installRequirementsFile",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::removeSymfonyStandardFiles"
        ],
        "post-update-cmd": [
            "Incenteev\\ParameterHandler\\ScriptHandler::buildParameters",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::buildBootstrap",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::clearCache",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installAssets",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installRequirementsFile",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::removeSymfonyStandardFiles"
        ]
    },
    "config": {
        "bin-dir": "bin"
    },
    "extra": {
        "symfony-app-dir": "app",
        "symfony-web-dir": "web",
        "symfony-assets-install": "relative",
        "incenteev-parameters": {
            "file": "app/config/parameters.yml"
        },
        "branch-alias": {
            "dev-master": "2.6-dev"
        }
    }
}
</code></pre>

<p>To make it official, we need to run the following command:</p>

<pre><code>composer dump-autoload
</code></pre>

<p>We'll also install <a href="http://phpspec.net">phpspec</a>:</p>

<pre><code>composer require phpspec/phpspec:~2.1
</code></pre>

<p>With this our tests will be awesome! Time to commit:</p>

<pre><code>git add -A
git commit -m 'Configured tests'
</code></pre>

<h2 id="patching-for-json-submit">Patching for JSON submit</h2>

<p>Symfony provides the posted data in the <code>Request</code>'s <code>request</code> attribute, except
if the content type is <code>application/json</code>, as it will be our case. To fix this
behavior we'll follow the steps described in <a href="/2014/09/03/master-sf2-part-5-events.html">this article</a>.</p>

<p>Let's start by the creation of an event listener:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/EventListener/SubmitJsonListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

/**
 * PHP does not populate $_POST with the data submitted via a JSON Request,
 * causing an empty $request-&gt;request.
 *
 * This listener fixes this.
 */
class SubmitJsonListener
{
    /**
     * @param GetResponseEvent $event
     */
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('POST', 'PUT'), true);
        $isJson = ('application/json' === $request-&gt;headers-&gt;get('Content-Type'));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new JsonResponse(array('error' =&gt; 'Invalid or malformed JSON'), 400));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>Finally we'll register it in the Dependency Injection Container:</p>

<pre><code># File: app/config/services.yml
services:
    app.submit_json_listener:
        class: AppBundle\EventListener\SubmitJsonListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<h2 id="setting-up-the-authentication">Setting up the authentication</h2>

<p>HTTP basic authentication can be configured through the <code>app/config/security.yml</code>
file, as described in <a href="http://symfony.com/doc/current/book/security.html">the official documentation</a>.</p>

<p>In the end we should have something like this:</p>

<pre><code># app/config/security.yml
security:
    encoders:
        Symfony\Component\Security\Core\User\User: plaintext

    providers:
        in_memory:
            memory:
                users:
                    spanish_inquisition:
                        password: 'NobodyExpectsIt!'
                        roles:
                            - ROLE_USER

    firewalls:
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false

        default:
            anonymous: ~
            http_basic: ~
            stateless: true

    access_control:
        - { path: /.*, roles: ROLE_USER }
</code></pre>

<p>Now to comply with our description we need to customize the error. We can do so
using another event listener:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/EventListener/ForbiddenExceptionListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;
use Symfony\Component\Security\Core\Exception\AccessDeniedException;

/**
 * PHP does not populate $_POST with the data submitted via a JSON Request,
 * causing an empty $request-&gt;request.
 *
 * This listener fixes this.
 */
class ForbiddenExceptionListener
{
    /**
     * @param GetResponseForExceptionEvent $event
     */
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof AccessDeniedException) {
            return;
        }
        $error = 'The credentials are either missing or incorrect';
        $event-&gt;setResponse(new JsonResponse(array('error' =&gt; $error), 403));
    }
}
</code></pre>

<p>And to register it:</p>

<pre><code># File: app/config/services.yml
services:
    app.submit_json_listener:
        class: AppBundle\EventListener\SubmitJsonListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.forbidden_exception_listener:
        class: AppBundle\EventListener\ForbiddenExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }
</code></pre>

<blockquote>
  <p><strong>Note</strong>: the Symfony Security event listener has a priority set to 0.
  In order for our listener to be executed, we need to set a higher one, like 10.</p>
</blockquote>

<p>As you can see by browsing http://ws.local/app_dev.php/app/example, we now need
to provide the <code>spanish_inquisition</code> with the <code>NobodyExpectsIt!</code> password to
access the page.</p>

<p>This is enough for today, we'll commit our work:</p>

<pre><code>git add -A
git commit -m 'Created custom event listeners'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Our application is now ready!</p>

<p>In the [next article](/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html
we'll create the first endpoint, the creation of profiles, using a pragmatic approach.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 1: Introduction]]></title>
            <link href="/2015/01/14/sf-ws-part-1-introduction.html"/>
            <updated>2015-01-14T00:00:00+00:00</updated>
            <id>/2015/01/14/sf-ws-part-1-introduction.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>Welcome to this new series of articles on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Its purpose is to provide an example,
it doesn't pretend to be the best solution and it requires you to know the basics
of Symfony (if you know what a service is, you're good) and of web services
(basically to know that they're a way to provide data remotely).</p>

<blockquote>
  <p><strong>Spoiler alert</strong>: There won't be much Symfony specific code ;) .</p>
</blockquote>

<p>In this post we'll describe the different endpoints of the (fake) web service
which will be used as a reference thoughout the whole series:</p>

<ul>
<li><a href="#json-objects">JSON objects</a></li>
<li><a href="#authentication">Authentication</a></li>
<li><a href="#create-a-profile">Create a profile</a></li>
<li><a href="#delete-a-profile">Delete a profile</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="json-objects">JSON objects</h2>

<p>The posted and returned resources will always be wrapped in a JSON object.</p>

<h2 id="authentication">Authentication</h2>

<p>All endpoints require HTTP Basic Authentication with the following credentials:</p>

<ul>
<li>user: <code>spanish_inquisition</code></li>
<li>password: <code>NobodyExpectsIt!</code></li>
</ul>

<p>If those credentials are missing or wrong (<code>403 FORBIDDEN</code>), it will return:</p>

<pre><code>{
    "error": "The credentials are either missing or incorrect"
}
</code></pre>

<h2 id="create-a-profile">Create a profile</h2>

<ul>
<li><code>POST http://ws.local/api/v1/profiles</code></li>
</ul>

<p>The request body should be as follow:</p>

<pre><code>{
    "name": "Fawlty Tower"
}
</code></pre>

<p>In case of success (<code>201 CREATED</code>), it will return:</p>

<pre><code>{
    "id": 23,
    "name": "Fawlty Tower"
}
</code></pre>

<p>If the request's body contains malformed JSON (<code>400 BAD REQUEST</code>), it will return:</p>

<pre><code>{
    "error": "Invalid or malformed JSON"
}
</code></pre>

<p>If the <code>name</code> parameter is missing from the request's body (<code>422 UNPROCESSABLE ENTITY</code>),
it will return:</p>

<pre><code>{
    "error": "The \"name\" parameter is missing from the request's body"
}
</code></pre>

<p>If the name already exists (<code>422 UNPROCESSABLE ENTITY</code>), it will return:</p>

<pre><code>{
    "error": "The name \"Provençal le Gaulois\" is already taken"
}
</code></pre>

<h2 id="delete-a-profile">Delete a profile</h2>

<ul>
<li><code>DELETE http://ws.local/api/v1/profiles/{id}</code></li>
</ul>

<p>This endpoint will always return an empty body (<code>204 NO CONTENT</code>).</p>

<h2 id="conclusion">Conclusion</h2>

<p>So basically we can create and remove profiles, which have an identifier and a name.</p>

<p>In <a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">the next article</a>
we'll see how to build such web service.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Links from 2014]]></title>
            <link href="/2015/01/07/links-from-2014.html"/>
            <updated>2015-01-07T00:00:00+00:00</updated>
            <id>/2015/01/07/links-from-2014.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Links I tweeted during 2014</p>
</blockquote>

<p>I've tweeted a lot of links in 2014, so in order to keep track of them I've
decided to list them here:</p>

<ul>
<li><a href="#cool-new-tools">Cool new tools</a></li>
<li><a href="#igor-wiedler-and-functional-programing">Igor Wiedler and Functional Programing</a></li>
<li><a href="#todd-moto-and-javascript">Todd Moto and Javascript</a></li>
<li><a href="#hexagonal-rchitecture">Hexagonal Architecture</a></li>
<li><a href="#some-insightful-tweets">Some insightful tweets</a></li>
<li><a href="#performance">Performance</a></li>
<li><a href="#symfony-components">Symfony Components</a></li>
<li><a href="#richard-miller">Richard Miller</a></li>
<li><a href="#mathias-verraes">Mathias Verraes</a></li>
<li><a href="#elnur">Elnur</a></li>
<li><a href="#uncle-bob-and-8th-light">Uncle Bob and 8th light</a></li>
<li><a href="#tests-and-tdd">Tests and TDD</a></li>
<li><a href="#agile-and-bdd">Agile and BDD</a></li>
<li><a href="#miscellaneous">Miscellaneous</a></li>
</ul>

<blockquote>
  <p><strong>Warning</strong>: The order and categories are quite random.</p>
</blockquote>

<h2 id="cool-new-tools">Cool new tools</h2>

<ul>
<li><a href="http://webmozarts.com/2014/12/03/puli-powerful-resource-management-for-php/">Puli - Powerful Resource Management for PHP</a></li>
<li><a href="http://gnugat.github.io/redaktilo/">Redaktilo - An easy line manipulation PHP lib: jump, insert and do anything!</a></li>
<li><a href="http://couscous.io/">Couscous - Put your markdown documentation online</a></li>
<li><a href="https://gist.github.com/mathiasverraes/9046427">Test Framework in a tweet</a></li>
<li><a href="http://yohan.giarel.li/Finite/index.html">Finite, a state machine library for PHP</a></li>
</ul>

<h2 id="igor-wiedler-and-functional-programing">Igor Wiedler and Functional Programing</h2>

<ul>
<li><a href="https://igor.io/2014/01/06/functional-library-iter.html">Functional Library: Iteration</a></li>
<li><a href="https://igor.io/2014/01/08/functional-library-traversal.html">Functional Library: Traversal</a></li>
<li><a href="https://igor.io/2014/01/10/functional-library-null.html">Functional Library: Null</a></li>
</ul>

<p>See also:</p>

<ul>
<li><a href="http://nikic.github.io/2014/01/10/The-case-against-the-ifsetor-function.html">The case against the ifsetor function</a></li>
</ul>

<h2 id="todd-moto-and-javascript">Todd Moto and Javascript</h2>

<ul>
<li><a href="http://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/">Everything you wanted to know about javascript scopes</a></li>
<li><a href="http://toddmotto.com/avoiding-anonymous-javascript-functions/">Avoiding anonymous JavaScript functions</a></li>
<li><a href="http://toddmotto.com/mastering-the-module-pattern/">Mastering the Module Pattern</a></li>
<li><a href="http://toddmotto.com/understanding-the-this-keyword-in-javascript/">Understanding the “this” keyword in JavaScript</a></li>
<li><a href="http://toddmotto.com/what-function-window-document-undefined-iife-really-means/">What (function (window, document, undefined) {})(window, document); really means</a></li>
</ul>

<p>See also:</p>

<ul>
<li><a href="http://www.slideshare.net/weaverryan/cool-like-frontend-developer-grunt-requirejs-bower-and-other-tools-29177248">Cool like a Frontend Developer: Grunt, RequireJS, Bower and other Tools</a></li>
<li><a href="http://www.maori.geek.nz/post/i_promise_this_will_be_short">What are Promises and Deferred Objects?</a></li>
</ul>

<h2 id="hexagonal-architecture">Hexagonal Architecture</h2>

<ul>
<li><a href="http://alistair.cockburn.us/Hexagonal+architecture">Hexagonal Architecture</a></li>
<li><a href="http://pivotallabs.com/hexagonal-rails-and-the-ludicrous-terminal-application/">Hexagonal Rails and The Ludicrous Terminal Application</a></li>
<li><a href="http://collectiveidea.com/blog/archives/2012/06/28/wheres-your-business-logic/">Where's Your Business Logic?</a></li>
<li><a href="https://github.com/igorw/doucheswag">doucheswag source code</a></li>
<li><a href="https://speakerdeck.com/igorw/silex-an-implementation-detail-tnphp">Silex, an implementation detail</a></li>
</ul>

<h2 id="some-insightful-tweets">Some insightful tweets</h2>

<ul>
<li><code>Interface</code> suffix and <code>Abstract</code> prefix is nothing else than an acceptance of
your failure to name things clear in the first place. <a href="https://twitter.com/everzet/status/432925046731186176">@everzet</a></li>
<li>Once #PuliPHP is stable, many reasons for bundles will be gone.
Then a bundle is just a package with DI config
<a href="https://twitter.com/webmozart/status/545642670753062914">@webmozart</a></li>
<li>TDD #InATweet: 1. write the test 2. write enough code to make it pass,
in a quick and dirty way 3. refactor <a href="https://twitter.com/epiloic/status/442202139600113664">@epiloic</a></li>
<li>spec #BDD #InATweet: test method names shoulb be senteces (it_should_do_something rather than testMethod)
<a href="https://twitter.com/epiloic/status/441830123437064192">@epiloic</a></li>
<li>story #BDD #InATweet: acceptance criteria (from user stories) should be executable
<a href="https://twitter.com/epiloic/status/446540046800543744">@epiloic</a></li>
<li>Rule of thumb number one: never follow blindly rule of thumbs
<a href="https://twitter.com/epiloic/status/442334229645762560">@epiloic</a></li>
<li>Should #Behat's training wheels come off too?
http://aslakhellesoy.com/post/11055981222/the-training-wheels-came-off
<a href="https://twitter.com/epiloic/status/463922386736136193">@epiloic</a></li>
</ul>

<h2 id="performance">Performance</h2>

<ul>
<li><a href="http://marcjschmidt.de/blog/2014/02/08/php-high-performance.html">Bring High Performance Into Your PHP App (with ReactPHP)</a></li>
<li><a href="http://symfony.com/blog/push-it-to-the-limits-symfony2-for-high-performance-needs">Push it to the limits - Symfony2 for High Performance needs</a></li>
<li><a href="http://labs.octivi.com/handling-1-billion-requests-a-week-with-symfony2/">Handling 1 Billion requests a week with Symfony2</a></li>
<li><a href="http://labs.octivi.com/mastering-symfony2-performance-doctrine/">Mastering Symfony2 Performance – Doctrine</a></li>
<li><a href="http://devplant.net/2014/08/11/optimizing-php-code/?utm_content=buffer133dd&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer">Optimizing PHP code</a></li>
<li><a href="http://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html">why GNU grep is fast</a></li>
<li><a href="http://www.sitepoint.com/time-complexity-algorithms/">Time Complexity of Algorithms</a></li>
<li><a href="https://github.com/mybuilder/phpunit-accelerator">PHPUnit accelerator</a></li>
<li><a href="https://gist.github.com/nikic/5015323">Why objects (usually) use less memory than arrays in PHP</a></li>
<li><a href="http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html">PHP's new hashtable implementation</a></li>
</ul>

<h2 id="symfony-components">Symfony Components</h2>

<ul>
<li><a href="http://loige.com/symfony-security-authentication-made-simple/">Symfony security: authentication made simple (well, maybe!)</a></li>
<li><p><a href="https://www.youtube.com/watch?v=xQyEXzug7P8&amp;feature=youtu.be">Love &amp; Loss, a Symfony Security Play</a></p></li>
<li><p><a href="http://blog.servergrove.com/2014/04/07/symfony2-components-overview-expression-language/">Symfony2 components overview: ExpressionLanguage</a></p></li>
<li><a href="http://jwage.com/post/76799775984/using-the-symfony-expression-language-for-a-reward">Using the Symfony Expression Language for a Reward Rules Engine</a></li>
<li><p><a href="http://blog.elcodi.io/blog/2014/05/20/about-rules-and-expressionlanguage/">About Rules and ExpressionLanguage</a></p></li>
<li><p><a href="http://www.lucas.courot.com/symfony2-console-component-on-steroids.html">Symfony2 Console Component on steroids</a></p></li>
</ul>

<h2 id="richard-miller">Richard Miller</h2>

<ul>
<li><a href="http://richardmiller.co.uk/2014/03/28/symfony2-configuring-different-services-for-different-environments/">Symfony2: Configuring different services for different environments</a></li>
<li><a href="http://richardmiller.co.uk/2012/10/31/symfony2-trimming-fat-from-controllers/">Symfony2: Trimming Fat from Controllers</a></li>
<li><a href="http://richardmiller.co.uk/2014/11/06/value-objects/">Value Objects</a></li>
</ul>

<h2 id="mathias-verraes">Mathias Verraes</h2>

<ul>
<li><a href="http://verraes.net/2014/06/named-constructors-in-php/">Named Constructors in PHP</a></li>
<li><a href="http://verraes.net/2014/08/resolving-feature-envy-in-the-domain/">Resolving Feature Envy in the Domain</a></li>
<li><a href="http://verraes.net/2014/08/sterile-estimation/">Sterile Estimation</a></li>
<li><a href="http://verraes.net/2013/09/extract-till-you-drop/">Extract Till You Drop</a></li>
<li><a href="http://verraes.net/2014/12/how-much-testing-is-too-much/">How Much Testing is Too Much?</a></li>
</ul>

<h2 id="elnur">Elnur</h2>

<ul>
<li><a href="http://elnur.pro/behat-and-mink-are-not-meant-to-be-together/">Behat and Mink Are Not Meant to Be Together</a></li>
<li><a href="http://elnur.pro/use-the-domain-language-in-bdd-features/">Use the Domain Language in BDD Features</a></li>
<li><a href="http://elnur.pro/use-only-infrastructural-bundles-in-symfony/">Use Only Infrastructural Bundles in Symfony</a></li>
<li><a href="http://elnur.pro/bdd-does-not-replace-testing/">BDD Does Not Replace Testing</a></li>
<li><a href="http://elnur.pro/triangulation-in-testing/">Triangulation in Testing</a></li>
<li><a href="http://elnur.pro/stop-playing-god-with-project-constraints/">Stop Playing God With Project Constraints</a></li>
<li><a href="http://elnur.pro/assets-cache-busting-in-symfony/">Assets Cache Busting in Symfony</a></li>
<li><a href="http://elnur.pro/make-atomic-commits/">Make Atomic Commits</a></li>
</ul>

<h2 id="uncle-bob-and-8th-light">Uncle Bob and 8th light</h2>

<ul>
<li><a href="http://blog.8thlight.com/uncle-bob/2014/01/27/TheChickenOrTheRoad.html">The Domain Discontinuity</a></li>
<li><a href="http://blog.8thlight.com/uncle-bob/2014/03/11/when-to-think.html">When should you think</a></li>
<li><a href="http://blog.8thlight.com/uncle-bob/2014/04/30/When-tdd-does-not-work.html">When TDD doesn't work</a></li>
<li><a href="http://blog.8thlight.com/uncle-bob/2014/05/10/WhenToMock.html">When to Mock</a></li>
<li><a href="http://blog.8thlight.com/uncle-bob/2014/05/14/TheLittleMocker.html">The little Mocker</a></li>
<li><a href="http://blog.8thlight.com/uncle-bob/2014/05/19/First.html">First</a></li>
<li><p><a href="http://blog.cleancoder.com/uncle-bob/2014/09/03/TestTime.html">TestTime</a></p></li>
<li><p><a href="http://blog.8thlight.com/doug-bradbury/2014/06/18/how-men-and-women-think-differently.html">How Men and Women Think Differently</a></p></li>
<li><a href="http://blog.8thlight.com/ben-spatafora/2014/07/15/command-objects-are-gerunds.html">Command Objects Are Verbs</a></li>
<li><a href="http://blog.8thlight.com/eric-smith/2014/07/18/standups-are-broken-but-should-they-be-fixed.html">Stand-ups are Broken, but Should They be Fixed?</a></li>
<li><a href="http://blog.8thlight.com/ginny-hendry/2014/07/11/take-pride-in-your-legacy-code.html">Take Pride in Your Legacy Code</a></li>
</ul>

<h2 id="tests-and-tdd">Tests and TDD</h2>

<ul>
<li><a href="http://www.getdonedone.com/five-test-cases-for-fewer-bugs/">Want To Introduce Fewer Bugs? Test Through These Five Cases.</a></li>
<li><a href="http://martinfowler.com/bliki/UnitTest.html">UnitTest</a></li>
<li><a href="https://www.destroyallsoftware.com/blog/2014/test-isolation-is-about-avoiding-mocks">Test Isolation Is About Avoiding Mocks</a></li>
<li><a href="http://pivotallabs.com/tests-implementation-detail/">Tests Are An Implementation Detail</a></li>
<li><a href="http://codurance.com/2014/12/13/naming-test-classes-and-methods/">Naming Test Classes and Methods</a></li>
<li><a href="http://www.daedtech.com/what-tdd-is-and-is-not?utm_content=buffer835cd&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer">What TDD is and is not</a></li>
<li><a href="http://martinfowler.com/articles/is-tdd-dead/">Is TDD dead</a></li>
<li><a href="https://www.destroyallsoftware.com/blog/2014/tdd-straw-men-and-rhetoric">TDD, Straw Men, and Rhetoric</a></li>
</ul>

<h2 id="agile-and-bdd">Agile and BDD</h2>

<ul>
<li><a href="http://rob.conery.io/2013/08/28/how-behavioral-is-your-bdd/">How behavioral is your BDD?</a></li>
<li><a href="http://dannorth.net/whats-in-a-story/">What's in a story?</a></li>
<li><a href="http://dannorth.net/2013/08/08/blink-estimation/">Blink estimations</a></li>
<li><a href="http://nomad8.com/acceptance_criteria/">On acceptance criteria for User Stories</a></li>
<li><a href="http://dannorth.net/2014/07/18/capturing-the-narrative/">Capturing the narrative</a></li>
<li><a href="http://labs.octivi.com/pair-programming-from-the-developers-perspective/">Pair programming from the developer’s perspective</a></li>
<li><a href="http://www.mountaingoatsoftware.com/blog/my-primary-criticism-of-scrum">My Primary Criticism of Scrum</a></li>
<li><a href="http://lizkeogh.com/2014/08/21/a-dev-walks-into-a-bar/">A dev walks into a bar…</a></li>
<li><a href="http://lizkeogh.com/2014/09/01/deriving-gherkin-from-real-conversations/">Deriving Gherkin from Real Conversations</a></li>
<li><a href="https://medium.com/@frankdejonge/a-case-against-coding-lingo-8ffae1a4fa4e">A Case Against Coding Lingo</a></li>
<li><a href="http://techportal.inviqa.com/2014/09/11/my-top-ten-favourite-phpspec-limitations/">My top ten favourite PhpSpec limitations</a></li>
<li><a href="http://everzet.com/post/99045129766/introducing-modelling-by-example">Introducing Modelling by Example</a></li>
</ul>

<h2 id="miscellaneous">Miscellaneous</h2>

<ul>
<li><a href="http://dongilbert.net/a-case-for-service-location/">A case for service location</a></li>
<li><a href="http://blog.schauderhaft.de/2012/01/01/the-one-correct-way-to-do-dependency-injection/">The One correct way to do Dependency Injection</a></li>
<li><p><a href="http://ewanvalentine.io/difference-between-services-and-controllers/">Difference between services and controllers</a></p></li>
<li><p><a href="http://code.tutsplus.com/tutorials/the-repository-design-pattern--net-35804">The repository Design Pattern</a></p></li>
<li><a href="http://www.jefclaes.be/2014/01/repositories-where-did-we-go-wrong_26.html">Repositories, where did we go wrong?</a></li>
<li><p><a href="http://mnapoli.fr/repository-interface/">The repository interface</a></p></li>
<li><p><a href="http://blog.ploeh.dk/2010/12/02/Interfacesarenotabstractions/">Interfaces are not abstractions</a></p></li>
<li><a href="http://blog.ploeh.dk/2010/12/03/Towardsbetterabstractions/">Towards better abstractions</a></li>
<li><a href="http://adamcod.es/2013/11/22/tell-dont-ask.html">Tell, don't ask</a></li>
<li><a href="http://jeremydmiller.com/2014/06/19/pragmatic-and-other-rants/">Why I hate the word “Pragmatic” and other rants</a></li>
<li><a href="http://techportal.inviqa.com/2014/07/23/your-code-sucks-tips-on-giving-feedback-2/">“Your code sucks” – Tips on giving feedback</a></li>
<li><a href="http://marcgg.com/blog/2014/07/22/in-defense-of-legacy-code/">Some Respect For Legacy Code</a></li>
<li><p><a href="https://medium.com/things-developers-care-about/why-your-previous-developer-was-terrible-506a06ae35ea">Why your previous developer was terrible</a></p></li>
<li><p><a href="http://www.dabeaz.com/coroutines/index.html">A Curious Course on Coroutines and Concurrency</a></p></li>
<li><p><a href="http://strongloop.com/strongblog/how-to-generators-node-js-yield-use-cases/">Generators in Node.js: Common Misconceptions and Three Good Use Cases</a></p></li>
<li><p><a href="https://wildlyinaccurate.com/a-hackers-guide-to-git">A Hacker’s Guide to Git</a></p></li>
<li><p><a href="https://wiki.openstack.org/wiki/GitCommitMessages">Git Commit Message Good Practice</a></p></li>
<li><p><a href="http://brikis98.blogspot.fr/2014/05/you-are-what-you-document.html">You are what you document</a></p></li>
<li><p><a href="http://www.infoq.com/articles/better-best-practices">Better Best Practices</a></p></li>
<li><a href="http://symfony.com/doc/2.6/best_practices/index.html">Symfony Best Practices</a></li>
<li><a href="http://knpuniversity.com/blog/AppBundle">Bundles, No Bundles and AppBundle in 10 Steps</a></li>
<li><a href="http://www.whitewashing.de/2014/10/26/symfony_all_the_things_web.html">Symfony All The Things (Web)</a></li>
<li><p><a href="http://welcometothebundle.com/best-resources-about-symfony-tdd-bdd-ddd-methologies/">Best resources about methodologies on Symfony, PHP, DDD, BDD ...</a></p></li>
<li><p><a href="http://jwage.com/post/73741567918/doctrine-is-not-just-an-orm-for-relational">Doctrine is not just an ORM for Relational Databases</a></p></li>
<li><p><a href="http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/working-with-objects.html#entity-object-graph-traversal">Doctrine Entity Object Graph Traversal</a></p></li>
<li><p><a href="http://www.udidahan.com/2009/06/07/the-fallacy-of-reuse/">The fallacy of reuse</a></p></li>
<li><a href="https://today.java.net/article/2006/04/04/exception-handling-antipatterns">Exception-Handling Antipatterns</a></li>
<li><a href="http://martinfowler.com/bliki/OpportunisticRefactoring.html">OpportunisticRefactoring</a></li>
<li><a href="http://www.jefclaes.be/2013/02/adding-r-to-cqs-some-storage-options.html?spref=tw">Adding the R to CQS: some storage options</a></li>
<li><a href="http://dev.imagineeasy.com/post/96604754704/naming-things-considered-hard">Naming things considered hard</a></li>
<li><a href="http://dev-human.com/entries/2014/07/17/Want_To_Be_More_Productive_Work_Less/">Want To Be More Productive? Work Less!</a></li>
<li><a href="http://marmelab.com/blog/2014/09/01/one-new-tech-per-project.html">One New Tech Per Project</a></li>
<li><a href="http://www.slate.com/articles/double_x/doublex/2014/03/brigid_schulte_s_overwhelmed_and_our_epidemic_of_busyness.html">You’re Not As Busy As You Say You Are</a></li>
<li><a href="http://www.martinfowler.com/eaaCatalog/dataMapper.html">For those using "Manager" as a classname: Data Mapper</a></li>
<li><a href="http://knpuniversity.com/blog/composer-require">Update your Docs for "composer require", then Celebrate with a Sandwich</a></li>
<li><a href="http://homakov.blogspot.fr/2013/03/oauth1-oauth2-oauth.html">OAuth1, OAuth2, OAuth...?</a></li>
<li><a href="http://rickosborne.org/blog/2014/01/uncheck-the-struggle-box/">Uncheck the struggle box</a></li>
<li><a href="https://medium.com/@ninjudd/passwords-are-obsolete-9ed56d483eb">Passwords are Obsolete</a></li>
<li><a href="http://php-di.org/news/06-php-di-4-0-new-definitions.html">Why was YAML a bad choice</a></li>
<li><a href="http://nikic.github.io/2012/06/15/The-true-power-of-regular-expressions.html">The true power of regular expressions</a></li>
<li><a href="http://rosstuck.com/notes-from-laraconeu/#custom-requests">Laravel Custom Requests</a></li>
<li><a href="http://blog.ircmaxell.com/2014/10/foundations-of-oo-design.html">Foundations Of OO Design</a></li>
<li><a href="http://stackoverflow.com/questions/22761554/php-get-all-class-names-inside-a-particular-namespace/27440555#27440555">PHP - get all class names inside a particular namespace</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony2 - Quick functional tests]]></title>
            <link href="/2014/11/15/sf2-quick-functional-tests.html"/>
            <updated>2014-11-15T00:00:00+00:00</updated>
            <id>/2014/11/15/sf2-quick-functional-tests.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Only check the status and exit code, don't use the given <code>TestCase</code>.</p>
</blockquote>

<p>Provided that your controllers and commands are thin and they rely on services
which are heavily unit tested, only checking the status and exit code in your
functional test should be entirely sufficient.</p>

<blockquote>
  <p><strong>Note</strong>: Checking at least the status and exit code is recommended by
  <a href="http://symfony.com/doc/current/best_practices/tests.html#functional-tests">Symfony's Official Best Practices</a>.</p>
</blockquote>

<p>In this article, we will see how easy and quick it is to write them.</p>

<h2 id="making-the-kernel-available">Making the Kernel available</h2>

<p>If you're familiar with <a href="http://symfony.com">Symfony2</a>, you might use one of
the given <code>KernelTestCase</code> to write your tests with <a href="http://phpunit.de">PHPUnit</a>.</p>

<p>The whole purpose of this file is to create an instance of the application's
Kernel, by guessing its localization. The problem with this approach is that it
ties you to the PHPUnit test framework. If you have a look at its code, you'll
also find it a bit complicated.</p>

<blockquote>
  <p><strong>Note</strong>: <code>WebTestCase</code> also makes available a <a href="http://symfony.com/doc/current/book/testing.html#functional-tests">crawler</a>,
  which we don't need as we only intend on checking the status code, not the body.</p>
</blockquote>

<p>Let's take an easier way: we will create a bootstrap file which requires the
kernel's file:</p>

<pre><code class="php">&lt;?php
// File: app/bootstrap.php

require __DIR__.'/bootstrap.php.cache';
require __DIR__.'/AppKernel.php';
</code></pre>

<p>Now all you need to do for your tests is to use this file. For example with
PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- File: app/phpunit.xml.dist --&gt;
&lt;phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.3/phpunit.xsd"
    backupGlobals="false"
    colors="true"
    bootstrap="./bootstrap.php"
&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="Test Suite"&gt;
            &lt;directory&gt;./src/AppBundle/Tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="testing-commands">Testing commands</h2>

<p>Now let's say we're testing the famous <a href="https://github.com/sensiolabs/SensioDistributionBundle/tree/master/Resources/skeleton/acme-demo-bundle/Acme/DemoBundle">AcmeDemoBundle</a>,
and its <a href="https://github.com/sensiolabs/SensioDistributionBundle/blob/master/Resources/skeleton/acme-demo-bundle/Acme/DemoBundle/Command/HelloWorldCommand.php">hello world command</a>:</p>

<pre><code class="php">&lt;?php

namespace Acme\DemoBundle\Tests\Command;

use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Output\NullOutput;
use Symfony\Component\Console\Input\ArrayInput;

class HelloWorldCommandTest extends \PHPUnit_Framework_TestCase
{
    private $app;
    private $output;

    protected function setUp()
    {
        $kernel = new \AppKernel('test', false);
        $this-&gt;app = new Application($kernel);
        $this-&gt;app-&gt;setAutoExit(false);
        $this-&gt;output = new NullOutput();
    }

    public function testItRunsSuccessfully()
    {
        $input = new ArrayInput(array(
            'commandName' =&gt; 'acme:hello',
            'name' =&gt; 'Igor',
        ));

        $exitCode = $this-&gt;app-&gt;run($input, $this-&gt;output);

        $this-&gt;assertSame(0, $exitCode);
    }
}
</code></pre>

<p>As you can see our test is neatly structured in 3 parts: input definition, the
actual call and finally the check.</p>

<blockquote>
  <p><strong>Note</strong>: the <code>setAutoExit</code> method will ensure that the application doesn't
  call PHP's <code>exit</code>. The <code>NullOutput</code> ensures that nothing is displayed.</p>
</blockquote>

<h2 id="testing-controllers">Testing controllers</h2>

<p>Once again let's test AcmeDemoBundle, this time the <a href="https://github.com/sensiolabs/SensioDistributionBundle/blob/master/Resources/skeleton/acme-demo-bundle/Acme/DemoBundle/Controller/DemoController.php">demo controller</a>:</p>

<pre><code class="php">&lt;?php

namespace Acme\DemoBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class DemoControllerTest extends \PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', false);
        $this-&gt;app-&gt;boot();
    }

    public function testHomepage()
    {
        $request = new Request::create('/', 'GET');

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertTrue($response-&gt;isSuccessful());
    }

    public function testItSaysHello()
    {
        $request = new Request('/hello/igor', 'GET');

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertTrue($response-&gt;isSuccessful());
    }

    public function testItSendsEmail()
    {
        $request = new Request('/contact', 'POST', array(
            'email' =&gt; 'igor@example.com',
            'content' =&gt; 'Hello',
        ));

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertTrue($response-&gt;isSuccessful());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: The <code>boot</code> method makes the container available.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>We stripped Symfony2 to its bare minimum and as a result we are now able to
write functional tests without any effort.</p>

<p>I hope you enjoyed this article, please feel free to
<a href="https://twitter.com/epiloic">tweet me</a> for any comment and question.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony2 Bundle, standalone]]></title>
            <link href="/2014/10/29/sf2-bundle-standalone.html"/>
            <updated>2014-10-29T00:00:00+00:00</updated>
            <id>/2014/10/29/sf2-bundle-standalone.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Create an empty application in your bundle to allow people to test
  it (manually or automatically) outside of an actual application.</p>
</blockquote>

<p><a href="http://symfony.com">Symfony2</a> bundles are a great way to:</p>

<ul>
<li>configure the application's Dependency Injection Container (DIC)</li>
<li>provide it with resources (mainly templates and assets)</li>
<li>register entry points (like controllers and commands)</li>
</ul>

<p>In this article, we will see how to make sure a third party bundle actually work
by creating an embed application. We will then have a look at its practical use:</p>

<ol>
<li><a href="#minimal-bundle">Minimal Bundle</a></li>
<li><a href="#embed-application">Embed Application</a></li>
<li><a href="#manual-tests">Manual tests</a>

<ul>
<li><a href="#running-commands">Running commands</a></li>
<li><a href="#browsing-pages">Browsing pages</a></li>
</ul></li>
<li><a href="#automated-tests">Automated tests</a>

<ul>
<li><a href="#container-tests">Container tests</a></li>
<li><a href="#functional-cli-tests">Functional CLI tests</a></li>
<li><a href="#functional-web-tests">Functional web tests</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ol>

<h2 id="minimal-bundle">Minimal Bundle</h2>

<p>Creating a bundle is fairly easy as you just need to create the following class:</p>

<pre><code class="php">&lt;?php
// File: AcmeStandaloneBundle.php

namespace Acme\StandaloneBundle;

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\HttpKernel\Bundle\Bundle;

class AcmeStandaloneBundle extends Bundle
{
}
</code></pre>

<p>It also needs a <code>composer.json</code> file, so it can be distributed all around the
world:</p>

<pre><code class="json">{
    "name": "acme/standalone-bundle",
    "type": "symfony-bundle",
    "license": "MIT",
    "autoload": {
        "psr-4": {
            "Acme\\StandaloneBundle\\": ""
        }
    },
    "require": {
        "symfony/http-kernel": "~2.3"
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: to release it, you would then need to create a git repository and
  to register it in <a href="https://packagist.org/">Packagist</a>.</p>
</blockquote>

<h2 id="embed-application">Embed Application</h2>

<p>Now how can we make sure our bundle would work in an application? We could:</p>

<ol>
<li>use an existing application</li>
<li>make the bundle's sources available in it somehow:

<ul>
<li>creating the bundle in the application</li>
<li>or making a symbolic link that points to the bundle</li>
</ul></li>
<li>register it in its <code>app/AppKernel.php</code> file and have a look...</li>
</ol>

<p>But we can do better!</p>

<p>We can create the smallest Symfony2 application ever <strong>inside</strong> our bundle:</p>

<pre><code class="php">&lt;?php
// File: Tests/app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Acme\StandaloneBundle\AcmeStandaloneBundle(),
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config.yml');
    }
}
</code></pre>

<p><a href="https://github.com/symfony/FrameworkBundle">FrameworkBundle</a> requires the
following configuration parameter in order to work:</p>

<pre><code class="yaml"># File: Tests/app/config.yml
framework:
    secret: "Three can keep a secret, if two of them are dead."
</code></pre>

<p>I'd also advise you to create an autoload file to make things easier:</p>

<pre><code class="php">&lt;?php
// File: Tests/app/autoload.php

$loader = require __DIR__.'/../../vendor/autoload.php';
require __DIR__.'/AppKernel.php';
</code></pre>

<p>The last step is to add the new dependency in the <code>composer.json</code> file:</p>

<pre><code class="json">{
    "name": "acme/standalone-bundle",
    "type": "symfony-bundle",
    "license": "MIT",
    "autoload": {
        "psr-4": {
            "Acme\\StandaloneBundle\\": ""
        }
    },
    "require": {
        "symfony/http-kernel": "~2.3"
    },
    "require-dev": {
        "symfony/framework-bundle": "~2.3"
    }
}
</code></pre>

<p>We would also need to ignore the following directories:</p>

<pre><code># File: .gitignore

/Tests/app/cache
/Tests/app/logs
</code></pre>

<p>And that's it, we now have a minimalistic embed application in our bundle.
As it can now be ran on its own, it has become a <strong>Standalone Bundle</strong>!</p>

<p>Let's see the practical use.</p>

<h2 id="manual-tests">Manual tests</h2>

<p>Because your bundle now doesn't need any existing applications to be used,
people will be able to test it manually and do some demonstrations with it.</p>

<h3 id="running-commands">Running commands</h3>

<p>Let's pretend we created a command in our bundle. We'd like to run it just to
make sure everything works as expected. For this we'll need to create an
embed console:</p>

<pre><code class="php">&lt;?php
// File: Tests/app/console.php

set_time_limit(0);

require_once __DIR__.'/autoload.php';

use Symfony\Bundle\FrameworkBundle\Console\Application;

$kernel = new AppKernel('dev', true);
$application = new Application($kernel);
$application-&gt;run();
</code></pre>

<p>That's it! You can now run:</p>

<pre><code>php Tests/app/console.php
</code></pre>

<h3 id="browsing-pages">Browsing pages</h3>

<p>Let's pretend we created a controller which returns some JSON data. We'd like to
browse it just to make sure everyting works as expected. For this, we'll need to
create an embed web app:</p>

<pre><code class="php">&lt;?php
// File: Tests/app/web.php

use Symfony\Component\HttpFoundation\Request;

require_once __DIR__.'/autoload.php';

$kernel = new AppKernel('prod', false);
$request = Request::createFromGlobals();
$response = $kernel-&gt;handle($request);
$response-&gt;send();
</code></pre>

<p>That's it! You can now run:</p>

<pre><code>php Tests/app/console.php server:run -d Tests/app
</code></pre>

<p>And browse your application.</p>

<blockquote>
  <p><strong>Note</strong>: If you use a templating engine like Twig to render HTML pages,
  or if you use the Symfony2 Form Component in your bundle, don't forget to add
  the dependencies to your <code>composer.json</code> file and to register the appropriate
  bundles to the embed <code>AppKernel</code>.</p>
</blockquote>

<h2 id="automated-tests">Automated tests</h2>

<p>Manual tests are great to get a quick idea of what your bundle does.
But an embed application is also great to write automated tests.</p>

<h3 id="container-tests">Container tests</h3>

<p>Let's pretend we created a service which is defined in the DIC. We'd like to
make sure it is properly configured (for e.g. checking if we forgot to inject a
dependency). For this, we'll need to created a simple test:</p>

<pre><code class="php">&lt;?php
// File: Tests/ServiceTest.php

namespace Acme\StandaloneBundle\Tests;

class ServiceTest extends \PHPUnit_Framework_TestCase
{
    private $container;

    protected function setUp()
    {
        $kernel = new \AppKernel('test', true);
        $kernel-&gt;boot();

        $this-&gt;container = $kernel-&gt;getContainer();
    }

    public function testServiceIsDefinedInContainer()
    {
        $service = $this-&gt;container-&gt;get('acme_standalone.service');

        $this-&gt;assertInstanceOf('Acme\StandaloneBundle\Service', $service);
    }
}
</code></pre>

<p>We need to add <a href="https://phpunit.de/">PHPUnit</a> as a development dependency:</p>

<pre><code class="json">{
    "name": "acme/standalone-bundle",
    "type": "symfony-bundle",
    "license": "MIT",
    "autoload": {
        "psr-4": {
            "Acme\\StandaloneBundle\\": ""
        }
    },
    "require": {
        "symfony/http-kernel": "~2.3"
    },
    "require-dev": {
        "symfony/framework-bundle": "~2.3",
        "phpunit/phpunit": "~4.3"
    }
}
</code></pre>

<p>Finally we need to configure PHPUnit to use our autoload:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- http://phpunit.de/manual/4.3/en/appendixes.configuration.html --&gt;
&lt;phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.3/phpunit.xsd"
    backupGlobals="false"
    colors="true"
    bootstrap="./Tests/app/autoload.php"
&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="Test Suite"&gt;
            &lt;directory&gt;./Tests/&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<p>That's it! You can now run:</p>

<pre><code>./vendor/bin/phpunit
</code></pre>

<blockquote>
  <p><strong>Note</strong>: You can of course use any testing framework of your choice.</p>
</blockquote>

<h3 id="functional-cli-tests">Functional CLI tests</h3>

<p>Let's pretend we created a command. We'd like to run it automatically and check
its exit code to make sure it works. For this, we'll need to created a simple
test:</p>

<pre><code class="php">&lt;?php
// File: Tests/ServiceTest.php

namespace Acme\StandaloneBundle\Tests\Command;

use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Output\NullOutput;

class DemoCommandTest extends \PHPUnit_Framework_TestCase
{
    private $application;

    protected function setUp()
    {
        $kernel = new AppKernel('dev', true);
        $this-&gt;application = new Application($kernel);
    }

    public function testItRunsSuccessfully()
    {
        $output = new NullOutput();
        $input = new ArrayInput(
            'command_name' =&gt; 'acme:demo',
            'argument' =&gt; 'value',
            '--option' =&gt; 'value',
        );
        $exitCode = $this-&gt;application-&gt;run($input, $output);

        $this-&gt;assertSame(0, $exitCode);
    }
}
</code></pre>

<p>And that's it!</p>

<h3 id="functional-web-tests">Functional web tests</h3>

<p>Let's pretend we created a controller which returns some JSON data. We'd like to
browse it automatically and check its status code to make sure it works. For
this, we'll need to created a simple test:</p>

<pre><code class="php">&lt;?php
// File: Tests/ServiceTest.php

namespace Acme\StandaloneBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Input\ArrayInput;
use Symfony\Component\Console\Output\NullOutput;

class DemoControllerTest extends \PHPUnit_Framework_TestCase
{
    private $client;

    protected function setUp()
    {
        $kernel = new AppKernel('test', true);
        $kernel-&gt;boot();

        $this-&gt;client = $kernel-&gt;getContainer()-&gt;get('test.client');
    }

    public function testItRunsSuccessfully()
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $content = array('parameter' =&gt; 'value');
        $response = $this-&gt;client-&gt;request(
            'POST',
            '/demo',
            array(),
            array(),
            $headers,
            $content
        );

        $this-&gt;assertTrue($response-&gt;isSuccessful());
    }
}
</code></pre>

<p>The <code>test.client</code> service is only available when the <code>test</code> configuration
parameter is set.</p>

<pre><code class="yaml"># File: Tests/app/config.yml
framework:
    secret: "Three can keep a secret, if two of them are dead."
    test: ~
</code></pre>

<p>And that's it!</p>

<blockquote>
  <p><strong>Note</strong>: When creating APIs, you might want to test the precise status code.</p>
</blockquote>

<h2 id="conclusion">Conclusion</h2>

<p>Creating an embed application in a third party bundle is fairly easy and brings
many advantages as it enables demonstrations and simple automated tests.</p>

<p>I hope you enjoyed this article, if you have any questions or comments, please
<a href="https://twitter.com/epiloic">let me know</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - Conclusion]]></title>
            <link href="/2014/10/08/master-sf2-conclusion.html"/>
            <updated>2014-10-08T00:00:00+01:00</updated>
            <id>/2014/10/08/master-sf2-conclusion.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the conclusion of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the five articles:</p>

<ul>
<li><a href="/2014/08/05/master-sf2-part-1-bootstraping.html">1: Bootstraping</a></li>
<li><a href="/2014/08/13/master-sf2-part-2-tdd.html">2: TDD</a></li>
<li><a href="/2014/08/22/master-sf2-part-3-services.html">3: Services</a></li>
<li><a href="/2014/08/27/master-sf2-part-4-doctrine.htm">4: Doctrine</a></li>
<li><a href="/2014/09/03/master-sf2-part-5-events.html">5: Events</a></li>
<li><a href="/2014/09/10/master-sf2-part-6-annotations.html">6: Annotations</a></li>
</ul>

<p>It quickly sums up what we've seen and provides some directions to the next
steps, for those interrested in learning more (there's always more!).</p>

<h2 id="summary">Summary</h2>

<p>In these 6 articles, we've learned how to master Symfony2 through:</p>

<ol>
<li>the usage of distributions to bootstrap our projects</li>
<li>the writing of simple functional tests (we used TDD/PHPUnit but any methodology/Framework can be used)</li>
<li>the creation of services and entities (where our business related code actually lies)</li>
<li>the usage of a third party library (Doctrine)</li>
<li>the extension of the framework via events (change the Request and Response at will)</li>
<li>the configuration via annotations, allowing to reduce the distance with the code</li>
</ol>

<p>As a bonus, we've also seen:</p>

<ul>
<li>the Repository Design Pattern (retrieve data and format it before using it)</li>
<li>the Symfony Console Component, which can be used as a standalone library</li>
</ul>

<h2 id="going-further">Going further</h2>

<p>There's still a deal lot more to learn, but with this series we've hopefully
seen the strict minimum to create any day to day application with deep knowledge
on how to extend the framework and where to put our code.</p>

<p>We've seen Symfony as a full stack framework: it deals with the HTTP protocol
for you. But the truth is that Symfony is a collection of third party libraries
before anything else. Here's a short selection of its available components:</p>

<ul>
<li>Validation: define constraints and check if the given variable complies to them</li>
<li>Form: define fields, generate the HTML form and populate variables from the request</li>
<li>Yaml: parse a yaml file</li>
<li>Security: check the identity users and their permissions</li>
</ul>

<p>Do you want to go further? Then have a look a these fabulous resources:</p>

<ul>
<li><a href="http://symfony.com/doc/current/index.html">The documentation</a></li>
<li><a href="https://twitter.com/raulfraile">Raul Fraile</a> overview articles on the:

<ul>
<li><a href="http://blog.servergrove.com/2013/09/23/symfony2-components-overview-httpfoundation/">HttpFoundation Component</a></li>
<li><a href="http://blog.servergrove.com/2013/09/30/symfony2-components-overview-httpkernel/">HttpKernel Component</a></li>
<li><a href="http://blog.servergrove.com/2013/10/08/symfony2-components-overview-routing/">Routing Component</a></li>
<li><a href="http://blog.servergrove.com/2013/10/23/symfony2-components-overview-eventdispatcher/">EventDispather Component</a></li>
<li><a href="http://blog.servergrove.com/2014/02/21/symfony2-components-overview-config/">Config Component</a></li>
<li><a href="http://blog.servergrove.com/2014/03/03/symfony2-components-overview-validator/">Validator Component</a></li>
<li><a href="http://blog.servergrove.com/2014/03/11/symfony2-components-overview-templating/">Templating Component</a></li>
<li><a href="http://blog.servergrove.com/2014/03/18/symfony2-components-overview-translation/">Translation Component</a></li>
<li><a href="http://blog.servergrove.com/2014/03/26/symfony2-components-overview-finder/">Finder Component</a></li>
<li><a href="http://blog.servergrove.com/2014/04/07/symfony2-components-overview-expression-language/">ExpressionLanguage Component</a></li>
<li><a href="http://blog.servergrove.com/2014/04/16/symfony2-components-overview-process/">Process Component</a></li>
</ul></li>
<li><a href="https://twitter.com/khepin">Sebastien Armand</a>'s book <a href="http://www.amazon.co.uk/Extending-Symfony-Web-Application-Framework/dp/1783287195">Extending Symfony Web Application Framework</a></li>
<li><a href="https://twitter.com/matthiasnoback">Matthias Noback</a>'s book <a href="http://www.amazon.co.uk/Year-With-Symfony-reusable-Symfony2/dp/9082120119">A Year with Symfony</a></li>
<li><a href="https://twitter.com/kriswallsmith">Kris Walsmith</a> slides on the <a href="http://www.slideshare.net/kriswallsmith/love-and-loss-a-symfony-security-play">Security Component</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 6: Annotations]]></title>
            <link href="/2014/09/10/master-sf2-part-6-annotations.html"/>
            <updated>2014-09-10T00:00:00+01:00</updated>
            <id>/2014/09/10/master-sf2-part-6-annotations.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the sixth article of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the four first ones:</p>

<ul>
<li><a href="/2014/08/05/master-sf2-part-1-bootstraping.html">1: Bootstraping</a></li>
<li><a href="/2014/08/13/master-sf2-part-2-tdd.html">2: TDD</a></li>
<li><a href="/2014/08/22/master-sf2-part-3-services.html">3: Services</a></li>
<li><a href="/2014/08/27/master-sf2-part-4-doctrine.htm">4: Doctrine</a></li>
<li><a href="/2014/09/03/master-sf2-part-5-events.html">5: Events</a></li>
</ul>

<p>In the previous articles we created an API allowing us to submit and list
quotes:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── doctrine.yml
│   │   ├── parameters.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── console
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Fortune
│       └── ApplicationBundle
│           ├── Controller
│           │   └── QuoteController.php
│           ├── DependencyInjection
│           │   └── FortuneApplicationExtension.php
│           ├── Entity
│           │   ├── QuoteFactory.php
│           │   ├── QuoteGateway.php
│           │   ├── Quote.php
│           │   └── QuoteRepository.php
│           ├── EventListener
│           │   └── SubmitJsonListener.php
│           ├── FortuneApplicationBundle.php
│           ├── Resources
│           │   └── config
│           │       ├── doctrine
│           │       │   └── Quote.orm.yml
│           │       └── services.xml
│           └── Tests
│               ├── Controller
│               │   └── QuoteControllerTest.php
│               └── Entity
│                   └── QuoteRepositoryTest.php
└── web
    └── app.php
</code></pre>

<p>Here's the <a href="https://github.com/gnugat/mastering-symfony2">repository where you can find the actual code</a>.</p>

<p>In this article, we'll discover annotations.</p>

<h2 id="doctrine-annotations">Doctrine Annotations</h2>

<p>Inspired by <a href="http://legacy.python.org/dev/peps/pep-0318/">Python Decorators</a> and
<a href="http://docs.oracle.com/javase/tutorial/java/annotations/">Java Annotations</a>,
the <a href="http://www.doctrine-project.org/">Doctrine Project</a> created a convenient
library allowing to put in the same file: information (like configuration) and
source code.</p>

<p>In concrete terms, <a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">Annotations</a>
are comments which are read by <code>AnnotationReader</code> and can then be cached in any
format (generally PHP) to make things faster afterwards.</p>

<p>It's main strength is the possibility to avoid having a configuration file in a
path too far from the source code which uses it. For example intead of having
the schema definition in <code>src/Fortune/ApplicationBundle/Resources/config/doctrine/Quote.orm.yml</code>
we could have it directly in the <code>QuoteEntity</code>.</p>

<h2 id="installing-sensio-frameworkextra-bundle">Installing Sensio FrameworkExtra Bundle</h2>

<p>The <a href="http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/index.html">Sensio FrameworkExtra Bundle</a>
provides controller annotations, amongst them lies <code>@Route</code> allowing us to move
the routing configuration from <code>app/config/routing.yml</code> directly to the actions.</p>

<p>Let's download the bundle:</p>

<pre><code>composer require sensio/framework-extra-bundle:~3.0
</code></pre>

<p>Then register it:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Fortune\ApplicationBundle\FortuneApplicationBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>Finally, we need to tell Doctrine's Annotation library  where to find the
classes by registering Composer's autoloader:</p>

<pre><code>&lt;?php
// File: app/autoload.php

use Doctrine\Common\Annotations\AnnotationRegistry;

$loader = require __DIR__.'/../vendor/autoload.php';

AnnotationRegistry::registerLoader(array($loader, 'loadClass'));

return $loader;
</code></pre>

<p>This file should be used in our front controller:</p>

<pre><code>&lt;?php

use Symfony\Component\HttpFoundation\Request;

require_once __DIR__.'/app/autoload.php';
require_once __DIR__.'/../app/AppKernel.php';

$kernel = new AppKernel('prod', false);
$request = Request::createFromGlobals();
$response = $kernel-&gt;handle($request);
$response-&gt;send();
$kernel-&gt;terminate($request, $response);
</code></pre>

<p>But also in our test suite:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit
    backupGlobals="false"
    colors="true"
    syntaxCheck="false"
    bootstrap="autoload.php"&gt;

    &lt;testsuites&gt;
        &lt;testsuite name="Functional Test Suite"&gt;
            &lt;directory&gt;../src/*/*/Tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="using-the-%40route-annotation">Using the @Route annotation</h2>

<p>We can now empty the <code>routing.yml</code> file and tell it to import the configuration
from the <code>QuoteController</code> using its annotations:</p>

<pre><code># File: app/config/routing.yml
fortune_application:
    resource: @FortuneApplicationBundle/Controller
    type: annotation
</code></pre>

<p>The controller itself will look like this:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    /**
     * @Route("/api/quotes", methods={"POST"})
     */
    public function submitAction(Request $request)
    {
        $postedValues = $request-&gt;request-&gt;all();
        if (empty($postedValues['content'])) {
            $answer = array('message' =&gt; 'Missing required parameter: content');

            return new JsonResponse($answer, Response::HTTP_UNPROCESSABLE_ENTITY);
        }
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quote = $quoteRepository-&gt;insert($postedValues['content']);

        return new JsonResponse($quote, Response::HTTP_CREATED);
    }

    /**
     * @Route("/api/quotes", methods={"GET"})
     */
    public function listAction(Request $request)
    {
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quotes = $quoteRepository-&gt;findAll();

        return new JsonResponse($quotes, Response::HTTP_OK);
    }
}
</code></pre>

<p>And now annotations are ready to be used, as the tests prove it:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>That's green enough for us to commit:</p>

<pre><code>git add -A
git commit -m 'Used annotations'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Annotations allow us to remove the distance between configuration and code.</p>

<blockquote>
  <p><strong>Note</strong>: You should know that annotations can
  <a href="https://r.je/php-annotations-are-an-abomination.html">raise concerns about tight coupling</a>,
  but it doesn't seem to be <a href="http://marekkalnik.tumblr.com/post/34047514685/are-annotations-really-bad">relevant when used as configuration</a>.</p>
  
  <p>The best thing to do is to minimize their use to the classes which are
  already coupled to our tools (for example the controllers) and do some
  research on the subject to make your own opinion.</p>
</blockquote>

<p>If the concept seduced you, have a look a <a href="https://github.com/mmoreram/ControllerExtraBundle">ControllerExtraBundle</a>.</p>

<p>The next artile will be the conclusion, I hope you enjoy this series!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 5: Events]]></title>
            <link href="/2014/09/03/master-sf2-part-5-events.html"/>
            <updated>2014-09-03T00:00:00+01:00</updated>
            <id>/2014/09/03/master-sf2-part-5-events.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fifth article of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the four first ones:</p>

<ul>
<li><a href="/2014/08/05/master-sf2-part-1-bootstraping.html">1: Bootstraping</a></li>
<li><a href="/2014/08/13/master-sf2-part-2-tdd.html">2: TDD</a></li>
<li><a href="/2014/08/22/master-sf2-part-3-services.html">3: Services</a></li>
<li><a href="/2014/08/27/master-sf2-part-4-doctrine.htm">4: Doctrine</a></li>
</ul>

<p>In the previous articles we created an API allowing us to submit and list
quotes:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── doctrine.yml
│   │   ├── parameters.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Fortune
│       └── ApplicationBundle
│           ├── Controller
│           │   └── QuoteController.php
│           ├── DependencyInjection
│           │   └── FortuneApplicationExtension.php
│           ├── Entity
│           │   ├── QuoteFactory.php
│           │   ├── QuoteGateway.php
│           │   ├── Quote.php
│           │   └── QuoteRepository.php
│           ├── FortuneApplicationBundle.php
│           ├── Resources
│           │   └── config
│           │       ├── doctrine
│           │       │   └── Quote.orm.yml
│           │       └── services.xml
│           └── Tests
│               ├── Controller
│               │   └── QuoteControllerTest.php
│               └── Entity
│                   └── QuoteRepositoryTest.php
└── web
    └── app.php
</code></pre>

<p>Here's the <a href="https://github.com/gnugat/mastering-symfony2">repository where you can find the actual code</a>.</p>

<p>In this one we'll learn how to extend the framework using events.</p>

<h2 id="eventdispatcher-component">EventDispatcher Component</h2>

<p>The <a href="http://symfony.com/doc/current/components/event_dispatcher/introduction.html">Event Dispatcher</a>
is another standalone component which can be summed up as follow:</p>

<pre><code>&lt;?php

class EventDispatcher
{
    private $events = array();

    public function addListener($event, $listener)
    {
        $this-&gt;events[$event][] = $listener;
    }

    public function dispatch($event)
    {
        foreach ($this-&gt;events[$event] as $listener) {
            $listener();
        }
    }
}
</code></pre>

<p>You can register listeners (which are callables) and then call them by
dispatching the subscribed event:</p>

<pre><code>$dispatcher = new EventDispatcher();
$dispatcher-&gt;addListener('before.boyard', function () { echo 'Ultimate Challenge'; });
$dispatcher-&gt;dispatch('before.boyard'); // Prints "Ultimate Challenge".
</code></pre>

<p>Here's the actual API:</p>

<pre><code>&lt;?php

namespace Symfony\Component\EventDispatcher;

interface EventDispatcherInterface
{
    public function dispatch($eventName, Event $event = null);

    public function addListener($eventName, $listener, $priority = 0);
    public function removeListener($eventName, $listener);
    public function getListeners($eventName = null);
    public function hasListeners($eventName = null);

    public function addSubscriber(EventSubscriberInterface $subscriber);
    public function removeSubscriber(EventSubscriberInterface $subscriber);
}
</code></pre>

<p>The Component handles priorities, and contrary to our previous example it needs
an <code>Event</code> object when dispatching events, allowing us to provide a context.</p>

<p>Subscribers are listeners which have a <code>getSubscribedEvents</code> method.</p>

<p><strong>Note</strong>: If you want to learn more about this component, have a look at
<a href="https://twitter.com/raulfraile">Raul Fraile</a>'s <a href="http://blog.servergrove.com/2013/10/23/symfony2-components-overview-eventdispatcher/">article</a>.</p>

<h2 id="in-the-fullstack-framework">In the fullstack framework</h2>

<p>The <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html">Symfony2 HttpKernel Component</a>
dispatches events to provide extension points, we can:</p>

<ul>
<li>modify the Request when it has just been received: <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#the-kernel-request-event">kernel.request</a></li>
<li>change the controller when it has been guessed: <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#the-kernel-controller-event">kernel.controller</a></li>
<li>use the value returned by the controller: <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#the-kernel-view-event">kernel.view</a></li>
<li>change the Response when it has been created: <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#the-kernel-response-event">kernel.response</a></li>
<li><a href="https://github.com/symfony/symfony/pull/8904">handle global state and cleanup</a>: kernel.finish_request</li>
<li>handle exceptions: <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#handling-exceptions-the-kernel-exception-event">kernel.exception</a></li>
</ul>

<p><strong>Note</strong>: exceptions are caught by default, but this can be disabled.</p>

<p>Here's the <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#component-http-kernel-event-table">full list of kernel events</a>.</p>

<p><strong>Note</strong>: If you want to learn more about those events, have a look at
<a href="https://twitter.com/matthiasnoback">Matthias Noback</a>'s book:
<a href="https://leanpub.com/a-year-with-symfony?utm_campaign=a-year-with-symfony&amp;utm_medium=embed&amp;utm_source=gnugat.github.io">A year with Symfony</a>.</p>

<p>The FrameworkBundle takes care of registering the listeners using the
Dependency Injection Container (DIC): we declare our listener as a service in
the configuration, with a specific tag.</p>

<p><strong>Note</strong>: the DIC can retrieve all the services with the given tag using
<code>findTaggedServiceIds</code>, making it easier to register listeners for example
(this is done in <code>Symfony\Component\EventDispatcher\DependencyInjection\RegisterListenersPass</code>
which is called in the <a href="https://github.com/symfony/symfony/blob/f940d92a32e4d70cbe045ab8e1b3c70d3eb6061e/src/Symfony/Bundle/FrameworkBundle/FrameworkBundle.php#L71">FrameworkBundle</a>).</p>

<h2 id="submitted-json">Submitted JSON</h2>

<p>In <code>QuoteController::submitAction</code>, we need to get the request's content and
convert it from JSON. This is a generic task which should be executed before
every controller: we can move it in an event listener.</p>

<p>First create the directory:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/EventListener
</code></pre>

<p>Then we create the actual listener:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/EventListener/SubmitJsonListener.php

namespace Fortune\ApplicationBundle\EventListener;

use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class SubmitJsonListener
{
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $content = $request-&gt;getContent();
        $data = json_decode($content, true);
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>Next we register it in the Dependency Injection Container:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;!-- File: src/Fortune/ApplicationBundle/Resources/config/services.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="fortune_application.quote_factory"
            class="Fortune\ApplicationBundle\Entity\QuoteFactory"
        &gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_gateway"
            class="Fortune\ApplicationBundle\Entity\QuoteGateway"
            factory-service="doctrine"
            factory-method="getRepository"&gt;
            &lt;argument&gt;FortuneApplicationBundle:Quote&lt;/argument&gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_repository"
            class="Fortune\ApplicationBundle\Entity\QuoteRepository"
        &gt;
            &lt;argument type="service" id="fortune_application.quote_gateway" /&gt;
            &lt;argument type="service" id="fortune_application.quote_factory" /&gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.submit_json_listener"
            class="Fortune\ApplicationBundle\EventListener\SubmitJsonListener"
        &gt;
            &lt;tag name="kernel.event_listener" event="kernel.request" method="onKernelRequest" /&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>And finally we update the controller:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    public function submitAction(Request $request)
    {
        $postedValues = $request-&gt;request-&gt;all();
        if (empty($postedValues['content'])) {
            $answer = array('message' =&gt; 'Missing required parameter: content');

            return new JsonResponse($answer, Response::HTTP_UNPROCESSABLE_ENTITY);
        }
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quote = $quoteRepository-&gt;insert($postedValues['content']);

        return new JsonResponse($quote, Response::HTTP_CREATED);
    }

    public function listAction(Request $request)
    {
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quotes = $quoteRepository-&gt;findAll();

        return new JsonResponse($quotes, Response::HTTP_OK);
    }
}
</code></pre>

<p>We can now run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>No regression detected! We can commit our work:</p>

<pre><code>git add -A
git ci -m 'Used event'
</code></pre>

<p><strong>Note</strong>: The <a href="https://github.com/FriendsOfSymfony/FOSRestBundle">FOSRestBundle</a>
provides such an event listener. We're only creating it manually here to learn
about events.</p>

<h2 id="managing-errors-in-a-listener">Managing errors in a listener</h2>

<p>If someone submits a malformed JSON, our listener can stop the execution and
return a proper response:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/EventListener/SubmitJsonListener.php

namespace Fortune\ApplicationBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class SubmitJsonListener
{
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $content = $request-&gt;getContent();
        $data = json_decode($content, true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $data = array('message' =&gt; 'Invalid or malformed JSON');
            $response = new JsonResponse($data, Response::HTTP_BAD_REQUEST);
            $event-&gt;setResponse($response);
            $event-&gt;stopPropagation();
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>By setting a response in the event, the <code>HttpKernel</code> will almost stop (it
dispatches a <code>kernel.response</code> event and an extra <code>kernel.finish_request</code> event)
and return it.</p>

<p>By using <code>stopPropagation</code>, we prevent further <code>kernel.request</code> listeners from
being executed.</p>

<p>Have a look at <a href="https://github.com/symfony/symfony/blob/f940d92a32e4d70cbe045ab8e1b3c70d3eb6061e/src/Symfony/Component/HttpKernel/HttpKernel.php#L120">HttpKernel::handleRaw</a>
to discover what's going on.</p>

<p>Let's run the tests one last time:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>All green, we can commit our work:</p>

<pre><code>git add -A
git ci -m 'Handled errors'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Events are a powerful way to extend the framework: you create a listener,
register it on a specific event and you're done.</p>

<p>Kernel events aren't the only ones available:
<a href="http://doctrine-orm.readthedocs.org/en/latest/reference/events.html">Doctrine provides its own</a>,
(it uses its own event dispatcher library)
<a href="http://symfony.com/doc/current/components/form/form_events.html">the Symfony2 Form Component uses them</a>
and we could even <a href="http://isometriks.com/symfony2-custom-events">create our own events</a>!</p>

<p>The only drawback is that they're sort of hidden: by looking at the controller's
code we cannot know that submitted JSON has been handled, we lose explicitness.</p>

<p>The next article will be about annotations.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 4: Doctrine]]></title>
            <link href="/2014/08/27/master-sf2-part-4-doctrine.html"/>
            <updated>2014-08-27T00:00:00+01:00</updated>
            <id>/2014/08/27/master-sf2-part-4-doctrine.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fourth article of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the three first ones:</p>

<ul>
<li><a href="/2014/08/05/master-sf2-part-1-bootstraping.html">1: Bootstraping</a></li>
<li><a href="/2014/08/13/master-sf2-part-2-tdd.html">2: TDD</a></li>
<li><a href="/2014/08/22/master-sf2-part-3-services.html">3: Services</a></li>
</ul>

<p>In the previous articles we created an API allowing us to submit and list
quotes:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── parameters.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Fortune
│       └── ApplicationBundle
│           ├── Controller
│           │   └── QuoteController.php
│           ├── DependencyInjection
│           │   └── FortuneApplicationExtension.php
│           ├── Entity
│           │   ├── QuoteFactory.php
│           │   ├── QuoteGateway.php
│           │   ├── Quote.php
│           │   └── QuoteRepository.php
│           ├── FortuneApplicationBundle.php
│           ├── Resources
│           │   └── config
│           │       └── services.xml
│           └── Tests
│               ├── Controller
│               │   └── QuoteControllerTest.php
│               └── Entity
│                   └── QuoteRepositoryTest.php
└── web
    └── app.php
</code></pre>

<p>Here's the <a href="https://github.com/gnugat/mastering-symfony2">repository where you can find the actual code</a>.</p>

<p>In this one we'll use real database persistence using
<a href="http://www.doctrine-project.org/projects/orm.html">Doctrine ORM</a>, a third party
bundle, the command line console and a mocking library.</p>

<p><strong>Note</strong>: Symfony2 isn't coupled to any ORM or database library. We could use
anything else like <a href="http://php.net/manual/en/book.pdo.php">PDO</a>,
<a href="http://propelorm.org/">Propel ORM</a>, <a href="http://www.pomm-project.org/">POMM</a>, or
anything you want!</p>

<h2 id="installing-doctrinebundle">Installing DoctrineBundle</h2>

<p>Just like Symfony, Doctrine is composed of many libraries which can be used
separately. The two main ones are:</p>

<ul>
<li>the DataBase Abstraction Layer (DBAL), provides a unique API for many database
vendors (MySQL, PostgreSQL, Oracle, etc)</li>
<li>the Object Relation Mapping (ORM), provides an object oriented way to depict
the data (which are usually relational)</li>
</ul>

<p>DoctrineBundle registers the library's services into our Dependency Injection
Container. It can be installed quickly:</p>

<pre><code>composer require 'doctrine/doctrine-bundle:~1.2'
</code></pre>

<p>The bundle doesn't force you to use the ORM (you can simply use the DBAL), so we
need to explicitly install it:</p>

<pre><code>composer require 'doctrine/orm:~2.2,&gt;=2.2.3'
</code></pre>

<p>The bundle has to be registered in our application:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Fortune\ApplicationBundle\FortuneApplicationBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>Its services depend on some configuration parameters, which we will add:</p>

<pre><code># File: app/config/config.yml
imports:
    - { resource: parameters.yml }
    - { resource: doctrine.yml }

framework:
    secret: %secret%
    router:
        resource: %kernel.root_dir%/config/routing.yml
</code></pre>

<p>Next we create the actual configuration:</p>

<pre><code># File: app/config/doctrine.yml
doctrine:
    dbal:
        driver: pdo_mysql
        host: 127.0.0.1
        port: ~
        dbname: %database_name%
        user: %database_user%
        password: %database_password%
        charset: UTF8

    orm:
        auto_generate_proxy_classes: %kernel.debug%
        auto_mapping: true
</code></pre>

<p><strong>Note</strong>: the <code>~</code> value is equivalent to <code>null</code> in PHP.</p>

<p>The values surrounded by <code>%</code> will be replaced by parameters coming from the DIC.
For example, <code>kernel.debug</code> is set by the FrameworkBundle. We'll set the values
of the database ones in the following file:</p>

<pre><code># File: app/config/parameters.yml
parameters:
    secret: hazuZRqYGdRrL8ATdB8kAqBZ

    database_name: fortune
    database_user: root
    database_password: ~
</code></pre>

<p>For security reason, this file is not commited. You can update the distributed
file though, so your team will know that they need to set a value:</p>

<pre><code># File: app/config/parameters.yml.dist
parameters:
    secret: ChangeMePlease

    database_name: fortune
    database_user: root
    database_password: ~
</code></pre>

<h2 id="configuring-the-schema">Configuring the schema</h2>

<p>The first thing we need is to define the schema (tables with their fields), so
we'll create this directory:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/Resources/config/doctrine
</code></pre>

<p>And then the configuration file for the <code>Quote</code> entity:</p>

<pre><code># src/Fortune/ApplicationBundle/Resources/config/doctrine/Quote.orm.yml
Fortune\ApplicationBundle\Entity\Quote:
    type: entity
    repositoryClass: Fortune\ApplicationBundle\Entity\QuoteGateway
    table: quote
    id:
        id:
            type: integer
            generator:
                strategy: AUTO
    fields:
        content:
            type: text
        createdAt:
            type: datetime
            column: created_at
</code></pre>

<p><strong>Note</strong>: Doctrine uses the word "Repository" with a different meaning than the
Repository design pattern (the one with gateway and factory). In our case it
corresponds to the gateway.</p>

<p>As you can see, we've added a <code>createdAt</code> attribute to our entity. Let's update
its code:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/Quote.php

namespace Fortune\ApplicationBundle\Entity;

class Quote
{
    private $id;
    private $content;
    private $createdAt;

    public function __construct($id, $content)
    {
        $this-&gt;id = $id;
        $this-&gt;content = $content;
        $this-&gt;createdAt = new \DateTime();
    }

    public static function fromContent($content)
    {
        return new Quote(null, $content);
    }

    public function getId()
    {
        return $this-&gt;id;
    }

    public function getContent()
    {
        return $this-&gt;content;
    }

    public function getCreatedAt()
    {
        return $this-&gt;createdAt;
    }
}
</code></pre>

<p><strong>Note</strong>: We've added <a href="http://verraes.net/2014/06/named-constructors-in-php/">a named constructor</a>
which will prove usefull with the gateway.</p>

<h2 id="creating-the-console">Creating the console</h2>

<p>Symfony2 provides a powerful <a href="http://symfony.com/doc/current/components/console/introduction.html">Console Component</a>
allowing you to create command line utilities. It can be used standalone, or
in the full stack framework thanks to the FrameworkBundle. To create the
console, we just need to create the following file:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: app/console

set_time_limit(0);

require_once __DIR__.'/../vendor/autoload.php';
require_once __DIR__.'/AppKernel.php';

use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Input\ArgvInput;

$input = new ArgvInput();
$kernel = new AppKernel('dev', true);
$application = new Application($kernel);
$application-&gt;run($input);
</code></pre>

<p>The object <code>ArgvInput</code> contains the input given by the user (command name,
arguments and options). Bundles can register commands in the application by
fetching them from their <code>Command</code> directory.</p>

<p>We can now create the database and schema easily:</p>

<pre><code>php app/console doctrine:database:create
php app/console doctrine:schema:create
</code></pre>

<p><strong>Note</strong>: Those are useful when developing the application, but shouldn't be used in
production.</p>

<p><strong>Note</strong>: If you want to learn more about the Symfony2 Console Component,
<a href="/2014/04/09/sf2-console-component-by-example.html">you can read this article</a>.</p>

<h2 id="adapting-the-gateway">Adapting the Gateway</h2>

<p>Until now, our <code>QuoteGateway</code> was saving and retrieving the quotes from a file.
We'll update it to be a Doctrine Repository:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/QuoteGateway.php

namespace Fortune\ApplicationBundle\Entity;

use Doctrine\ORM\EntityRepository;

class QuoteGateway extends EntityRepository
{
    public function insert($content)
    {
        $entityManager = $this-&gt;getEntityManager();

        $quote = Quote::fromContent($content);
        $entityManager-&gt;persist($quote);
        $entityManager-&gt;flush();

        return $quote;
    }
}
</code></pre>

<p>The <code>EntityManager</code> object does the actual persistence and will set the quote's
ID. The <code>EntityRepository</code> already has a <code>findAll</code> method, so we can remove it.</p>

<p>The last thing we need is to update the DIC's configuration:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;!-- File: src/Fortune/ApplicationBundle/Resources/config/services.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="fortune_application.quote_factory"
            class="Fortune\ApplicationBundle\Entity\QuoteFactory"
        &gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_gateway"
            class="Fortune\ApplicationBundle\Entity\QuoteGateway"
            factory-service="doctrine"
            factory-method="getRepository"&gt;
            &lt;argument&gt;FortuneApplicationBundle:Quote&lt;/argument&gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_repository"
            class="Fortune\ApplicationBundle\Entity\QuoteRepository"
        &gt;
            &lt;argument type="service" id="fortune_application.quote_gateway" /&gt;
            &lt;argument type="service" id="fortune_application.quote_factory" /&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>The <code>doctrine</code> service manages the Doctrine Repositories. To manually get a
repository you'd need to do somethig like
<code>$container-&gt;get('doctrine')-&gt;getRepository('FortuneApplicationBundle:QuoteGateway')</code>,
the <code>factory-service</code> and <code>factory-method</code> attributes allow us to simply call
container->get('fortune_application.quote_gateway')`.</p>

<h2 id="mocking-the-database">Mocking the database</h2>

<p>Database operations can be slow however we want our tests to run as fast as
possible: <a href="http://blog.8thlight.com/uncle-bob/2014/05/10/WhenToMock.html">this is a good opportunity to use a test double</a>.</p>

<p>PHPUnit comes with its own mocking library, but we'll use a less verbose and
more one: <a href="https://github.com/phpspec/prophecy">Prophecy</a>. First we install
the PHPUnit integration of Prophecy:</p>

<pre><code>composer require --dev 'phpspec/prophecy-phpunit:~1.0'
</code></pre>

<p>Then we update our test:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Tests/Entity/QuoteRepositoryTest.php

namespace Fortune\ApplicationBundle\Tests\Entity;

use Fortune\ApplicationBundle\Entity\Quote;
use Fortune\ApplicationBundle\Entity\QuoteFactory;
use Fortune\ApplicationBundle\Entity\QuoteGateway;
use Fortune\ApplicationBundle\Entity\QuoteRepository;
use Prophecy\PhpUnit\ProphecyTestCase;

class QuoteRepositoryTest extends ProphecyTestCase
{
    const ID = 42;
    const CONTENT = '&lt;KnightOfNi&gt; Ni!';

    private $gateway;
    private $repository;

    public function setUp()
    {
        parent::setUp();
        $gatewayClassname = 'Fortune\ApplicationBundle\Entity\QuoteGateway';
        $this-&gt;gateway = $this-&gt;prophesize($gatewayClassname);
        $factory = new QuoteFactory();
        $this-&gt;repository = new QuoteRepository($this-&gt;gateway-&gt;reveal(), $factory);
    }

    public function testItPersistsTheQuote()
    {
        $quote = new Quote(self::ID, self::CONTENT);
        $this-&gt;gateway-&gt;insert(self::CONTENT)-&gt;willReturn($quote);
        $this-&gt;repository-&gt;insert(self::CONTENT);

        $this-&gt;gateway-&gt;findAll()-&gt;willReturn(array($quote));
        $quotes = $this-&gt;repository-&gt;findAll();
        $foundQuote = $quotes['quotes'][self::ID];

        $this-&gt;assertSame(self::CONTENT, $foundQuote['content']);
    }
}
</code></pre>

<p>We created a mock of <code>QuoteGateway</code> which returns a quote we created beforehand.</p>

<p>Our changes are finished, let's run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>No regression detected! We can commit our work:</p>

<pre><code>git add -A
git ci -m 'Added doctrine'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Doctrine allows us to persist the data, its bundle integrates it smoothly into
our application and provides us with handy command line tools.</p>

<p>You can have a look at <a href="http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/reference/introduction.html">Doctrine Migration</a>,
a standalone library allowing you to deploy database changes, it even has
<a href="http://symfony.com/doc/current/bundles/DoctrineMigrationsBundle/index.html">a bundle</a>.</p>

<p>In the next article, we'll talk about how to extend the framework using events.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 3: Services]]></title>
            <link href="/2014/08/22/master-sf2-part-3-services.html"/>
            <updated>2014-08-22T00:00:00+01:00</updated>
            <id>/2014/08/22/master-sf2-part-3-services.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the third article of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the two first ones:</p>

<ul>
<li><a href="/2014/08/05/master-sf2-part-1-bootstraping.html">1: Bootstraping</a></li>
<li><a href="/2014/08/13/master-sf2-part-2-tdd.html">2: TDD</a></li>
</ul>

<p>In the previous articles we created an API allowing us to submit new quotes:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── parameters.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Fortune
│       └── ApplicationBundle
│           ├── Controller
│           │   └── QuoteController.php
│           ├── FortuneApplicationBundle.php
│           └── Tests
│               └── Controller
│                   └── QuoteControllerTest.php
└── web
    └── app.php
</code></pre>

<p>Here's the <a href="https://github.com/gnugat/mastering-symfony2">repository where you can find the actual code</a>.</p>

<p>In this one we'll list the existing quotes and learn about entities, services,
the repository design pattern and dependency injection.</p>

<h2 id="defining-the-second-user-story">Defining the second User Story</h2>

<p>By the time we finished to implement the first User Story, Nostradamus (our
customer and product owner) wrote the second one:</p>

<pre><code>As a User
I want to be able to read the available quotes
In order to find interesting ones
</code></pre>

<p>Currently we don't persist our quotes, but now we will need to. However I'd like
to dedicate a separate article to database persistence, so we will save our
quotes in a file and concentrate on services.</p>

<h2 id="the-quote-entity">The quote entity</h2>

<p>Until now we wrote our code in the controller and it was ok, as there wasn't
much code. But now our application will grow, so we need to put the code
elsewhere: in the services.</p>

<p>Basically a service is just a class which does one thing (and does it well).
They are stateless, which means that calling a method many times with the same
parameter should always return the same value.</p>

<p>They manipulate entities which are classes representing the data. Those don't
have any behavior. Let's create the <code>Entity</code> directory:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/Entity
</code></pre>

<p>And now we'll write the <code>Quote</code> entity:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/Quote.php

namespace Fortune\ApplicationBundle\Entity;

class Quote
{
    private $id;
    private $content;

    public function __construct($id, $content)
    {
        $this-&gt;id = $id;
        $this-&gt;content = $content;
    }

    public function getId()
    {
        return $this-&gt;id;
    }

    public function getContent()
    {
        return $this-&gt;content;
    }
}
</code></pre>

<p>There's no need to write a unit test for it: it doesn't contain any logic. The
tests of its services (which manipulate it) will be enough.</p>

<h2 id="the-repository-service">The repository service</h2>

<p>We'll create a persistence service which will follow the
<a href="http://code.tutsplus.com/tutorials/the-repository-design-pattern--net-35804">Repository design pattern</a>:
the repository calls a gateway to retreive some raw data and transforms it using
a factory.</p>

<p>Before creating it, we will write a unit test which will help us to specify how
it should work. Here's its directory:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/Tests/Entity
</code></pre>

<p>And its code:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Tests/Entity/QuoteRepositoryTest.php

namespace Fortune\ApplicationBundle\Tests\Entity;

use Fortune\ApplicationBundle\Entity\QuoteFactory;
use Fortune\ApplicationBundle\Entity\QuoteGateway;
use Fortune\ApplicationBundle\Entity\QuoteRepository;

class QuoteRepositoryTest extends \PHPUnit_Framework_TestCase
{
    const CONTENT = '&lt;KnightOfNi&gt; Ni!';

    private $repository;

    public function setUp()
    {
        $filename = '/tmp/fortune_database_test.txt';
        $gateway = new QuoteGateway($filename);
        $factory = new QuoteFactory();
        $this-&gt;repository = new QuoteRepository($gateway, $factory);
    }

    public function testItPersistsTheQuote()
    {
        $quote = $this-&gt;repository-&gt;insert(self::CONTENT);
        $id = $quote['quote']['id'];
        $quotes = $this-&gt;repository-&gt;findAll();
        $foundQuote = $quotes['quotes'][$id];

        $this-&gt;assertSame(self::CONTENT, $foundQuote['content']);
    }
}
</code></pre>

<p>Now we can create the class which should make the test pass:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/QuoteRepository.php

namespace Fortune\ApplicationBundle\Entity;

class QuoteRepository
{
    private $gateway;
    private $factory;

    public function __construct(QuoteGateway $gateway, QuoteFactory $factory)
    {
        $this-&gt;gateway = $gateway;
        $this-&gt;factory = $factory;
    }

    public function insert($content)
    {
        $quote = $this-&gt;gateway-&gt;insert($content);

        return $this-&gt;factory-&gt;makeOne($quote);
    }

    public function findAll()
    {
        $quotes = $this-&gt;gateway-&gt;findAll();

        return $this-&gt;factory-&gt;makeAll($quotes);
    }
}
</code></pre>

<p>See what we've done in the constructor? That's dependency injection (passing
arguments on which the class relies).</p>

<p><strong>Note</strong>: for more information about the Dependency Injection,
<a href="/2014/01/22/ioc-di-and-service-locator.html">you can read this article</a>.</p>

<h3 id="the-gateway-service">The gateway service</h3>

<p>The gateway is the class where the actual persistence is done:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/QuoteGateway.php

namespace Fortune\ApplicationBundle\Entity;

class QuoteGateway
{
    private $filename;

    public function __construct($filename)
    {
        $this-&gt;filename = $filename;
    }

    public function insert($content)
    {
        $content = trim($content);
        $line = $content."\n";
        file_put_contents($this-&gt;filename, $line, FILE_APPEND);
        $lines = file($this-&gt;filename);
        $lineNumber = count($lines) - 1;

        return new Quote($lineNumber, $content);
    }

    public function findAll()
    {
        $contents = file($this-&gt;filename);
        foreach ($contents as $id =&gt; $content) {
            $quotes[$id] = new Quote($id, trim($content));
        }

        return $quotes;
    }
}
</code></pre>

<p>Wait a minute, we didn't write any test for this class! Well, that's because
<code>QuoteRepositoryTest</code> already covers it.</p>

<h2 id="the-factory-service">The factory service</h2>

<p>The factroy converts the object returned by the gateway to something usable by
the controller (a JSONable array):</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/QuoteFactory.php

namespace Fortune\ApplicationBundle\Entity;

class QuoteFactory
{
    public function makeOne(Quote $rawQuote)
    {
        return array('quote' =&gt; $this-&gt;make($rawQuote));
    }

    public function makeAll(array $rawQuotes)
    {
        foreach ($rawQuotes as $rawQuote) {
            $quotes['quotes'][$rawQuote-&gt;getId()] = $this-&gt;make($rawQuote);
        }

        return $quotes;
    }

    private function make(Quote $rawQuote)
    {
        return array(
            'id' =&gt; $rawQuote-&gt;getId(),
            'content' =&gt; $rawQuote-&gt;getContent(),
        );
    }
}
</code></pre>

<p>No unit test for this factory: the one for the repository already covers it.
Now that the code is written, we can check that the test pass:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<h2 id="using-the-service-in-the-controller">Using the service in the controller</h2>

<p>The controller responsibility is to retrieve the parameters from the request,
inject them in a service and then use its return value to create a response.
We won't construct directly the <code>QuoteRepository</code> service in the controller:
Symfony2 comes with a <a href="http://symfony.com/doc/current/components/dependency_injection/introduction.html">Dependency Injection Container</a> (DIC).
In a nutshell when you ask the container a service, it will construct it for
you.</p>

<p>The first thing we need is to prepare the bundle by creating the following
directories:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/DependencyInjection
mkdir -p src/Fortune/ApplicationBundle/Resources/config
</code></pre>

<p>Then we need to create a class which will load the bundle's services into the
DIC:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/DependencyInjection/FortuneApplicationExtension.php

namespace Fortune\ApplicationBundle\DependencyInjection;

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\HttpKernel\DependencyInjection\Extension;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

class FortuneApplicationExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $fileLocator = new FileLocator(__DIR__.'/../Resources/config');
        $loader = new XmlFileLoader($container, $fileLocator);

        $loader-&gt;load('services.xml');
    }
}
</code></pre>

<p>As you can see, we told the extension to look for a configuration file. Here it
is:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;!-- File: src/Fortune/ApplicationBundle/Resources/config/services.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="fortune_application.quote_factory"
            class="Fortune\ApplicationBundle\Entity\QuoteFactory"
        &gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_gateway"
            class="Fortune\ApplicationBundle\Entity\QuoteGateway"
        &gt;
            &lt;argument&gt;/tmp/fortune_database.txt&lt;/argument&gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_repository"
            class="Fortune\ApplicationBundle\Entity\QuoteRepository"
        &gt;
            &lt;argument type="service" id="fortune_application.quote_gateway" /&gt;
            &lt;argument type="service" id="fortune_application.quote_factory" /&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>Now <code>QuoteRepository</code> is available in the controller:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    public function submitAction(Request $request)
    {
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);
        if (empty($postedValues['content'])) {
            $answer = array('message' =&gt; 'Missing required parameter: content');

            return new JsonResponse($answer, Response::HTTP_UNPROCESSABLE_ENTITY);
        }
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quote = $quoteRepository-&gt;insert($postedValues['content']);

        return new JsonResponse($quote, Response::HTTP_CREATED);
    }
}
</code></pre>

<p>We can now make sure that everything is fine by running the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p><strong>Note</strong>: for more information about Symfony2 Dependency Injection Component
<a href="/2014/01/29/sf2-di-component-by-example.html">you can read this article</a>.</p>

<h2 id="listing-quotes">Listing quotes</h2>

<p>It's now time to fulfill the second user story, starting with a functional test:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Tests/Controller/QuoteControllerTest.php

namespace Fortune\ApplicationBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class QuoteControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), $headers, $content);

        return $client-&gt;getResponse();
    }

    private function get($uri)
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $client = static::createClient();
        $client-&gt;request('GET', $uri, array(), array(), $headers);

        return $client-&gt;getResponse();
    }

    public function testSubmitNewQuote()
    {
        $response = $this-&gt;post('/api/quotes', array('content' =&gt; '&lt;KnightOfNi&gt; Ni!'));

        $this-&gt;assertSame(Response::HTTP_CREATED, $response-&gt;getStatusCode());
    }

    public function testSubmitEmptyQuote()
    {
        $response = $this-&gt;post('/api/quotes', array('content' =&gt; ''));

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY, $response-&gt;getStatusCode());
    }

    public function testSubmitNoQuote()
    {
        $response = $this-&gt;post('/api/quotes', array());

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY, $response-&gt;getStatusCode());
    }

    public function testListingAllQuotes()
    {
        $response = $this-&gt;get('/api/quotes');

        $this-&gt;assertSame(Response::HTTP_OK, $response-&gt;getStatusCode());
    }
}
</code></pre>

<p>The next step is to update the configuration:</p>

<pre><code># File: app/config/routing.yml
submit_quote:
    path: /api/quotes
    methods:
        - POST
    defaults:
        _controller: FortuneApplicationBundle:Quote:submit

list_quotes:
    path: /api/quotes
    methods:
        - GET
    defaults:
        _controller: FortuneApplicationBundle:Quote:list
</code></pre>

<p>Then we write the action:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    public function submitAction(Request $request)
    {
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);

        if (empty($postedValues['content'])) {
            $answer = array('message' =&gt; 'Missing required parameter: content');

            return new JsonResponse($answer, Response::HTTP_UNPROCESSABLE_ENTITY);
        }
        $quote = $quoteRepository-&gt;insert($postedValues['content']);

        return new JsonResponse($quote, Response::HTTP_CREATED);
    }

    public function listAction(Request $request)
    {
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quotes = $quoteRepository-&gt;findAll();

        return new JsonResponse($quotes, Response::HTTP_OK);
    }
}
</code></pre>

<p>And finally we run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>Everything is fine, we can commit:</p>

<pre><code>git add -A
git ci -m 'Added listing of quotes'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Services is where the logic should be. Those manipulate entities, which carry
the data. We used the repository design pattern which is very handy for APIs:
it calls a gateway which retrieves raw data and then convert it using a factory,
so the controller only needs to comunicate with the repository. Finally, we saw
that "Dependency Injection" is just a fancy term for "passing arguments".</p>

<p>In the next article, we'll learn use database persistence, using
<a href="http://www.doctrine-project.org/projects/orm.html">Doctrine2 ORM</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 2: Test Driven Development]]></title>
            <link href="/2014/08/13/master-sf2-part-2-tdd.html"/>
            <updated>2014-08-13T00:00:00+01:00</updated>
            <id>/2014/08/13/master-sf2-part-2-tdd.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the second article of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the first one:
<a href="/2014/08/05/master-sf2-part-1-bootstraping.html">Bootstraping</a>.</p>

<p>In the first article we bootstraped our project with the following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Fortune
│       └── ApplicationBundle
│           └── FortuneApplicationBundle.php
└── web
    └── app.php
</code></pre>

<p>Here's the <a href="https://github.com/gnugat/mastering-symfony2">repository where you can find the actual code</a>.</p>

<p>In this one we'll implement the first User Story, by writing tests first.</p>

<p><strong>Note</strong>: writing tests before writing any code is part of the
<a href="/2014/02/19/test-driven-development.html">Test Driven Development (TDD) methodology</a>.</p>

<h2 id="defining-the-user-story">Defining the User Story</h2>

<p>With the help of our Scrum Master, our Product Owner (Nostradamus) managed to
write the following user story:</p>

<pre><code>As a User
I want to be able to submit a new quote
In order to make it available
</code></pre>

<h2 id="writing-the-test">Writing the test</h2>

<p>Our first reflex will be to write a functional test. First create the directory:</p>

<pre><code>mkdir -p src/Fortune/ApplicationBundle/Tests/Controller
</code></pre>

<p>Then the test class:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Tests/Controller/QuoteControllerTest.php

namespace Fortune\ApplicationBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class QuoteControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), $headers, $content);

        return $client-&gt;getResponse();
    }

    public function testSubmitNewQuote()
    {
        $response = $this-&gt;post('/api/quotes', array('content' =&gt; '&lt;KnightOfNi&gt; Ni!'));

        $this-&gt;assertSame(Response::HTTP_CREATED, $response-&gt;getStatusCode());
    }
}
</code></pre>

<h2 id="configuring-the-route">Configuring the route</h2>

<p>Now we need to link the <code>/quotes</code> URL to a controller, so let's edit the
configuration:</p>

<pre><code># File: app/config/routing.yml
submit_quote:
    path: /api/quotes
    methods:
        - POST
    defaults:
        _controller: FortuneApplicationBundle:Quote:submit
</code></pre>

<h2 id="creating-the-controller">Creating the controller</h2>

<p>There wasn't any controllers until now, so we create the directory:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/Controller
</code></pre>

<p>And finally the controller class:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    public function submitAction(Request $request)
    {
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);

        $answer['quote']['content'] = $postedValues['content'];

        return new JsonResponse($answer, Response::HTTP_CREATED);
    }
}
</code></pre>

<p>Now let's run our tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p><a href="https://www.youtube.com/watch?v=lFeLDc2CzOs">All green</a>! This makes us
confident enough to commit our work:</p>

<pre><code>git add -A
git commit -m 'Created submission of quotes'
</code></pre>

<h2 id="testing-bad-cases">Testing bad cases</h2>

<p>The submitted content shouldn't be empty. Let's add a test for the bad cases:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Tests/Controller/QuoteControllerTest.php

namespace Fortune\ApplicationBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class QuoteControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), $headers, $content);

        return $client-&gt;getResponse();
    }

    public function testSubmitNewQuote()
    {
        $response = $this-&gt;post('/api/quotes', array('content' =&gt; '&lt;KnightOfNi&gt; Ni!'));

        $this-&gt;assertSame(Response::HTTP_CREATED, $response-&gt;getStatusCode());
    }

    public function testSubmitEmptyQuote()
    {
        $response = $this-&gt;post('/api/quotes', array('content' =&gt; ''));

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY, $response-&gt;getStatusCode());
    }

    public function testSubmitNoQuote()
    {
        $response = $this-&gt;post('/api/quotes', array());

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY, $response-&gt;getStatusCode());
    }
}
</code></pre>

<h2 id="checking-bad-cases">Checking bad cases</h2>

<p>Now let's fix the new tests:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    public function submitAction(Request $request)
    {
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);

        if (empty($postedValues['content'])) {
            $answer = array('message' =&gt; 'Missing required parameter: content');

            return new JsonResponse($answer, Response::HTTP_UNPROCESSABLE_ENTITY);
        }
        $answer['quote']['content'] = $postedValues['content'];

        return new JsonResponse($answer, Response::HTTP_CREATED);
    }
}
</code></pre>

<p>Finally run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>All green! Let's call it a day and commit our work:</p>

<pre><code>git add -A
git commit -m 'Managed submission of empty/no quotes'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>For those who didn't practice a lot with Symfony2, this article should have
demonstrated how quick and simple it is to implement the first User Story
(test and code alike).</p>

<p>In the next article, we'll learn how to work with services.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 1: Bootstraping]]></title>
            <link href="/2014/08/05/master-sf2-part-1-bootstraping.html"/>
            <updated>2014-08-05T00:00:00+01:00</updated>
            <id>/2014/08/05/master-sf2-part-1-bootstraping.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>You know the basics of the <a href="http://symfony.com/">Symfony2</a> framework
(<a href="https://getcomposer.org/">Composer</a>, empty application, bundle, controller and
functional test with <a href="http://phpunit.de/">PHPUnit</a>) and you want to learn more
about how to extend it (and understanding what you're doing)?</p>

<p>Then this series of articles is for you :) .</p>

<p>If you don't feel confident about the prerequisites, have a look at
<a href="/2014/06/18/learn-sf2-composer-part-1.html">the Learn Symfony2 series</a>.
Don't worry, we'll start with a bit of practicing before starting to learn
anything new.</p>

<p>In the first article of this series, we'll discover our cutomer's needs and
we'll bootstrap our application.</p>

<h2 id="our-use-case%3A-creating-a-fortune-application">Our use case: creating a Fortune application</h2>

<p>In order to have real world examples, we'll need a use case. The Knight of Ni
were pretty satisfied with our previous work, and they recommended us to
Nostradamus!</p>

<p>Nostradamus is a fortune teller and wants to jump on the internet bandwagon. He
wants us to create a
<a href="http://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune application</a>
where users can submit quotes.</p>

<p>Our first task will be to create an empty application so we can start working.
We could use the <a href="http://symfony.com/distributions">Symfony Standard Edition</a>,
but in order to understand what really happens behind the scene we'll use an
emptier distribution.</p>

<h2 id="installing-symfony2-emptier-edition">Installing Symfony2 Emptier Edition</h2>

<p>First make sure to have the last version of <a href="https://getcomposer.org/">Composer</a>
installed:</p>

<pre><code>curl -sS https://getcomposer.org/installer | php
sudo mv composer.phar /usr/local/bin/composer
</code></pre>

<p>Then ask Composer to create the boilerplate of our application, using the
<a href="https://github.com/gnugat/sf2-emptier">Symfony2 Emptier Edition</a>:</p>

<pre><code>composer create-project 'gnugat/sf2-emptier' fortune '0.1.*'
cd fortune
</code></pre>

<p>This distribution is similar to the empty application we created in the
<a href="/2014/06/25/learn-sf2-empty-app-part-2.html">learn Symfony2 series</a>.
It contains the following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── LICENSE
├── README.md
└── web
    └── app.php
</code></pre>

<p>Remove the documentation files:</p>

<pre><code>rm README.md LICENSE
</code></pre>

<p>Change the <code>composer.json</code> information:</p>

<pre><code>{
    "name": "nostradamus/fortune",
    "license": "proprietary",
    "type": "project",
    "description": "A collection of quotes",
    "autoload": {
        "psr-4": { "": "src/" }
    },
    "require": {
        "php": "&gt;=5.3.17",

        "symfony/symfony": "~2.4"
    },
    "require-dev": {
        "phpunit/phpunit": "~4.1"
    }
}
</code></pre>

<p>Next you'll have to configure the project specific parameters:</p>

<pre><code>cp app/config/parameters.yml.dist app/config/parameters.yml
</code></pre>

<p>Don't forget to edit <code>app/config/parameters.yml</code> and change the value of the
secret parameter:</p>

<pre><code>parameters:
    secret: hazuZRqYGdRrL8ATdB8kAqBZ
</code></pre>

<p><strong>Tip</strong>: Use <a href="https://www.random.org/passwords/?num=1&amp;len=24&amp;format=html&amp;rnd=new">random.org</a>
to generate your secret token.</p>

<p><strong>Note</strong>: For security reason, this parameter file is ignored by git. It means
that this file should be created on each installation.</p>

<p>Let's commit our hard work:</p>

<pre><code>git init
git add -A
git add -f app/logs/.gitkeep app/cache/.gitkeep
git commit -m 'Created a Symfony2 Emptier application'
</code></pre>

<h2 id="creating-the-application-bundle">Creating the Application Bundle</h2>

<p>We will also need an Application bundle. First we create the directories:</p>

<pre><code>mkdir -p src/Fortune/ApplicationBundle
</code></pre>

<p>Then the Bundle class:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/FortuneApplicationBundle.php

namespace Fortune\ApplicationBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;

class FortuneApplicationBundle extends Bundle
{
}
</code></pre>

<p>And finally register it in the application's kernel:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Fortune\ApplicationBundle\FortuneApplicationBundle(), // &lt;-- Here!
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>We're now ready to get started with our real concern, so let's commit our work:</p>

<pre><code>git add -A
git commit -m 'Created ApplicationBundle'
</code></pre>

<h3 id="apache-configuration">Apache configuration</h3>

<p>In order for your website to be browsed, you'll need to configure your web
server. This configuration is well explained
<a href="http://symfony.com/doc/current/cookbook/configuration/web_server_configuration.html">in the documentation</a>,
so here's a dump of an apache vhost:</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerName fortune.local

    DocumentRoot /home/loic.chardonnet/Projects/gnugat/fortune/web

    ErrorLog "/home/loic.chardonnet/Projects/gnugat/fortune/app/logs/apache_errors.log"
    CustomLog "/home/loic.chardonnet/Projects/gnugat/fortune/app/logs/apache_accesses.log" common

    &lt;Directory /home/loic.chardonnet/Projects/gnugat/fortune/web&gt;
        Options Indexes FollowSymLinks MultiViews
        AllowOverride None
        Order allow,deny
        allow from all
        &lt;IfModule mod_rewrite.c&gt;
            RewriteEngine On
            RewriteCond %{REQUEST_FILENAME} !-f
            RewriteRule ^(.*)$ /app.php [QSA,L]
        &lt;/IfModule&gt;
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</code></pre>

<p>If you run into some permission problem (like writing in <code>cache</code> and <code>logs</code>),
you might consider to change <code>APACHE_RUN_USER</code> and <code>APACHE_RUN_GROUP</code>
environment variables present in <code>/etc/apache2/envvars</code> to your own user and
group.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Using Composer's <code>create-project</code> command with a Symfony2 Distribution is the
quickest way to bootstrap a project.</p>

<p>In the next article, we will start to work on our first User Story.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - Conclusion]]></title>
            <link href="/2014/07/23/learn-sf2-conclusion.html"/>
            <updated>2014-07-23T00:00:00+01:00</updated>
            <id>/2014/07/23/learn-sf2-conclusion.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the conclusion of the series on learning
<a href="http://symfony.com/">the Symfony2 framework</a>.
Have a look at the five first ones:</p>

<ol>
<li><a href="/2014/06/18/learn-sf2-composer-part-1.html">Composer</a></li>
<li><a href="/2014/06/25/learn-sf2-empty-app-part-2.html">Empty application</a></li>
<li><a href="/2014/07/02/learn-sf2-bundles-part-3.html">Bundles</a></li>
<li><a href="/2014/07/12/learn-sf2-controllers-part-4.html">Controllers</a></li>
<li><a href="/2014/07/20/learn-sf2-tests-part-5.html">Tests</a></li>
</ol>

<p>In the previous articles we created a tested application for the Knight of Ni
with the following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Knight
│       └── ApplicationBundle
│           ├── Controller
│           │   └── ApiController.php
│           ├── KnightApplicationBundle.php
│           └── Tests
│               └── Controller
│                   └── ApiControllerTest.php
├── .gitignore
└── web
    └── app.php
</code></pre>

<p>Running <code>composer install</code> should create a <code>vendor</code> directory, which we ignored
with git.</p>

<p>Here's the <a href="https://github.com/gnugat/learning-symfony2/tree/5-tests">repository where you can find the actual code</a>.</p>

<p>This article will be like a cheat sheet of what we saw in the previous ones.</p>

<h2 id="composer">Composer</h2>

<p><a href="https://getcomposer.org/">Composer</a> will help you install and update third
party libraries.</p>

<p>Download it once for all and install it in your global binaries:</p>

<pre><code>curl -sS https://getcomposer.org/installer | php
sudo mv ./composer.phar /usr/local/bin/composer
</code></pre>

<p>It should then be executable like this: <code>composer</code>.</p>

<ul>
<li>install a third party library: <code>composer require [--dev] &lt;vendor/name:version&gt;</code></li>
<li>download the project's third party libraries: <code>composer install</code></li>
<li>update the project's third party libraries: <code>composer update</code></li>
</ul>

<p>The available third party libraries can be found on
<a href="https://packagist.org/">Packagist</a>.</p>

<p>Here's an explanation of <a href="https://igor.io/2013/01/07/composer-versioning.html">Composer version constraints by Igor</a>.</p>

<p>In these articles, we create a project from scratch, but the recommended way of
starting a Symfony2 application is to use the Composer bootstrap command:
<code>composer create-project &lt;vendor/name&gt; &lt;path-to-install&gt;</code></p>

<p>You could use the <a href="https://github.com/symfony/symfony-standard">Symfony Standard Edition</a>
(<code>symfony/framework-standard-edition</code>), or any other distribution.</p>

<p>I'd advise you to use an empty boilerplate with the
<a href="https://github.com/gnugat/symfony-empty">Symfony Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-framework-empty-edition &lt;path-to-install&gt;
</code></pre>

<p><em>Tip</em>: For the production server, use this command to install the project's
dependencies (the third party libraries):</p>

<pre><code>composer install --no-dev --optimize
</code></pre>

<h2 id="bundles">Bundles</h2>

<p>They integrate your code with the framework. More specifically, they configure
the Kernel's dependency injection container.</p>

<p><em>Note</em>: To learn more about Dependency Injection, have a look at the following
articles:</p>

<ul>
<li><a href="/2014/01/22/ioc-di-and-service-locator.html">Inversion of Control, Dependency Injection, Dependency Injection Container and Service Locator</a></li>
<li><a href="/2014/01/29/sf2-di-component-by-example.html">Symfony2 Dependency Injection component, by example</a></li>
</ul>

<p>The only bundle you'll need to create is the <code>ApplicationBundle</code>, where all your
code will be. Here's how to create a bundle:</p>

<ol>
<li>create its directory: <code>mkdir -p src/&lt;Vendor&gt;/&lt;Name&gt;Bundle</code></li>
<li>create its class: <code>$EDITOR src/&lt;Vendor&gt;/&lt;Name&gt;Bundle/&lt;Vendor&gt;&lt;Name&gt;Bundle.php</code></li>
<li>register it in the kernel: <code>$EDITOR app/AppKernel.php</code></li>
</ol>

<p>A Bundle class looks like this:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/KnightApplicationBundle.php

namespace Knight\ApplicationBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;

class KnightApplicationBundle extends Bundle
{
}
</code></pre>

<h2 id="application">Application</h2>

<p>In your application, there's only a few files related to the Symfony2 framework.
Here's the list of the ones you'll usually edit.</p>

<h3 id="the-application%27s-kernel">The application's kernel</h3>

<p>The <code>app/AppKernel.php</code> file is where the bundles are registered and where the
configuration is loaded. You'll only need to edit it when you install a new
bundle.</p>

<p>Here's how we would proceed: first install the bundle via Composer:</p>

<pre><code>composer require [--dev] &lt;vendor/name:version&gt;
</code></pre>

<p>Then register it in the application's kernel:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),

            // Add your bundles here!
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            $bundles[] = new Sensio\Bundle\DistributionBundle\SensioDistributionBundle();
            $bundles[] = new Sensio\Bundle\GeneratorBundle\SensioGeneratorBundle();

            // Or here, if you want it to only be available in dev or test environment
        }

        return $bundles;
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<h3 id="the-routing-configuration">The routing configuration</h3>

<p>The <code>app/config/routing.yml</code> file is where you will link a controller's action
to an URL. Here's an example:</p>

<pre><code># File: app/config/routing.yml
ni:
    path: /api/ni
    methods:
        - POST
    defaults:
        _controller: KnightApplicationBundle:Api:ni

question_to_cross_the_bridge:
    path: /api/question/{number}
    methods:
        - GET
    defaults:
        _controller: KnightApplicationBundle:Api:question
</code></pre>

<p>As you can see, you can tell the routing to use placeholders, which will be then
available in the controller via the Request object:</p>

<pre><code>$request-&gt;query-&gt;get('number'); // query is an instance of ParameterBag
</code></pre>

<h3 id="controllers%2C-your-entry-point">Controllers, your entry point</h3>

<p>Each route is associated to a controller's action.</p>

<p>A controller is a class located in <code>src/&lt;Vendor&gt;/ApplicationBundle/Controller</code>,
suffixed with <code>Controller</code>.</p>

<p>An action is a controller's public method, suffixed with <code>Action</code>, which takes
a <code>Request $request</code> parameter and must return an instance of the <code>Response</code>
object:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Controller/ApiController.php

namespace Knight\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class ApiController extends Controller
{
    public function niAction(Request $request)
    {
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);

        $answer = array('answer' =&gt; 'Ecky-ecky-ecky-ecky-pikang-zoop-boing-goodem-zoo-owli-zhiv');
        $statusCode = Response::HTTP_OK;
        if (!isset($postedValues['offering']) || 'shrubbery' !== $postedValues['offering']) {
            $answer['answer'] = 'Ni';
            $statusCode = Response::HTTP_UNPROCESSABLE_ENTITY;
        }

        return new JsonResponse($answer, $statusCode);
    }
}
</code></pre>

<p><em>Note</em>: you can create sub-directories in <code>src/&lt;Vendor&gt;/ApplicationBundle/Controller</code>,
allowing you to categorize your controllers. In the routing, this would look
like this: <code>KnightApplicationBundle:Subdirectory\Controller:action</code>.</p>

<h3 id="functional-tests">Functional tests</h3>

<p>Of course you can use any test framework with a Symfony2 project. PHPUnit is one
of them, and a popular one, so we'll use it for our examples.</p>

<p>Functional tests mirror the controllers and check if the status code is
successful. If you're building an API, you can check more precisely the status
code:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Tests/Controller/ApiControllerTest.php

namespace Knight\ApplicationBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class ApiControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), array(), $content);

        return $client-&gt;getResponse();
    }

    public function testOfferingTheRightThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'shrubbery'));

        $this-&gt;assertSame(Response::HTTP_OK , $response-&gt;getStatusCode());
    }

    public function testOfferingTheWrongThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'hareng'));

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY , $response-&gt;getStatusCode());
    }
}
</code></pre>

<p>The <code>WebTestCase</code> class is provided by the framework: it creates an application
(just like we do in <code>web/app.php</code>), so you can send requests and test the
response.</p>

<h3 id="where-to-put-your-own-code">Where to put your own code</h3>

<p>You can put your code anywhere in <code>src/&lt;Vendor&gt;/ApplicationBundle</code>.</p>

<p>Who said you needed to decouple your code from Symfony2? You can already write
decoupled code!</p>

<p>A convention is to create directories named after the type of objects it holds.
For example the <code>Controller</code> contains controller classes (which are suffixed
with <code>Controller</code>). You don't have to follow it though (except for controllers
and commands): use your best judgement!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Symfony2 gets out of your way, the only class from the framework we need to use
is the controller, the request and the response.</p>

<p>The workflow is really simple:</p>

<ol>
<li>Symfony2 converts the HTTP request into a <code>Request</code> object</li>
<li>the routing allows to execute a controller related to the current URL</li>
<li>the controller receives the <code>Request</code> object as a parameter and must return a
<code>Response</code> object</li>
<li>Symfony2 converts the <code>Response</code> object into the HTTP response</li>
</ol>

<h3 id="what-should-we-do-now%3F">What should we do now?</h3>

<p>Practice.</p>

<p>We now know the strict minimum about Symfony2, and the only way to learn more is
to practice, encounter new use cases, find answers in the
<a href="http://symfony.com/doc/current/index.html">documentation</a> and ask questions on
<a href="http://stackoverflow.com/questions/tagged/symfony2">StackOverflow</a> (if they
haven't been already asked).</p>

<p>If you really want to master Symfony2, then stay tuned: I'll start writing a new
series of articles!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - part 5: Tests]]></title>
            <link href="/2014/07/20/learn-sf2-tests-part-5.html"/>
            <updated>2014-07-20T00:00:00+01:00</updated>
            <id>/2014/07/20/learn-sf2-tests-part-5.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fifth article of the series on learning
<a href="http://symfony.com/">the Symfony2 framework</a>.
Have a look at the four first ones:</p>

<ol>
<li><a href="/2014/06/18/learn-sf2-composer-part-1.html">Composer</a></li>
<li><a href="/2014/06/25/learn-sf2-empty-app-part-2.html">Empty application</a></li>
<li><a href="/2014/07/02/learn-sf2-bundles-part-3.html">Bundles</a></li>
<li><a href="/2014/07/12/learn-sf2-controllers-part-4.html">Controllers</a></li>
</ol>

<p>In the previous articles we created an application for the Knight of Ni with the
following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config.yml
│   │   └── routing.yml
│   └── logs
│       └── .gitkeep
├── composer.json
├── composer.lock
├── src
│   └── Knight
│       └── ApplicationBundle
│           ├── Controller
│           │   └── ApiController.php
│           └── KnightApplicationBundle.php
├── .gitignore
└── web
    └── app.php
</code></pre>

<p>Running <code>composer install</code> should create a <code>vendor</code> directory, which we ignored
with git.</p>

<p>Here's the <a href="https://github.com/gnugat/learning-symfony2/tree/4-controllers">repository where you can find the actual code</a>.</p>

<p>In this article, we'll create functional tests using PHPUnit.</p>

<h2 id="installing-phpunit">Installing PHPUnit</h2>

<p><a href="http://phpunit.de/">PHPUnit</a> is a popular test framework.
Its name is deceptive: you can write any kind of test with it (unit, functional,
end to end, anything).</p>

<p>Let's install it in our project:</p>

<pre><code>composer require --dev "phpunit/phpunit:~4.1"
</code></pre>

<p>The <code>--dev</code> options will prevent Composer from installing PHPUnit when running
<code>composer install --no-dev</code>: this is use in production (download is costly).</p>

<p>We will need to create a configuration file to tell PHPUnit to execute the tests
found in <code>src/Knight/ApplicationBundle/Tests</code>, and to use Composer as an
autoloader:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- File: app/phpunit.xml.dist --&gt;

&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit
    backupGlobals="false"
    colors="true"
    syntaxCheck="false"
    bootstrap="../vendor/autoload.php"&gt;

    &lt;testsuites&gt;
        &lt;testsuite name="Functional Test Suite"&gt;
            &lt;directory&gt;../src/Knight/ApplicationBundle/Tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;

&lt;/phpunit&gt;
</code></pre>

<p><em>Note</em>: <a href="http://symfony.com/doc/current/cookbook/bundles/best_practices.html#directory-structure">By convention</a>
you should put your tests in <code>src/Knight/ApplicationBundle/Tests</code>. It's not hard
coded though, but if you want people to find things where they expect them to be
you better follow them ;) .</p>

<p>This file is suffixed with <code>.dist</code> because we intend to allow developer to
override the configuration by creating a <code>app/phpunit.xml</code> file. Only the
distribution file should be commited, though:</p>

<pre><code>echo '/app/phpunit.xml' &gt;&gt; .gitignore
git add -A
git commit -m 'Installed PHPUnit'
</code></pre>

<h2 id="environments">Environments</h2>

<p>For our functional tests, we will be using the <code>WebTestCase</code> class: it
instanciates our <code>AppKernel</code> with the <code>test</code> environment. It also uses a
<code>test.client</code> service, which is disabled by default.</p>

<p>In order to enable this service, we must change the configuration:</p>

<pre><code># File: app/config/config.yml
framework:
    secret: "Three can keep a secret, if two of them are dead."
    router:
        resource: %kernel.root_dir%/config/routing.yml

    # test: ~
</code></pre>

<p>Sometimes, you don't want your configuration to be the same for your tests and
your production server. That's what environments are for. Let's put this test
specific configuration in a different file:</p>

<pre><code># File: app/config/config_test.yml
imports:
    - { resource: config.yml }

framework:
    test: ~
</code></pre>

<p><em>Note</em>: the <code>imports</code> parameter allows you to include other configuration files.
You can then overwrite the included parameters, or add new ones.</p>

<p>We should also change the <code>registerContainerConfiguration</code> method of the
<code>AppKernel</code> class in order to load the test configuration, depending on the
environment:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Knight\ApplicationBundle\KnightApplicationBundle(),
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $file = 'config';
        if ('test' === $this-&gt;getEnvironment()) {
            $file .= '_test';
        }
        $loader-&gt;load(__DIR__."/config/$file.yml");
    }
}
</code></pre>

<p>Let's commit our work:</p>

<pre><code>git add -A
git commit -m 'Added test configuration'
</code></pre>

<h2 id="functional-tests">Functional tests</h2>

<p>Our test must check that the application behaves as expected. We won't be
checking that it actually fulfills our business expectations. This means that
checking the HTTP status code is entirely sufficient.</p>

<p>Let's create the directory:</p>

<pre><code>mkdir -p src/Knight/ApplicationBundle/Tests/Controller
</code></pre>

<p><em>Note</em>: Again, <a href="http://symfony.com/doc/current/book/testing.html#unit-tests">by convention</a>,
your test directory structure must mirror the one found in the bundle.</p>

<p>And then our first functional test:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Tests/Controller/ApiControllerTest.php

namespace Knight/ApplicationBundle/Tests/Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

class ApiControllerTest extends WebTestCase
{
    public function testOfferingTheRightThing()
    {
        $method = 'POST';
        $uri = '/api/ni';
        $parameters = array();
        $files = array();
        $server = array();
        $content = json_encode(array(
            'offering' =&gt; 'shrubbery',
        ));

        $client = static::createClient();
        $client-&gt;request($method, $uri, $parameters, $files, $server, $content);
        $response = $client-&gt;getResponse();

        $this-&gt;assertTrue($response-&gt;isSuccessful());
    }
}
</code></pre>

<p>To make sure the test pass, run the following command:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>Composer has installed a binary in <code>vendor/bin</code>, and the <code>-c</code> option allows you
to tell PHPUnit where the configuration is (in <code>./app</code>).</p>

<p>This looks a bit long because of the content parameter... We can improve this
with helper methods:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Tests/Controller/ApiControllerTest.php

namespace Knight/ApplicationBundle/Tests/Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

class ApiControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), array(), $content);

        return $client-&gt;getResponse();
    }

    public function testOfferingTheRightThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'shrubbery'));

        $this-&gt;assertTrue($response-&gt;isSuccessful());
    }
}
</code></pre>

<p>Make sure the test still pass:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>The Response's <code>isSuccessful</code> method only checks that the status code is 200ish.</p>

<p>Here's a test for failure cases:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Tests/Controller/ApiControllerTest.php

namespace Knight/ApplicationBundle/Tests/Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

class ApiControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), array(), $content);

        return $client-&gt;getResponse();
    }

    public function testOfferingTheRightThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'shrubbery'));

        $this-&gt;assertTrue($response-&gt;isSuccessful());
    }

    public function testOfferingTheWrongThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'hareng'));

        $this-&gt;assertFalse($response-&gt;isSuccessful());
    }
}
</code></pre>

<p>Run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p><em>Note</em>: At this point running the tests should become a habit. Make sure to run
them whenever you finish a change, and to run them before commiting anything.</p>

<h2 id="rest-api-functional-tests">Rest API functional tests</h2>

<p>In my humble opinion, checking if the status code is 200ish and not checking the
response content is entirely sufficient for functional tests.</p>

<p>When creating REST API, it can prove useful to test more precisely the status
code. Our application is a REST API, so let's do this:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Tests/Controller/ApiControllerTest.php

namespace Knight/ApplicationBundle/Tests/Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class ApiControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), array(), $content);

        return $client-&gt;getResponse();
    }

    public function testOfferingTheRightThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'shrubbery'));

        $this-&gt;assertSame(Response::HTTP_OK , $response-&gt;getStatusCode());
    }

    public function testOfferingTheWrongThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'hareng'));

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY , $response-&gt;getStatusCode());
    }
}
</code></pre>

<p>Run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>All green! That's comforting enough for us to commit our work and call it a day!</p>

<pre><code>git add -A
git commit -m 'Added tests'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Running <code>./vendor/bin/phpunit -c app</code> is less cumbersome than having to run
manually HTTPie (like in the previous article)!</p>

<p>Writing functional tests is easy and quick, the only thing you need to do is
check if the HTTP response's status code is successful (and for REST API you
need to check the precise HTTP response's status code).</p>

<p>The next article will be the conclusion of this series, I hope you enjoyed it!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - part 4: Controllers]]></title>
            <link href="/2014/07/12/learn-sf2-controllers-part-4.html"/>
            <updated>2014-07-12T00:00:00+01:00</updated>
            <id>/2014/07/12/learn-sf2-controllers-part-4.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fourth article of the series on learning
<a href="http://symfony.com/">the Symfony2 framework</a>.
Have a look at the three first ones:</p>

<ol>
<li><a href="/2014/06/18/learn-sf2-composer-part-1.html">Composer</a></li>
<li><a href="/2014/06/25/learn-sf2-empty-app-part-2.html">Empty application</a></li>
<li><a href="/2014/07/02/learn-sf2-bundles-part-3.html">Bundles</a></li>
</ol>

<p>In the previous articles we created a one-bundled empty application with the
following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   └── config.yml
│   └── logs
│       └── .gitkeep
├── composer.json
├── composer.lock
├── src
│   └── Knight
│       └── ApplicationBundle
│           └── KnightApplicationBundle.php
├── .gitignore
└── web
    └── app.php
</code></pre>

<p>Running <code>composer install</code> should create a <code>vendor</code> directory, which we ignored
with git.</p>

<p>Here's the <a href="https://github.com/gnugat/learning-symfony2/releases/tag/3-bundles">repository where you can find the actual code</a>.</p>

<p>In this article, we'll learn more about the routing and the controllers.</p>

<h2 id="discovering-routing-and-controller">Discovering routing and controller</h2>

<p>In order to get familiar with the routing and controllers, we will create a
route which returns nothing. The first thing to do is to configure the router:</p>

<pre><code># File: app/config/app.yml
framework:
    secret: "Three can keep a secret, if two of them are dead."
    router:
        resource: %kernel.root_dir%/config/routing.yml
</code></pre>

<p>We can now write our routes in a separate file:</p>

<pre><code># File: app/config/routing.yml
what_john_snow_knows:
    path: /api/ygritte
    methods:
        - GET
    defaults:
        _controller: KnightApplicationBundle:Api:ygritte
</code></pre>

<p>As you can see, a route has:</p>

<ul>
<li>a name (<code>what_john_snow_knows</code>)</li>
<li>a path (<code>/api/ygritte</code>)</li>
<li>one or many HTTP verbs (<code>GET</code>)</li>
<li>a controller <code>Knight\ApplicationBundle\Controller\ApiController::ygritteAction()</code></li>
</ul>

<p><em>Note</em>: the <code>_controller</code> parameter is a shortcut composed of three parts, which
are the name of the bundle, then the unprefixed controller name and finally the
unprefixed method name.</p>

<p>Now we need to create the following directory:</p>

<pre><code>mkdir src/Knight/ApplicationBundle/Controller
</code></pre>

<p>And to create the controller class:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Controller/ApiController.php

namespace Knight\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class ApiController extends Controller
{
    public function ygritteAction(Request $request)
    {
        return new Response('', Response::HTTP_NO_CONTENT);
    }
}
</code></pre>

<p>To test it, I'd advise you to use a HTTP client. Let's install
<a href="http://httpie.org">HTTPie, the CLI HTTP client</a>:</p>

<pre><code>sudo apt-get install python-pip
sudo pip install --upgrade httpie
</code></pre>

<p>We can now test our webservice:</p>

<pre><code>http GET knight.local/api/ygritte
</code></pre>

<p>The first line should be <code>HTTP/1.1 204 No Content</code>.</p>

<h2 id="posting-data">Posting data</h2>

<p>Our scrum master and product owner managed to write a user story for us:</p>

<pre><code>As a Knight of Ni
I want a webservice which says "ni"
In order to get a shrubbery
</code></pre>

<p>This means we're going to need the following route:</p>

<pre><code># File: app/config/routing.yml
ni:
    path: /api/ni
    methods:
        - POST
    defaults:
        _controller: KnightApplicationBundle:Api:ni
</code></pre>

<p>Our controller will retrieve the posted value (named <code>offering</code>), check if it
is a <code>shrubbery</code> and send back a response containing either <code>Ni</code> (on error) or
<code>Ecky-ecky-ecky-ecky-pikang-zoop-boing-goodem-zoo-owli-zhiv</code> (on success):</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Controller/ApiController.php

namespace Knight\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class ApiController extends Controller
{
    public function niAction(Request $request)
    {
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);

        $answer = array('answer' =&gt; 'Ecky-ecky-ecky-ecky-pikang-zoop-boing-goodem-zoo-owli-zhiv');
        $statusCode = Response::HTTP_OK;
        if (!isset($postedValues['offering']) || 'shrubbery' !== $postedValues['offering']) {
            $answer['answer'] = 'Ni';
            $statusCode = Response::HTTP_UNPROCESSABLE_ENTITY;
        }

        return new JsonResponse($answer, $statusCode);
    }
}
</code></pre>

<p>The <code>JsonResponse</code> class will convert the array into JSON and set the proper
HTTP headers.</p>

<p>If we try to submit something fishy like this:</p>

<pre><code>http POST knight.local/api/ni offering=hareng
</code></pre>

<p>Then we should have a response similar to:</p>

<pre><code>HTTP/1.1 422 Unprocessable Entity
Cache-Control: no-cache
Content-Type: application/json
Date: Thu, 10 Jul 2014 15:23:00 GMT
Server: Apache
Transfer-Encoding: chunked

{
    "answer": "Ni"
}
</code></pre>

<p>And when we submit the correct offering:</p>

<pre><code>http POST knight.local/api/ni offering=shrubbery
</code></pre>

<p>Then we should have something similar to:</p>

<pre><code>HTTP/1.1 200 OK
Cache-Control: no-cache
Content-Type: application/json
Date: Thu, 10 Jul 2014 21:42:00 GMT
Server: Apache
Transfer-Encoding: chunked

{
    "answer": "Ecky-ecky-ecky-ecky-pikang-zoop-boing-goodem-zoo-owli-zhiv"
}
</code></pre>

<h2 id="request%27s-api">Request's API</h2>

<p>Here's part of the Request's API:</p>

<pre><code>&lt;?php

namespace Symfony\Component\HttpFoundation;

class Request
{
    public $request; // Request body parameters ($_POST)
    public $query; // Query string parameters ($_GET)
    public $files; // Uploaded files ($_FILES)
    public $cookies; // $_COOKIE
    public $headers; // Taken from $_SERVER

    public static function createFromGlobals():
    public static function create(
        $uri,
        $method = 'GET',
        $parameters = array(),
        $cookies = array(),
        $files = array(),
        $server = array(),
        $content = null
    );

    public function getContent($asResource = false);
}
</code></pre>

<p>We used <code>createFromGlobals</code> in our front controller (<code>web/app.php</code>), it does
excalty what it says: it initializes the Request from the PHP superglobals
(<code>$_POST</code>, <code>$_GET</code>, etc).</p>

<p>The <code>create</code> method is really handful in tests as we won't need to override the
values in PHP's superglobals.</p>

<p>The attributes here listed are all instances of
<code>Symfony\Component\HttpFoundation\ParameterBag</code>, which is like an object
oriented array with <code>set</code>, <code>has</code> and <code>get</code> methods (amongst others).</p>

<p>When you submit a form, your browser automatically sets the HTTP request's
header <code>Content-Type</code> to <code>application/x-www-form-urlencoded</code>, and the form
values are sent in the request's content like this:</p>

<pre><code>offering=hareng
</code></pre>

<p>PHP understands this and will put the values in the <code>$_POST</code> superglobal. This
mean you could retrieve it like this:</p>

<pre><code>$request-&gt;request-&gt;get('offering');
</code></pre>

<p>However, when we submit something in JSON with the <code>Content-Type</code> set to
<code>application/json</code>, PHP doesn't populate <code>$_POST</code>. You need to retrieve the raw
data with <code>getContent</code> and to convert it using <code>json_decode</code>, as we did in our
controller.</p>

<h2 id="response%27s-api">Response's API</h2>

<p>Here's a part of the Response's API:</p>

<pre><code>&lt;?php

namespace Symfony\Component\HttpFoundation;

class Response
{
    const HTTP_OK = 200;
    const HTTP_CREATED = 201;
    const HTTP_NO_CONTENT = 204;
    const HTTP_UNAUTHORIZED = 401;
    const HTTP_FORBIDDEN = 403;
    const HTTP_NOT_FOUND = 404;
    const HTTP_UNPROCESSABLE_ENTITY = 422; // RFC4918

    public $headers; // @var Symfony\Component\HttpFoundation\ResponseHeaderBag

    public function __construct($content = '', $status = 200, $headers = array())

    public function getContent();
    public function getStatusCode();

    public function isSuccessful();
}
</code></pre>

<p>There's a lot of HTTP status code constants, so I've selected only those I'd use
the most.</p>

<p>You can set and get the Response's headers via a public property which is also
a <code>ParameterBag</code>.</p>

<p>The constructor allows you to set the content, status code and headers.</p>

<p>The three other methods are mostly used in tests. There's a lot of <code>is</code> methods
to check the type of the request, but usually you'll just want to make sure the
response is successful.</p>

<p>You can find other types of responses:</p>

<ul>
<li><code>JsonResponse</code>: sets the <code>Content-Type</code> and converts the content into JSON</li>
<li><code>BinaryFileResponse</code>: sets headers and attaches a file to the response</li>
<li><code>RedirectResponse</code>: sets the target location for a redirection</li>
<li><code>StreamedResponse</code>: useful for streaming large files</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Symfony2 is an HTTP framework which primary's public API are the controllers:
those receive a Request as parameter and return a Response. All you have to do
is to create a controller, write some configuration in order to link
it to an URL and you're done!</p>

<p>Do not forget to commit your work:</p>

<pre><code>git add -A
git commit -m 'Created Ni route and controller'
</code></pre>

<p>The next article should be about tests: stay tuned!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - part 3: Bundles]]></title>
            <link href="/2014/07/02/learn-sf2-bundles-part-3.html"/>
            <updated>2014-07-02T00:00:00+01:00</updated>
            <id>/2014/07/02/learn-sf2-bundles-part-3.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the third article of the series on learning
<a href="http://symfony.com/">the Symfony2 framework</a>.
Have a look at the two first ones:</p>

<ul>
<li><a href="/2014/06/18/learn-sf2-composer-part-1.html">1: Composer</a></li>
<li><a href="/2014/06/25/learn-sf2-empty-app-part-2.html">2: Empty application</a></li>
</ul>

<p>In the previous articles we began to create an empty application with the
following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   └── config.yml
│   └── logs
│       └── .gitkeep
├── composer.json
├── composer.lock
├── .gitignore
└── web
    └── app.php
</code></pre>

<p>Running <code>composer install</code> should create a <code>vendor</code> directory, which we ignored
with git.</p>

<p>Here's the <a href="https://github.com/gnugat/learning-symfony2/releases/tag/2-empty-application">repository where you can find the actual code</a>.</p>

<p>We'll now see what a bundle is.</p>

<h2 id="creating-the-application-bundle">Creating the application bundle</h2>

<p>We'll need some use case in order for our code snippets to make sense. So here
it is: the Knights Who Say 'Ni', demand a webservice! It shall say 'ni' if the
user do not appease it. To do so, the user should post a shrubbery!</p>

<p>Let's create our application bundle, in order to have a place where we can put
our code. To do so we need to create the directory:</p>

<pre><code>mkdir -p src/Knight/ApplicationBundle
</code></pre>

<p>Then the class extending <code>Symfony\Component\HttpKernel\Bundle\Bundle</code>:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/KnightApplicationBundle.php

namespace Knight\ApplicationBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;

class KnightApplicationBundle extends Bundle
{
}
</code></pre>

<p>Finally we register the bundle into our application:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Knight\ApplicationBundle\KnightApplicationBundle(), // &lt;-- Here!
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config.yml');
    }
}
</code></pre>

<p>Let's commit our work:</p>

<pre><code>git add -A
git commit -m 'Created Application bundle'
</code></pre>

<h2 id="bundles-allow-you-to-extend-the-application%27s-dic">Bundles allow you to extend the application's DIC</h2>

<p>The <code>KnightApplicationBundle</code> class extends the following one:</p>

<pre><code>&lt;?php

namespace Symfony\Component\HttpKernel\Bundle;

use Symfony\Component\DependencyInjection\ContainerAware;
use Symfony\Component\Console\Application;

abstract class Bundle extends ContainerAware implements BundleInterface
{
    public function getContainerExtension();
    public function registerCommands(Application $application);
}
</code></pre>

<p><em>Note</em>: Only the part we're interested in is shown here.</p>

<p>Those two methods make the bundle capable of autodiscovering its commands and
its Dependency Injection Container's (DIC) extension, if the following directory
directory structure is used:</p>

<pre><code>.
├── Command
│   └── *Command.php
├── DependencyInjection
│   └── KnightApplicationExtension.php
└── KnightApplicationBundle.php
</code></pre>

<p><em>Note</em>: the only file required in a bundle is the <code>KnightApplicationBundle.php</code>
one.</p>

<p>The name of a bundle (in our example <code>KnightApplication</code>) is composed of:</p>

<ul>
<li>the vendor name (here our customer's name: <code>Knight</code>)</li>
<li>the actual bundle name (<code>Application</code>)</li>
</ul>

<p>For your own sake, choose a small one-word name for you vendor name and for your
bundle name (there's no hard rules but that's my advice).</p>

<p>The <code>KnightApplicationExtension</code> class allows you to manipulate the DIC (more
often you'll load a configuration file which can be located in
<code>Resources/config/services.xml</code>).</p>

<p>And that's precisely the purpose of bundles: registering services in the
application's DIC.</p>

<h3 id="side-note-about-dic-and-services">Side note about DIC and services</h3>

<p>Services and Dependency Injection isn't in the scope of this series. However if
you want to discover what it is all about, have a look at these two articles:</p>

<ul>
<li><a href="/2014/01/22/ioc-di-and-service-locator.html">Inversion of Control, Dependency Injection, Dependency Injection Container and Service Locator</a></li>
<li><a href="/2014/01/29/sf2-di-component-by-example.html">Symfony2 Dependency Injection component, by example</a></li>
</ul>

<p><em>Note</em>: this is a kindly reminder about the nature of Symfony2 Components. Those
are third party libraries which can be used on their own outside of the
framework.</p>

<h3 id="side-note-about-commands">Side note about commands</h3>

<p>The Symfony2 Console Component allows you to create CLI applications. This
application can have one or many commands. To learn more about them, have a look
at this article:</p>

<ul>
<li><a href="/2014/04/09/sf2-console-component-by-example.html">Symfony2 Console component, by example</a></li>
</ul>

<p><em>Note</em>: commands aren't in the scope of this article, but they're worth
mentioning.</p>

<h2 id="two-kinds-of-bundles">Two kinds of bundles</h2>

<p>There's two kinds of bundle:</p>

<ul>
<li>third party application integration ones (reusable, shared between
applications)</li>
<li>application's ones (non reusable and dedicated to your business model)</li>
</ul>

<p>Let's take the <a href="https://github.com/KnpLabs/snappy">KnpLabs snappy library</a>: it
allows you to generate a PDF from a HTML page and can be used in any
applications (non-symfony ones, and even framework-less ones).</p>

<p>The class allowing this generation is
<code>Knp\Bundle\SnappyBundle\Snappy\LoggableGenerator</code>: its construction is a bit
tiresome. To fix this, we can define its construction inside the DIC and
fortunately there's already a bundle doing it for us:
<a href="https://github.com/KnpLabs/KnpSnappyBundle">KnpSnappyBundle</a>.</p>

<p>That's a good example of the first kind of bundles.</p>

<p>Now about the second kind: in our Symfony2 application, we'll need to integrate
our own code to it, one day or another. We could go the long and painful way
(writing a lot of boilerplate code and configurations), or we could use a bundle
to do automatically the job for us!</p>

<p>Sometimes, we'll find applications which have many bundles in order to
categorize them into modules. This isn't necessary and it's a bit tiresome if
you ask me: we can simply create folders in a unique bundle to categorize our
modules.</p>

<p>The creation of many bundles necessitates some extra manual steps. It also makes
little sense as a bundle is supposed to be a decoupled unit: if we create a
UserBundle, FrontendBundle, BlogBundle and ForumBundle, we'll find ourselves
with bundles depending on one another, often with cyclic dependencies and we'll
waste time wondering where to put new classes (which can rely on 3 bundles).</p>

<p>My advice: create a single bundle for your application. If later on you find
that inside it you created a set of classes which makes sense in other projects
(Symfony2 and non-Symfon2 ones alike), then maybe you can extract them to
create a third party library. And then you might create a bundle to integrate
it inside Symfony2 applications.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Bundles are a way to extend the Dependency Injection Container: they're the glue
layer between your code and Symfony2 applications.</p>

<p>They follow conventions which aren't hard coded (you can override anything),
allowing them to autodiscover some convenient classes.</p>

<p>Thanks for reading, in the next article, we'll create controllers!</p>

<h3 id="resources">Resources</h3>

<p>Here's a good article about how reusable bundles should be created:</p>

<ul>
<li><a href="http://elnur.pro/use-only-infrastructural-bundles-in-symfony/">Use only infrastructural bundles in Symfony2, by Elnur Abdurrakhimov</a></li>
</ul>

<p>You don't like the conventions and you're ready to write a lot of boilerplate
code and configuration? Here you go (I'd not advise you to do so, though):</p>

<ul>
<li><a href="http://stackoverflow.com/questions/9999433/should-everything-really-be-a-bundle-in-symfony-2-x/10001019#10001019">Should everything really be a bundle in Symfony2?</a></li>
<li><a href="http://danielribeiro.org/blog/yes-you-can-have-low-coupling-in-a-symfony-standard-edition-application/">Yes, you can have low coupling in a Symfony2 application</a></li>
<li><a href="http://elnur.pro/symfony-without-bundles/">Symfony2 without bundles, by Elnur Abdurrakhimov, by Daniel Ribeiro</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2013/10/symfony2-some-things-i-dont-like-about-bundles/">Symfony2 some things I dont like about bundles, by Matthias Noback</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2013/10/symfony2-console-commands-as-services-why/">Symfony2 console commands as services why, by Matthias Noback</a></li>
<li><a href="http://www.slideshare.net/matthiasnoback/high-quality-symfony-bundles-tutorial-dutch-php-conference-2014">Naked bundles, slides by Matthias Noback</a></li>
</ul>

<p>I'm only putting these links because I like how they explain how Symfony2 works
behind the hood, but I wouldn't apply them in a real world application as it
makes too much fuss to no avail (that's my humble opinion anyway).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - part 2: Empty application]]></title>
            <link href="/2014/06/25/learn-sf2-empty-app-part-2.html"/>
            <updated>2014-06-25T00:00:00+01:00</updated>
            <id>/2014/06/25/learn-sf2-empty-app-part-2.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the second article of the series on learning
<a href="http://symfony.com/">the Symfony2 framework</a>.
Have a look at the first one: <a href="/2014/06/18/learn-sf2-composer-part-1.html">Composer</a>.</p>

<p>In the first article we began to create an empty project with the following
files:</p>

<pre><code>.
├── composer.json
├── composer.lock
└── .gitignore
</code></pre>

<p>Running <code>composer install</code> should create a <code>vendor</code> directory, which we ignored
in git.</p>

<p>Here's the <a href="https://github.com/gnugat/learning-symfony2/tree/1-composer">repository where you can find the actual code</a>.</p>

<p>We'll now see how to create an empty Symfony2 application.</p>

<h2 id="the-front-controller">The front controller</h2>

<p>First things first, we will create an index file which will act as a front
controller: it will be the only entry point of our application and will decide
which page to display.</p>

<p>Create its directory:</p>

<pre><code>mkdir web
</code></pre>

<p>Then the file:</p>

<pre><code>&lt;?php
// File: web/app.php

use Symfony\Component\HttpFoundation\Request;

require_once __DIR__.'/../vendor/autoload.php';
require_once __DIR__.'/../app/AppKernel.php';

$kernel = new AppKernel('prod', false);
$request = Request::createFromGlobals();
$response = $kernel-&gt;handle($request);
$response-&gt;send();
$kernel-&gt;terminate($request, $response);
</code></pre>

<p>First it includes Composer's autoloader: it will require every files needed.</p>

<p>Then we create an instance of our Kernel with the production environment and
the debug utilities disabled. This class acts like a web server: it takes a
HTTP request as input and returns a HTTP response as output.</p>

<p><code>Request::createFromGlobals()</code> creates a representation of the HTTP request.
It is filled from PHP's variable super globals (<code>$_GET</code>, <code>$_POST</code>, etc).</p>

<p>The kernel then handles the request. To keep explanations short, let's simply
say that it will find the controller associated to the requested URL. It is the
controller's responsibility to return a representation of the HTTP response (see
<code>Symfony\Component\HttpFoundation\Response</code>).</p>

<p>The <code>$response-&gt;send()</code> method will simply call the PHP <code>header</code> function and
print a string representing the response's body (usually HTML, JSON or anything
you want).</p>

<p>Finally the <code>$kernel-&gt;terminate()</code> method will call any tasks which registered
to the <code>kernel.terminate</code> event. This alows you to return a response as fast as
possible and then execute some actions like sending emails.</p>

<p><em>Note</em>: events aren't in the scope of this article, but they're worth
mentioning.</p>

<h2 id="creating-the-application%27s-kernel">Creating the application's kernel</h2>

<p><a href="http://symfony.com/doc/current/components/http_kernel/introduction.html">The HttpKernel component</a>
provides you with a <code>Kernel</code> class, which we will extend.</p>

<p>Create the following directory:</p>

<pre><code>mkdir app
</code></pre>

<p>And then the kernel file:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config.yml');
    }
}
</code></pre>

<p>This class will load the project's configuration. This is also where you
register the project's bundles. We'll talk more about bundles in the next
article, for now the only thing you need to know is that they're like plugins.</p>

<p>The Kernel has the responsibility to look at every registered bundle to retrieve
their configuration.</p>

<p>The <code>FrameworkBundle</code> defines some services and allows you to choose what to
enable via configuration.</p>

<p><em>Note</em>: Services are objects which do one thing and do it well. They provide
exactly what they're called: a service. We'll learn more about them in one of
the next article.</p>

<p>We need to put some configuration in order to be able to make it work properly.</p>

<p>Create its directory:</p>

<pre><code>mkdir app/config
</code></pre>

<p>And the the YAML file:</p>

<pre><code># File: app/config/config.yml
framework:
    secret: "Three can keep a secret, if two of them are dead."
</code></pre>

<p>The <code>secret</code> parameter is used as a seed to generate random strings (for e.g.
CSRF tokens).</p>

<p>Now that we have our application structure, let's commit it:</p>

<pre><code>git add -A
git commit -m 'Created application structure'
</code></pre>

<h3 id="logs-and-cache">Logs and cache</h3>

<p>You'll also need to create <code>logs</code> and <code>cache</code> directories:</p>

<pre><code>mkdir app/{cache,logs}
touch app/{cache,logs}/.gitkeep
</code></pre>

<p>Git doesn't allow to commit empty directory, hence the <code>.gitkeep</code> files.</p>

<p>Because files in these directories are temporaries, we'll ignore them:</p>

<pre><code>echo '/app/cache/*' &gt;&gt; .gitignore
echo '/app/logs/*' &gt;&gt; .gitignore
git add -A
git add -f app/cache/.gitkeep
git add -f app/logs/.gitkeep
git commit -m 'Created temporary directories'
</code></pre>

<h3 id="apache-configuration">Apache configuration</h3>

<p>In order for your website to be browsed, you'll need to configure your web
server. This configuration is well explained
<a href="http://symfony.com/doc/current/cookbook/configuration/web_server_configuration.html">in the documentation</a>,
so here's a dump of an apache vhost:</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerName knight.local

    DocumentRoot /home/loic.chardonnet/Projects/gnugat/knight/web

    ErrorLog "/home/loic.chardonnet/Projects/gnugat/knight/app/logs/apache_errors.log"
    CustomLog "/home/loic.chardonnet/Projects/gnugat/knight/app/logs/apache_accesses.log" common

    &lt;Directory /home/loic.chardonnet/Projects/gnugat/knight/web&gt;
        Options Indexes FollowSymLinks MultiViews
        AllowOverride None
        Order allow,deny
        allow from all
        &lt;IfModule mod_rewrite.c&gt;
            RewriteEngine On
            RewriteCond %{REQUEST_FILENAME} !-f
            RewriteRule ^(.*)$ /app.php [QSA,L]
        &lt;/IfModule&gt;
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</code></pre>

<p>If you run into some permission problem (like writing in <code>cache</code> and <code>logs</code>),
you might consider to change <code>APACHE_RUN_USER</code> and <code>APACHE_RUN_GROUP</code>
environment variables present in <code>/etc/apache2/envvars</code> to your own user and
group.</p>

<h2 id="conclusion">Conclusion</h2>

<p>A Symfony2 application follows this pattern: a front controller associate an URL
to a controller which takes a HTTP request and returns a HTTP response.</p>

<p>The next article will be all about bundles, so stay tuned :) .</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - part 1: Composer]]></title>
            <link href="/2014/06/18/learn-sf2-composer-part-1.html"/>
            <updated>2014-06-18T00:00:00+01:00</updated>
            <id>/2014/06/18/learn-sf2-composer-part-1.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>You don't know anything about the <a href="http://symfony.com/">Symfony2</a> framework,
and you'd like a quick guide to learn how to use it, and how it works?</p>

<p>Then this article is for you :) .</p>

<p>Don't get me wrong: one day or another you'll have to read the
<a href="http://symfony.com/doc/current/index.html">documentation</a>, and you'll have to
practice a lot in order to master it. But for now this guide should be a good
start for you.</p>

<p>In the first article of this series, you'll learn about
<a href="https://getcomposer.org/">Composer</a>, which helps you with third party library
installation and updates.</p>

<h2 id="creating-the-project">Creating the project</h2>

<p>In order to understand how Symfony2 works, we won't use the
<a href="http://symfony.com/distributions">Symfony Standard Edition</a>, but rather start
from scratch with the bare minimum.</p>

<p>Let's create our project:</p>

<pre><code>mkdir knight
cd knight
git init
</code></pre>

<h2 id="getting-composer">Getting Composer</h2>

<p>When developing a project the last thing you want is to waste your time
re-inventing the wheel, so you install third party libraries. Those libraries
have their own life cycle: they might release some bug fixes and new features
after you installed them, so you'll need to update them sometimes.</p>

<p><a href="https://getcomposer.org/">Composer</a> makes these things so easy you'll never
have to worry again about versions. First download it:</p>

<pre><code>curl -sS https://getcomposer.org/installer | php
sudo mv composer.phar /usr/local/bin/composer
</code></pre>

<p>And we're done! If only every project were so easy to install... :)</p>

<h2 id="installing-and-updating-symfony2">Installing and updating Symfony2</h2>

<p>Actually, Symfony2 is only a name regrouping many libraries which can be used
individually (you can even use them in other frameworks, CMS or projects like
<a href="http://symfony.com/projects/drupal">Drupal</a>,
<a href="http://symfony.com/projects/phpbb">phpBB</a>,
<a href="http://symfony.com/projects/laravel">Laravel</a>,
<a href="http://symfony.com/projects/ezpublish">eZ Publish</a>,
<a href="http://symfony.com/projects/orocrm">OroCRM</a> and
<a href="http://symfony.com/projects/piwik">Piwik</a> did).</p>

<p><em>Note</em>: Symfony2 libraries are called <code>components</code>.</p>

<p>Composer was made to install libraries, so let's use it:</p>

<pre><code>composer require 'symfony/symfony:~2.5' # install every single libraries in sf2
</code></pre>

<p>This command will do the following steps:</p>

<ol>
<li>create a <code>composer.json</code> configuration file if it doesn't already exist</li>
<li>add <code>symfony/symfony: ~2.5</code> in it (useful for further <code>composer install</code>)</li>
<li>actually download symfony inside the <code>vendor/symfony/symfony</code> directory</li>
<li>create a <code>composer.lock</code> file</li>
</ol>

<p>Later on, to update those dependencies you'll just have to run
<code>composer update</code>.</p>

<p><em>Note</em>: a library on which you depend upon is called a <code>dependency</code>.</p>

<p>This will look in the <code>composer.lock</code> file to know which version has been
installed (e.g. 2.5.0) and then checks if there's any new version available.
For more information about how Composer handles versions, see
<a href="https://igor.io/2013/01/07/composer-versioning.html">Igor's article</a>.</p>

<p>This means that you can totally ignore the <code>vendor</code> directory:</p>

<pre><code>echo '/vendor/*' &gt;&gt; .gitignore
</code></pre>

<p>If your team wants to install your project, they'll just have to clone your
repository and then run <code>composer install</code> which runs into the following steps:</p>

<ol>
<li>read the <code>composer.json</code> file to see the list of dependencies</li>
<li>read the <code>composer.lock</code> file to check the version installed by the commiter</li>
<li>download the dependencies with the version specified in the lock (even if new
ones are available)</li>
</ol>

<p>If a dependency is listed in <code>composer.json</code> but not in <code>composer.lock</code>,
Composer will download the last matching version and add it to the lock.</p>

<p>This means that everyone will have the same version installed! If you allow only
one person to run <code>composer update</code> you can guarantee this.</p>

<h2 id="autloading">Autloading</h2>

<p>Because Composer knows where each classes of the installed libraries are, it
provides a nice feature:
<a href="http://www.php.net/manual/en/language.oop5.autoload.php">autoloading</a>.</p>

<p>Simply put, each time a class is called, Composer will automatically include the
file where it's declared.</p>

<p>Your own code too can benefit from it. We just need to edit the <code>composer.json</code>
file:</p>

<pre><code>{
    "require": {
        "symfony/symfony": "~2.5"
    },
    "autoload": {
        "psr-4": {
            "": "src/"
        }
    }
}
</code></pre>

<p>And run the following command to take the changes into account:</p>

<pre><code>composer update
</code></pre>

<p>This tells Composer that we're going to follow the
<a href="http://www.php-fig.org/psr/psr-4/">PSR-4</a> standard and that we're going to put
our sources in the <code>src</code> directory.</p>

<p><em>Note</em>: PSR 4 requires you to:</p>

<ul>
<li>create one class per file</li>
<li>give the same name to your file and your class</li>
<li>use the path of the class for the namespace</li>
</ul>

<p>For example: the file <code>src/Knight/ApplicationBundle/KnightApplicationBundle.php</code>
contains a class named <code>KnightApplicationBundle</code> located in the namespace
<code>Knight\ApplicationBundle</code>.</p>

<p>Don't worry too much about it for now.</p>

<h2 id="conclusion">Conclusion</h2>

<p>And that's everything you need to know about Composer for now. Let's commit our
work:</p>

<pre><code>git add -A
git commit -m 'Installed Symfony2'
</code></pre>

<p>I hope this could help you, stay tuned for the next articles!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Sessions introduction]]></title>
            <link href="/2014/04/23/sf2-sessions-introduction.html"/>
            <updated>2014-04-23T00:00:00+01:00</updated>
            <id>/2014/04/23/sf2-sessions-introduction.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is
  kept up to date.</p>
  
  <p><em>Last reviewed</em>: 22/02/2016.</p>
</blockquote>

<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>The <a href="http://symfony.com/doc/current/components/http_foundation/introduction.html">Symfony HttpFoundation component</a>
is a library which provides an Object Oriented implementation of the HTTP
protocol: it wraps PHP's variable superglobals (<code>$_POST</code>, <code>$_GET</code>, <code>$_SERVER</code>,
etc) inside objects (<code>Request</code>, <code>Response</code>, <code>Session</code>, etc).</p>

<p>The idea behind it: web applications should receive a Request and return a
Response.</p>

<p>In this article, we'll focus on the Session management which solves many issues
(for example the <a href="https://www.google.com/search?q=php+session+already+started+error">PHP session already started error</a>
nightmare).</p>

<p>This introduction will show you how to use it in a "non-symfony" project:</p>

<ol>
<li><a href="#basics">Basics</a></li>
<li><a href="#examples">Examples</a>

<ul>
<li><a href="#simple-attributes">Simple attributes</a></li>
<li><a href="#deep-attributes">Deep attributes</a></li>
</ul></li>
<li><a href="#going-further">Going further</a>

<ul>
<li><a href="#root-attributes">Root attributes</a></li>
<li><a href="#documentation">Documentation</a></li>
<li><a href="#troubleshooting">Troubleshooting</a></li>
</ul></li>
</ol>

<h2 id="basics">Basics</h2>

<p>In almost any cases, you'll only deal with the following three methods of the
<code>Session</code> object:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpFoundation\Session;

use Symfony\Component\HttpFoundation\Session\SessionBagInterface;

class Session implements SessionInterface, \IteratorAggregate, \Countable
{
    public function registerBag(SessionBagInterface $bag);
    public function start();
    public function getBag($name);
}
</code></pre>

<p>A <code>Bag</code> is a group of attributes stored in the session. Again, in most cases
you'll only deal with the following four methods of the <code>AttributeBag</code> object:</p>

<pre><code class="php">&lt;?php

namespace Symfony\Component\HttpFoundation\Session\Attribute;

class AttributeBag implements AttributeBagInterface, \IteratorAggregate, \Countable
{
    public function __construct($storageKey = '_sf2_attributes');
    public function setName($name);
    public function get($name, $default = null);
    public function set($name, $value);
}
</code></pre>

<p>When using the sessions, you'll generally need to bootstrap things up as follows:</p>

<pre><code class="php">&lt;?php

$session = new Session();

$myAttributeBag = new AttributeBag('my_storage_key');
$myAttributeBag-&gt;setName('some_descriptive_name');
$session-&gt;registerBag($myAttributeBag);

$session-&gt;start();
</code></pre>

<p>The session <strong>MUST</strong> be started by Symfony, and it <em>SHOULD</em> be started after
the bag registrations.</p>

<h2 id="examples">Examples</h2>

<p>Here's some code samples to make things clear.</p>

<h3 id="simple-attributes">Simple attributes</h3>

<p>Let's assume that our session looks like this:</p>

<pre><code class="php">&lt;?php

$_SESSION = array(
    'user' =&gt; array(
        'first_name' =&gt; 'Arthur',
        'last_name' =&gt; 'Dent',
    ),
);
</code></pre>

<p>Here's the bootstrap code we need:</p>

<pre><code class="php">&lt;?php

$session = new Session();

$userAttributeBag = new AttributeBag('user');
$session-&gt;registerBag($userAttributeBag);

$session-&gt;start();
</code></pre>

<p>The equivalent to:</p>

<pre><code class="php">&lt;?php

$firstName = 'Ford';
if (isset($_SESSION['user']['first_name'])) {
    $firstName = $_SESSION['user']['first_name'];
}
$_SESSION['user']['last_name'] = 'Prefect';
</code></pre>

<p>Would be:</p>

<pre><code class="php">&lt;?php

$userAttributeBag = $session-&gt;getBag('user');

$firstName = $userAttributeBag-&gt;get('first_name', 'Ford');
$userAttributeBag-&gt;set('last_name', 'Prefect');
</code></pre>

<h3 id="deep-attributes">Deep attributes</h3>

<p>Now, let's assume we have a session which has deep attributes:</p>

<pre><code class="php">&lt;?php

$_SESSION = array(
    'authentication' =&gt; array(
        'tokens' =&gt; array(
            'github' =&gt; 'A45E96F',
            'twitter' =&gt; '11AEBC980D456E4EF',
        ),
    ),
);
</code></pre>

<p>Here's the bootstrap code we need:</p>

<pre><code class="php">&lt;?php

$session = new Session();

$authenticationAttributeBag = new NamespacedAttributeBag('authentication');
$session-&gt;registerBag($authenticationAttributeBag);

$session-&gt;start();
</code></pre>

<p>The equivalent to:</p>

<pre><code class="php">&lt;?php

$_SESSION['authentication']['tokens']['github'] = 'AEB558F02C3B346';
</code></pre>

<p>Would be:</p>

<pre><code class="php">&lt;?php

$authenticationAttributeBag = $session-&gt;getBag($authenticationAttributeBag);

$authenticationAttributeBag-&gt;set('tokens/github', 'AEB558F02C3B346');
</code></pre>

<h2 id="going-further">Going further</h2>

<p>The <code>Session</code> has been designed to contain a group of attribute bags. But when
working with legacy sessions, you might have to access attributes which are
located at the root of the session. Here's how to extend the <code>Session</code> to allow
this.</p>

<h3 id="root-attributes">Root attributes</h3>

<p>A root attribute might look like:</p>

<pre><code class="php">&lt;?php

$_SESSION = array(
    'attribute' =&gt; 'value',
);
</code></pre>

<p>You need to create your own kind of <code>Bag</code>:</p>

<pre><code class="php">&lt;?php

namespace Acme\Session;

use Symfony\Component\HttpFoundation\Session\SessionBagInterface;

class RootAttributeBag implements SessionBagInterface
{
    private $name = 'single_attribute';

    /** @var string */
    private $storageKey;

    /** @var mixed */
    private $attribute;

    public function __construct($storageKey)
    {
        $this-&gt;storageKey = $storageKey;
    }

    /** {@inheritdoc} */
    public function getName()
    {
        return $this-&gt;name;
    }

    public function setName($name)
    {
        $this-&gt;name = $name;
    }

    /** {@inheritdoc} */
    public function initialize(array &amp;$array)
    {
        $attribute = !empty($array) ? $array[0] : null;
        $this-&gt;attribute = &amp;$attribute;
    }

    /** {@inheritdoc} */
    public function getStorageKey()
    {
        return $this-&gt;storageKey;
    }

    /** {@inheritdoc} */
    public function clear()
    {
        $this-&gt;attribute = null;
    }

    public function get()
    {
        return $this-&gt;attribute;
    }

    public function set($value)
    {
        $this-&gt;attribute = $value;
    }
}
</code></pre>

<p>The <code>storage key</code> will be directly the attribute's key.</p>

<p>We also need to hack a <code>Storage</code> class which supports our <code>Bag</code>:</p>

<pre><code class="php">&lt;?php

namespace Acme\Session;

use Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage;

class LegacySessionStorage extends NativeSessionStorage
{
    /** {@inheritdoc} */
    protected function loadSession(array &amp;$session = null)
    {
        if (null === $session) {
            $session = &amp;$_SESSION;
        }

        $bags = array_merge($this-&gt;bags, array($this-&gt;metadataBag));

        foreach ($bags as $bag) {
            $key = $bag-&gt;getStorageKey();
            // We cast $_SESSION[$key] to an array, because of the SessionBagInterface::initialize() signature
            $session[$key] = isset($session[$key]) ? (array) $session[$key] : array();
            $bag-&gt;initialize($session[$key]);
        }

        $this-&gt;started = true;
        $this-&gt;closed = false;
    }
}
</code></pre>

<p>Finally, we'll need the following bootstrap code:</p>

<pre><code class="php">&lt;?php

use Acme\Session\LegacySessionStorage;
use Acme\Session\RootAttributeBag;
use Symfony\Component\HttpFoundation\Session\Session;

$sessionStorage = new LegacySessionStorage();
$session = new Session($sessionStorage);

// before: $_SESSION['attribute']
$legacyBag = new RootAttributeBag('attribute');
$legacyBag-&gt;setName('legacy');

// after: $session-&gt;getBag('legacy')-&gt;get()
$session-&gt;registerBag($legacyBag);
</code></pre>

<h3 id="documentation">Documentation</h3>

<p><a href="http://symfony.com/doc/current/components/http_foundation/sessions.html">The official documentation</a>
provides useful information about how the session use it.
For example it explains <a href="http://symfony.com/doc/current/components/http_foundation/sessions.html#flash-messages">how to manage flash messages</a>.</p>

<p>It also explains <a href="http://symfony.com/doc/current/components/http_foundation/session_configuration.html">how the session works behind the scene</a>
with useful tips on how to write the session in a database.</p>

<p><a href="http://symfony.com/doc/current/cookbook/session/index.html">Some cookbooks</a> are
also available.
You can find for instance one describing how to use
<a href="http://symfony.com/doc/current/cookbook/session/proxy_examples.html">session proxy</a>
which is useful if you want to encrypt the session data or to make it read
only.</p>

<h3 id="troubleshooting">Troubleshooting</h3>

<p>The common cases of problems encountered are due to the fact that the session
was started before Symfony2 did.</p>

<p>To fix this, check in your <code>php.ini</code> that the <code>session.auto_start</code> option is set
to <code>0</code> (its default value).</p>

<p>If the session isn't auto started, it means that the application is starting the
session itself. If you cannot prevent this, use
<a href="https://github.com/symfony/HttpFoundation/blob/master/Session/Storage/PhpBridgeSessionStorage.php"><code>PhpBridgeSessionStorage</code></a>
with
<a href="https://github.com/symfony/HttpFoundation/blob/master/Session/Storage/Handler/NativeFileSessionHandler.php"><code>NativeFileSessionHandler</code></a>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\HttpFoundation\Session\Session;
use Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeFileSessionHandler;
use Symfony\Component\HttpFoundation\Session\Storage\PhpBridgeSessionStorage;

$sessionHandler = new NativeFileSessionHandler();
$sessionStorage = new PhpBridgeSessionStorage($sessionHandler);
$session = new Session($sessionStorage);
</code></pre>

<p>Another trouble you can encounter: you register some bags but they're always
empty, even though the <code>$_SESSION</code> contains the targeted values.
This would be because you register your bags after starting the session: if you
can't do otherwise then simply call <code>$session-&gt;migrate()</code> after your bag
registration, this will reload the values.</p>

<p>Finally when doing AJAX request you might notice slow performances, or non
persistence of the data. This might be caused by a
<a href="http://blog.alterphp.com/2012/08/how-to-deal-with-asynchronous-request.html">session locking mechanism</a>
which can be solved like this by saving manually the session:</p>

<pre><code class="php">&lt;?php

$session-&gt;save();
// session_write_close(); // Only required before Symfony 2.1
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>By wrapping <code>$_SESSION</code> and <code>session_*()</code> functions, <code>Session</code> allows you to
make your code more testable
(<a href="http://symfony.com/doc/current/components/http_foundation/session_testing.html">you can mock it</a>)
and to solve starting session issues (just make sure to be the first to start
it).</p>

<p>It's divided into <code>AttributeBag</code> which are arrays of parameters: this allows you
to organize your session by namespaces.</p>

<p>I hope you found some useful tips in this article, if you have any comments or
questions don't be shy and drop me a line on
<a href="https://twitter.com/epiloic">Twitter</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony2 Console component, by example]]></title>
            <link href="/2014/04/09/sf2-console-component-by-example.html"/>
            <updated>2014-04-09T00:00:00+01:00</updated>
            <id>/2014/04/09/sf2-console-component-by-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see
  <a href="/2016/03/02/ultimate-symfony-console.html">The Ultimate Developer Guide to Symfony - Console</a></p>
</blockquote>

<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p><a href="http://symfony.com/">Symfony2</a> is a set of libraries which help you in your
everyday tasks. You can even stack them together and create a framework with it:</p>

<ul>
<li><a href="https://github.com/symfony/symfony-standard">Symfony standard edition</a></li>
<li><a href="https://github.com/gnugat/symfony-empty">Symfony empty edition</a></li>
<li><a href="http://silex.sensiolabs.org/">Silex</a></li>
</ul>

<p>Many frameworks already use a lot of components from Symfony2:</p>

<ul>
<li><a href="http://laravel.com/">Laravel</a></li>
<li><a href="https://drupal.org/">Drupal</a></li>
<li><a href="http://ez.no/">eZ Publish</a></li>
<li><a href="http://phpunit.de/">PHPUnit</a></li>
<li><a href="https://www.phpbb.com/">phpBB</a></li>
<li><a href="https://getcomposer.org/">Composer</a></li>
</ul>

<p>In this article, we'll see the
<a href="http://symfony.com/doc/master/components/console/introduction.html">Console Component</a>,
which allows you to build Command Line Interface (CLI) applications. Symfony 2.5
will be released in may 2014, with great new features for the Console, so I'll
speak about this version here.</p>

<ul>
<li><a href="#introduction">Introduction</a>

<ul>
<li><a href="#application">Application</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#input">Input</a></li>
<li><a href="#output">Output</a></li>
<li><a href="#consolelogger">ConsoleLogger</a></li>
</ul></li>
<li><a href="#standalone-example">Standalone example</a>

<ul>
<li><a href="#creating-the-application">Creating the application</a></li>
<li><a href="#creating-the-command">Creating the command</a></li>
<li><a href="#registering-the-command">Registering the command</a></li>
<li><a href="#using-the-filesystem-component">Using the Filesystem component</a></li>
<li><a href="#thin-controller-many-small-services">Thin controller, many small services</a></li>
<li><a href="#registering-the-services">Registering the services</a></li>
</ul></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>This component allows you to focus on one thing: creating commands. It takes
care of all the coloring output, input gathering and command containing stuff.</p>

<p>The big picture is: you have an <code>Application</code> which contains a set of
<code>Command</code>s. When ran, the <code>Application</code> will create an <code>Input</code> object which
contains <code>Option</code>s and <code>Argument</code>s provided by the user, and will feed it to
the right <code>Command</code>.</p>

<p>The code being the best documentation, we'll now see the strict minimum classes
you should know, with the methods you'll likely use.</p>

<h3 id="application">Application</h3>

<p>All you need to know about the <code>Application</code> is this:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class Application
{
    public function __construct($name = 'UNKNOWN', $version = 'UNKNOWN');
    public function add(Command $command);
    public function setDefaultCommand($commandName); // New in 2.5!
    public function run(InputInterface $input = null, OutputInterface $output = null);
}
</code></pre>

<p>Minimum usage:</p>

<pre><code>#!/usr/bin/env php
&lt;?php

use Symfony\Component\Console\Application;

$application = new Application();
$application-&gt;run();
</code></pre>

<p>By running this script, you should be able to see a colorful output which lists
the available commands (<code>list</code> is the default command, and a <code>help</code> is also
available).</p>

<h3 id="command">Command</h3>

<p>The <code>Command</code> class is the controller of your CLI application:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Command;

use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

class Command
{
    protected function configure();
    protected function execute(InputInterface $input, OutputInterface $output);
    protected function interact(InputInterface $input, OutputInterface $output);

    // To be called in configure
    public function setName($name);
    public function addArgument($name, $mode = null, $description = '', $default = null);
    public function addOption($name, $shortcut = null, $mode = null, $description = '', $default = null);
    public function setDescription($description);
    public function setHelp($help);
    public function setAliases($aliases);
}
</code></pre>

<p>Basically you create a class which extends <code>Command</code>. You need to implement 2
methods:</p>

<ul>
<li><code>configure</code>: the configuration of the command's name, arguments, options, etc</li>
<li><code>execute</code>: where you process the input, call your services and write to the
output</li>
</ul>

<p>The <code>interact</code> method is called before the <code>execute</code> one: it allows you to ask
questions to the user to set more input arguments and options.</p>

<p>Here's my stand on arguments and options modes:</p>

<ul>
<li>an argument should always be required (<code>InputArgument::REQUIRED</code>)</li>
<li>a flag is an option without value (<code>InputOption::VALUE_NONE</code>)</li>
<li>an option should always have a required value (<code>InputOption::VALUE_REQUIRED</code>),
don't forget to provide a default one</li>
</ul>

<h3 id="input">Input</h3>

<p>The container of the arguments and options given by the user:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Input;

interface InputInterface
{
    public function getArgument($name);
    public function getOption($name);
}
</code></pre>

<p>The <code>Application</code> validates a part of the input: it checks if the command
actually accepts the given arguments and options (is the value required? Does
the <code>hello:world</code> command have a <code>--yell</code> option? etc), but you still need to
validate the input against your business rules (the <code>--number</code> option should
be an integer, the <code>name</code> argument should be escaped to avoid SQL injection,
etc).</p>

<h3 id="output">Output</h3>

<p>A convenient object which allows you to write on the console output:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Output;

abstract class Output implements OutputInterface
{
    public function writeln($messages, $type = self::OUTPUT_NORMAL);
}
</code></pre>

<p>The <code>writeln</code> method allows you to write a new line (with a newline character at
the end). If the given <code>message</code> is an array, it will print each elements on a
new line.</p>

<p>The tags allow you to color some parts:</p>

<ul>
<li>green text for informative messages (usage example: <code>&lt;info&gt;foo&lt;/info&gt;</code>)</li>
<li>yellow text for comments (usage example: <code>&lt;comment&gt;foo&lt;/comment&gt;</code>)</li>
<li>black text on a cyan background for questions (usage example: <code>&lt;question&gt;foo&lt;/question&gt;</code>)</li>
<li>white text on a red background for errors (usage example: <code>&lt;error&gt;foo&lt;/error&gt;</code>)</li>
</ul>

<h3 id="consolelogger">ConsoleLogger</h3>

<p>Another brand new class from the version 2.5:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Logger;

use Psr\Log\AbstractLogger;
use Symfony\Component\Console\Output\OutputInterface;

class ConsoleLogger extends AbstractLogger
{
    public function __construct(
        OutputInterface $output,
        array $verbosityLevelMap = array(),
        array $formatLevelMap = array()
    );

    public function log($level, $message, array $context = array());
}
</code></pre>

<p>As you can see, it uses the <code>OutputInterface</code> provided by the <code>Application</code>.
You should inject this logger into your services, this will allow them to write
messages on the standard output of the console while keeping them decoupled from
this component (so you can use these services in a web environment).</p>

<p>Oh, and the good news is: it colors the output and decides whether or not to
print it depending on the verbosity and level of log! An error message would
always be printed in red, an informative message would be printed in green if
you pass the <code>-vv</code> option.</p>

<h2 id="standalone-example">Standalone example</h2>

<p>Just like any other component, the Console can be used as a standalone library.</p>

<p>In this example, we'll create a tool which will create a <code>LICENSE</code> file, just
like <a href="https://github.com/gnugat/fossil">fossil</a> (the <a href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html">bootstraper of markdown files for your FOSS projetcs</a>).</p>

<h3 id="creating-the-application">Creating the application</h3>

<p>To begin, let's install the component using <a href="https://getcomposer.org/">Composer</a>:</p>

<pre><code>$ curl -sS https://getcomposer.org/installer | php # Downloading composer
$ ./composer.phar require "symfony/console:~2.5@dev"
</code></pre>

<p>Then create an empty application:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

require __DIR__.'/vendor/autoload.php';

use Symfony\Component\Console\Application;

$application = new Application('Fossil', '2.0.0');
$application-&gt;run();
</code></pre>

<h3 id="creating-the-command">Creating the command</h3>

<p>Our command has two arguments:</p>

<ul>
<li>the name for the copyright</li>
<li>the year for the copyright</li>
</ul>

<p>It can also take the path of the project as an option (we'll provide the
current directory as default value).</p>

<p>Let's create it:</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class LicenseCommand extends Command
{
    protected function configure()
    {
        $this-&gt;setName('license');
        $this-&gt;setDescription('Bootstraps the license file of your project');

        $this-&gt;addArgument('author', InputArgument::REQUIRED);
        $this-&gt;addArgument('year', InputArgument::REQUIRED);

        $this-&gt;addOption('path', 'p', InputOption::VALUE_REQUIRED, '', getcwd());
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
    }
}
</code></pre>

<h3 id="registering-the-command">Registering the command</h3>

<p>Our command doesn't do anything yet, but we can already register it in our
application:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

require __DIR__.'/vendor/autoload.php';

use Symfony\Component\Console\Application;
use Gnugat\Fossil\LicenseCommand;

$command = new LicenseCommand();

$application = new Application('Fossil', '2.0.0');
$application-&gt;add($command);
$application-&gt;run();
</code></pre>

<p>In order for it to run, you'll need to register the namespace in the autoloader
by editing the <code>composer.json</code> file at the root of the project:</p>

<pre><code>{
    "require": {
        "symfony/console": "~2.5@dev"
    },
    "autoload": {
        "psr-4": { "": "src" }
    }
}
</code></pre>

<p>Then you need to run <code>./composer.phar update</code> to update the configuration.</p>

<h3 id="using-the-filesystem-component">Using the Filesystem component</h3>

<p>In <code>fossil</code>, <a href="https://github.com/gnugat/fossil/tree/master/skeletons">templates</a>
are retrieved using the
<a href="http://symfony.com/doc/current/components/finder.html">Finder component</a>, their
values are replaced using <a href="http://twig.sensiolabs.org/">Twig</a> and written using the
<a href="http://symfony.com/doc/current/components/filesystem.html">Filesystem component</a>.</p>

<p>In order to keep this article short, we'll:</p>

<ul>
<li>use a fictive license which requires only the copyright line</li>
<li>simply store the <code>LICENSE</code> template in the command</li>
<li>inject the values using <code>implode</code></li>
</ul>

<p>This means that you have to install the new component:</p>

<pre><code>$ ./composer.phar require "symfony/filesystem:~2.4"
</code></pre>

<p>And then you need to fill the <code>execute</code> method:</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;

class LicenseCommand extends Command
{
    // configure method...

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $filesystem = new Filesystem();
        $filesystem-&gt;dumpFile($path, $license.PHP_EOL);

        $output-&gt;writeln(sprintf('Created the file %s', $path));
    }
}
</code></pre>

<p>Now running <code>./fossil license "Loïc Chardonnet" "2013-2014" -p="/tmp"</code> will
output the message "Created the file /tmp/LICENSE", which should be what really
happened.</p>

<h3 id="thin-controller%2C-many-small-services">Thin controller, many small services</h3>

<p>I'm not a big fan of putting logic in my commands, so generally I use services
to do the actual job:</p>

<pre><code>&lt;?php
// File src/Gnugat/Fossil/DocumentationWriter.php

namespace Gnugat\Fossil;

use Symfony\Component\Filesystem\Filesystem;
use Psr\Log\LoggerInterface;

class DocumentationWriter
{
    private $filesystem;
    private $logger;

    public function __construct(Filesystem $filesystem, LoggerInterface $logger)
    {
        $this-&gt;filesystem = $filesystem;
        $this-&gt;logger = $logger;
    }

    public function write($path, $content)
    {
        $this-&gt;filesystem-&gt;dumpFile($path, $content);
        $this-&gt;logger-&gt;notice(sprintf('Created file %s', $path));
    }
}
</code></pre>

<p>As you can see, the <code>DocumentationWriter</code> isn't very big. It might seem
overkill, but now it's easy to write tests which will check if the <code>LICENSE</code>
file has been created. Also, in <code>fossil</code> the class does a bit more work: it
checks if the file already exists, and takes a "force overwrite" option into
account.</p>

<p>You'll also notice that we inject a logger to notice the user of what happens.
We need to install the PSR-3 logger interface:</p>

<pre><code>$ composer require "psr/log:~1.0"
</code></pre>

<p>Our command will now be much thinner, just like any controller should be (MVC
can also be applied in CLI):</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Gnugat\Fossil\DocumentationWriter;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Logger\ConsoleLogger;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;

class LicenseCommand extends Command
{
    // configure method...

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $filesystem = new Filesystem();
        $logger = new ConsoleLogger($output);
        $documentationWriter = new DocumentationWriter($filesystem, $logger);

        $documentationWriter-&gt;write($path, $license.PHP_EOL);
    }
}
</code></pre>

<p>To be fair, our command is longer. But it <strong>is</strong> thinner as it now has less
responsibilities:</p>

<ul>
<li>it retrieves the input</li>
<li>creates the dependencies</li>
<li>calls the services</li>
</ul>

<p>If you run again <code>./fossil license "Loïc Chardonnet" "2013-2014" -p="/tmp"</code>,
you won't see anything: <code>ConsoleLogger</code> hides informative messages by default.
You need to pass the verbose option to see the message:</p>

<pre><code>$ ./fossil license -v "Loïc Chardonnet" "2013-2014" -p="/tmp"
</code></pre>

<h3 id="registering-the-services">Registering the services</h3>

<p>The dependency creation isn't a responsibility a controller should have. We'll
delegate this to the
<a href="http://symfony.com/doc/current/components/dependency_injection/introduction.html">Dependency Injection component</a>:</p>

<pre><code>$ ./composer.phar require "symfony/dependency-injection:~2.4"
</code></pre>

<p>We'll also install the
<a href="http://symfony.com/doc/current/components/config/introduction.html">Config component</a>:</p>

<pre><code>$ ./composer.phar require "symfony/config:~2.4"
</code></pre>

<p>If you don't know yet this component, go read
<a href="/2014/01/29/sf2-di-component-by-example.html">this helpful article</a>.</p>

<p>We'll create a XML file to configure the registration of our services:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: config/services.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="symfony.application"
            class="Symfony\Component\Console\Application"&gt;
            &lt;argument key="name"&gt;Fossil&lt;/argument&gt;
            &lt;argument key="version"&gt;2.0.0&lt;/argument&gt;
            &lt;call method="add"&gt;
                 &lt;argument type="service" id="fossil.license_command" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="fossil.license_command" class="Gnugat\Fossil\LicenseCommand"&gt;
            &lt;argument type="service" id="fossil.documentation_writer" /&gt;
        &lt;/service&gt;

        &lt;service id="fossil.documentation_writer" class="Gnugat\Fossil\DocumentationWriter"&gt;
            &lt;argument type="service" id="symfony.filesystem" /&gt;
            &lt;argument type="service" id="symfony.console_logger" /&gt;
        &lt;/service&gt;

        &lt;service id="symfony.filesystem" class="Symfony\Component\Filesystem\Filesystem"&gt;
        &lt;/service&gt;

        &lt;service id="symfony.console_logger" class="Symfony\Component\Console\Logger\ConsoleLogger"&gt;
            &lt;argument type="service" id="symfony.console_output" /&gt;
        &lt;/service&gt;

        &lt;service id="symfony.console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>As you can see, I've delegated <strong>every</strong> construction to the DIC (Dependency
Injection Container), even the construction of the application. Now the command
looks like this:</p>

<pre><code>    &lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Gnugat\Fossil\DocumentationWriter;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class LicenseCommand extends Command
{
    private $documentationWriter;

    public function __construct(DocumentationWriter $documentationWriter)
    {
        $this-&gt;documentationWriter = $documentationWriter;

        parent::__construct();
    }

    protected function configure()
    {
        $this-&gt;setName('license');
        $this-&gt;setDescription('Bootstraps the license file of your project');

        $this-&gt;addArgument('author', InputArgument::REQUIRED);
        $this-&gt;addArgument('year', InputArgument::REQUIRED);

        $this-&gt;addOption('path', 'p', InputOption::VALUE_REQUIRED, '', getcwd());
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $this-&gt;documentationWriter-&gt;write($path, $license.PHP_EOL);
    }
}
</code></pre>

<p>And the console now contains the DIC initialization:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

require __DIR__.'/vendor/autoload.php';

$container = new ContainerBuilder();
$loader = new XmlFileLoader($container, new FileLocator(__DIR__.'/config'));
$loader-&gt;load('services.xml');

$output = $container-&gt;get('symfony.console_output');

$application = $container-&gt;get('symfony.application');
$application-&gt;run(null, $output);
</code></pre>

<p>And voilà! You now know how to create CLI applications :) .</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Console component allows you to create CLI applications. The commands are a
thin layer which gathers the input and call services. Those services can then
output messages to the user using a special kind of logger.</p>

<p>Although this article was a bit long, I might have missed something here, so
if you have any feedbacks/questions, be sure to contact me on
<a href="https://twitter.com/epiloic">Twitter</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony2 Dependency Injection component, by example]]></title>
            <link href="/2014/01/29/sf2-di-component-by-example.html"/>
            <updated>2014-01-29T00:00:00+00:00</updated>
            <id>/2014/01/29/sf2-di-component-by-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see
  <a href="/2016/02/24/ultimate-symfony-dependency-injection.html">The Ultimate Developer Guide to Symfony - Dependency Injection</a></p>
</blockquote>

<p>In <a href="/2014/01/22/ioc-di-and-service-locator.html">the previous article</a>
we've seen among other things the definition of Dependency Injection (DI) and of
the Dependency Injection Container (DIC).</p>

<p>In this article we'll see the Symfony2's DI component which provides a powerful
DIC. Here's the summary:</p>

<ul>
<li>putting the construction of your services into configuration</li>
<li>how to use it to wire your application</li>
</ul>

<p>You don't use Symfony2? Don't worry, this article is all about using this
component as a standalone library (you can use it in your
CakePHP/Zend/Home-made-framework application).</p>

<h2 id="construction-configuration">Construction configuration</h2>

<p>DI is all about passing arguments to the constructor of an object. Because
constructing all those object might become a burden, the DIC is here to
take this responsibility and centralize it.</p>

<p>Let's replace <a href="http://pimple.sensiolabs.org/">Pimple</a> by
<a href="http://symfony.com/doc/current/components/dependency_injection/index.html">Symfony2 DI component</a>
in the code sample from the previous article:</p>

<pre><code>&lt;?php

use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\DependencyInjection\ContainerBuilder;

$container = new ContainerBuilder();

// This is a parameter definition
$container-&gt;setParameter('verbosity_level_map', array(
    OutputInterface::VERBOSITY_NORMAL =&gt; Logger::NOTICE,
    OutputInterface::VERBOSITY_VERBOSE =&gt; Logger::INFO,
    OutputInterface::VERBOSITY_VERY_VERBOSE =&gt; Logger::DEBUG,
    OutputInterface::VERBOSITY_DEBUG =&gt; Logger::DEBUG,
);

// register takes the service name, and then its fully qualified classname as a string
$container-&gt;register(
    'console_output',
    'Symfony\Component\Console\Output\ConsoleOutput'
);
$container-&gt;register(
    'output_formatter',
    'Gnugat\Fossil\ApplicationLayer\OutputFormatter'
);

// You can inject:
// * dependencies which have been declared previously
// * arguments
// * parameters which have been declared previously
// * setter dependencies
$container
    -&gt;register('console_handler', 'Symfony\Bridge\Monolog\Handler\ConsoleHandler')
    -&gt;addArgument(new Reference('console_output'))
    -&gt;addArgument(true)
    -&gt;addArgument('%verbosity_level_map%')
    -&gt;addMethodCall('setFormatter', array(new Reference('output_formatter')));
;

$container
    -&gt;register('logger', 'Monolog\Logger')
    -&gt;addArgument('default.logger')
    -&gt;addMethodCall('pushHandler', array(new Reference('console_handler')));
;

$container-&gt;register('filesystem', 'Symfony\Component\Filesystem\Filesystem');

$container
    -&gt;register('documentation_writer', 'Gnugat\Fossil\MarkdownFile\DocumentationWriter')
    -&gt;addArgument(new Reference('filesystem'))
    -&gt;addArgument(new Reference('logger'))
;
</code></pre>

<p>If you think about it, the construction of objects is a configuration thing:
you need to define for each object their dependencies. Symfony2's DI component
allows you to put all those definition inside a configuration file:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;!-- File: dic_config.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;parameters&gt;
        &lt;parameter key="verbosity_Level_map" type="collection"&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_NORMAL"&gt;Monolog\Logger::NOTICE&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_VERBOSE"&gt;Monolog\Logger::INFO&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_VERY_VERBOSE"&gt;Monolog\Logger::DEBUG&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_DEBUG"&gt;Monolog\Logger::DEBUG&lt;/parameter&gt;
        &lt;/parameter&gt;
    &lt;/parameters&gt;

    &lt;services&gt;
        &lt;service id="console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;

        &lt;service id="output_formatter"
            class="Gnugat\Fossil\ApplicationLayer\OutputFormatter"&gt;
        &lt;/service&gt;

        &lt;service id="console_handler"
            class="Symfony\Bridge\Monolog\Handler\ConsoleHandler"&gt;
            &lt;argument type="service" id="console.output" /&gt;
            &lt;argument key="bubble"&gt;true&lt;/argument&gt;
            &lt;argument&gt;%verbosity_Level_map%&lt;/argument&gt;
            &lt;call method="setFormatter"&gt;
                 &lt;argument type="service" id="output_formatter" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="logger" class="Monolog\Logger"&gt;
            &lt;argument&gt;default.logger&lt;/argument&gt;
            &lt;call method="pushHandler"&gt;
                 &lt;argument type="service" id="console_handler" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="filesystem"
            class="Symfony\Component\Filesystem\Filesystem"&gt;
        &lt;/service&gt;

        &lt;service id="documentation_writer"
            class="Gnugat\Fossil\MarkdownFile\DocumentationWriter"&gt;
            &lt;argument type="service" id="filesystem" /&gt;
            &lt;argument type="service" id="logger" /&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>And here's the code sample allowing you to feed the DIC with this configuration:</p>

<pre><code>&lt;?php

// File: front_controller.php

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$documentationWriter = $container-&gt;get('documentation_writer');
$documentationWriter-&gt;write('/tmp/example.txt', 'Hello world');
</code></pre>

<p>The construction of our objects has been completely removed from the code and
has been put into a configuration file. Actually, we've replaced object
constructions by container initialization, which is way more concise.</p>

<h3 id="configuration-format">Configuration format</h3>

<p>The Symfony2's DI component <a href="http://symfony.com/doc/current/components/dependency_injection/configurators.html">allows many configuration formats</a>:</p>

<ul>
<li>plain PHP (like in our first code sample)</li>
<li>XML (like in our second code sample)</li>
<li><a href="http://www.yaml.org/">YAML</a></li>
</ul>

<p>I wouldn't advise you to use YAML format, as it needs to introduce
<a href="http://symfony.com/doc/current/components/dependency_injection/parameters.html#yaml">special formating in order to support advanced options</a>
like:</p>

<ul>
<li>prefixing services ID's with <code>@</code></li>
<li>prefixing services ID's which aren't mandatory with <code>@?</code></li>
<li>prefixing <code>@</code> with <code>@</code> in order to escape them</li>
<li><a href="http://symfony.com/doc/current/book/service_container.html#using-the-expression-language">prefixing expressions with <code>@=</code></a></li>
</ul>

<p>Not to mention the fact that it doesn't support every options (for instance
<a href="http://symfony.com/doc/current/components/dependency_injection/parameters.html#constants-as-parameters">you cannot declare constants as parameters</a>)</p>

<p>On the other hand, the only thing XML doesn't support is concatenation:</p>

<pre><code>&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;

$container = new ContainerBuilder();
// Needs to be done in plain PHP
$container-&gt;setParameter('skeletons_path', __DIR__.'/skeletons');
</code></pre>

<p>XML can be easily validated and it also can be read by many software like IDE's
which can use it in order to provide you with blissful autocompletion.</p>

<p>If you're concerned about performances (reading XML might be slower than
requiring directly plain PHP), Symfony2's DI component allows you to convert it
into plain PHP and dump it into a cache file which you can then include in
your application: <a href="http://symfony.com/doc/current/components/dependency_injection/compilation.html#dumping-the-configuration-for-performance">take a look at the documentation</a>.</p>

<h2 id="wiring-your-application">Wiring your application</h2>

<p>There's a fantastic conclusion we can deduce from the above section: we can
reduce the lines of codes of our projects simply by extracting object
construction and putting it into configuration files.</p>

<p>Object construction is part of the "wiring layer" of your application: it
doesn't solve your "business problem", nor does it solve your
"application problem". It simply is the boilerplate code necessary to write
those.</p>

<p>Let's explore the impact of wiring your application using Symfony2's DI
component. You might not have noticed it, but the code samples used in the
previous article as well as in this one all come from <a href="https://github.com/gnugat/fossil">fossil</a>,
a command which allows you to bootstrap markdown files of your projects
(<a href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html">cf this article</a>).
It uses Symfony2's Console component which requires some boilerplate code in
order to create the application:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Gnugat\Fossil\DocCommand;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\Console\Application;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$documentationWriter = $container-&gt;get('documentation_writer');

$docCommand = new DocCommand($documentationWriter);

$application = new Application('Fossil', '2.0.0');
$application-&gt;add($docCommand);

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>Can you imagine what this front controller can become if we were to add more
commands? You'd rather not? Me neither, that's why I advise you to put all this
boilerplate code into a configuration file:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: dic_config.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;

        &lt;service id="output_formatter"
            class="Gnugat\Fossil\ApplicationLayer\OutputFormatter"
        &lt;/service&gt;

        &lt;service id="console_handler"
            class="Symfony\Bridge\Monolog\Handler\ConsoleHandler"
            &lt;argument type="service" id="console.output" /&gt;
            &lt;argument key="bubble"&gt;true&lt;/argument&gt;
            &lt;argument&gt;%verbosity_Level_map%&lt;/argument&gt;
            &lt;call method="setFormatter"&gt;
                 &lt;argument type="service" id="output_formatter" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="logger" class="Monolog\Logger"&gt;
            &lt;argument&gt;default.logger&lt;/argument&gt;
            &lt;call method="pushHandler"&gt;
                 &lt;argument type="service" id="console_handler" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="filesystem"
            class="Symfony\Component\Filesystem\Filesystem"
        &lt;/service&gt;

        &lt;service id="documentation_writer"
            class="Gnugat\Fossil\MarkdownFile\DocumentationWriter"
            &lt;argument type="service" id="filesystem" /&gt;
            &lt;argument type="service" id="logger" /&gt;
        &lt;/service&gt;

        &lt;service id="doc_command" class="Gnugat\Fossil\DocCommand"&gt;
            &lt;argument type="service" id="documentation_writer" /&gt;
        &lt;/service&gt;

        &lt;service id="application"
            class="Symfony\Component\Console\Application"&gt;
            &lt;argument key="name"&gt;Fossil&lt;/argument&gt;
            &lt;argument key="version"&gt;2.0.0&lt;/argument&gt;
            &lt;call method="add"&gt;
                 &lt;argument type="service" id="doc_command" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>Which allows us to reduce our front controller:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$application = $container-&gt;get('application');

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>Now our concern is the size of the <code>dic_config.xml</code> file which will keep growing
each time we create new services. Don't panic! You can split it into many files
using the <code>imports</code> tag:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: config/dic.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;imports&gt;
        &lt;import resource="01-application.xml" /&gt;
        &lt;import resource="02-documentation_writer.xml" /&gt;
    &lt;/imports&gt;
&lt;/container&gt;
</code></pre>

<p>We created a <code>config</code> directory to put all those XML files, which means we
should change our front controller to:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__.'/config');

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic.xml');

$application = $container-&gt;get('application');

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>The creation of the <code>config/01-application.xml</code> and
<code>config/02-documentation_writer.xml</code> files is left as an exercise for the
reader.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Symfony2's Dependency Injection component can be used outside of a Symfony2
application. It provides a powerful DIC which can be initialized using
configuration files. This means that boilerplate code (also called "wiring
layer") can be removed from your code and put in configuration files, hooray!</p>

<p>I hope you enjoyed this article, be sure to
<a href="https://twitter.com/epiloic">tweet me what you think about it</a> ;) .</p>

<h3 id="nota-bene">Nota bene</h3>

<p>We've used the component as a standalone library, but everything we've done
here is possible inside a Symfony2 fullstack application.</p>

<p>There's also some tips I'd like to share with you:</p>

<h3 id="doctrine-repositories-as-services">Doctrine repositories as services</h3>

<p>The construction of Doctrine repositories is fully handled by the EntityManager,
which means:</p>

<ol>
<li>you cannot inject them as dependencies in your own services</li>
<li>you cannot inject dependencies into them</li>
</ol>

<p><a href="https://gist.github.com/gnugat/8314217">Or can you?</a></p>

<h3 id="service-locator">Service locator</h3>

<p><a href="/2014/01/22/ioc-di-and-service-locator.html">The previous article</a>
spoke about service locator, which is all about using DIC as a dependency. If
you still don't see what it means, take a look at <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/ContainerAware.php">Symfony2 ContainerAware classes</a>.</p>

<p>For example, a <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/Controller/Controller.php">Symfony2 controller</a>
uses the DIC as a Service Locator. In this specific case it might be justified,
as the controller shouldn't contain any logic: its purpose is to pass the
request's parameters to some services, and to feed their return values as the
response's parameters.</p>

<p>Keep in mind that in your own code, there's a 99.99% chance that using Service
Locator is a unjustified decision ;) .</p>
]]></content>
        </entry>
    </feed>