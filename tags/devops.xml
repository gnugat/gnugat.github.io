<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[LoÃ¯c Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2025-08-13T06:56:38+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[LoÃ¯c Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[My Symfony Makefile]]></title>
            <link href="/2025/08/13/my-symfony-makefile.html"/>
            <updated>2025-08-13T00:00:00+01:00</updated>
            <id>/2025/08/13/my-symfony-makefile.html</id>
            <content type="html"><![CDATA[<p>Command your codebase with the crown of steel: <a href="https://www.gnu.org/software/make/">Make</a>,
the eternal overlord of task runners.</p>

<p>For a Docker-based Symfony project, typing mundane commands like running tests
can quickly become cumbersome:</p>

<pre><code class="console">docker compose exec app symfony php vendor/bin/phpunit --testdoc
</code></pre>

<p><strong>Make</strong> allows you to define a list of "rules" that provide:</p>

<ul>
<li>simple commands (eg <code>make test</code>)</li>
<li>environment abstraction (eg <code>make console env=prod</code>)</li>
<li>built-in documentation (run <code>make</code> to list available rules)</li>
<li>combining multiple rules into a single one
(eg <code>make qa</code> is equivalent to <code>make cs-check; make static-analysis; make test</code>)</li>
</ul>

<p>With Make, the previous example becomes:</p>

<pre><code class="console">make test arg=--testdox
</code></pre>

<ul>
<li><a href="#makefile">Makefile</a>

<ul>
<li><a href="#usage">Usage</a></li>
<li><a href="#docker-compose-version">Docker Compose version</a></li>
<li><a href="#docker-version">Docker version</a></li>
<li><a href="#native-php-version">Native PHP version</a></li>
</ul></li>
</ul>

<h2 id="makefile">Makefile</h2>

<p>In this article, I'm sharing the Makefiles I use for my Symfony / PHP projects.</p>

<h3 id="usage">Usage</h3>

<p>Here are the rules I usually define:</p>

<pre><code class="console"># ğŸ³ Docker related rules
## Build the Docker image
make build

## Start the services (eg database, message queue, etc)
make up

## Check the services logs
make logs

## Stop the services
make down

## Open interactive shell in container
make bash

# ğŸ˜ Project related rules
## Install composer dependencies
make composer arg='install --optimize-autoloader'

## Run the Symfony console
make console arg='cache:clear'

### To change the environment
make console env=prod arg='cache:clear'

# ğŸ›‚ Quality Assurance related rules
## Run phpstan, php-cs-fixer (check) and phpunit
make qa

## To just run phpstan
make static-analysis

## To just run php-cs-fixer check
make cs-check

## To just run phpunit
make test

### To display technical specifications:
make test arg='--testdox'

### To just run Integration tests:
make test arg='./tests/Integration'

### To just run Unit tests:
make test arg='./tests/Unit'

# Run php-cs-fixer fix
make cs-fix

# Discover everything you can do
make
</code></pre>

<h3 id="docker-compose-version">Docker Compose version</h3>

<p>Here's the <code>Makefile</code> I use in Docker-based Symfony projects, which use a database
(with Docker Compose):</p>

<pre><code class="Makefile"># Parameters (optional)
# * `arg`: arbitrary arguments to pass to rules (default: none)
# * `env`: used to set `APP_ENV` (default: `test`)
arg ?=
env ?= test

# Executables (local)
DOCKER_RUN = docker run -it -v "$(PWD)":/app --user $(shell id -u):$(shell id -g)

# Docker containers
PHP_SERVICE = app
PHP_CONT = $(DOCKER_RUN) $(PHP_SERVICE)

# Executables
PHP = docker compose exec $(PHP_SERVICE) symfony php
COMPOSER = docker compose exec $(PHP_SERVICE) symfony composer
CONSOLE = docker compose exec -e APP_ENV=$(env) $(PHP_SERVICE) symfony console
PHINX = docker compose exec -e APP_ENV=$(env) $(PHP_SERVICE) symfony php vendor/bin/phinx
PHPUNIT = docker compose exec $(PHP_SERVICE) symfony php vendor/bin/phpunit
PHP_CS_FIXER = docker compose exec $(PHP_SERVICE) symfony php vendor/bin/php-cs-fixer
PHPSTAN = docker compose exec $(PHP_SERVICE) symfony php vendor/bin/phpstan

# Misc
.DEFAULT_GOAL = help
.PHONY: *

## â€”â€” ğŸµ ğŸ³ The Symfony Docker Makefile ğŸ³ ğŸµ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
## Based on https://github.com/dunglas/symfony-docker
## (arg) denotes the possibility to pass "arg=" parameter to the target
##     this allows to add command and options, example: make composer arg='dump --optimize'
## (env) denotes the possibility to pass "env=" parameter to the target
##     this allows to set APP_ENV environment variable (default: test), example: make console env='prod' arg='cache:warmup'
help: ## Outputs this help screen
    @grep -E '(^[a-zA-Z0-9\./_-]+:.*?##.*$$)|(^##)' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}{printf "\033[32m%-30s\033[0m %s\n", $$1, $$2}' | sed -e 's/\[32m##/[33m/'

## â€”â€” Docker ğŸ³ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
build: ## Builds the Docker images
    @docker compose build --pull

up: ## Starts Docker Compose services, in detached mode (no logs)
    @docker compose up --detach

logs: ## Show live logs
    @docker compose logs --tail=0 --follow

down: ## Stops Docker Compose services
    @docker compose down --remove-orphans

bash: ## Connect to the container via bash so up and down arrows go to previous commands
    @docker compose exec $(PHP_SERVICE) bash

## â€”â€” PHP ğŸ˜ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
composer: ## Runs Composer (arg, eg `arg='install --optimize-autoloader'`)
    @$(COMPOSER) $(arg)

console: ## Runs bin/console (arg, eg `arg='cache:clear'`) (env, eg `env=prod`)
    @$(CONSOLE) $(arg)

phinx: ## Runs Phinx (arg, eg `arg='create MyMigration'`)
    @$(PHINX) $(arg)

migrate: ## Runs DB migrations (arg, eg `arg='--environment prod'`; env, eg env=prod)
    @$(PHINX) migrate --environment=$(env) $(arg)

## â€”â€” Quality ğŸ›‚ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
db-reset: ## Resets test database (drop, create, migrate, fixtures)
    @$(CONSOLE) doctrine:database:drop --force --if-exists
    @$(CONSOLE) doctrine:database:create --if-not-exists
    @$(PHINX) migrate --environment=$(env)
    @$(PHINX) seed:run --environment=$(env)

test: ## Runs the tests with PHPUnit (arg, eg `arg='./tests/Unit'`)
    @$(PHPUNIT) $(arg)

static-analysis: ## Static Analysis with phpstan (arg, eg `arg='./src/'`)
    @$(PHPSTAN) analyze $(arg)

cs-check: ## Checks CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) check --verbose $(arg)

qa: ## Equivalent to cs-check &amp;&amp; static-analysis &amp;&amp; test
    @$(MAKE) cs-check
    @$(MAKE) static-analysis
    @$(MAKE) test

cs-fix: ## Fixes CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) fix --verbose $(arg)
</code></pre>

<h3 id="docker-version">Docker version</h3>

<p>If your project doesn't have a database (or services),
and therefore relies on Docker directly (without Docker Compose),
here's what it could look like:</p>

<pre><code class="Makefile"># Parameters (optional)
# * `arg`: arbitrary arguments to pass to rules (default: none)
# * `env`: used to set `APP_ENV` (default: `test`)
arg ?=
env ?= test

# Executables (local)
DOCKER_RUN = docker run -it -v "$(PWD)":/app --user $(shell id -u):$(shell id -g)

# Docker containers
PHP_SERVICE = app
PHP_CONT = $(DOCKER_RUN) $(PHP_SERVICE)

# Executables
PHP = $(PHP_CONT) symfony php
COMPOSER = $(PHP_CONT) symfony composer
CONSOLE = $(DOCKER_RUN) -e APP_ENV=$(env) $(PHP_SERVICE) symfony console
PHPUNIT = $(PHP_CONT) symfony php vendor/bin/phpunit
PHP_CS_FIXER = $(PHP_CONT) symfony php vendor/bin/php-cs-fixer
PHPSTAN = $(PHP_CONT) symfony php vendor/bin/phpstan

# Misc
.DEFAULT_GOAL = help
.PHONY: *

## â€”â€” ğŸµ ğŸ³ The Symfony Docker Makefile ğŸ³ ğŸµ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
## Based on https://github.com/dunglas/symfony-docker
## (arg) denotes the possibility to pass "arg=" parameter to the target
##     this allows to add command and options, example: make composer arg='dump --optimize'
## (env) denotes the possibility to pass "env=" parameter to the target
##     this allows to set APP_ENV environment variable (default: test), example: make console env='prod' arg='cache:warmup'
help: ## Outputs this help screen
    @grep -E '(^[a-zA-Z0-9\./_-]+:.*?##.*$$)|(^##)' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}{printf "\033[32m%-30s\033[0m %s\n", $$1, $$2}' | sed -e 's/\[32m##/[33m/'

## â€”â€” Docker ğŸ³ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
build: ## Builds the Docker image
    @docker build -t $(PHP_SERVICE) .

bash: ## Connect to the container via bash so up and down arrows go to previous commands
    @$(DOCKER_RUN) $(PHP_SERVICE) bash

## â€”â€” PHP ğŸ˜ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
composer: ## Runs Composer (arg, eg `arg='install --optimize-autoloader'`)
    @$(COMPOSER) $(arg)

console: ## Runs bin/console (arg, eg `arg='cache:clear'`) (env, eg `env=prod`)
    @$(CONSOLE) $(arg)

## â€”â€” Quality ğŸ›‚ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
test: ## Runs the tests with PHPUnit (arg, eg `arg='./tests/Unit'`)
    @$(PHPUNIT) $(arg)

static-analysis: ## Static Analysis with phpstan (arg, eg `arg='./src/'`)
    @$(PHPSTAN) analyze $(arg)

cs-check: ## Checks CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) check --verbose $(arg)

qa: ## Equivalent to cs-check &amp;&amp; static-analysis &amp;&amp; test
    @$(MAKE) cs-check
    @$(MAKE) static-analysis
    @$(MAKE) test

cs-fix: ## Fixes CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) fix --verbose $(arg)
</code></pre>

<h3 id="native-php-version">Native PHP version</h3>

<p>For pure PHP projects without Symfony CLI (or Symfony console),
that don't run in Docker Containers, the <code>Makefile</code> can look like this:</p>

<pre><code class="Makefile"># Parameters (optional)
# * `arg`: arbitrary arguments to pass to rules (default: none)
# * `env`: used to set `APP_ENV` (default: `test`)
arg ?=
env ?= test

# Executables
PHP = php
COMPOSER = composer
PHPUNIT = php vendor/bin/phpunit
PHP_CS_FIXER = php vendor/bin/php-cs-fixer
PHPSTAN = php vendor/bin/phpstan

# Misc
.DEFAULT_GOAL = help
.PHONY: *

## â€”â€” ğŸµ ğŸ˜ The Pure PHP Makefile ğŸ˜ ğŸµ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
## Based on https://github.com/dunglas/symfony-docker
## (arg) denotes the possibility to pass "arg=" parameter to the target
##     this allows to add command and options, example: make composer arg='dump --optimize'
## (env) denotes the possibility to pass "env=" parameter to the target
##     this allows to set APP_ENV environment variable (default: test), example: make php env='prod' arg='script.php'
help: ## Outputs this help screen
    @grep -E '(^[a-zA-Z0-9\./_-]+:.*?##.*$$)|(^##)' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}{printf "\033[32m%-30s\033[0m %s\n", $$1, $$2}' | sed -e 's/\[32m##/[33m/'

## â€”â€” PHP ğŸ˜ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
composer: ## Runs Composer (arg, eg `arg='install --optimize-autoloader'`)
    @$(COMPOSER) $(arg)

php: ## Runs PHP (arg, eg `arg='script.php'`) (env, eg `env=prod`)
    @APP_ENV=$(env) $(PHP) $(arg)

## â€”â€” Quality ğŸ›‚ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
test: ## Runs the tests with PHPUnit (arg, eg `arg='./tests/Unit'`)
    @$(PHPUNIT) $(arg)

static-analysis: ## Static Analysis with phpstan (arg, eg `arg='./src/'`)
    @$(PHPSTAN) analyze $(arg)

cs-check: ## Checks CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) check --verbose $(arg)

qa: ## Equivalent to cs-check &amp;&amp; static-analysis &amp;&amp; test
    @$(MAKE) cs-check
    @$(MAKE) static-analysis
    @$(MAKE) test

cs-fix: ## Fixes CS with PHP-CS-Fixer (arg, eg `arg='./src'`)
    @$(PHP_CS_FIXER) fix --verbose $(arg)
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>With this, you can streamline your development workflow across projects
and focus on writing code instead of remembering complex Docker commands.</p>

<blockquote>
  <p><strong>Note</strong>: I took massive inspiration from Kevin Dunglas'
  <a href="https://github.com/dunglas/symfony-docker">Symfony Docker Makefile</a>.</p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[My Symfony Dockerfile]]></title>
            <link href="/2025/08/06/my-symfony-dockerfile.html"/>
            <updated>2025-08-06T00:00:00+01:00</updated>
            <id>/2025/08/06/my-symfony-dockerfile.html</id>
            <content type="html"><![CDATA[<p>Dockerize your PHP / Symfony application, to eliminate "works on MY machine".</p>

<p>I'm describing here a solution that ensures consistent development environment,
to run the project locally with just a few commands, without having to worry about:</p>

<ul>
<li>PHP version / extensions</li>
<li><p>database / search engine / messaging queue / services setup</p></li>
<li><p><a href="#dockerfile">Dockerfile</a></p></li>
<li><a href="#dockerignore">Dockerignore</a></li>
<li><a href="#compose">Compose</a></li>
<li><a href="#going-further">Going further</a>

<ul>
<li><a href="#sqlite">SQLite</a></li>
</ul></li>
</ul>

<h2 id="dockerfile">Dockerfile</h2>

<p>The following <code>Dockerfile</code> will build an image with:</p>

<ul>
<li><strong>Alpine Linux</strong>

<ul>
<li>Lightweight distribution (5-10MB compared to 100MB for Ubuntu)</li>
<li>uses <em>musl libc</em> instead of glibc, expect incompatibility issues with some binaries</li>
</ul></li>
<li><strong>PHP 8.3</strong>

<ul>
<li>this is needed for any PHP applications</li>
<li>change the version to your liking</li>
</ul></li>
<li><strong>bash</strong>

<ul>
<li>not required, but I like to use bash as my shell when I connect to the container</li>
</ul></li>
<li><strong>Composer</strong>

<ul>
<li>in production, you don't need the Composer binary in the container</li>
<li>in development, it's useful to have the same running environment for your app and Composer</li>
</ul></li>
<li><strong>PostgreSQL</strong>

<ul>
<li>my favourite database</li>
<li>skip it or switch it to MySQL, SQLite, etc</li>
</ul></li>
<li><strong>Symfony CLI</strong>

<ul>
<li>in production, you don't need the Symfony CLI binary in the container</li>
<li>in development, useful to start a web server</li>
</ul></li>
</ul>

<pre><code># syntax=docker/dockerfile:1

###
# PHP Dev Container
# Utility Tools: PHP, bash, Composer, PostgreSQL, Symfony CLI
###
FROM php:8.3-cli-alpine AS php_dev_container

# Composer environment variables:
# * default user is superuser (root), so allow them
# * put cache directory in a readable/writable location
# _Note_: When running `composer` in container, use `--no-cache` option
ENV COMPOSER_ALLOW_SUPERUSER=1 \
    COMPOSER_CACHE_DIR=/tmp/.composer/cache

# Install dependencies:
# * bash for shell access and scripting
# * postgresql for the database
# * zip for composer packages that use ZIP archives
# _Note (Alpine)_: `--no-cache` includes `--update` and keeps image size minimal
#
# Then install PHP extensions
#
# _Note (Hadolint)_: No version locking, since Alpine only ever provides one version
# hadolint ignore=DL3018
RUN apk add --update --no-cache \
        bash \
        libzip-dev \
        postgresql-dev \
        zip \
    &amp;&amp; docker-php-ext-install \
        bcmath \
        zip \
        pdo_pgsql

# Copy Symfony CLI binary from image
# _Note_: Avoid using Symfony CLI installer, use Docker image instead
# See: https://github.com/symfony-cli/symfony-cli/issues/195#issuecomment-1273269735
# _Note (Hadolint)_: False positive as `COPY` works with images too
# See: https://github.com/hadolint/hadolint/issues/197#issuecomment-1016595425
# hadolint ignore=DL3022
COPY --from=ghcr.io/symfony-cli/symfony-cli:v5 /usr/local/bin/symfony /usr/local/bin/symfony

# Copy Composer binary from composer image
# _Note (Hadolint)_: False positive as `COPY` works with images too
# See: https://github.com/hadolint/hadolint/issues/197#issuecomment-1016595425
# hadolint ignore=DL3022
COPY --from=composer:2 /usr/bin/composer /usr/bin/composer

WORKDIR /app

# Caching `composer install`, as long as composer.{json,lock} don't change.
COPY composer.json composer.lock ./
RUN composer install \
    --no-cache \
    --no-interaction \
    --no-plugins \
    --no-scripts \
    --optimize-autoloader

# Copy the remaining application files (excluding those listed in .dockerignore)
COPY . .
</code></pre>

<p>You can check the validity of your Dockerfile syntax here: <a href="https://hadolint.github.io/hadolint/">hadolint</a></p>

<p>Here's how to build the image, and then run the container:</p>

<blockquote>
  <p><strong>Note</strong>: <code>-v "$(PWD)":/app</code> mounts current directory for live code changes.</p>
</blockquote>

<pre><code class="console">docker build -t app .

# Run with interactive shell
docker run --rm -it -v "$(PWD)":/app app bash

# Run composer
docker run --rm -it -v "$(PWD)":/app app symfony composer install -o

# Run symfony's console
docker run --rm -it -v "$(PWD)":/app -e APP_ENV=prod app symfony console

# Run PHPUnit, phpstan, PHP CS Fixer
docker run --rm -it -v "$(PWD)":/app app symfony php vendor/bin/phpunit
docker run --rm -it -v "$(PWD)":/app app symfony php vendor/bin/phpstan analyze
docker run --rm -it -v "$(PWD)":/app app symfony php vendor/bin/php-cs-fixer check --verbose
docker run --rm -it -v "$(PWD)":/app app symfony php vendor/bin/php-cs-fixer fix --verbose

# Start Symfony CLI's web server
docker run --rm -it -v "$(PWD)":/app -p 8000:8000 app symfony server:start --port=8000 --host=0.0.0.0
</code></pre>

<h2 id="dockerignore">Dockerignore</h2>

<p>When using <code>COPY . .</code> in <code>Dockerfile</code>, it's useful to limit what's going to be copied, with a <code>.dockerignore</code>:</p>

<pre><code>## composer
vendor

## git
.git/

## friendsofphp/php-cs-fixer
.php-cs-fixer.php
.php-cs-fixer.cache

## phpstan/phpstan
phpstan.neon

## phpunit/phpunit
phpunit.xml
.phpunit.cache

## symfony/framework-bundle
.env.local
.env.local.php
.env.*.local
var/cache/
var/log/
</code></pre>

<h2 id="compose">Compose</h2>

<p>When the PHP application relies on other services,
such as a database (eg PostgreSQL), search engine (eg Elasticsearch), or message queue (eg RabbitMQ),
having a <code>compose.yaml</code> file will make the development experience much smoother
by handling services, networking, and volumes automatically:</p>

<pre><code class="yaml">services:
  app:
    build: .
    # Mount current directory into container for live code changes
    volumes:
      - .:/app
    # Database should be started first
    depends_on:
      - db
    ports:
      - "8000:8000"
    command: symfony serve --no-tls --port=8000 --listen-ip=0.0.0.0

  db:
    image: postgres:${POSTGRES_VERSION:-16}-alpine
    environment:
        POSTGRES_DB: ${POSTGRES_DB:-app}
        POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-ChangeMe}
        POSTGRES_USER: ${POSTGRES_USER:-app}
    # Persist database data between container restarts
    volumes:
      - db-data:/var/lib/postgresql/data:rw
    # Port mapping to avoid conflict with locally running PostgreSQL
    ports:
      - "5433:5432"

# Define the db-data volume used above
volumes:
  db-data:
</code></pre>

<p>Now usage commands will be a bit different:</p>

<pre><code class="console"># Build docker images
docker compose build --pull
# Start services (no logs)
docker compose up --detach
# Show live logs
docker compose logs --tail=0 --follow
# Stop services
docker compose down --remove-orphans

# Run with interactive shell
docker compose exec app bash

# Run composer
docker compose exec app symfony composer

# Run symfony's console
docker compose exec -e APP_ENV=prod app symfony console

# Run PHPUnit, phpstan, PHP CS Fixer
docker compose exec -e APP_ENV=prod app symfony php vendor/bin/phpunit
docker compose exec -e APP_ENV=prod app symfony php vendor/bin/phpstan analyze
docker compose exec -e APP_ENV=prod app symfony php vendor/bin/php-cs-fixer check --verbose
docker compose exec -e APP_ENV=prod app symfony php vendor/bin/php-cs-fixer fix --verbose
</code></pre>

<h2 id="going-further">Going further</h2>

<h3 id="sqlite">SQLite</h3>

<p>To setup SQLite, you'll need to modify <code>Dockerfile</code>:</p>

<pre><code>RUN apk add --update --no-cache \
    ...
    sqlite \
    &amp;&amp; docker-php-ext-install \
    ...
    pdo_sqlite
</code></pre>

<p>As well as <code>compose.yaml</code>:</p>

<pre><code class="yaml">services:
    app:
        ...
        volumes:
            ...
            # Mount SQLite database directory to persist data
            - sqlite-data:/app/var/data

volumes:
    ...
    sqlite-data:
</code></pre>

<p>This is assuming your SQLite database file is located in the projects' <code>var/data</code> folder.</p>

<p>Make sure to set up the following environment varaible in <code>.env</code>:</p>

<pre><code>DATABASE_URL="sqlite:///%kernel.project_dir%/var/data/database.sqlite"
</code></pre>

<h3 id="rabbitmq">RabbitMQ</h3>

<p>For RabbitMQ, modify <code>Dockerfile</code>:</p>

<pre><code>RUN apk add --update --no-cache \
    ...
    rabbitmq-c-dev \
    &amp;&amp; docker-php-ext-install \
    ...
    sockets \
    &amp;&amp; pecl install amqp \
    &amp;&amp; docker-php-ext-enable amqp
</code></pre>

<p>Also <code>compose.yaml</code>:</p>

<pre><code class="yaml">services:
    app:
        ...
        depends_on:
            ...
            - rabbitmq

    rabbitmq:
        image: rabbitmq:${RABBITMQ_VERSION:-3.13}-management-alpine
        environment:
            RABBITMQ_DEFAULT_USER: ${RABBITMQ_USER:-app}
            RABBITMQ_DEFAULT_PASS: ${RABBITMQ_PASSWORD:-ChangeMe}
        # Persist RabbitMQ data between container restarts
        volumes:
            - rabbitmq-data:/var/lib/rabbitmq:rw
        ports:
            # Port mapping to avoid conflict with locally running RabbitMQ
            - "5673:5672"
            # Management UI port
            - "15673:15672"

volumes:
    ...
    rabbitmq-data:
</code></pre>

<p>Again, make sure to set up the following environment varaible in <code>.env</code>:</p>

<pre><code>RABBITMQ_URL="amqp://app:ChangeMe@rabbitmq:5672/"
</code></pre>

<p>The RabbitMQ management interface will be available at http://localhost:15673,
with the credentials defined in the environment variables.</p>

<h2 id="maintenance">Maintenance</h2>

<p>Here's a list of helpful commands to maintain the images and containers:</p>

<ul>
<li><code>docker images</code>: lists images

<ul>
<li><code>docker images --filter dangling=true</code>: lists untagged / unused images</li>
</ul></li>
<li><code>docker container ls</code>: lists running containers

<ul>
<li><code>docker container ls -a</code>: lists running and stopped containers</li>
</ul></li>
<li><code>docker system prune</code>: removes dangling containers, networks and images

<ul>
<li><code>docker system prune --volumes</code>: removes dangling containers, networks, volumes and images</li>
</ul></li>
<li><code>docker history &lt;image&gt;</code>: Inspects layers of an image</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>With this, we can finally write bugs once, and run them everywhere!</p>
]]></content>
        </entry>
    </feed>