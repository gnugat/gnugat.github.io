<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2024-09-12T12:57:37+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Symfony Differently - part 3: Conclusion]]></title>
            <link href="/2015/08/02/sf-differently-part-3-conclusion.html"/>
            <updated>2015-08-02T00:00:00+01:00</updated>
            <id>/2015/08/02/sf-differently-part-3-conclusion.html</id>
            <content type="html"><![CDATA[<p>This series isn't really working for me, so I've decided to conclude it prematurely.
Have a look at the first ones:</p>

<ol>
<li><a href="/2015/06/03/sf-differently-part-1-introduction.html">Introduction</a></li>
<li><a href="/2015/06/10/sf-differently-part-2-bootstrap.html">Bootstrap</a></li>
</ol>

<p>In this article we'll see a series of optimizations with their impact. Then we'll
conclude that Caching is actually better, let's see those figures!</p>

<h2 id="tools">Tools</h2>

<p>The application is built with the Symfony Standard Edition and Doctrine ORM's QueryBuilder.
Composer's configuration has been tweaked to use PSR-4 and to not autoload tests.
Also Composer has been run with the <code>--optimize-autoloader</code> option.</p>

<p>Tests are done using <a href="https://httpd.apache.org/docs/2.2/programs/ab.html">ab</a>
(with 10 concurrent clients for 10 seconds), on a different server than the application's
one.</p>

<p>Also, we're using PHP 5.5 and Symfony 2.7.</p>

<h2 id="optimizations">Optimizations</h2>

<p>The application would initially serve: <strong>22 requests / seconds</strong>.</p>

<p>By removing unused dependencies, we get <strong>23 requests / seconds</strong>.</p>

<blockquote>
  <p>Note</p>
  
  <p>Removed:</p>
  
  <ul>
  <li>AsseticBundle</li>
  <li>SensioDistributionBundle (only from <code>AppKernel</code>, the dependency is kept to generate <code>app/bootstrap.php.cache</code>)</li>
  <li>SensioGeneratorBundle</li>
  <li>SwiftmailerBundle</li>
  <li>TwigBundle</li>
  <li>WebProfilerBundle</li>
  </ul>
  
  <p>Also, the following components have been disabled:</p>
  
  <ul>
  <li>Form</li>
  <li>Validation</li>
  </ul>
</blockquote>

<p>By switching from Doctrine ORM's Query Builder to Doctrine DBAL's one: <strong>28 requests / seconds</strong>.</p>

<p>By <a href="http://labs.octivi.com/mastering-symfony2-performance-internals/">adding classes to compile</a>:
<strong>29 requests / seconds</strong>.</p>

<p>By defining controllers as services: <strong>30 requests / seconds</strong>.</p>

<p>This sums up to an increase of 36%.</p>

<h2 id="how-about-using-http-cache%3F">How about using HTTP cache?</h2>

<p>By setting a 10 seconds HTTP cache (using <a href="http://foshttpcachebundle.readthedocs.org/en/latest/">FOSCacheBundle</a>),
on top of the previous optimizations , we get <strong>160 requests / seconds</strong> (an increase of 430%).</p>

<p>And that's by using Symfony's built in reverse proxy, imagine what we could get with varnish!</p>

<h2 id="conclusion">Conclusion</h2>

<p>While optimizations are fun, they don't bring much value. The main bottlenecks
are usually the autoloading, database/network transactions and the number of functions
called.</p>

<p>On the other hand, using a reverse proxy is quite simple and does pay off!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Differently - part 2: Bootstrap]]></title>
            <link href="/2015/06/10/sf-differently-part-2-bootstrap.html"/>
            <updated>2015-06-10T00:00:00+01:00</updated>
            <id>/2015/06/10/sf-differently-part-2-bootstrap.html</id>
            <content type="html"><![CDATA[<p>This is the second article of the <a href="https://symfony.com">Symfony</a> Differently series,
Have a look at the first one: <a href="/2015/06/03/sf-differently-part-1-introduction.html">Introduction</a>.</p>

<p>Our goal in this post is to bootstrap an application to then create a search endpoint for items.
We've decided to use Symfony for a single reason: our company Acme used it since the begining
and the API developers team has Symfony and PHP skills.</p>

<blockquote>
  <p><strong>Note</strong>: Most frameworks have a good community support, a strong documentation,
  similar features and many developers available on the market. We'll see the
  importance of a framework performances in the following articles, but the point
  here is that the choice should mainly rely on skills we have internally
  (and the ones we can acquire).</p>
</blockquote>

<h2 id="symfony-standard-edition">Symfony Standard Edition</h2>

<p>The first step is to use <a href="http://getcomposer.com/">Composer</a>:</p>

<pre><code>composer create-project symfony/framework-standard-edition items
</code></pre>

<p>This will create a directory structure for our project, download a set of third
party libraries and ask us to set a bunch of configuration parameters. In this
series we'll use a Postgres database, so we need to edit <code>app/config/config.yml</code>:</p>

<pre><code># ...

# Doctrine Configuration
doctrine:
    dbal:
        driver: pdo_pgsql

# ...
</code></pre>

<p>Once finished we'll save our work using Git:</p>

<pre><code>cd items
git init
git add -A
git ci -m 'Created a standard Symfony application'
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We can also use the <a href="http://symfony.com/doc/current/book/installation.html#installing-the-symfony-installer">Symfony Installer</a>
  to create new projects.</p>
</blockquote>

<h2 id="configuring-apache">Configuring Apache</h2>

<p>For the same reason we chose Symfony we've decided to use Apache for our web servers
(it's the one used for all previous projects).</p>

<blockquote>
  <p><strong>Note</strong>: By providing Nginx trainings and recruiting devops used to, it Acme
  could change its technology stack. The only rule when switching to another
  technology is to stick to it in order to avoid having too many different technologies.</p>
</blockquote>

<p>We need to create a virtual host first by creating the <code>/etc/apache2/sites-available/items.conf</code>
file:</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerName items.local

    DocumentRoot /home/foobar/items/web

    ErrorLog "/home/foobar/items/app/logs/apache_errors.log"
    CustomLog "/home/foobar/items/app/logs/apache_accesses.log" common

    &lt;Directory /home/foobar/items/web&gt;
        Options Indexes FollowSymLinks MultiViews
        AllowOverride all
        Require all granted
        Order allow,deny
        allow from all
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</code></pre>

<p>Apache will require access to the logs and cache directories, as well as our user.
The easiest way to avoid permission issues is to change Apache's user and group
to ours in <code>/etc/apache2/envvars</code>:</p>

<pre><code>export APACHE_RUN_USER=foobar
export APACHE_RUN_GROUP=foobar
</code></pre>

<p>We'll aslo need to add the hostname to our <code>/etc/hosts</code> file:</p>

<pre><code>echo '127.0.0.1 items.local' | sudo tee -a /etc/hosts
</code></pre>

<p>Finally we have to enable the website and reload Apache to take the configuration into account:</p>

<pre><code>sudo a2ensite items
sudo service apache2 reload
</code></pre>

<p>We now should be able to see the message "Homepage" when browsing http://items.local/app_dev.php/app/example</p>

<h2 id="tests">Tests</h2>

<p>A nice tweak to do is to move tests in a separate directory, allowing Composer to only
autoload test class in development environments. This can be done by changing <code>composer.json</code>
as follow:</p>

<pre><code>{
    "name": "acme/items",
    "license": "private",
    "type": "project",
    "description": "Specific APIs for items",
    "autoload": {
        "psr-4": { "AppBundle\\": "src/AppBundle" }
    },
    "autoload-dev": {
        "psr-4": { "AppBundle\\Tests\\": "tests/" }
    },
    "require": {
        "php": "&gt;=5.3.3",
        "symfony/symfony": "~2.7@beta",
        "doctrine/orm": "~2.2,&gt;=2.2.3,&lt;2.5",
        "doctrine/dbal": "&lt;2.5",
        "doctrine/doctrine-bundle": "~1.4",
        "symfony/assetic-bundle": "~2.3",
        "symfony/swiftmailer-bundle": "~2.3",
        "symfony/monolog-bundle": "~2.4",
        "sensio/distribution-bundle": "~3.0,&gt;=3.0.12",
        "sensio/framework-extra-bundle": "~3.0,&gt;=3.0.2",
        "incenteev/composer-parameter-handler": "~2.0"
    },
    "require-dev": {
        "sensio/generator-bundle": "~2.3"
    },
    "scripts": {
        "post-install-cmd": [
            "Incenteev\\ParameterHandler\\ScriptHandler::buildParameters",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::buildBootstrap",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::clearCache",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installAssets",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installRequirementsFile",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::removeSymfonyStandardFiles",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::prepareDeploymentTarget"
        ],
        "post-update-cmd": [
            "Incenteev\\ParameterHandler\\ScriptHandler::buildParameters",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::buildBootstrap",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::clearCache",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installAssets",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installRequirementsFile",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::removeSymfonyStandardFiles",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::prepareDeploymentTarget"
        ]
    },
    "extra": {
        "symfony-app-dir": "app",
        "symfony-web-dir": "web",
        "symfony-assets-install": "relative",
        "incenteev-parameters": {
            "file": "app/config/parameters.yml"
        }
    }
}
</code></pre>

<p>Since we've decided to move vendor binaries back to <code>vendor/bin</code>, we can un-ignore
the <code>bin</code> directory by editing <code>.gitignore</code>:</p>

<pre><code>/web/bundles/
/app/bootstrap.php.cache
/app/cache/*
/app/config/parameters.yml
/app/logs/*
!app/cache/.gitkeep
!app/logs/.gitkeep
/app/phpunit.xml
/build/
/vendor/
/composer.phar
</code></pre>

<p>To make it official, we need to run the following commands:</p>

<pre><code>rm -rf bin
composer update
</code></pre>

<blockquote>
  <p><strong>Note</strong>: In production, we'll need to run <code>composer install --no-dev --optimize-autoloader</code></p>
</blockquote>

<p>Our system/functional tests will involve database queries which can make the test suite
unreliable. To fix this, we'll create a "middleware" that wraps our <code>AppKernel</code> in a
database transaction and rolls it back after each requests:</p>

<p>To do so, we can create the following <code>app/RollbackKernel.php</code>:</p>

<pre><code class="php">&lt;?php
// File: app/RollbackKernel.php

use Doctrine\DBAL\Connection;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\HttpKernelInterface;

class RollbackKernel implements HttpKernelInterface
{
    private $app;
    private $connection;

    public function __construct(HttpKernelInterface $app, Connection $connection)
    {
        $this-&gt;app = $app;
        $this-&gt;connection = $connection;
    }

    public static function make()
    {
        $kernel = new \AppKernel('test', false);
        $kernel-&gt;boot();
        $connection = $kernel-&gt;getContainer()-&gt;get('doctrine.dbal.default_connection');

        return new self($kernel, $connection);
    }

    public function handle(Request $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true)
    {
        $this-&gt;connection-&gt;beginTransaction();
        $response = $this-&gt;app-&gt;handle($request, $type, $catch);
        $this-&gt;connection-&gt;rollback();

        return $response;
    }
}
</code></pre>

<p>To be able to use <code>RollbackKernel</code> in our tests we need to make it available by
creating the following <code>app/bootstrap_test.php</code>:</p>

<pre><code class="php">&lt;?php
// File: app/bootstrap_test.php

require __DIR__.'/bootstrap.php.cache';
require __DIR__.'/AppKernel.php';
require __DIR__.'/RollBackKernel.php';
</code></pre>

<p>Then we can configure PHPUnit to use it by editing <code>app/phpunit.xml.dist</code>:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="bootstrap_test.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="Functional Tests"&gt;
            &lt;directory&gt;../tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<p>Finally we'll install <a href="http://phpspec.net/">phpspec</a> with <a href="http://memio.github.io/spec-gen">SpecGen</a>
for our unit tests:</p>

<pre><code>composer require --dev phpunit/phpunit:~4.6 phpspec/phpspec:~2.2 memio/spec-gen:~0.3
echo 'extensions:' &gt; phpspec.yml
echo '  - Memio\SpecGen\MemioSpecGenExtension' &gt;&gt; phpspec.yml
</code></pre>

<p>And now we're ready to test our application! Let's save our work:</p>

<pre><code>git add -A
git commit -m 'Prepared application for tests'
</code></pre>

<h2 id="scripts">Scripts</h2>

<p>There's 3 common tasks we'll be doing as developers with our application:</p>

<ul>
<li>build it for our development environment</li>
<li>test it locally or in a Continuous Integration environment</li>
<li>deploy it to production</li>
</ul>

<p>In order to automate those in a simple way, we've decided to create 3 scripts:
<code>bin/build.sh</code>, <code>bin/deploy.sh</code> and <code>bin/test.sh</code>, but for this series we'll only
take care of <code>build</code> and <code>test</code>.</p>

<p>The build steps should reinitialize the database and Symfony's cache, for this
we'll need Doctrine Fixtures and Doctrine Migrations:</p>

<pre><code>composer require doctrine/doctrine-fixtures-bundle:~2.2
composer require doctrine/migrations:~1.0@alpha
composer require doctrine/doctrine-migrations-bundle:~1.0
</code></pre>

<p>Then we have to register them in <code>app/AppKernel.php</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
            new AppBundle\AppBundle(),
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            $bundles[] = new Doctrine\Bundle\FixturesBundle\DoctrineFixturesBundle();
            $bundles[] = new Doctrine\Bundle\MigrationsBundle\DoctrineMigrationsBundle();
            $bundles[] = new Symfony\Bundle\DebugBundle\DebugBundle();
            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            $bundles[] = new Sensio\Bundle\DistributionBundle\SensioDistributionBundle();
            $bundles[] = new Sensio\Bundle\GeneratorBundle\SensioGeneratorBundle();
        }

        return $bundles;
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load($this-&gt;getRootDir().'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>Now we can write the following <code>bin/build.sh</code> script:</p>

<pre><code>#!/usr/bin/env sh

echo ''
echo '// Building development environment'


rm -rf app/cache/* app/logs/*

composer --quiet --no-interaction install --optimize-autoloader &gt; /dev/null

php app/console --quiet doctrine:database:drop --force &gt; /dev/null 2&gt;&amp;1
php app/console --quiet doctrine:database:create
php app/console --no-interaction --quiet doctrine:migrations:migrate
php app/console --no-interaction --quiet doctrine:fixtures:load --fixtures=src

echo ''
echo ' [OK] Development environment built'
echo ''
</code></pre>

<p>The test steps should be similar, in addition they will run the test suites and
check for coding standards. We can install PHP CS Fixer for this:</p>

<pre><code>composer require --dev fabpot/php-cs-fixer:~1.6
</code></pre>

<p>Here's the <code>bin/test.sh</code> script:</p>

<pre><code>#!/usr/bin/env sh

echo ''
echo '// Building test environment'

rm -rf app/cache/test app/logs/*test.log

composer --quiet --no-interaction install --optimize-autoloader  &gt; /dev/null
php app/console --env=test --quiet cache:clear


php app/console --env=test --no-debug --quiet doctrine:database:drop --force &gt; /dev/null 2&gt;&amp;1
php app/console --env=test --no-debug --quiet doctrine:database:create
php app/console --env=test --no-debug --no-interaction --quiet doctrine:migrations:migrate
php app/console --env=test --no-debug --no-interaction --quiet doctrine:fixtures:load --fixtures=src

echo ''
echo ' [OK] Test environment built'
echo ''

vendor/bin/phpunit -c app &amp;&amp; vendor/bin/phpspec --no-interaction run --format=dot &amp;&amp; vendor/bin/php-cs-fixer fix --dry-run --config=sf23 .
</code></pre>

<p>With this we can start the tickets assigned to us, we can commit the changes:</p>

<pre><code>chmod +x bin/*.sh
git add -A
git commit -m 'Created build and test scripts'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Acme's technology stack is composed of Apache2, PostgreSQL, Symfony, PHPUnit and phpspec.
In order to ake sure that anyone in the team or any new comers can maintain this new
application in the future, we've chosen to stay consistent with the rest.</p>

<p>In the next article, we'll create the search items endpoint in a pragmatic way.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony Differently - part 1: Introduction]]></title>
            <link href="/2015/06/03/sf-differently-part-1-introduction.html"/>
            <updated>2015-06-03T00:00:00+01:00</updated>
            <id>/2015/06/03/sf-differently-part-1-introduction.html</id>
            <content type="html"><![CDATA[<p><a href="https://symfony.com">Symfony</a> is an amazing HTTP framework which powers
<a href="http://labs.octivi.com/handling-1-billion-requests-a-week-with-symfony2/">high traffic websites</a>.
Performance shouldn't be a concern when first creating a website, because between
the time it is launched and the time it actually has a high traffic many things
that we didn't expect in the first days will happen:</p>

<ul>
<li>requirements will change</li>
<li>user behavior will change</li>
<li>even the team can change</li>
</ul>

<p>Optimizing applications has an impact over maintenance, and making it harder to change
right from the begining might not be the best option. However when the need of performance
actually arises, we need to tackle it.</p>

<p>This series of articles is about this specific moment, and how to tackle it in a pragmatic way.</p>

<blockquote>
  <p><strong>Spoiler Alert</strong>: It will feature a section where we optimize our application step by step,
  with a monitoring of the impact on performance. We'll see that those don't make a big
  difference, which is why those concerns shouldn't be addressed from day 1.</p>
</blockquote>

<p>First, let's have a look at the big picture. Please note that the approach we use
here is only one amongst many (every need is different, it might not be the best in every situations).</p>

<h2 id="the-project">The project</h2>

<p>For our examples, we'll pretend to be the Acme Company which powers half the planet
in almost every aspect of our lives. Performance isn't just a concern, it has become
a reality.</p>

<blockquote>
  <p><strong>Note</strong>: Those examples are all made up, but they're based on real experience.</p>
</blockquote>

<p>We've analysed our market and we'd like to have the following new feature:</p>

<pre><code>As a customer, I'd like to buy an item
</code></pre>

<p>During a meeting, we've come up with the following example:</p>

<pre><code>Given a "fruit" category
When I pick a "banana"
Then it should be ordered
</code></pre>

<h2 id="the-team">The team</h2>

<p>In the first days of Acme, we only had a few developers which were full stack. It
worked quite well but we've grown so much that we had to recruit more specialized
profiles with a frontend team and an API one: it allowed us to parallelize the work.</p>

<h2 id="the-architecture">The architecture</h2>

<p>Frontend applications that live in the customer's browser have been chosen because:</p>

<ul>
<li>they are extremely responsive</li>
<li>they provide a richer User eXperience</li>
<li>they have a lower server consumption</li>
</ul>

<p>In the early days of Acme there was a single big application, but with the number
of customer growing and asking features specific to their need, it failed us hard
costing us Money, Customers and Developers.
Now each frontend applications talk to a dedicated API.</p>

<p>The dedicated APIs mix and match data coming from another layer of specific APIs.
Those basically provide Create Read Update Delete and Search (CRUDS) access to
their own data storage.</p>

<blockquote>
  <p><strong>Note</strong>: We've decided to have two layers of APIs in order to avoid mixing
  features specific to a customer in an endpoint used by everyone.</p>
</blockquote>

<p>From the Use Stories, we've identified two types of data: <code>item</code> related ones
and <code>order</code> related one.
We've decided to create the following applications:</p>

<ul>
<li><code>acme/order-items-front</code>, the frontend application</li>
<li><code>acme/order-items-api</code> the dedicated API</li>
<li><code>acme/items</code>, an API specific to the <code>item</code> and <code>item_category</code> tables</li>
<li><code>acme/orders</code>, an API specific to the <code>order</code> table</li>
</ul>

<p><img src="http://yuml.me/c0591d90" alt="Diagram" /></p>

<p>In this series, we'll focus on the creation of the Search endpoint in <code>acme/items</code>.</p>

<h2 id="the-task">The task</h2>

<p>The Search endpoint should allow:</p>

<ul>
<li>pagination of items, using <code>page</code> and <code>per_page</code> parameters</li>
<li>filtering of items, using column name with value for parameters</li>
<li>ordering items, using a <code>sort</code> parameter</li>
</ul>

<p>In this series, we'll focus on paginating items.</p>

<p>Here's a valid <code>Request</code> sample:</p>

<pre><code>GET /v1/items?page=2&amp;per_page=1 HTTP/1.1
</code></pre>

<p>It should return a <code>Response</code> similar to:</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: application/json

{"data":[{"id":42,"name":"banana","category_id":23}],"page":{"current_page":2,"per_page":1,"total_elements":2,"total_pages":2}}
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Our Acme mega corporation needs a new feature and we've decided to implement it
by creating a frontend, its dedicated API which mix and match data coming from two
new specific APIs.</p>

<p>The choice of this architecture has been made because it solved issues encountered
in Acme's past, when we had a single big application.</p>

<p>In the next article we'll bootstrap a Symfony application to create an endpoint to search
for items.</p>

<p>In the mean time if you're interrested in creating APIs in a pragmatic way you can
read <a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">the following article</a>.
If you're wondering why Acme didn't use this approach from the begining you might
want to read <a href="http://martinfowler.com/bliki/MonolithFirst.html">the following article</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 3.3: Consuming, remote calls]]></title>
            <link href="/2015/03/25/sf-ws-part-3-3-consuming-remote.html"/>
            <updated>2015-03-25T00:00:00+00:00</updated>
            <id>/2015/03/25/sf-ws-part-3-3-consuming-remote.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the seventh article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the six first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
<li><a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">2.3 Creation, refactoring</a></li>
<li><a href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html">3.1 Consuming, RequestHandler</a></li>
<li><a href="/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html">3.2 Consuming, Guzzle</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-cs">following repository</a>.</p>

<p>In the previous article, we've created a Guzzle RequestHandler: we are now able
to make remote calls using a third party library, but without the cost of coupling
ourselves to it. If Guzzle 6 is released we'll have to change only one class, instead
of everywhere in our application.</p>

<p>In this article, we'll create the actual remote calls.</p>

<h2 id="credential-configuration">Credential configuration</h2>

<p>The web service we want to call requires us to authenticate. Those credentials
shouldn't be hardcoded, we'll create new parameters for them (same goes for the URL):</p>

<pre><code># File: app/config/parameters.yml.dist
    ws_url: http://example.com
    ws_username: username
    ws_password: ~
</code></pre>

<p>We can then set those values in the actual parameter file:</p>

<pre><code># File: app/config/parameters.yml
    ws_url: "http://ws.local/app_dev.php"
    ws_username: spanish_inquisition
    ws_password: "NobodyExpectsIt!"
</code></pre>

<p>Note that because our password contains a character which is reserved in YAML (<code>!</code>),
we need to put the value between double quotes (same goes for <code>%</code> and <code>@</code>).</p>

<p>Let's commit this:</p>

<pre><code>git add -A
git commit -m 'Added credentials configuration'
</code></pre>

<h2 id="profile-gateway">Profile Gateway</h2>

<p>We can create a <a href="http://martinfowler.com/eaaCatalog/gateway.html">Gateway</a>
specialized in calling the profile web service:</p>

<pre><code>./bin/phpspec describe 'AppBundle\Profile\ProfileGateway'
</code></pre>

<p>Usually we categorize our Symfony applications by Pattern: we'd create a <code>Gateway</code>
directory with all the Gateway service. However this can become quite cubersome
when the application grows, services are usually linked to a model meaning that
we'd have to jump from the <code>Model</code> (or <code>Entity</code>) directory to the <code>Gateway</code> one,
then go to the <code>Factory</code> directory, etc...</p>

<p>Here we've chosen an alternative: group services by model. All <code>Profile</code> services
can be found in the same directory.</p>

<p>Let's write the Gateway's specification:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/Profile/ProfileGatewaySpec.php

namespace spec\AppBundle\Profile;

use AppBundle\RequestHandler\RequestHandler;
use AppBundle\RequestHandler\Response;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class ProfileGatewaySpec extends ObjectBehavior
{
    const URL = 'http://example.com';
    const USERNAME = 'spanish inquisition';
    const PASSWORD = 'nobody expects it';

    const ID = 42;
    const NAME = 'Arthur';

    function let(RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($requestHandler, self::URL, self::USERNAME, self::PASSWORD);
    }

    function it_creates_profiles(RequestHandler $requestHandler, Response $response)
    {
        $profile = array(
            'id' =&gt; self::ID,
            'name' =&gt; self::NAME,
        );

        $request = Argument::type('AppBundle\RequestHandler\Request');
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $response-&gt;getBody()-&gt;willReturn($profile);

        $this-&gt;create(self::NAME)-&gt;shouldBe($profile);
    }
}
</code></pre>

<p>We can now generate the code's skeleton:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>It constructs a <code>Request</code> object, gives it to <code>RequestHandler</code> and then returns the
<code>Response</code>'s body:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Profile/ProfileGateway.php

namespace AppBundle\Profile;

use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;

class ProfileGateway
{
    private $requestHandler;
    private $url;
    private $username;
    private $password;

    public function __construct(RequestHandler $requestHandler, $url, $username, $password)
    {
        $this-&gt;requestHandler = $requestHandler;
        $this-&gt;username = $username;
        $this-&gt;password = $password;
    }

    public function create($name)
    {
        $request = new Request('POST', $this-&gt;url.'/api/v1/profiles');
        $request-&gt;setHeader('Authorization', 'Basic '.base64_encode($this-&gt;username.':'.$this-&gt;password));
        $request-&gt;setHeader('Content-Type', 'application/json');
        $request-&gt;setBody(json_encode(array('name' =&gt; $name)));

        $response = $this-&gt;requestHandler-&gt;handle($request);

        return $response-&gt;getBody();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Managing URLs can become quite tricky when the number of routes grows.
  Sometimes we'll want HTTPS, sometimes HTTP. Sometimes we'll want the first version
  of the API, sometimes the pre production one. And what should we do when we'll
  need query parameters?</p>
  
  <p>Usually I don't bother with those until the need is actually there, then I create
  a <code>UrlGenerator</code> which works a bit like Symfony's one and relies on a configuration array.</p>
</blockquote>

<p>Let's check our tests:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green!</p>

<pre><code>git add -A
git commit -m 'Created ProfileGateway'
</code></pre>

<h2 id="create-profile-command">Create Profile Command</h2>

<p>Our application happens to be a Command Line Interface (CLI). We want to write a
command to create profiles, and as usual we'll begin with a test:</p>

<pre><code class="php">&lt;?php
// File: tests/Command/CreateProfileCommandTest.php

namespace AppBundle\Tests\Command;

use PHPUnit_Framework_TestCase;
use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Output\NullOutput;
use Symfony\Component\Console\Input\ArrayInput;

class CreateProfileCommandTest extends PHPUnit_Framework_TestCase
{
    private $app;
    private $output;

    protected function setUp()
    {
        $kernel = new \AppKernel('test', false);
        $this-&gt;app = new Application($kernel);
        $this-&gt;app-&gt;setAutoExit(false);
        $this-&gt;output = new NullOutput();
    }

    public function testItRunsSuccessfully()
    {
        $input = new ArrayInput(array(
            'commandName' =&gt; 'app:profile:create',
            'name' =&gt; 'Igor',
        ));

        $exitCode = $this-&gt;app-&gt;run($input, $this-&gt;output);

        $this-&gt;assertSame(0, $exitCode);
    }
}
</code></pre>

<p>Let's make this test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Command/CreateProfileCommand.php

namespace AppBundle\Command;

use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class CreateProfileCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this-&gt;setName('app:profile:create');
        $this-&gt;setDescription('Create a new profile');

        $this-&gt;addArgument('name', InputArgument::REQUIRED);
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $profileGateway = $this-&gt;getContainer()-&gt;get('app.profile_gateway');

        $profile = $profileGateway-&gt;create($input-&gt;getArgument('name'));

        $output-&gt;writeln(sprintf('Profile #%s "%s" created', $profile['id'], $profile['name']));
    }
}
</code></pre>

<p>We'll need to define <code>ProfileGateway</code> as a service:</p>

<pre><code># File: app/config/services.yml
imports:
    - { resource: services/request_handler.yml }

services:
    app.profile_gateway:
        class: AppBundle\Profile\ProfileGateway
        arguments:
            - "@app.request_handler"
            - "%ws_url%"
            - "%ws_username%"
            - "%ws_password%"
</code></pre>

<p>By having a look <code>ProfileGateway</code> we can spot a mistake, the initialization or URL
is missing from the constructor:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Profile/ProfileGateway.php

    public function __construct(RequestHandler $requestHandler, $url, $username, $password)
    {
        $this-&gt;requestHandler = $requestHandler;
        $this-&gt;username = $username;
        $this-&gt;password = $password;
        $this-&gt;url = $url;
    }
</code></pre>

<p>Another mistake lies in <code>JsonResponseListener</code>, each Guzzle header is an array:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Listener/JsonResponseListener.php

        $contentType = $response-&gt;getHeader('Content-Type');
        if (false === strpos($contentType[0], 'application/json')) {
            return;
        }
</code></pre>

<p>With these fixes, the test should pass:</p>

<pre><code>phpunit -c app
</code></pre>

<blockquote>
  <p><strong>Note</strong>: if we get a <code>You have requested a non-existent service "app.profile_gateway"</code>
  error, we might need to clear the cache for test environment: <code>php app/console cache:clear --env=test</code>.</p>
  
  <p><strong>Note</strong>: if we get a Guzzle exception, we need to check that the previous application installed
  ("ws.local"), and that its database is created:</p>

<pre><code>cd ../ws
php app/console doctrine:database:create
php app/console doctrine:schema:create
cd ../cs
</code></pre>
</blockquote>

<p>We can now save our work:</p>

<pre><code>git add -A
git commit -m 'Created CreateProfileCommand'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We have now an application that consumes a web service. We have decoupled it from
third party libraries using RequestHandler and isolated the endpoint logic in a
Gateway class.</p>

<p>There's a lot to say about the test we wrote: it makes a network call which is slow, unreliable
and it isn't immutable. If we try to run again our test, it will fail!
To fix this we have many possibilities:</p>

<ul>
<li>mock the endpoints, it will make the tests faster and immutable but if the endpoints change our tests will still pass</li>
<li>cleanup the created profile by aking another network call, it will make the test even slower</li>
</ul>

<p>At this point it depends on how confident we are in the web services and what we want to test.</p>

<p>We should also write more test on edge cases: what happens with the wrong credentials?
What happens if the endpoints cannot be reached (request timeout, connection timeout, etc)?
What happens when we try to create a profile which already exists?</p>

<p>As it happens, this is also the conclusion of this series on managing Web Services in a
Symfony environment. There's a lot more to say for example about caching remote resources
in a local database, about self discovering APIs and about micro services, but I feel
those should each have their own series of article :) .</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 3.2: Consuming, Guzzle]]></title>
            <link href="/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html"/>
            <updated>2015-03-18T00:00:00+00:00</updated>
            <id>/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the sixth article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the five first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
<li><a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">2.3 Creation, refactoring</a></li>
<li><a href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html">3.1 Consuming, RequestHandler</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-cs">following repository</a>.</p>

<p>In the previous article, we've bootstrapped an application with a RequestHandler,
allowing us to be decoupled from the third part library we'll choose to request
remote endpoints.</p>

<p>In this article, we'll create a Guzzle 5 implementation.</p>

<h2 id="guzzle-request-handler">Guzzle Request Handler</h2>

<p>As usual, we first describe the class we want to create:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Middleware\GuzzleRequestHandler'
</code></pre>

<p>Our Guzzle implementation will translate our <code>Request</code> into a guzzle one, and a
guzzle response into our <code>Response</code>:</p>

<pre><code class="php">&lt;?php
// spec/AppBundle/RequestHandler/Middleware/GuzzleRequestHandlerSpec.php

namespace spec\AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Request;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Message\RequestInterface;
use GuzzleHttp\Message\ResponseInterface;
use GuzzleHttp\Stream\StreamInterface;
use PhpSpec\ObjectBehavior;

class GuzzleRequestHandlerSpec extends ObjectBehavior
{
    const VERB = 'POST';
    const URI = '/api/v1/profiles';

    const HEADER_NAME = 'Content-Type';
    const HEADER_VALUE = 'application/json';

    const BODY = '{"username":"King Arthur"}';

    function let(ClientInterface $client)
    {
        $this-&gt;beConstructedWith($client);
    }

    function it_is_a_request_handler()
    {
        $this-&gt;shouldImplement('AppBundle\RequestHandler\RequestHandler');
    }

    function it_uses_guzzle_to_do_the_actual_request(
        ClientInterface $client,
        RequestInterface $guzzleRequest,
        ResponseInterface $guzzleResponse,
        StreamInterface $stream
    )
    {
        $request = new Request(self::VERB, self::URI);
        $request-&gt;setHeader(self::HEADER_NAME, self::HEADER_VALUE);
        $request-&gt;setBody(self::BODY);

        $client-&gt;createRequest(self::VERB, self::URI, array(
            'headers' =&gt; array(self::HEADER_NAME =&gt; self::HEADER_VALUE),
            'body' =&gt; self::BODY,
        ))-&gt;willReturn($guzzleRequest);
        $client-&gt;send($guzzleRequest)-&gt;willReturn($guzzleResponse);
        $guzzleResponse-&gt;getStatusCode()-&gt;willReturn(201);
        $guzzleResponse-&gt;getHeaders()-&gt;willReturn(array('Content-Type' =&gt; 'application/json'));
        $guzzleResponse-&gt;getBody()-&gt;willReturn($stream);
        $stream-&gt;__toString()-&gt;willReturn('{"id":42,"username":"King Arthur"}');

        $this-&gt;handle($request)-&gt;shouldHaveType('AppBundle\RequestHandler\Response');
    }
}
</code></pre>

<p>Time to boostrap this implementation:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And to actually write it:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Middleware/GuzzleRequestHandler.php

namespace AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;
use AppBundle\RequestHandler\Response;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Message\RequestInterface;
use GuzzleHttp\Message\ResponseInterface;
use GuzzleHttp\Stream\StreamInterface;

class GuzzleRequestHandler implements RequestHandler
{
    private $client;

    public function __construct(ClientInterface $client)
    {
        $this-&gt;client = $client;
    }

    public function handle(Request $request)
    {
        $guzzleRequest = $this-&gt;client-&gt;createRequest($request-&gt;getVerb(), $request-&gt;getUri(), array(
            'headers' =&gt; $request-&gt;getHeaders(),
            'body' =&gt; $request-&gt;getBody(),
        ));
        $guzzleResponse = $this-&gt;client-&gt;send($guzzleRequest);
        $response = new Response($guzzleResponse-&gt;getStatusCode());
        $response-&gt;setHeaders($guzzleResponse-&gt;getHeaders());
        $response-&gt;setBody($guzzleResponse-&gt;getBody()-&gt;__toString());

        return $response;
    }
}
</code></pre>

<p>Let's check it:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Brilliant!</p>

<pre><code>git add -A
git commit -m 'Created GuzzleRequestHandler'
</code></pre>

<h2 id="event-middleware">Event Middleware</h2>

<p>In the future we'd like to be able to hook in the <code>RequestHandler</code>'s workflow,
for example if the Response's body is in JSON, convert it into an array.</p>

<p>This kind of thing can be done by sending events, in our case when a Response is received:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/ReceivedResponse.php

namespace AppBundle\RequestHandler\Event;

use AppBundle\RequestHandler\Response;
use Symfony\Component\EventDispatcher\Event;

class ReceivedResponse extends Event
{
    private $response;

    public function __construct(Response $response)
    {
        $this-&gt;response = $response;
    }

    public function getResponse()
    {
        return $this-&gt;response;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: This is a simple Data Transfer Object (DTO), it doesn't contain any
  logic and never will. This means that we don't have to write any tests for it.</p>
</blockquote>

<p>We could add an <code>EventDispatcher</code> in <code>GuzzleRequestHandler</code>, or we could create
a middleware: a RequestHandler that dispatches events and then calls another RequestHandler
(e.g. <code>GuzzleRequestHandler</code>):</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Middleware\EventRequestHandler'
</code></pre>

<p>This way if we want to throw away <code>GuzzleRequestHandler</code> and replace it with something
else, we don't have to write again the dispatching code. Here's the specification:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/RequestHandler/Middleware/EventRequestHandlerSpec.php

namespace spec\AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;
use AppBundle\RequestHandler\Response;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;

class EventRequestHandlerSpec extends ObjectBehavior
{
    function let(EventDispatcherInterface $eventDispatcher, RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($eventDispatcher, $requestHandler);
    }

    function it_is_a_request_handler()
    {
        $this-&gt;shouldImplement('AppBundle\RequestHandler\RequestHandler');
    }

    function it_dispatches_events(
        EventDispatcherInterface $eventDispatcher,
        Request $request,
        RequestHandler $requestHandler,
        Response $response
    )
    {
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $receivedResponse = Argument::type('AppBundle\RequestHandler\Event\ReceivedResponse');
        $eventDispatcher-&gt;dispatch('request_handler.received_response', $receivedResponse)-&gt;shouldBeCalled();

        $this-&gt;handle($request)-&gt;shouldBe($response);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We could improve this middleware by dispatching an event before giving
  the request to the RequestHandler. We could also catch exceptions coming from
  the RequestHandler and dispatch an event.</p>
</blockquote>

<p>Time to bootstrap the code:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And to make the test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Middleware/EventRequestHandler.php

namespace AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Event\ReceivedResponse;
use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;

class EventRequestHandler implements RequestHandler
{
    private $eventDispatcher;
    private $requestHandler;

    public function __construct(EventDispatcherInterface $eventDispatcher, RequestHandler $requestHandler)
    {
        $this-&gt;eventDispatcher = $eventDispatcher;
        $this-&gt;requestHandler = $requestHandler;
    }

    public function handle(Request $request)
    {
        $response = $this-&gt;requestHandler-&gt;handle($request);
        $this-&gt;eventDispatcher-&gt;dispatch('request_handler.received_response', new ReceivedResponse($response));

        return $response;
    }
}
</code></pre>

<p>Did we succeed?</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Yes, we did:</p>

<pre><code>git add -A
git commit -m 'Created EventRequestHandler'
</code></pre>

<h2 id="json-response-listener">Json Response Listener</h2>

<p>When a Response contains a JSON body, we need to:</p>

<ul>
<li>check the content type</li>
<li>decode the body</li>
<li>check that the JSON syntax is valid</li>
</ul>

<p>With this in mind, we can describe the listerner:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Listener\JsonResponseListener'
</code></pre>

<p>Now we can write the specification:</p>

<pre><code class="php">&lt;?php
// src: spec/AppBundle/RequestHandler/Listener/JsonResponseListenerSpec.php

namespace spec\AppBundle\RequestHandler\Listener;

use AppBundle\RequestHandler\Event\ReceivedResponse;
use AppBundle\RequestHandler\Response;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class JsonResponseListenerSpec extends ObjectBehavior
{
    function it_handles_json_response(ReceivedResponse $receivedResponse, Response $response)
    {
        $receivedResponse-&gt;getResponse()-&gt;willReturn($response);
        $response-&gt;getHeader('Content-Type')-&gt;willReturn('application/json');
        $response-&gt;getBody()-&gt;willReturn('{"data":[]}');
        $response-&gt;setBody(array('data' =&gt; array()))-&gt;shouldBeCalled();

        $this-&gt;onReceivedResponse($receivedResponse);
    }

    function it_does_not_handle_non_json_response(ReceivedResponse $receivedResponse, Response $response)
    {
        $receivedResponse-&gt;getResponse()-&gt;willReturn($response);
        $response-&gt;getHeader('Content-Type')-&gt;willReturn('text/html');
        $response-&gt;getBody()-&gt;shouldNotBeCalled();

        $this-&gt;onReceivedResponse($receivedResponse);
    }

    function it_fails_to_handle_invalid_json(ReceivedResponse $receivedResponse, Response $response)
    {
        $receivedResponse-&gt;getResponse()-&gt;willReturn($response);
        $response-&gt;getHeader('Content-Type')-&gt;willReturn('application/json');
        $response-&gt;getBody()-&gt;willReturn('{"data":[');

        $exception = 'Exception';
        $this-&gt;shouldThrow($exception)-&gt;duringOnReceivedResponse($receivedResponse);
    }
}
</code></pre>

<p>Time to implement the code:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Listener/JsonResponseListener.php

namespace AppBundle\RequestHandler\Listener;

use AppBundle\RequestHandler\Event\ReceivedResponse;
use Exception;

class JsonResponseListener
{
    public function onReceivedResponse(ReceivedResponse $receivedResponse)
    {
        $response = $receivedResponse-&gt;getResponse();
        $contentType = $response-&gt;getHeader('Content-Type');
        if (false === strpos($response-&gt;getHeader('Content-Type'), 'application/json')) {
            return;
        }
        $body = $response-&gt;getBody();
        $json = json_decode($body, true);
        if (json_last_error()) {
            throw new Exception("Invalid JSON: $body");
        }
        $response-&gt;setBody($json);
    }
}
</code></pre>

<p>Is it enough to make the tests pass?</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Yes, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created JsonResponseListener'
</code></pre>

<h2 id="creating-services">Creating services</h2>

<p>In order to be able to use this code in our Symfony application, we need to
define those classes as services. Since we'll have a lot of definitions, we'll
create a <code>services</code> directory:</p>

<pre><code>mkdir app/config/services
</code></pre>

<p>We'll update <code>services.yml</code> to include our new file:</p>

<pre><code># File: app/config/services.yml
imports:
    - { resource: services/request_handler.yml }
</code></pre>

<p>And finally we'll create the <code>request_handler.yml</code> file:</p>

<pre><code>touch app/config/services/request_handler.yml
</code></pre>

<p>The first service we'll define is Guzzle:</p>

<pre><code>#file: app/config/services/request_handler.yml
services:
    guzzle.client:
        class: GuzzleHttp\Client
</code></pre>

<p>This allows us to define the GuzzleRequestHandler:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.guzzle_request_handler:
        class: AppBundle\RequestHandler\Middleware\GuzzleRequestHandler
        arguments:
            - "@guzzle.client"
</code></pre>

<p>We want to wrap each of these GuzzleRequestHandler calls with events, so we define
EventRequestHandler like this:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.event_request_handler:
        class: AppBundle\RequestHandler\Middleware\EventRequestHandler
        arguments:
            - "@event_dispatcher"
            - "@app.guzzle_request_handler"
</code></pre>

<p>In the future we might add more middlewares (e.g. RetryRequestHandler, StopwatchRequestHandler, etc),
so we want to avoid using a service that points directly to an implementation. We
can define an alias:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.request_handler:
        alias: app.event_request_handler
</code></pre>

<p>Finally, we want to define our listener:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.request_handler.json_response_listener:
        class: AppBundle\RequestHandler\Listener\JsonResponseListener
        tags:
            - { name: kernel.event_listener, event: request_handler.received_response, method: onReceivedResponse }
</code></pre>

<p>And that's it!</p>

<pre><code>git add -A
git commit -m 'Defined RequestHandler as a service'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We can now send remote request using Guzzle, without coupling ourself to the library.
We even implemented an EventRequestHandler to allow extension points, it also provides
us an example on how to write more RequestHandler middlewares.</p>

<p>In the next article we'll start using RequestHandler in a specific kind of service:
Gateways.</p>

<h3 id="http-adapter">HTTP Adapter</h3>

<p>You might be interested in <a href="https://github.com/egeloen/ivory-http-adapter">Ivory HttpAdapter</a>,
a library very similar to our RequestHandler: it sends remote request through a
given client (it supports many of them). It also provides events to hook into its workflow!</p>

<p>Personnaly, I'd rather create my own RequestHandler, as my purpose is to decouple
the application from an external library like Guzzle: using a third party library
to do so seems a bit ironic.
As you can see there's little effort involved, and it has the advantage of providing
the strict minimum the application needs.</p>

<h3 id="psr-7">PSR-7</h3>

<p><a href="https://github.com/php-fig/fig-standards/blob/master/proposed/http-message.md">PSR-7</a>
is a standard currently under review: it defines how frameworks should ideally
implement the HTTP protocole.</p>

<p>Since it's not yet accepted, it is subject to change so I wouldn't recommend to follow it yet.
Our RequestHandler kind of implement the HTTP protocole, but I'd rather not make
it PSR-7 compliant, as it requires the implementation of many features we don't
really need.</p>

<p>To get a balanced opinion on the matter, I'd recommend you to read:</p>

<ul>
<li><a href="https://mwop.net/blog/2015-01-26-psr-7-by-example.html">PSR-7 By Example</a></li>
<li><a href="http://evertpot.com/psr-7-issues/">PSR-7 is imminent, and here's my issues with it.</a></li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 3.1: Consuming, RequestHandler]]></title>
            <link href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html"/>
            <updated>2015-03-11T00:00:00+00:00</updated>
            <id>/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fifth article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the four first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
<li><a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">2.3 Creation, refactoring</a></li>
</ul>

<p>Our purpose in this third section is to create an application that consumes the
<a href="https://github.com/gnugat-examples/sf-ws">previously created web services</a>.</p>

<p>But for now, we'll just bootstrap it, and start to create a RequestHandler!</p>

<h2 id="installation">Installation</h2>

<p>We will follow the exact same steps as in <a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">the chapter 2.1</a>:</p>

<ol>
<li>Installing the standard edition</li>
<li>Twitching for tests</li>
</ol>

<p>Instead of calling our application <code>ws</code>, we'll call it <code>cs</code> (like Consuming Service).</p>

<h2 id="making-remote-calls-with-guzzle">Making remote calls with Guzzle</h2>

<p>Is the application boostrapped yet? If it is, then we can continue.</p>

<p>In order to consume web services, we need to be able to make remote requests. PHP
provides some native functions for this (<code>file_get_contents</code>, <code>stream_socket_client</code>,
<code>fopen</code>, etc) and we can find many libraries as well (<a href="https://github.com/kriswallsmith/Buzz">Buzz</a>,
<a href="http://phphttpclient.com/">HTTP Full</a>, <a href="http://reactphp.org/">React</a>, etc).</p>

<p>For this series, we'll use <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>:</p>

<pre><code>composer require guzzlehttp/guzzle:~5.0
</code></pre>

<p>Let's commit it for now:</p>

<pre><code>git add -A
git commit -m 'Installed Guzzle'
</code></pre>

<h2 id="creating-a-request-handler">Creating a Request Handler</h2>

<p>Sometimes we need to decouple our application from the third party libraries it depends on.</p>

<p>For example let's say that we were using Guzzle 4, but we'd like to use Amazon Web Service (AWS)
S3 in our project. The issue? It's version 2 depends on Guzzle 3 and its version 3
depends on Guzzle 5. We now need to upgrade our usage of Guzzle everywhere in our
application.</p>

<p><a href="http://knowyourmeme.com/photos/141710-true-story"><img src="http://i0.kym-cdn.com/photos/images/newsfeed/000/141/710/7nTnr.png?1309357850" alt="True story" /></a></p>

<p>To minimize this, we can centralize the usage of Guzzle in one single file. In order
to be able to do so, we'll create a RequestHandler:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/RequestHandler.php

namespace AppBundle\RequestHandler;

interface RequestHandler
{
    // @return Response
    public function handle(Request $request);
}
</code></pre>

<p>In our application we can rely on this interface: we own it and it has few chances to change.
We'll now create an object that describes the request to send:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Request'
</code></pre>

<p>A minimalistic raw HTTP request looks like the following:</p>

<pre><code>GET /api/v1/profiles HTTP/1.1
</code></pre>

<p>Since we don't really care about the protocol's version we can define the constructor
with two arguments:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/RequestSpec.php

    function it_has_a_verb_and_an_uri()
    {
        $this-&gt;beConstructedWith('GET', '/api/v1/profiles');

        $this-&gt;getVerb()-&gt;shouldBe('GET');
        $this-&gt;getUri()-&gt;shouldBe('/api/v1/profiles');
    }
</code></pre>

<p>Running the specifications will bootstrap the class for us:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>We can now make the test pass by writing the code:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Request.php

namespace AppBundle\RequestHandler;

class Request
{
    private $verb;
    private $uri;

    public function __construct($verb, $uri)
    {
        $this-&gt;verb = $verb;
        $this-&gt;uri = $uri;
    }

    public function getVerb()
    {
        return $this-&gt;verb;
    }

    public function getUri()
    {
        return $this-&gt;uri;
    }
}
</code></pre>

<p>Let's check if it's enough for now:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created Request'
</code></pre>

<h2 id="request-headers">Request headers</h2>

<p>A request usually has headers:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/RequestSpec.php

    function it_can_have_headers()
    {
        $this-&gt;beConstructedWith('GET', '/api/v1/profiles');
        $this-&gt;setHeader('Content-Type', 'application/json');

        $this-&gt;getHeaders()-&gt;shouldBe(array('Content-Type' =&gt; 'application/json'));
    }
</code></pre>

<p>Let's boostrap them:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And complete the code:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Request.php

    private $headers = array();

    public function setHeader($name, $value)
    {
        $this-&gt;headers[$name] = $value;
    }

    public function getHeaders()
    {
        return $this-&gt;headers;
    }
</code></pre>

<p>This makes the test pass:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>That's worth a commit:</p>

<pre><code>git add -A
git commit -m 'Added headers to Request'
</code></pre>

<h2 id="request-body">Request body</h2>

<p>The last addition to our request will be the possibility to add a body:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/RequestSpec.php

    function it_can_have_a_body()
    {
        $this-&gt;beConstructedWith('GET', '/api/v1/profiles');
        $this-&gt;setBody('{"wound":"just a flesh one"}');

        $this-&gt;getBody()-&gt;shouldBe('{"wound":"just a flesh one"}');
    }
</code></pre>

<p>As usual we bootstrap it:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And then we complete it:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Request.php

    private $body;

    public function setBody($body)
    {
        $this-&gt;body = $body;
    }

    public function getBody()
    {
        return $this-&gt;body;
    }
</code></pre>

<p>Let's make our console green:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Let's make our console grin:</p>

<pre><code>git add -A
git commit -m 'Added body to Request'
</code></pre>

<h2 id="creating-a-response">Creating a Response</h2>

<p><code>RequestHandler</code> should return a <code>Response</code> object:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Response'
</code></pre>

<p>A minimalistic raw HTTP response looks like the following:</p>

<pre><code>HTTP/1.1 204 NO CONTENT
</code></pre>

<p>Since we don't care about both the protocol's version and the reason, we can
define the constructor with a single argument:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/ResponseSpec.php

    function it_has_a_status_code()
    {
        $this-&gt;beConstructedWith(204);

        $this-&gt;getStatusCode()-&gt;shouldBe(204);
    }
</code></pre>

<p>Running the specifications will bootstrap the class for us:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>We can now make the test pass by writing the code:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Response.php

namespace AppBundle\RequestHandler;

class Response
{
    private $statusCode;

    public function __construct($statusCode)
    {
        $this-&gt;statusCode = $statusCode;
    }

    public function getStatusCode()
    {
        return $this-&gt;statusCode;
    }
}
</code></pre>

<p>Let's check if it's enough for now:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created Response'
</code></pre>

<h2 id="response-headers">Response headers</h2>

<p>A response can also have headers:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/ResponseSpec.php

    function it_can_have_headers()
    {
        $this-&gt;beConstructedWith(204);
        $this-&gt;setHeaders(array('Content-Type' =&gt; 'application/json'));

        $this-&gt;getHeader('Content-Type')-&gt;shouldBe('application/json');
    }
</code></pre>

<p>Let's boostrap them:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And complete the code:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Response.php

    private $headers = array();

    public function setHeaders(array $headers)
    {
        $this-&gt;headers = $headers;
    }

    public function getHeader($name)
    {
        return (isset($this-&gt;headers[$name]) ? $this-&gt;headers[$name] : null);
    }
</code></pre>

<p>This makes the test pass:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>That's worth a commit:</p>

<pre><code>git add -A
git commit -m 'Added headers to Response'
</code></pre>

<h2 id="response-body">Response body</h2>

<p>Last but not least, the response's body:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/ResponseSpec.php

    function it_can_have_a_body()
    {
        $this-&gt;beConstructedWith(200);
        $this-&gt;setBody('{"wound":"just a flesh one"}');

        $this-&gt;getBody()-&gt;shouldBe('{"wound":"just a flesh one"}');
    }
</code></pre>

<p>As usual we bootstrap it:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And then we complete it:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Response.php

    private $body;

    public function setBody($body)
    {
        $this-&gt;body = $body;
    }

    public function getBody()
    {
        return $this-&gt;body;
    }
</code></pre>

<p>Let's make our console green:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Let's make our console grin:</p>

<pre><code>git add -A
git commit -m 'Added body to Response'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We've bootstrapped an application, and created a RequestHandler which will help us
to avoid coupling with Guzzle. In the <a href="/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html">next article</a>,
we'll talk about middleware and start to create some RequestHandler
implementations (yes, more than one!).</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 2.3: Creation, refactoring]]></title>
            <link href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html"/>
            <updated>2015-03-04T00:00:00+00:00</updated>
            <id>/2015/03/04/sf-ws-part-2-3-creation-refactoring.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fourth article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the three first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-ws">following repository</a>.</p>

<p>In the previous post we've created a first endpoint by taking a few shortcuts.
As we wouldn't want to get technical debt, we're going to refactor it.</p>

<h2 id="the-controller-responsibility">The controller responsibility</h2>

<p>In order to <a href="https://speakerdeck.com/richardmiller/avoiding-the-mud">avoid the mud</a>,
we need to remove the logic from the controller. But which logic?</p>

<p>In <a href="https://symfony.com">Symfony</a>, controllers receive a Request and return a Response
(this follows the HTTP protocol). It is also the glue between the framework and our application.</p>

<p>From this we can assume that its responsibility is to:</p>

<ol>
<li>extract the parameters from the Request</li>
<li>give it to our application</li>
<li>get a result and build the Response with it</li>
</ol>

<p>The request's parameters could be legion, we woudln't like to have a method with too many arguments.
A way to solve this would be to create a Data Transfer Object (DTO): we would put all those parameters
in it and give it to the appropriate service.</p>

<h2 id="command-bus">Command Bus</h2>

<p>The Command Bus pattern is very fitting for this purpose: the DTO is called a Command, its name should
communicate our intention (in our example <code>CreateProfile</code>). It also has the responsibility of
validating user's input (for example converting IDs into integers).</p>

<p>Each Command is associated to only one CommandHandler service which do the actual logic.</p>

<p>Finally, there's the CommandBus: it finds the appropriate CommandHandler for the given Command
and executes it. It also executes some routines before and after the call (for example we can flush doctrine
after each commands).</p>

<blockquote>
  <p><strong>Note</strong>: CommandHandlers don't return anything.</p>
</blockquote>

<p>If you want to find out more on the Command Bus pattern, I'd recommend you to
have a look at this series by Matthias Noback:</p>

<ol>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/a-wave-of-command-buses/">a wave of command buses</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/responsibilities-of-the-command-bus/">responsibilities of the command bus</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/from-commands-to-events/">from commands to events</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/some-questions-about-the-command-bus/">some questions about the command bus</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/collecting-events-and-the-events-aware-command-bus/">collectiong events and the event dispatching comand bus</a></li>
</ol>

<p>Since commands are all about sending a message, you can also read Mathias Verraes article on
<a href="http://verraes.net/2015/01/messaging-flavours">Messaging flavours</a>. He also wrote a nice
article on <a href="http://verraes.net/2015/02/form-command-model-validation/">Form, Command and Model validation</a>.</p>

<h2 id="simplebus">SimpleBus</h2>

<p><a href="http://simplebus.github.io/MessageBus">SimpleBus</a> is a small library that fits our purpose:</p>

<pre><code>composer require simple-bus/doctrine-orm-bridge
composer require simple-bus/symfony-bridge
</code></pre>

<blockquote>
  <p><strong>Note</strong>: It requires at least PHP 5.4.</p>
</blockquote>

<p>You need to register the bundle in our application's kernel:</p>

<pre><code class="php">&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
            new SimpleBus\SymfonyBridge\SimpleBusCommandBusBundle(),
            new SimpleBus\SymfonyBridge\SimpleBusEventBusBundle(),
            new SimpleBus\SymfonyBridge\DoctrineOrmBridgeBundle(),
            new AppBundle\AppBundle(),
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            $bundles[] = new Symfony\Bundle\DebugBundle\DebugBundle();
            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            $bundles[] = new Sensio\Bundle\DistributionBundle\SensioDistributionBundle();
            $bundles[] = new Sensio\Bundle\GeneratorBundle\SensioGeneratorBundle();
        }

        return $bundles;
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>Let's commit this installation:</p>

<pre><code>git add -A
git commit -m 'Installed SimpleBus'
</code></pre>

<h2 id="create-profile">Create Profile</h2>

<p>We didn't create a <code>ProfileRepository</code> earlier, but we're going to need it now:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Entity/ProfileRepository.php

namespace AppBundle\Entity;

use Doctrine\ORM\EntityRepository;

class ProfileRepository extends EntityRepository
{
}
</code></pre>

<p>We should name the Command after the action we want to do. In our case we want
to create a profile:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle\CommandBus/CreateProfile.php

namespace AppBundle\CommandBus;

use SimpleBus\Message\Message;

class CreateProfile implements Message
{
    public $name;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }
}
</code></pre>

<p>We then need a CommandHandler to do the actual creation. Since there will be some logic,
let's create a specification:</p>

<pre><code>./bin/phpspec describe 'AppBundle\CommandBus\CreateProfileHandler'
</code></pre>

<p>And now we can describe it:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/CommandBus/CreateProfileHandlerSpec.php

namespace spec\AppBundle\CommandBus;

use AppBundle\CommandBus\CreateProfile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class CreateProfileHandlerSpec extends ObjectBehavior
{
    const NAME = 'John Cleese';

    function let(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;beConstructedWith($objectManager, $profileRepository);
    }

    function it_creates_a_profile(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $profileRepository-&gt;findOneBy(array('name' =&gt; self::NAME))-&gt;willReturn(null);
        $createdProfile = Argument::type('AppBundle\Entity\Profile');
        $objectManager-&gt;persist($createdProfile)-&gt;shouldBeCalled();

        $this-&gt;handle(new CreateProfile(self::NAME));
    }
}
</code></pre>

<p>This allows us to generate the code's skeleton:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And to finally write the code to make the test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/CommandBus/CreateProfileHandler.php

namespace AppBundle\CommandBus;

use AppBundle\Entity\Profile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use SimpleBus\Message\Handler\MessageHandler;
use SimpleBus\Message\Message;

class CreateProfileHandler implements MessageHandler
{
    private $objectManager;
    private $profileRepository;

    public function __construct(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;objectManager = $objectManager;
        $this-&gt;profileRepository = $profileRepository;
    }

    public function handle(Message $message)
    {
        $profile = $this-&gt;profileRepository-&gt;findOneBy(array('name' =&gt; $message-&gt;name));
        $newProfile = new Profile($message-&gt;name);
        $this-&gt;objectManager-&gt;persist($newProfile);
    }
}
</code></pre>

<p>Let's check the tests:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created CreateProfileHandler'
</code></pre>

<h2 id="name-duplication">Name duplication</h2>

<p>Domain validation (e.g. name duplication check) should be handled by the CommandHandler
(previously it was done in the controller):</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/CommandBus/CreateProfileHandlerSpec.php

namespace spec\AppBundle\CommandBus;

use AppBundle\CommandBus\CreateProfile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class CreateProfileHandlerSpec extends ObjectBehavior
{
    const NAME = 'John Cleese';

    function let(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;beConstructedWith($objectManager, $profileRepository);
    }

    function it_creates_a_profile(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $profileRepository-&gt;findOneBy(array('name' =&gt; self::NAME))-&gt;willReturn(null);
        $createdProfile = Argument::type('AppBundle\Entity\Profile');
        $objectManager-&gt;persist($createdProfile)-&gt;shouldBeCalled();

        $this-&gt;handle(new CreateProfile(self::NAME));
    }

    function it_cannot_create_the_profile_if_the_name_has_already_been_registered(ProfileRepository $profileRepository)
    {
        $profile = Argument::type('AppBundle\Entity\Profile');
        $profileRepository-&gt;findOneBy(array('name' =&gt; self::NAME))-&gt;willReturn($profile);

        $domainException = '\DomainException';
        $this-&gt;shouldThrow($domainException)-&gt;duringHandle(new CreateProfile(self::NAME));
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We try to be as descriptive as necessary in the test methods (a bad example
  would have been <code>testThrowsDomainException</code>).</p>
</blockquote>

<p>Here's the code to make the test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/CommandBus/CreateProfileHandler.php

namespace AppBundle\CommandBus;

use AppBundle\Entity\Profile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use SimpleBus\Message\Handler\MessageHandler;
use SimpleBus\Message\Message;

class CreateProfileHandler implements MessageHandler
{
    private $objectManager;
    private $profileRepository;

    public function __construct(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;objectManager = $objectManager;
        $this-&gt;profileRepository = $profileRepository;
    }

    public function handle(Message $message)
    {
        $profile = $this-&gt;profileRepository-&gt;findOneBy(array('name' =&gt; $message-&gt;name));
        if (null !== $profile) {
            throw new \DomainException(sprintf('The name "%s" is already taken', $message-&gt;name));
        }
        $newProfile = new Profile($message-&gt;name);
        $this-&gt;objectManager-&gt;persist($newProfile);
    }
}
</code></pre>

<p>Let's check the tests:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>They pass!</p>

<pre><code>git add -A
git commit -m 'Added check on name duplication'
</code></pre>

<h2 id="input-validation">Input validation</h2>

<p>Input validation (e.g. presence of name parameter) should be done in the Command
(previously it was done in the controller):</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle\CommandBus/CreateProfile.php

namespace AppBundle\CommandBus;

use SimpleBus\Message\Message;

class CreateProfile implements Message
{
    public $name;

    public function __construct($name)
    {
        if (null === $name) {
            throw new \DomainException('The "name" parameter is missing from the request\'s body');
        }
        $this-&gt;name = $name;
    }
}
</code></pre>

<p>Let's commit it:</p>

<pre><code>git add -A
git commit -m 'Added check on name presence in the request'
</code></pre>

<h2 id="domainexceptionlistener">DomainExceptionListener</h2>

<p>Our Command and CommandHandler both throw a DomainException, we can catch it in an
exception listener and create a nice response:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/EventListener/DomainExceptionListener.php

namespace AppBundle\EventListener;

use DomainException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;

class DomainExceptionListener
{
    /**
     * @param GetResponseForExceptionEvent $event
     */
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof DomainException) {
            return;
        }
        $error = $exception-&gt;getMessage();
        $event-&gt;setResponse(new JsonResponse(array('error' =&gt; $error), 422));
    }
}
</code></pre>

<p>It needs to be registerd in the Dependency Injection Container:</p>

<pre><code># File: app/config/services.yml
services:
    app.submit_json_listener:
        class: AppBundle\EventListener\SubmitJsonListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.forbidden_exception_listener:
        class: AppBundle\EventListener\ForbiddenExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }

    app.domain_exception_listener:
        class: AppBundle\EventListener\DomainExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }
</code></pre>

<p>We can save it:</p>

<pre><code>git add -A
git commit -m 'Created DomainExceptionListener'
</code></pre>

<h2 id="using-the-command">Using the command</h2>

<p>Now that our CommandHandler is ready, we'll define it as a service with its repository:</p>

<pre><code># File: app/config/services.yml
services:
    app.submit_json_listener:
        class: AppBundle\EventListener\SubmitJsonListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.forbidden_exception_listener:
        class: AppBundle\EventListener\ForbiddenExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }

    app.domain_exception_listener:
        class: AppBundle\EventListener\DomainExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }

    app.profile_repository:
        class: AppBundle\Entity\ProfileRepository
        factory_service: doctrine.orm.default_entity_manager
        factory_method: getRepository
        arguments: ['AppBundle:Profile']

    app.create_profile_handler:
        class: AppBundle\CommandBus\CreateProfileHandler
        arguments:
            - "@doctrine.orm.entity_manager"
            - "@app.profile_repository"
        tags:
            - { name: command_handler, handles: AppBundle\CommandBus\CreateProfile }
</code></pre>

<p>And call it in the controller:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use AppBundle\CommandBus\CreateProfile;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $name = $request-&gt;request-&gt;get('name');

        $this-&gt;get('command_bus')-&gt;handle(new CreateProfile($name));
        $createdProfile = $this-&gt;get('app.profile_repository')-&gt;findOneBy(array('name' =&gt; $name));

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Since the CommandHandler doesn't return anything, we need to call the repository
  to get the created profile.</p>
</blockquote>

<p>As it happens, we've forgotten to set <code>ProfileRepository</code> in <code>Profile</code>'s <code>Entity</code> annotation.
Let's fix it now:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Entity/Profile.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Table(name="profile")
 * @ORM\Entity(repositoryClass="AppBundle\Entity\ProfileRepository")
 */
class Profile
{
    /**
     * @ORM\Column(name="id", type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    private $id;

    /**
     * @ORM\Column(name="name", type="string", unique=true)
     */
    private $name;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }

    public function toArray()
    {
        return array(
            'id' =&gt; $this-&gt;id,
            'name' =&gt; $this-&gt;name,
        );
    }
}
</code></pre>

<p>Did we break anything?</p>

<pre><code>make test
</code></pre>

<p>No, all tests are super green!</p>

<pre><code>git add -A
git commit -m 'Used CreateProfileHandler in controller'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Technical debt is something we should be able to manage. When the time comes to refactor,
design patterns can be a helpful tool.</p>

<p>CommandBus is a nice pattern which allows us to remove imperative logic from the controllers.
It's easy to write unit test for CommandHandlers, and they can be reused
(creating a profile is surely something we can need elsewhere in our application).</p>

<p>This article concludes the second part of this series on web services in a Symfony environment.
In the <a href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html">next one</a>,
we'll start a new application which consumes the one we just created.</p>

<blockquote>
  <p><strong>Note</strong>: The web service we described also had a removal endpoint. Since there's not much else
  to learn, it won't be created in this series.</p>
</blockquote>

<h3 id="going-further">Going further</h3>

<p>A lot of things can be improved in the current application, here's some tips for those
who'd like to practice:</p>

<ul>
<li>name duplication is actually a "Conflict" type of error, not "Unprocessable Entity"</li>
<li>we could use Symfony's validation component (use <code>validator</code> in the CommandHandler and set annotations in the Command)</li>
<li>we could create a CommandBus that always validate the Command using Symfony's validation component</li>
<li>we can create our own DomainException to avoid catching ones that could be thrown by third party libraries</li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 2.2: Creation, the pragmatic way]]></title>
            <link href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html"/>
            <updated>2015-01-28T00:00:00+00:00</updated>
            <id>/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the third article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the two first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-ws">following repository</a>.</p>

<p>In this post we'll see how to create profiles:</p>

<ul>
<li><a href="#creating-the-controller">The controller</a></li>
<li><a href="#the-profile-entity">The profile entity</a></li>
<li><a href="#linking-with-the-database">Linking with the database</a></li>
<li><a href="#managing-errors">Managing errors</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="creating-the-controller">Creating the controller</h2>

<p>First things first, we'll write a functional test:</p>

<pre><code class="php">&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends \PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', false);
        $this-&gt;app-&gt;boot();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }
}
</code></pre>

<p>The test should fail, because the route hasn't been found (<code>404 NOT FOUND</code>):</p>

<pre><code>phpunit -c app
</code></pre>

<p>Flabergast! The test fails with a <code>PHP Fatal error:  Class 'AppKernel' not found</code>!
Let's fix this by adding the forgotten PHP tag opening in the bootstrap file:</p>

<pre><code class="php">&lt;?php
// File: app/bootstrap.php

require __DIR__.'/bootstrap.php.cache';
require __DIR__.'/AppKernel.php';
</code></pre>

<p>Let's check how the tests react:</p>

<pre><code>phpunit -c app
</code></pre>

<p>Another failure: the database doesn't exist. We need to create it for the test
environment:</p>

<pre><code>php app/console doctrine:database:create --env=test
</code></pre>

<p>Let's run the tests once again:</p>

<pre><code>phpunit -c app
</code></pre>

<p>This time the test fails for the right reason: the page doesn't exist.
To fix this, we'll create an empty controller:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $name = $request-&gt;request-&gt;get('name');
        $createdProfile = array();

        return new JsonResponse($createdProfile, 201);
    }
}
</code></pre>

<p>This should make the test pass:</p>

<pre><code>phpunit -c app
</code></pre>

<p>If an error occurs (404 not found), then it might be because of the cache:</p>

<pre><code>php app/console cache:clear --env=test
phpunit -c app
</code></pre>

<p>Running tests is becoming cumbersome, let's make it easy using a Makefile:</p>

<pre><code># Makefile
test:
    php app/console cache:clear --env=test
    php app/console doctrine:database:create --env=test
    phpunit -c app
    php app/console doctrine:database:drop --force --env=test
</code></pre>

<blockquote>
  <p><strong>Note</strong>: mind the tabs, make doesn't support space indentation.</p>
</blockquote>

<p>In order for this to work we'll need to drop the database (because it already exists):</p>

<pre><code>php app/console doctrine:database:drop --force --env=test
</code></pre>

<p>Tests can now be run using:</p>

<pre><code>make test
</code></pre>

<p>Everything's fine, we can commit our work:</p>

<pre><code>git add -A
git commit -m 'Created profile creation endpoint'
</code></pre>

<h2 id="the-profile-entity">The profile entity</h2>

<p>At this point, we'll need to store the profile in a database. For this purpose,
we'll use MySQL and Doctrine, so we'll need to create a profile entity.</p>

<p>We'll first generate a skeleton of its specification using <a href="http://phpspec.net">phpspec</a>:</p>

<pre><code>./bin/phpspec describe 'AppBundle\Entity\Profile'
</code></pre>

<p>Then we'll edit the specification:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/Entity/ProfileSpec.php

namespace spec\AppBundle\Entity;

use PhpSpec\ObjectBehavior;

class ProfileSpec extends ObjectBehavior
{
    const NAME = 'Arthur Dent';

    function let()
    {
        $this-&gt;beConstructedWith(self::NAME);
    }

    function it_can_be_converted_to_array()
    {
        $this-&gt;toArray()-&gt;shouldBe(array(
            'id' =&gt; null,
            'name' =&gt; self::NAME,
        ));
    }
}
</code></pre>

<p>Since we're happy with this step, we'll generate a skeleton of the code:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Of course we need to edit it:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Entity/Profile.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Table(name="profile")
 * @ORM\Entity
 */
class Profile
{
    /**
     * @ORM\Column(name="id", type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    private $id;

    /**
     * @ORM\Column(name="name", type="string", unique=true)
     */
    private $name;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }

    public function toArray()
    {
        return array(
            'id' =&gt; $this-&gt;id,
            'name' =&gt; $this-&gt;name,
        );
    }
}
</code></pre>

<p>Let's check if it satisfies our specification:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>It does! With this we can generate our database:</p>

<pre><code>php app/console doctrine:database:create
php app/console doctrine:schema:create
</code></pre>

<p>Let's update our Makefile:</p>

<pre><code># Makefile
prod:
    php app/console cache:clear --env=prod
    php app/console doctrine:database:create --env=prod
    php app/console doctrine:schema:create --env=prod

dev:
    php app/console cache:clear --env=dev
    php app/console doctrine:database:create --env=dev
    php app/console doctrine:schema:create --env=dev

test:
    php app/console cache:clear --env=test
    php app/console doctrine:database:create --env=test
    php app/console doctrine:schema:create --env=test
    phpunit -c app
    bin/phpspec run
    php app/console doctrine:database:drop --force --env=test
</code></pre>

<p>This allows us to also run phpspec for tests. Installing a project should be as
simple as:</p>

<pre><code>make
</code></pre>

<p>And for development we can use:</p>

<pre><code>make dev
</code></pre>

<blockquote>
  <p><strong>Note</strong>: trying to run a second time <code>make</code> or <code>make dev</code> will fail as the
  database already exists. We'll need to run respectively
  <code>php app/console doctrine:database:drop --force --env=prod</code> and
  <code>php app/console doctrine:database:drop --force --env=dev</code>, but we should really
  run those commands only once.</p>
</blockquote>

<p>It is time to commit our progress:</p>

<pre><code>git add -A
git commit -m 'Created Profile entity'
</code></pre>

<h2 id="linking-with-the-database">Linking with the database</h2>

<p>The only thing missing in our application is the actual creation of the profile.
Before doing anything with the code, we'll need to update our functional test:
we don't want the data to be actually persisted, as it would make the test fail
on a second run:</p>

<pre><code>&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends \PHPUnit_Framework_TestCase
{
    private $app;
    private $em;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', true);
        $this-&gt;app-&gt;boot();

        $this-&gt;em = $this-&gt;app-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');
        $this-&gt;em-&gt;beginTransaction();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    protected function tearDown()
    {
        $this-&gt;em-&gt;rollback();
        $this-&gt;em-&gt;close();
    }
}
</code></pre>

<p>Let's update the controller:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use AppBundle\Entity\Profile;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $em = $this-&gt;get('doctrine.orm.entity_manager');

        $createdProfile = new Profile($request-&gt;request-&gt;get('name'));
        $em-&gt;persist($createdProfile);
        $em-&gt;flush();

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<p>Time to run the tests:</p>

<pre><code>make test
</code></pre>

<p>All green! We can commit:</p>

<pre><code>git add -A
git commit -m 'Saved created profile in database'
</code></pre>

<h2 id="managing-errors">Managing errors</h2>

<p>Our endpoint should return an error if the "name" parameter is missing. Let's add
a functional test for this:</p>

<pre><code>&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;
    private $em;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', true);
        $this-&gt;app-&gt;boot();

        $this-&gt;em = $this-&gt;app-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');
        $this-&gt;em-&gt;beginTransaction();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    public function testItFailsIfNameIsMissing()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('no-name' =&gt; ''));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    protected function tearDown()
    {
        $this-&gt;em-&gt;rollback();
        $this-&gt;em-&gt;close();
    }
}
</code></pre>

<p>It should make our tests fail:</p>

<pre><code>make test
</code></pre>

<p>We can make this test pass by adding a simple check:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $em = $this-&gt;get('doctrine.orm.entity_manager');

        $name = $request-&gt;request-&gt;get('name');
        if (null === $name) {
            return new JsonResponse(array('error' =&gt; 'The "name" parameter is missing from the request\'s body'), 422);
        }
        $createdProfile = new Profile($name);
        $em-&gt;persist($createdProfile);
        $em-&gt;flush();

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<p>Let's see:</p>

<pre><code>php app/console doctrine:database:drop --force --env=test
make test
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Because our last test failed, the database hasn't been removed, so we
  need to do it manually.</p>
</blockquote>

<p>Looks nice! Our endpoint should also fail when a profile with the same name
already exist:</p>

<pre><code>&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;
    private $em;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', true);
        $this-&gt;app-&gt;boot();

        $this-&gt;em = $this-&gt;app-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');
        $this-&gt;em-&gt;beginTransaction();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    public function testItFailsIfNameIsMissing()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('no-name' =&gt; ''));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    public function testItFailsIfNameAlreadyExists()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Provençal le Gaulois'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $this-&gt;app-&gt;handle($request);
        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    protected function tearDown()
    {
        $this-&gt;em-&gt;rollback();
        $this-&gt;em-&gt;close();
    }
}
</code></pre>

<p>Our tests should be broken again:</p>

<pre><code>make test
</code></pre>

<p>Another check can fix this awful situation:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $em = $this-&gt;get('doctrine.orm.entity_manager');

        $name = $request-&gt;request-&gt;get('name');
        if (null === $name) {
            return new JsonResponse(array('error' =&gt; 'The "name" parameter is missing from the request\'s body'), 422);
        }
        if (null !== $em-&gt;getRepository('AppBundle:Profile')-&gt;findOneByName($name)) {
            return new JsonResponse(array('error' =&gt; 'The name "'.$name.'" is already taken'), 422);
        }
        $createdProfile = new Profile($name);
        $em-&gt;persist($createdProfile);
        $em-&gt;flush();

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<p>Are we there yet?</p>

<pre><code>php app/console doctrine:database:drop --force --env=test
make test
</code></pre>

<p>Yes we are. Here's our last commit for this time:</p>

<pre><code>git add -A
git commit -m 'Added error checks'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Creating an endpoint with Symfony is pretty straighfoward: it all comes down to
HTTP knowledge.</p>

<p>Our codebase is very small due to the simplicity of our examples, but in a real
life application we'll need to add more complexity as new requirements appear.</p>

<p>The pragmatic approach is good for now, but at some point we'll need to refactor
our code by creating some services, each with their specific responsibilities,
to prevent our application from becoming a <a href="https://speakerdeck.com/richardmiller/atm">big ball of mud</a>
where everything is hard to read, impossible to test and expensive to change.</p>

<p>This will the subject of <a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">the next article</a>.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 2.1: Creation bootstrap]]></title>
            <link href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html"/>
            <updated>2015-01-21T00:00:00+00:00</updated>
            <id>/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the second article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the first one:
<a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a>.</p>

<p>In this post we'll create an empty application and prepare it:</p>

<ul>
<li><a href="#installing-the-standard-edition">Installing the standard edition</a></li>
<li><a href="#twitching-for-tests">Twitching for tests</a></li>
<li><a href="#patching-for-json-submit">Patching for JSON submit</a></li>
<li><a href="#setting-up-the-authentication">Setting up the authentication</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="installing-the-standard-edition">Installing the standard edition</h2>

<p>First of all, we need to create an empty Symfony application:</p>

<pre><code>composer create-project symfony/framework-standard-edition ws
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Take the time to configure a MySQL database, we'll need it later.</p>
</blockquote>

<p>Next we'll configure an Apache's virtual host (should be in <code>/etc/apache2/sites-available/ws.conf</code>):</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerName ws.local

    DocumentRoot /home/foobar/ws/web

    ErrorLog "/home/foobar/ws/app/logs/apache_errors.log"
    CustomLog "/home/foobar/ws/app/logs/apache_accesses.log" common

    &lt;Directory /home/foobar/ws/web&gt;
        Options Indexes FollowSymLinks MultiViews
        AllowOverride None
        Require all granted
        Order allow,deny
        allow from all
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</code></pre>

<p>Apache will require access to the logs and cache directories, as well as your
user. The easiest way to do so is to change Apache's user and group to yours in
<code>/etc/apache2/envvars</code>:</p>

<pre><code>export APACHE_RUN_USER=foobar
export APACHE_RUN_GROUP=foobar
</code></pre>

<p>In order for this to work we'll update our <code>/etc/hosts</code> file:</p>

<pre><code>echo '127.0.0.1 ws.local' | sudo tee -a /etc/hosts
</code></pre>

<p>And finally we'll restart the web server:</p>

<pre><code>sudo service apache2 restart
</code></pre>

<p>We should be able to see "Homepage" when browsing http://ws.local/app_dev.php/app/example</p>

<p>Let's commit our work:</p>

<pre><code>git init
git add -A
git ci -m 'Created a standard Symfony application'
</code></pre>

<h2 id="twitching-for-tests">Twitching for tests</h2>

<p>As explained in <a href="/2014/11/15/sf2-quick-functional-tests.html">this article</a>,
we'll twitch the standard edition a little bit in order to make tests more explicit.</p>

<p>First we create a bootstraping file:</p>

<pre><code class="php">&lt;?php
// File: app/bootstrap.php

require __DIR__.'/bootstrap.php.cache';
require __DIR__.'/AppKernel.php';
</code></pre>

<p>Then we configure PHPUnit to use it:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- http://phpunit.de/manual/4.1/en/appendixes.configuration.html --&gt;
&lt;phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
         backupGlobals="false"
         colors="true"
         bootstrap="bootstrap.php"
&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="Project Test Suite"&gt;
            &lt;directory&gt;../tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<p>We've decided to put our tests in a separate <code>tests</code> directory, allowing us to
decalre an autoload mapping specific for development. To fully optimize our
autoloading, we'll also define our <code>src/AppBundle</code> folder as a path for the
<code>AppBundle</code> namespace, using PSR-4:</p>

<pre><code>{
    "name": "symfony/framework-standard-edition",
    "license": "MIT",
    "type": "project",
    "description": "The \"Symfony Standard Edition\" distribution",
    "autoload": {
        "psr-4": { "AppBundle\\": "src/AppBundle" }
    },
    "autoload-dev": {
        "psr-4": { "AppBundle\\Tests\\": "tests" }
    },
    "require": {
        "php": "&gt;=5.3.3",
        "symfony/symfony": "2.6.*",
        "doctrine/orm": "~2.2,&gt;=2.2.3",
        "doctrine/doctrine-bundle": "~1.2",
        "twig/extensions": "~1.0",
        "symfony/assetic-bundle": "~2.3",
        "symfony/swiftmailer-bundle": "~2.3",
        "symfony/monolog-bundle": "~2.4",
        "sensio/distribution-bundle": "~3.0.12",
        "sensio/framework-extra-bundle": "~3.0",
        "incenteev/composer-parameter-handler": "~2.0"
    },
    "require-dev": {
        "sensio/generator-bundle": "~2.3"
    },
    "scripts": {
        "post-root-package-install": [
            "SymfonyStandard\\Composer::hookRootPackageInstall"
        ],
        "post-install-cmd": [
            "Incenteev\\ParameterHandler\\ScriptHandler::buildParameters",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::buildBootstrap",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::clearCache",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installAssets",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installRequirementsFile",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::removeSymfonyStandardFiles"
        ],
        "post-update-cmd": [
            "Incenteev\\ParameterHandler\\ScriptHandler::buildParameters",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::buildBootstrap",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::clearCache",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installAssets",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::installRequirementsFile",
            "Sensio\\Bundle\\DistributionBundle\\Composer\\ScriptHandler::removeSymfonyStandardFiles"
        ]
    },
    "config": {
        "bin-dir": "bin"
    },
    "extra": {
        "symfony-app-dir": "app",
        "symfony-web-dir": "web",
        "symfony-assets-install": "relative",
        "incenteev-parameters": {
            "file": "app/config/parameters.yml"
        },
        "branch-alias": {
            "dev-master": "2.6-dev"
        }
    }
}
</code></pre>

<p>To make it official, we need to run the following command:</p>

<pre><code>composer dump-autoload
</code></pre>

<p>We'll also install <a href="http://phpspec.net">phpspec</a>:</p>

<pre><code>composer require phpspec/phpspec:~2.1
</code></pre>

<p>With this our tests will be awesome! Time to commit:</p>

<pre><code>git add -A
git commit -m 'Configured tests'
</code></pre>

<h2 id="patching-for-json-submit">Patching for JSON submit</h2>

<p>Symfony provides the posted data in the <code>Request</code>'s <code>request</code> attribute, except
if the content type is <code>application/json</code>, as it will be our case. To fix this
behavior we'll follow the steps described in <a href="/2014/09/03/master-sf2-part-5-events.html">this article</a>.</p>

<p>Let's start by the creation of an event listener:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/EventListener/SubmitJsonListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

/**
 * PHP does not populate $_POST with the data submitted via a JSON Request,
 * causing an empty $request-&gt;request.
 *
 * This listener fixes this.
 */
class SubmitJsonListener
{
    /**
     * @param GetResponseEvent $event
     */
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('POST', 'PUT'), true);
        $isJson = ('application/json' === $request-&gt;headers-&gt;get('Content-Type'));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new JsonResponse(array('error' =&gt; 'Invalid or malformed JSON'), 400));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>Finally we'll register it in the Dependency Injection Container:</p>

<pre><code># File: app/config/services.yml
services:
    app.submit_json_listener:
        class: AppBundle\EventListener\SubmitJsonListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<h2 id="setting-up-the-authentication">Setting up the authentication</h2>

<p>HTTP basic authentication can be configured through the <code>app/config/security.yml</code>
file, as described in <a href="http://symfony.com/doc/current/book/security.html">the official documentation</a>.</p>

<p>In the end we should have something like this:</p>

<pre><code># app/config/security.yml
security:
    encoders:
        Symfony\Component\Security\Core\User\User: plaintext

    providers:
        in_memory:
            memory:
                users:
                    spanish_inquisition:
                        password: 'NobodyExpectsIt!'
                        roles:
                            - ROLE_USER

    firewalls:
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false

        default:
            anonymous: ~
            http_basic: ~
            stateless: true

    access_control:
        - { path: /.*, roles: ROLE_USER }
</code></pre>

<p>Now to comply with our description we need to customize the error. We can do so
using another event listener:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/EventListener/ForbiddenExceptionListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;
use Symfony\Component\Security\Core\Exception\AccessDeniedException;

/**
 * PHP does not populate $_POST with the data submitted via a JSON Request,
 * causing an empty $request-&gt;request.
 *
 * This listener fixes this.
 */
class ForbiddenExceptionListener
{
    /**
     * @param GetResponseForExceptionEvent $event
     */
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof AccessDeniedException) {
            return;
        }
        $error = 'The credentials are either missing or incorrect';
        $event-&gt;setResponse(new JsonResponse(array('error' =&gt; $error), 403));
    }
}
</code></pre>

<p>And to register it:</p>

<pre><code># File: app/config/services.yml
services:
    app.submit_json_listener:
        class: AppBundle\EventListener\SubmitJsonListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.forbidden_exception_listener:
        class: AppBundle\EventListener\ForbiddenExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }
</code></pre>

<blockquote>
  <p><strong>Note</strong>: the Symfony Security event listener has a priority set to 0.
  In order for our listener to be executed, we need to set a higher one, like 10.</p>
</blockquote>

<p>As you can see by browsing http://ws.local/app_dev.php/app/example, we now need
to provide the <code>spanish_inquisition</code> with the <code>NobodyExpectsIt!</code> password to
access the page.</p>

<p>This is enough for today, we'll commit our work:</p>

<pre><code>git add -A
git commit -m 'Created custom event listeners'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Our application is now ready!</p>

<p>In the [next article](/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html
we'll create the first endpoint, the creation of profiles, using a pragmatic approach.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 1: Introduction]]></title>
            <link href="/2015/01/14/sf-ws-part-1-introduction.html"/>
            <updated>2015-01-14T00:00:00+00:00</updated>
            <id>/2015/01/14/sf-ws-part-1-introduction.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>Welcome to this new series of articles on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Its purpose is to provide an example,
it doesn't pretend to be the best solution and it requires you to know the basics
of Symfony (if you know what a service is, you're good) and of web services
(basically to know that they're a way to provide data remotely).</p>

<blockquote>
  <p><strong>Spoiler alert</strong>: There won't be much Symfony specific code ;) .</p>
</blockquote>

<p>In this post we'll describe the different endpoints of the (fake) web service
which will be used as a reference thoughout the whole series:</p>

<ul>
<li><a href="#json-objects">JSON objects</a></li>
<li><a href="#authentication">Authentication</a></li>
<li><a href="#create-a-profile">Create a profile</a></li>
<li><a href="#delete-a-profile">Delete a profile</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="json-objects">JSON objects</h2>

<p>The posted and returned resources will always be wrapped in a JSON object.</p>

<h2 id="authentication">Authentication</h2>

<p>All endpoints require HTTP Basic Authentication with the following credentials:</p>

<ul>
<li>user: <code>spanish_inquisition</code></li>
<li>password: <code>NobodyExpectsIt!</code></li>
</ul>

<p>If those credentials are missing or wrong (<code>403 FORBIDDEN</code>), it will return:</p>

<pre><code>{
    "error": "The credentials are either missing or incorrect"
}
</code></pre>

<h2 id="create-a-profile">Create a profile</h2>

<ul>
<li><code>POST http://ws.local/api/v1/profiles</code></li>
</ul>

<p>The request body should be as follow:</p>

<pre><code>{
    "name": "Fawlty Tower"
}
</code></pre>

<p>In case of success (<code>201 CREATED</code>), it will return:</p>

<pre><code>{
    "id": 23,
    "name": "Fawlty Tower"
}
</code></pre>

<p>If the request's body contains malformed JSON (<code>400 BAD REQUEST</code>), it will return:</p>

<pre><code>{
    "error": "Invalid or malformed JSON"
}
</code></pre>

<p>If the <code>name</code> parameter is missing from the request's body (<code>422 UNPROCESSABLE ENTITY</code>),
it will return:</p>

<pre><code>{
    "error": "The \"name\" parameter is missing from the request's body"
}
</code></pre>

<p>If the name already exists (<code>422 UNPROCESSABLE ENTITY</code>), it will return:</p>

<pre><code>{
    "error": "The name \"Provençal le Gaulois\" is already taken"
}
</code></pre>

<h2 id="delete-a-profile">Delete a profile</h2>

<ul>
<li><code>DELETE http://ws.local/api/v1/profiles/{id}</code></li>
</ul>

<p>This endpoint will always return an empty body (<code>204 NO CONTENT</code>).</p>

<h2 id="conclusion">Conclusion</h2>

<p>So basically we can create and remove profiles, which have an identifier and a name.</p>

<p>In <a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">the next article</a>
we'll see how to build such web service.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Lightweight console library]]></title>
            <link href="/2014/12/03/lightweight-console-lib.html"/>
            <updated>2014-12-03T00:00:00+00:00</updated>
            <id>/2014/12/03/lightweight-console-lib.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been deprecated.</p>
  
  <p><strong>TL;DR</strong>: <a href="https://github.com/gnugat/konzolo">Konzolo</a> can be used to create
  minimalistic CLI applications, or to implement the command design pattern.</p>
</blockquote>

<p>After implementing a same feature in many projects, I usually have the reflex to
create a library out of it. <a href="https://github.com/gnugat/konzolo">Konzolo</a> is one
of them :) .</p>

<p>In this article we'll see its features:</p>

<ul>
<li><a href="#create-a-command">Create a command</a></li>
<li><a href="#binding-up-an-application">Binding up an application</a></li>
<li><a href="#input-constraint">Input constraint</a></li>
<li><a href="#input-validator">Input validator</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="create-a-command">Create a command</h2>

<p>Let's create a "hello world" command:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Command;

use Gnugat\Konzolo\Command;
use Gnugat\Konzolo\Input;

class HelloWorldCommand implements Command
{
    public function execute(Input $input)
    {
        $name = $input-&gt;getArgument('name');
        echo "Hello $name\n";

        return Command::EXIT_SUCCESS;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: If the name argument is missing, an exception will be thrown.
  Keep reading to know more about those exceptions.</p>
</blockquote>

<p>We only have to implement the <code>execute</code> method, which receives a convenient
<code>Input</code> class and returns 0 on success (actually this is optional).</p>

<h2 id="binding-up-an-application">Binding up an application</h2>

<p>Now that we have a command, let's put it in an application:</p>

<pre><code class="php">&lt;?php
// File: console.php

use Acme\Demo\Command\HelloWorldCommand;
use Gnugat\Konzolo\Application;
use Gnugat\Konzolo\Input;

require __DIR__.'/vendor/autoload.php';

$input = new Input($argv[1]); // command name (acme:hello-world)
if (isset($argv[2])) {
    $input-&gt;setArgument('name', $argv[2]);
}

$application = new Application();
$application-&gt;addCommand('acme:hello-world', new HelloWorldCommand());

$application-&gt;run($input);
</code></pre>

<p>You can then run it:</p>

<pre><code>php console.php acme:hello-world Igor
</code></pre>

<h2 id="input-constraint">Input constraint</h2>

<p>If you need to validate the input, you can create a constraint:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Validation;

use Gnugat\Konzolo\Exception\InvalidInputException;
use Gnugat\Konzolo\Input;
use Gnugat\Konzolo\Validation\InputConstraint;

class NoWorldNameConstraint implements InputConstraint
{
    public function throwIfInvalid(Input $input)
    {
        $name = $input-&gt;getArgument('name');
        if ('World' === $name) {
            throw new InvalidInputException($input, 'The "name" parameter must not be set to "World"');
        }
    }
}
</code></pre>

<p>This constraint can be used directly in the command, as a dependency:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Command;

use Acme\Demo\Validation\NoWorldNameConstraint;
use Gnugat\Konzolo\Command;
use Gnugat\Konzolo\Input;

class HelloWorldCommand implements Command
{
    private $noWorldNameConstraint;

    public function __construct(NoWorldNameConstraint $noWorldNameConstraint)
    {
        $this-&gt;noWorldNameConstraint = $noWorldNameConstraint;
    }

    public function execute(Input $input)
    {
        $this-&gt;noWorldNameConstraint-&gt;throwIfInvalid($input);
        $name = $input-&gt;getArgument('name');
        echo "Hello $name\n";

        return Command::EXIT_SUCCESS;
    }
}
</code></pre>

<p>And then inject it:</p>

<pre><code class="php">&lt;?php
// File: console.php

use Acme\Demo\Command\HelloWorldCommand;
use Acme\Demo\Validation\NoWorldNameConstraint;
use Gnugat\Konzolo\Application;
use Gnugat\Konzolo\Input;

require __DIR__.'/vendor/autoload.php';

$input = new Input($argv[1]); // command name (acme:hello-world)
if (isset($argv[2])) {
    $input-&gt;setArgument('name', $argv[2]);
}

$application = new Application();
$application-&gt;addCommand('acme:hello-world', new HelloWorldCommand(new NoWorldNameConstraint()));

$application-&gt;run($input);
</code></pre>

<h2 id="input-validator">Input validator</h2>

<p>More conveniently, the command can depend on a validator:</p>

<pre><code class="php">&lt;?php

namespace Acme\Demo\Command;

use Gnugat\Konzolo\Command;
use Gnugat\Konzolo\Input;
use Gnugat\Konzolo\Validation\InputValidator;

class HelloWorldCommand implements Command
{
    private $validator;

    public function __construct(InputValidator $validator)
    {
        $this-&gt;validator = $validator;
    }

    public function execute(Input $input)
    {
        $this-&gt;validator-&gt;throwIfInvalid($input);
        $name = $input-&gt;getArgument('name');
        echo "Hello $name\n";

        return Command::EXIT_SUCCESS;
    }
}
</code></pre>

<p>You can add many constraint in a validator, and set priorities:</p>

<pre><code class="php">&lt;?php
// File: console.php

use Acme\Demo\Command\HelloWorldCommand;
use Acme\Demo\Validation\NoWorldNameConstraint;
use Gnugat\Konzolo\Application;
use Gnugat\Konzolo\Input;
use Gnugat\Konzolo\Validation\InputValidator;

require __DIR__.'/vendor/autoload.php';

$input = new Input($argv[1]); // command name (acme:hello-world)
if (isset($argv[2])) {
    $input-&gt;setArgument('name', $argv[2]);
}

$helloWorldValidator = new InputValidator();
$helloWorldValidator-&gt;addConstraint(new NoWorldNameConstraint(), 42);

$application = new Application();
$application-&gt;addCommand('acme:hello-world', new HelloWorldCommand($helloWorldValidator));

$application-&gt;run($input);
</code></pre>

<blockquote>
  <p><strong>Note</strong>: The highest the priority, the soonest the constraint will be executed.
  For example, a constraint with priority 1337 will be executed before another
  one with priority 23 (even if this second one has been added first in the validator).</p>
</blockquote>

<h2 id="exceptions">Exceptions</h2>

<p>Konzolo's exceptions all implement the <code>Gnugat\Konzolo\Exception\Exception</code> interface.
This means you can catch every single one of them using this type. They also
extend at the standard <code>\Exception</code> class, so if you don't care about Konzolo
specific exceptions, you can catch them all!</p>

<p>This is usefull for example in <a href="https://symfony.com">Symfony2</a>: you can create
a Konzolo exception listener.</p>

<p>You can find more about the different kind of exceptions and their specific
methods in <a href="http://github.com/gnugat/konzolo/tree/master/doc/exception.md">its dedicated documentation</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>We have seen how to create commands and validate their inputs.</p>

<p>Our examples showed how to create a CLI application, but Konzolo is mainly aimed at being used <strong>in</strong>
applications (not only CLI ones).
For example, <a href="https://github.com/gnugat/redaktilo">Redaktilo</a> uses internally
a system of Command/CommandInvoker, using an array as input and sanitizer as a
validation mechanism. All this logic can now be externalized, thanks to Konzolo!</p>

<p>I'd like to keep Konzolo as small as possible, but here's a list of possible
features it could see in the future:</p>

<h3 id="command-finder">Command finder</h3>

<p>Currently we can find commands by their exact names. But wouldn't it be nice if
we could just provide part of a name? Or an alias?</p>

<h3 id="input-factories">Input Factories</h3>

<p>Creating input manually isn't always what we need. A factory that creates one
from an array could improve the situation.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - Conclusion]]></title>
            <link href="/2014/10/08/master-sf2-conclusion.html"/>
            <updated>2014-10-08T00:00:00+01:00</updated>
            <id>/2014/10/08/master-sf2-conclusion.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the conclusion of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the five articles:</p>

<ul>
<li><a href="/2014/08/05/master-sf2-part-1-bootstraping.html">1: Bootstraping</a></li>
<li><a href="/2014/08/13/master-sf2-part-2-tdd.html">2: TDD</a></li>
<li><a href="/2014/08/22/master-sf2-part-3-services.html">3: Services</a></li>
<li><a href="/2014/08/27/master-sf2-part-4-doctrine.htm">4: Doctrine</a></li>
<li><a href="/2014/09/03/master-sf2-part-5-events.html">5: Events</a></li>
<li><a href="/2014/09/10/master-sf2-part-6-annotations.html">6: Annotations</a></li>
</ul>

<p>It quickly sums up what we've seen and provides some directions to the next
steps, for those interrested in learning more (there's always more!).</p>

<h2 id="summary">Summary</h2>

<p>In these 6 articles, we've learned how to master Symfony2 through:</p>

<ol>
<li>the usage of distributions to bootstrap our projects</li>
<li>the writing of simple functional tests (we used TDD/PHPUnit but any methodology/Framework can be used)</li>
<li>the creation of services and entities (where our business related code actually lies)</li>
<li>the usage of a third party library (Doctrine)</li>
<li>the extension of the framework via events (change the Request and Response at will)</li>
<li>the configuration via annotations, allowing to reduce the distance with the code</li>
</ol>

<p>As a bonus, we've also seen:</p>

<ul>
<li>the Repository Design Pattern (retrieve data and format it before using it)</li>
<li>the Symfony Console Component, which can be used as a standalone library</li>
</ul>

<h2 id="going-further">Going further</h2>

<p>There's still a deal lot more to learn, but with this series we've hopefully
seen the strict minimum to create any day to day application with deep knowledge
on how to extend the framework and where to put our code.</p>

<p>We've seen Symfony as a full stack framework: it deals with the HTTP protocol
for you. But the truth is that Symfony is a collection of third party libraries
before anything else. Here's a short selection of its available components:</p>

<ul>
<li>Validation: define constraints and check if the given variable complies to them</li>
<li>Form: define fields, generate the HTML form and populate variables from the request</li>
<li>Yaml: parse a yaml file</li>
<li>Security: check the identity users and their permissions</li>
</ul>

<p>Do you want to go further? Then have a look a these fabulous resources:</p>

<ul>
<li><a href="http://symfony.com/doc/current/index.html">The documentation</a></li>
<li><a href="https://twitter.com/raulfraile">Raul Fraile</a> overview articles on the:

<ul>
<li><a href="http://blog.servergrove.com/2013/09/23/symfony2-components-overview-httpfoundation/">HttpFoundation Component</a></li>
<li><a href="http://blog.servergrove.com/2013/09/30/symfony2-components-overview-httpkernel/">HttpKernel Component</a></li>
<li><a href="http://blog.servergrove.com/2013/10/08/symfony2-components-overview-routing/">Routing Component</a></li>
<li><a href="http://blog.servergrove.com/2013/10/23/symfony2-components-overview-eventdispatcher/">EventDispather Component</a></li>
<li><a href="http://blog.servergrove.com/2014/02/21/symfony2-components-overview-config/">Config Component</a></li>
<li><a href="http://blog.servergrove.com/2014/03/03/symfony2-components-overview-validator/">Validator Component</a></li>
<li><a href="http://blog.servergrove.com/2014/03/11/symfony2-components-overview-templating/">Templating Component</a></li>
<li><a href="http://blog.servergrove.com/2014/03/18/symfony2-components-overview-translation/">Translation Component</a></li>
<li><a href="http://blog.servergrove.com/2014/03/26/symfony2-components-overview-finder/">Finder Component</a></li>
<li><a href="http://blog.servergrove.com/2014/04/07/symfony2-components-overview-expression-language/">ExpressionLanguage Component</a></li>
<li><a href="http://blog.servergrove.com/2014/04/16/symfony2-components-overview-process/">Process Component</a></li>
</ul></li>
<li><a href="https://twitter.com/khepin">Sebastien Armand</a>'s book <a href="http://www.amazon.co.uk/Extending-Symfony-Web-Application-Framework/dp/1783287195">Extending Symfony Web Application Framework</a></li>
<li><a href="https://twitter.com/matthiasnoback">Matthias Noback</a>'s book <a href="http://www.amazon.co.uk/Year-With-Symfony-reusable-Symfony2/dp/9082120119">A Year with Symfony</a></li>
<li><a href="https://twitter.com/kriswallsmith">Kris Walsmith</a> slides on the <a href="http://www.slideshare.net/kriswallsmith/love-and-loss-a-symfony-security-play">Security Component</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 6: Annotations]]></title>
            <link href="/2014/09/10/master-sf2-part-6-annotations.html"/>
            <updated>2014-09-10T00:00:00+01:00</updated>
            <id>/2014/09/10/master-sf2-part-6-annotations.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the sixth article of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the four first ones:</p>

<ul>
<li><a href="/2014/08/05/master-sf2-part-1-bootstraping.html">1: Bootstraping</a></li>
<li><a href="/2014/08/13/master-sf2-part-2-tdd.html">2: TDD</a></li>
<li><a href="/2014/08/22/master-sf2-part-3-services.html">3: Services</a></li>
<li><a href="/2014/08/27/master-sf2-part-4-doctrine.htm">4: Doctrine</a></li>
<li><a href="/2014/09/03/master-sf2-part-5-events.html">5: Events</a></li>
</ul>

<p>In the previous articles we created an API allowing us to submit and list
quotes:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── doctrine.yml
│   │   ├── parameters.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── console
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Fortune
│       └── ApplicationBundle
│           ├── Controller
│           │   └── QuoteController.php
│           ├── DependencyInjection
│           │   └── FortuneApplicationExtension.php
│           ├── Entity
│           │   ├── QuoteFactory.php
│           │   ├── QuoteGateway.php
│           │   ├── Quote.php
│           │   └── QuoteRepository.php
│           ├── EventListener
│           │   └── SubmitJsonListener.php
│           ├── FortuneApplicationBundle.php
│           ├── Resources
│           │   └── config
│           │       ├── doctrine
│           │       │   └── Quote.orm.yml
│           │       └── services.xml
│           └── Tests
│               ├── Controller
│               │   └── QuoteControllerTest.php
│               └── Entity
│                   └── QuoteRepositoryTest.php
└── web
    └── app.php
</code></pre>

<p>Here's the <a href="https://github.com/gnugat/mastering-symfony2">repository where you can find the actual code</a>.</p>

<p>In this article, we'll discover annotations.</p>

<h2 id="doctrine-annotations">Doctrine Annotations</h2>

<p>Inspired by <a href="http://legacy.python.org/dev/peps/pep-0318/">Python Decorators</a> and
<a href="http://docs.oracle.com/javase/tutorial/java/annotations/">Java Annotations</a>,
the <a href="http://www.doctrine-project.org/">Doctrine Project</a> created a convenient
library allowing to put in the same file: information (like configuration) and
source code.</p>

<p>In concrete terms, <a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">Annotations</a>
are comments which are read by <code>AnnotationReader</code> and can then be cached in any
format (generally PHP) to make things faster afterwards.</p>

<p>It's main strength is the possibility to avoid having a configuration file in a
path too far from the source code which uses it. For example intead of having
the schema definition in <code>src/Fortune/ApplicationBundle/Resources/config/doctrine/Quote.orm.yml</code>
we could have it directly in the <code>QuoteEntity</code>.</p>

<h2 id="installing-sensio-frameworkextra-bundle">Installing Sensio FrameworkExtra Bundle</h2>

<p>The <a href="http://symfony.com/doc/current/bundles/SensioFrameworkExtraBundle/index.html">Sensio FrameworkExtra Bundle</a>
provides controller annotations, amongst them lies <code>@Route</code> allowing us to move
the routing configuration from <code>app/config/routing.yml</code> directly to the actions.</p>

<p>Let's download the bundle:</p>

<pre><code>composer require sensio/framework-extra-bundle:~3.0
</code></pre>

<p>Then register it:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Fortune\ApplicationBundle\FortuneApplicationBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>Finally, we need to tell Doctrine's Annotation library  where to find the
classes by registering Composer's autoloader:</p>

<pre><code>&lt;?php
// File: app/autoload.php

use Doctrine\Common\Annotations\AnnotationRegistry;

$loader = require __DIR__.'/../vendor/autoload.php';

AnnotationRegistry::registerLoader(array($loader, 'loadClass'));

return $loader;
</code></pre>

<p>This file should be used in our front controller:</p>

<pre><code>&lt;?php

use Symfony\Component\HttpFoundation\Request;

require_once __DIR__.'/app/autoload.php';
require_once __DIR__.'/../app/AppKernel.php';

$kernel = new AppKernel('prod', false);
$request = Request::createFromGlobals();
$response = $kernel-&gt;handle($request);
$response-&gt;send();
$kernel-&gt;terminate($request, $response);
</code></pre>

<p>But also in our test suite:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit
    backupGlobals="false"
    colors="true"
    syntaxCheck="false"
    bootstrap="autoload.php"&gt;

    &lt;testsuites&gt;
        &lt;testsuite name="Functional Test Suite"&gt;
            &lt;directory&gt;../src/*/*/Tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="using-the-%40route-annotation">Using the @Route annotation</h2>

<p>We can now empty the <code>routing.yml</code> file and tell it to import the configuration
from the <code>QuoteController</code> using its annotations:</p>

<pre><code># File: app/config/routing.yml
fortune_application:
    resource: @FortuneApplicationBundle/Controller
    type: annotation
</code></pre>

<p>The controller itself will look like this:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    /**
     * @Route("/api/quotes", methods={"POST"})
     */
    public function submitAction(Request $request)
    {
        $postedValues = $request-&gt;request-&gt;all();
        if (empty($postedValues['content'])) {
            $answer = array('message' =&gt; 'Missing required parameter: content');

            return new JsonResponse($answer, Response::HTTP_UNPROCESSABLE_ENTITY);
        }
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quote = $quoteRepository-&gt;insert($postedValues['content']);

        return new JsonResponse($quote, Response::HTTP_CREATED);
    }

    /**
     * @Route("/api/quotes", methods={"GET"})
     */
    public function listAction(Request $request)
    {
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quotes = $quoteRepository-&gt;findAll();

        return new JsonResponse($quotes, Response::HTTP_OK);
    }
}
</code></pre>

<p>And now annotations are ready to be used, as the tests prove it:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>That's green enough for us to commit:</p>

<pre><code>git add -A
git commit -m 'Used annotations'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Annotations allow us to remove the distance between configuration and code.</p>

<blockquote>
  <p><strong>Note</strong>: You should know that annotations can
  <a href="https://r.je/php-annotations-are-an-abomination.html">raise concerns about tight coupling</a>,
  but it doesn't seem to be <a href="http://marekkalnik.tumblr.com/post/34047514685/are-annotations-really-bad">relevant when used as configuration</a>.</p>
  
  <p>The best thing to do is to minimize their use to the classes which are
  already coupled to our tools (for example the controllers) and do some
  research on the subject to make your own opinion.</p>
</blockquote>

<p>If the concept seduced you, have a look a <a href="https://github.com/mmoreram/ControllerExtraBundle">ControllerExtraBundle</a>.</p>

<p>The next artile will be the conclusion, I hope you enjoy this series!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 5: Events]]></title>
            <link href="/2014/09/03/master-sf2-part-5-events.html"/>
            <updated>2014-09-03T00:00:00+01:00</updated>
            <id>/2014/09/03/master-sf2-part-5-events.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fifth article of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the four first ones:</p>

<ul>
<li><a href="/2014/08/05/master-sf2-part-1-bootstraping.html">1: Bootstraping</a></li>
<li><a href="/2014/08/13/master-sf2-part-2-tdd.html">2: TDD</a></li>
<li><a href="/2014/08/22/master-sf2-part-3-services.html">3: Services</a></li>
<li><a href="/2014/08/27/master-sf2-part-4-doctrine.htm">4: Doctrine</a></li>
</ul>

<p>In the previous articles we created an API allowing us to submit and list
quotes:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── doctrine.yml
│   │   ├── parameters.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Fortune
│       └── ApplicationBundle
│           ├── Controller
│           │   └── QuoteController.php
│           ├── DependencyInjection
│           │   └── FortuneApplicationExtension.php
│           ├── Entity
│           │   ├── QuoteFactory.php
│           │   ├── QuoteGateway.php
│           │   ├── Quote.php
│           │   └── QuoteRepository.php
│           ├── FortuneApplicationBundle.php
│           ├── Resources
│           │   └── config
│           │       ├── doctrine
│           │       │   └── Quote.orm.yml
│           │       └── services.xml
│           └── Tests
│               ├── Controller
│               │   └── QuoteControllerTest.php
│               └── Entity
│                   └── QuoteRepositoryTest.php
└── web
    └── app.php
</code></pre>

<p>Here's the <a href="https://github.com/gnugat/mastering-symfony2">repository where you can find the actual code</a>.</p>

<p>In this one we'll learn how to extend the framework using events.</p>

<h2 id="eventdispatcher-component">EventDispatcher Component</h2>

<p>The <a href="http://symfony.com/doc/current/components/event_dispatcher/introduction.html">Event Dispatcher</a>
is another standalone component which can be summed up as follow:</p>

<pre><code>&lt;?php

class EventDispatcher
{
    private $events = array();

    public function addListener($event, $listener)
    {
        $this-&gt;events[$event][] = $listener;
    }

    public function dispatch($event)
    {
        foreach ($this-&gt;events[$event] as $listener) {
            $listener();
        }
    }
}
</code></pre>

<p>You can register listeners (which are callables) and then call them by
dispatching the subscribed event:</p>

<pre><code>$dispatcher = new EventDispatcher();
$dispatcher-&gt;addListener('before.boyard', function () { echo 'Ultimate Challenge'; });
$dispatcher-&gt;dispatch('before.boyard'); // Prints "Ultimate Challenge".
</code></pre>

<p>Here's the actual API:</p>

<pre><code>&lt;?php

namespace Symfony\Component\EventDispatcher;

interface EventDispatcherInterface
{
    public function dispatch($eventName, Event $event = null);

    public function addListener($eventName, $listener, $priority = 0);
    public function removeListener($eventName, $listener);
    public function getListeners($eventName = null);
    public function hasListeners($eventName = null);

    public function addSubscriber(EventSubscriberInterface $subscriber);
    public function removeSubscriber(EventSubscriberInterface $subscriber);
}
</code></pre>

<p>The Component handles priorities, and contrary to our previous example it needs
an <code>Event</code> object when dispatching events, allowing us to provide a context.</p>

<p>Subscribers are listeners which have a <code>getSubscribedEvents</code> method.</p>

<p><strong>Note</strong>: If you want to learn more about this component, have a look at
<a href="https://twitter.com/raulfraile">Raul Fraile</a>'s <a href="http://blog.servergrove.com/2013/10/23/symfony2-components-overview-eventdispatcher/">article</a>.</p>

<h2 id="in-the-fullstack-framework">In the fullstack framework</h2>

<p>The <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html">Symfony2 HttpKernel Component</a>
dispatches events to provide extension points, we can:</p>

<ul>
<li>modify the Request when it has just been received: <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#the-kernel-request-event">kernel.request</a></li>
<li>change the controller when it has been guessed: <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#the-kernel-controller-event">kernel.controller</a></li>
<li>use the value returned by the controller: <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#the-kernel-view-event">kernel.view</a></li>
<li>change the Response when it has been created: <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#the-kernel-response-event">kernel.response</a></li>
<li><a href="https://github.com/symfony/symfony/pull/8904">handle global state and cleanup</a>: kernel.finish_request</li>
<li>handle exceptions: <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#handling-exceptions-the-kernel-exception-event">kernel.exception</a></li>
</ul>

<p><strong>Note</strong>: exceptions are caught by default, but this can be disabled.</p>

<p>Here's the <a href="http://symfony.com/doc/current/components/http_kernel/introduction.html#component-http-kernel-event-table">full list of kernel events</a>.</p>

<p><strong>Note</strong>: If you want to learn more about those events, have a look at
<a href="https://twitter.com/matthiasnoback">Matthias Noback</a>'s book:
<a href="https://leanpub.com/a-year-with-symfony?utm_campaign=a-year-with-symfony&amp;utm_medium=embed&amp;utm_source=gnugat.github.io">A year with Symfony</a>.</p>

<p>The FrameworkBundle takes care of registering the listeners using the
Dependency Injection Container (DIC): we declare our listener as a service in
the configuration, with a specific tag.</p>

<p><strong>Note</strong>: the DIC can retrieve all the services with the given tag using
<code>findTaggedServiceIds</code>, making it easier to register listeners for example
(this is done in <code>Symfony\Component\EventDispatcher\DependencyInjection\RegisterListenersPass</code>
which is called in the <a href="https://github.com/symfony/symfony/blob/f940d92a32e4d70cbe045ab8e1b3c70d3eb6061e/src/Symfony/Bundle/FrameworkBundle/FrameworkBundle.php#L71">FrameworkBundle</a>).</p>

<h2 id="submitted-json">Submitted JSON</h2>

<p>In <code>QuoteController::submitAction</code>, we need to get the request's content and
convert it from JSON. This is a generic task which should be executed before
every controller: we can move it in an event listener.</p>

<p>First create the directory:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/EventListener
</code></pre>

<p>Then we create the actual listener:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/EventListener/SubmitJsonListener.php

namespace Fortune\ApplicationBundle\EventListener;

use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class SubmitJsonListener
{
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $content = $request-&gt;getContent();
        $data = json_decode($content, true);
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>Next we register it in the Dependency Injection Container:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;!-- File: src/Fortune/ApplicationBundle/Resources/config/services.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="fortune_application.quote_factory"
            class="Fortune\ApplicationBundle\Entity\QuoteFactory"
        &gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_gateway"
            class="Fortune\ApplicationBundle\Entity\QuoteGateway"
            factory-service="doctrine"
            factory-method="getRepository"&gt;
            &lt;argument&gt;FortuneApplicationBundle:Quote&lt;/argument&gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_repository"
            class="Fortune\ApplicationBundle\Entity\QuoteRepository"
        &gt;
            &lt;argument type="service" id="fortune_application.quote_gateway" /&gt;
            &lt;argument type="service" id="fortune_application.quote_factory" /&gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.submit_json_listener"
            class="Fortune\ApplicationBundle\EventListener\SubmitJsonListener"
        &gt;
            &lt;tag name="kernel.event_listener" event="kernel.request" method="onKernelRequest" /&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>And finally we update the controller:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    public function submitAction(Request $request)
    {
        $postedValues = $request-&gt;request-&gt;all();
        if (empty($postedValues['content'])) {
            $answer = array('message' =&gt; 'Missing required parameter: content');

            return new JsonResponse($answer, Response::HTTP_UNPROCESSABLE_ENTITY);
        }
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quote = $quoteRepository-&gt;insert($postedValues['content']);

        return new JsonResponse($quote, Response::HTTP_CREATED);
    }

    public function listAction(Request $request)
    {
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quotes = $quoteRepository-&gt;findAll();

        return new JsonResponse($quotes, Response::HTTP_OK);
    }
}
</code></pre>

<p>We can now run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>No regression detected! We can commit our work:</p>

<pre><code>git add -A
git ci -m 'Used event'
</code></pre>

<p><strong>Note</strong>: The <a href="https://github.com/FriendsOfSymfony/FOSRestBundle">FOSRestBundle</a>
provides such an event listener. We're only creating it manually here to learn
about events.</p>

<h2 id="managing-errors-in-a-listener">Managing errors in a listener</h2>

<p>If someone submits a malformed JSON, our listener can stop the execution and
return a proper response:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/EventListener/SubmitJsonListener.php

namespace Fortune\ApplicationBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class SubmitJsonListener
{
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $content = $request-&gt;getContent();
        $data = json_decode($content, true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $data = array('message' =&gt; 'Invalid or malformed JSON');
            $response = new JsonResponse($data, Response::HTTP_BAD_REQUEST);
            $event-&gt;setResponse($response);
            $event-&gt;stopPropagation();
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>By setting a response in the event, the <code>HttpKernel</code> will almost stop (it
dispatches a <code>kernel.response</code> event and an extra <code>kernel.finish_request</code> event)
and return it.</p>

<p>By using <code>stopPropagation</code>, we prevent further <code>kernel.request</code> listeners from
being executed.</p>

<p>Have a look at <a href="https://github.com/symfony/symfony/blob/f940d92a32e4d70cbe045ab8e1b3c70d3eb6061e/src/Symfony/Component/HttpKernel/HttpKernel.php#L120">HttpKernel::handleRaw</a>
to discover what's going on.</p>

<p>Let's run the tests one last time:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>All green, we can commit our work:</p>

<pre><code>git add -A
git ci -m 'Handled errors'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Events are a powerful way to extend the framework: you create a listener,
register it on a specific event and you're done.</p>

<p>Kernel events aren't the only ones available:
<a href="http://doctrine-orm.readthedocs.org/en/latest/reference/events.html">Doctrine provides its own</a>,
(it uses its own event dispatcher library)
<a href="http://symfony.com/doc/current/components/form/form_events.html">the Symfony2 Form Component uses them</a>
and we could even <a href="http://isometriks.com/symfony2-custom-events">create our own events</a>!</p>

<p>The only drawback is that they're sort of hidden: by looking at the controller's
code we cannot know that submitted JSON has been handled, we lose explicitness.</p>

<p>The next article will be about annotations.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 4: Doctrine]]></title>
            <link href="/2014/08/27/master-sf2-part-4-doctrine.html"/>
            <updated>2014-08-27T00:00:00+01:00</updated>
            <id>/2014/08/27/master-sf2-part-4-doctrine.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fourth article of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the three first ones:</p>

<ul>
<li><a href="/2014/08/05/master-sf2-part-1-bootstraping.html">1: Bootstraping</a></li>
<li><a href="/2014/08/13/master-sf2-part-2-tdd.html">2: TDD</a></li>
<li><a href="/2014/08/22/master-sf2-part-3-services.html">3: Services</a></li>
</ul>

<p>In the previous articles we created an API allowing us to submit and list
quotes:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── parameters.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Fortune
│       └── ApplicationBundle
│           ├── Controller
│           │   └── QuoteController.php
│           ├── DependencyInjection
│           │   └── FortuneApplicationExtension.php
│           ├── Entity
│           │   ├── QuoteFactory.php
│           │   ├── QuoteGateway.php
│           │   ├── Quote.php
│           │   └── QuoteRepository.php
│           ├── FortuneApplicationBundle.php
│           ├── Resources
│           │   └── config
│           │       └── services.xml
│           └── Tests
│               ├── Controller
│               │   └── QuoteControllerTest.php
│               └── Entity
│                   └── QuoteRepositoryTest.php
└── web
    └── app.php
</code></pre>

<p>Here's the <a href="https://github.com/gnugat/mastering-symfony2">repository where you can find the actual code</a>.</p>

<p>In this one we'll use real database persistence using
<a href="http://www.doctrine-project.org/projects/orm.html">Doctrine ORM</a>, a third party
bundle, the command line console and a mocking library.</p>

<p><strong>Note</strong>: Symfony2 isn't coupled to any ORM or database library. We could use
anything else like <a href="http://php.net/manual/en/book.pdo.php">PDO</a>,
<a href="http://propelorm.org/">Propel ORM</a>, <a href="http://www.pomm-project.org/">POMM</a>, or
anything you want!</p>

<h2 id="installing-doctrinebundle">Installing DoctrineBundle</h2>

<p>Just like Symfony, Doctrine is composed of many libraries which can be used
separately. The two main ones are:</p>

<ul>
<li>the DataBase Abstraction Layer (DBAL), provides a unique API for many database
vendors (MySQL, PostgreSQL, Oracle, etc)</li>
<li>the Object Relation Mapping (ORM), provides an object oriented way to depict
the data (which are usually relational)</li>
</ul>

<p>DoctrineBundle registers the library's services into our Dependency Injection
Container. It can be installed quickly:</p>

<pre><code>composer require 'doctrine/doctrine-bundle:~1.2'
</code></pre>

<p>The bundle doesn't force you to use the ORM (you can simply use the DBAL), so we
need to explicitly install it:</p>

<pre><code>composer require 'doctrine/orm:~2.2,&gt;=2.2.3'
</code></pre>

<p>The bundle has to be registered in our application:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Fortune\ApplicationBundle\FortuneApplicationBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>Its services depend on some configuration parameters, which we will add:</p>

<pre><code># File: app/config/config.yml
imports:
    - { resource: parameters.yml }
    - { resource: doctrine.yml }

framework:
    secret: %secret%
    router:
        resource: %kernel.root_dir%/config/routing.yml
</code></pre>

<p>Next we create the actual configuration:</p>

<pre><code># File: app/config/doctrine.yml
doctrine:
    dbal:
        driver: pdo_mysql
        host: 127.0.0.1
        port: ~
        dbname: %database_name%
        user: %database_user%
        password: %database_password%
        charset: UTF8

    orm:
        auto_generate_proxy_classes: %kernel.debug%
        auto_mapping: true
</code></pre>

<p><strong>Note</strong>: the <code>~</code> value is equivalent to <code>null</code> in PHP.</p>

<p>The values surrounded by <code>%</code> will be replaced by parameters coming from the DIC.
For example, <code>kernel.debug</code> is set by the FrameworkBundle. We'll set the values
of the database ones in the following file:</p>

<pre><code># File: app/config/parameters.yml
parameters:
    secret: hazuZRqYGdRrL8ATdB8kAqBZ

    database_name: fortune
    database_user: root
    database_password: ~
</code></pre>

<p>For security reason, this file is not commited. You can update the distributed
file though, so your team will know that they need to set a value:</p>

<pre><code># File: app/config/parameters.yml.dist
parameters:
    secret: ChangeMePlease

    database_name: fortune
    database_user: root
    database_password: ~
</code></pre>

<h2 id="configuring-the-schema">Configuring the schema</h2>

<p>The first thing we need is to define the schema (tables with their fields), so
we'll create this directory:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/Resources/config/doctrine
</code></pre>

<p>And then the configuration file for the <code>Quote</code> entity:</p>

<pre><code># src/Fortune/ApplicationBundle/Resources/config/doctrine/Quote.orm.yml
Fortune\ApplicationBundle\Entity\Quote:
    type: entity
    repositoryClass: Fortune\ApplicationBundle\Entity\QuoteGateway
    table: quote
    id:
        id:
            type: integer
            generator:
                strategy: AUTO
    fields:
        content:
            type: text
        createdAt:
            type: datetime
            column: created_at
</code></pre>

<p><strong>Note</strong>: Doctrine uses the word "Repository" with a different meaning than the
Repository design pattern (the one with gateway and factory). In our case it
corresponds to the gateway.</p>

<p>As you can see, we've added a <code>createdAt</code> attribute to our entity. Let's update
its code:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/Quote.php

namespace Fortune\ApplicationBundle\Entity;

class Quote
{
    private $id;
    private $content;
    private $createdAt;

    public function __construct($id, $content)
    {
        $this-&gt;id = $id;
        $this-&gt;content = $content;
        $this-&gt;createdAt = new \DateTime();
    }

    public static function fromContent($content)
    {
        return new Quote(null, $content);
    }

    public function getId()
    {
        return $this-&gt;id;
    }

    public function getContent()
    {
        return $this-&gt;content;
    }

    public function getCreatedAt()
    {
        return $this-&gt;createdAt;
    }
}
</code></pre>

<p><strong>Note</strong>: We've added <a href="http://verraes.net/2014/06/named-constructors-in-php/">a named constructor</a>
which will prove usefull with the gateway.</p>

<h2 id="creating-the-console">Creating the console</h2>

<p>Symfony2 provides a powerful <a href="http://symfony.com/doc/current/components/console/introduction.html">Console Component</a>
allowing you to create command line utilities. It can be used standalone, or
in the full stack framework thanks to the FrameworkBundle. To create the
console, we just need to create the following file:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: app/console

set_time_limit(0);

require_once __DIR__.'/../vendor/autoload.php';
require_once __DIR__.'/AppKernel.php';

use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Input\ArgvInput;

$input = new ArgvInput();
$kernel = new AppKernel('dev', true);
$application = new Application($kernel);
$application-&gt;run($input);
</code></pre>

<p>The object <code>ArgvInput</code> contains the input given by the user (command name,
arguments and options). Bundles can register commands in the application by
fetching them from their <code>Command</code> directory.</p>

<p>We can now create the database and schema easily:</p>

<pre><code>php app/console doctrine:database:create
php app/console doctrine:schema:create
</code></pre>

<p><strong>Note</strong>: Those are useful when developing the application, but shouldn't be used in
production.</p>

<p><strong>Note</strong>: If you want to learn more about the Symfony2 Console Component,
<a href="/2014/04/09/sf2-console-component-by-example.html">you can read this article</a>.</p>

<h2 id="adapting-the-gateway">Adapting the Gateway</h2>

<p>Until now, our <code>QuoteGateway</code> was saving and retrieving the quotes from a file.
We'll update it to be a Doctrine Repository:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/QuoteGateway.php

namespace Fortune\ApplicationBundle\Entity;

use Doctrine\ORM\EntityRepository;

class QuoteGateway extends EntityRepository
{
    public function insert($content)
    {
        $entityManager = $this-&gt;getEntityManager();

        $quote = Quote::fromContent($content);
        $entityManager-&gt;persist($quote);
        $entityManager-&gt;flush();

        return $quote;
    }
}
</code></pre>

<p>The <code>EntityManager</code> object does the actual persistence and will set the quote's
ID. The <code>EntityRepository</code> already has a <code>findAll</code> method, so we can remove it.</p>

<p>The last thing we need is to update the DIC's configuration:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;!-- File: src/Fortune/ApplicationBundle/Resources/config/services.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="fortune_application.quote_factory"
            class="Fortune\ApplicationBundle\Entity\QuoteFactory"
        &gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_gateway"
            class="Fortune\ApplicationBundle\Entity\QuoteGateway"
            factory-service="doctrine"
            factory-method="getRepository"&gt;
            &lt;argument&gt;FortuneApplicationBundle:Quote&lt;/argument&gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_repository"
            class="Fortune\ApplicationBundle\Entity\QuoteRepository"
        &gt;
            &lt;argument type="service" id="fortune_application.quote_gateway" /&gt;
            &lt;argument type="service" id="fortune_application.quote_factory" /&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>The <code>doctrine</code> service manages the Doctrine Repositories. To manually get a
repository you'd need to do somethig like
<code>$container-&gt;get('doctrine')-&gt;getRepository('FortuneApplicationBundle:QuoteGateway')</code>,
the <code>factory-service</code> and <code>factory-method</code> attributes allow us to simply call
container->get('fortune_application.quote_gateway')`.</p>

<h2 id="mocking-the-database">Mocking the database</h2>

<p>Database operations can be slow however we want our tests to run as fast as
possible: <a href="http://blog.8thlight.com/uncle-bob/2014/05/10/WhenToMock.html">this is a good opportunity to use a test double</a>.</p>

<p>PHPUnit comes with its own mocking library, but we'll use a less verbose and
more one: <a href="https://github.com/phpspec/prophecy">Prophecy</a>. First we install
the PHPUnit integration of Prophecy:</p>

<pre><code>composer require --dev 'phpspec/prophecy-phpunit:~1.0'
</code></pre>

<p>Then we update our test:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Tests/Entity/QuoteRepositoryTest.php

namespace Fortune\ApplicationBundle\Tests\Entity;

use Fortune\ApplicationBundle\Entity\Quote;
use Fortune\ApplicationBundle\Entity\QuoteFactory;
use Fortune\ApplicationBundle\Entity\QuoteGateway;
use Fortune\ApplicationBundle\Entity\QuoteRepository;
use Prophecy\PhpUnit\ProphecyTestCase;

class QuoteRepositoryTest extends ProphecyTestCase
{
    const ID = 42;
    const CONTENT = '&lt;KnightOfNi&gt; Ni!';

    private $gateway;
    private $repository;

    public function setUp()
    {
        parent::setUp();
        $gatewayClassname = 'Fortune\ApplicationBundle\Entity\QuoteGateway';
        $this-&gt;gateway = $this-&gt;prophesize($gatewayClassname);
        $factory = new QuoteFactory();
        $this-&gt;repository = new QuoteRepository($this-&gt;gateway-&gt;reveal(), $factory);
    }

    public function testItPersistsTheQuote()
    {
        $quote = new Quote(self::ID, self::CONTENT);
        $this-&gt;gateway-&gt;insert(self::CONTENT)-&gt;willReturn($quote);
        $this-&gt;repository-&gt;insert(self::CONTENT);

        $this-&gt;gateway-&gt;findAll()-&gt;willReturn(array($quote));
        $quotes = $this-&gt;repository-&gt;findAll();
        $foundQuote = $quotes['quotes'][self::ID];

        $this-&gt;assertSame(self::CONTENT, $foundQuote['content']);
    }
}
</code></pre>

<p>We created a mock of <code>QuoteGateway</code> which returns a quote we created beforehand.</p>

<p>Our changes are finished, let's run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>No regression detected! We can commit our work:</p>

<pre><code>git add -A
git ci -m 'Added doctrine'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Doctrine allows us to persist the data, its bundle integrates it smoothly into
our application and provides us with handy command line tools.</p>

<p>You can have a look at <a href="http://docs.doctrine-project.org/projects/doctrine-migrations/en/latest/reference/introduction.html">Doctrine Migration</a>,
a standalone library allowing you to deploy database changes, it even has
<a href="http://symfony.com/doc/current/bundles/DoctrineMigrationsBundle/index.html">a bundle</a>.</p>

<p>In the next article, we'll talk about how to extend the framework using events.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 3: Services]]></title>
            <link href="/2014/08/22/master-sf2-part-3-services.html"/>
            <updated>2014-08-22T00:00:00+01:00</updated>
            <id>/2014/08/22/master-sf2-part-3-services.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the third article of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the two first ones:</p>

<ul>
<li><a href="/2014/08/05/master-sf2-part-1-bootstraping.html">1: Bootstraping</a></li>
<li><a href="/2014/08/13/master-sf2-part-2-tdd.html">2: TDD</a></li>
</ul>

<p>In the previous articles we created an API allowing us to submit new quotes:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── parameters.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Fortune
│       └── ApplicationBundle
│           ├── Controller
│           │   └── QuoteController.php
│           ├── FortuneApplicationBundle.php
│           └── Tests
│               └── Controller
│                   └── QuoteControllerTest.php
└── web
    └── app.php
</code></pre>

<p>Here's the <a href="https://github.com/gnugat/mastering-symfony2">repository where you can find the actual code</a>.</p>

<p>In this one we'll list the existing quotes and learn about entities, services,
the repository design pattern and dependency injection.</p>

<h2 id="defining-the-second-user-story">Defining the second User Story</h2>

<p>By the time we finished to implement the first User Story, Nostradamus (our
customer and product owner) wrote the second one:</p>

<pre><code>As a User
I want to be able to read the available quotes
In order to find interesting ones
</code></pre>

<p>Currently we don't persist our quotes, but now we will need to. However I'd like
to dedicate a separate article to database persistence, so we will save our
quotes in a file and concentrate on services.</p>

<h2 id="the-quote-entity">The quote entity</h2>

<p>Until now we wrote our code in the controller and it was ok, as there wasn't
much code. But now our application will grow, so we need to put the code
elsewhere: in the services.</p>

<p>Basically a service is just a class which does one thing (and does it well).
They are stateless, which means that calling a method many times with the same
parameter should always return the same value.</p>

<p>They manipulate entities which are classes representing the data. Those don't
have any behavior. Let's create the <code>Entity</code> directory:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/Entity
</code></pre>

<p>And now we'll write the <code>Quote</code> entity:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/Quote.php

namespace Fortune\ApplicationBundle\Entity;

class Quote
{
    private $id;
    private $content;

    public function __construct($id, $content)
    {
        $this-&gt;id = $id;
        $this-&gt;content = $content;
    }

    public function getId()
    {
        return $this-&gt;id;
    }

    public function getContent()
    {
        return $this-&gt;content;
    }
}
</code></pre>

<p>There's no need to write a unit test for it: it doesn't contain any logic. The
tests of its services (which manipulate it) will be enough.</p>

<h2 id="the-repository-service">The repository service</h2>

<p>We'll create a persistence service which will follow the
<a href="http://code.tutsplus.com/tutorials/the-repository-design-pattern--net-35804">Repository design pattern</a>:
the repository calls a gateway to retreive some raw data and transforms it using
a factory.</p>

<p>Before creating it, we will write a unit test which will help us to specify how
it should work. Here's its directory:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/Tests/Entity
</code></pre>

<p>And its code:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Tests/Entity/QuoteRepositoryTest.php

namespace Fortune\ApplicationBundle\Tests\Entity;

use Fortune\ApplicationBundle\Entity\QuoteFactory;
use Fortune\ApplicationBundle\Entity\QuoteGateway;
use Fortune\ApplicationBundle\Entity\QuoteRepository;

class QuoteRepositoryTest extends \PHPUnit_Framework_TestCase
{
    const CONTENT = '&lt;KnightOfNi&gt; Ni!';

    private $repository;

    public function setUp()
    {
        $filename = '/tmp/fortune_database_test.txt';
        $gateway = new QuoteGateway($filename);
        $factory = new QuoteFactory();
        $this-&gt;repository = new QuoteRepository($gateway, $factory);
    }

    public function testItPersistsTheQuote()
    {
        $quote = $this-&gt;repository-&gt;insert(self::CONTENT);
        $id = $quote['quote']['id'];
        $quotes = $this-&gt;repository-&gt;findAll();
        $foundQuote = $quotes['quotes'][$id];

        $this-&gt;assertSame(self::CONTENT, $foundQuote['content']);
    }
}
</code></pre>

<p>Now we can create the class which should make the test pass:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/QuoteRepository.php

namespace Fortune\ApplicationBundle\Entity;

class QuoteRepository
{
    private $gateway;
    private $factory;

    public function __construct(QuoteGateway $gateway, QuoteFactory $factory)
    {
        $this-&gt;gateway = $gateway;
        $this-&gt;factory = $factory;
    }

    public function insert($content)
    {
        $quote = $this-&gt;gateway-&gt;insert($content);

        return $this-&gt;factory-&gt;makeOne($quote);
    }

    public function findAll()
    {
        $quotes = $this-&gt;gateway-&gt;findAll();

        return $this-&gt;factory-&gt;makeAll($quotes);
    }
}
</code></pre>

<p>See what we've done in the constructor? That's dependency injection (passing
arguments on which the class relies).</p>

<p><strong>Note</strong>: for more information about the Dependency Injection,
<a href="/2014/01/22/ioc-di-and-service-locator.html">you can read this article</a>.</p>

<h3 id="the-gateway-service">The gateway service</h3>

<p>The gateway is the class where the actual persistence is done:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/QuoteGateway.php

namespace Fortune\ApplicationBundle\Entity;

class QuoteGateway
{
    private $filename;

    public function __construct($filename)
    {
        $this-&gt;filename = $filename;
    }

    public function insert($content)
    {
        $content = trim($content);
        $line = $content."\n";
        file_put_contents($this-&gt;filename, $line, FILE_APPEND);
        $lines = file($this-&gt;filename);
        $lineNumber = count($lines) - 1;

        return new Quote($lineNumber, $content);
    }

    public function findAll()
    {
        $contents = file($this-&gt;filename);
        foreach ($contents as $id =&gt; $content) {
            $quotes[$id] = new Quote($id, trim($content));
        }

        return $quotes;
    }
}
</code></pre>

<p>Wait a minute, we didn't write any test for this class! Well, that's because
<code>QuoteRepositoryTest</code> already covers it.</p>

<h2 id="the-factory-service">The factory service</h2>

<p>The factroy converts the object returned by the gateway to something usable by
the controller (a JSONable array):</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Entity/QuoteFactory.php

namespace Fortune\ApplicationBundle\Entity;

class QuoteFactory
{
    public function makeOne(Quote $rawQuote)
    {
        return array('quote' =&gt; $this-&gt;make($rawQuote));
    }

    public function makeAll(array $rawQuotes)
    {
        foreach ($rawQuotes as $rawQuote) {
            $quotes['quotes'][$rawQuote-&gt;getId()] = $this-&gt;make($rawQuote);
        }

        return $quotes;
    }

    private function make(Quote $rawQuote)
    {
        return array(
            'id' =&gt; $rawQuote-&gt;getId(),
            'content' =&gt; $rawQuote-&gt;getContent(),
        );
    }
}
</code></pre>

<p>No unit test for this factory: the one for the repository already covers it.
Now that the code is written, we can check that the test pass:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<h2 id="using-the-service-in-the-controller">Using the service in the controller</h2>

<p>The controller responsibility is to retrieve the parameters from the request,
inject them in a service and then use its return value to create a response.
We won't construct directly the <code>QuoteRepository</code> service in the controller:
Symfony2 comes with a <a href="http://symfony.com/doc/current/components/dependency_injection/introduction.html">Dependency Injection Container</a> (DIC).
In a nutshell when you ask the container a service, it will construct it for
you.</p>

<p>The first thing we need is to prepare the bundle by creating the following
directories:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/DependencyInjection
mkdir -p src/Fortune/ApplicationBundle/Resources/config
</code></pre>

<p>Then we need to create a class which will load the bundle's services into the
DIC:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/DependencyInjection/FortuneApplicationExtension.php

namespace Fortune\ApplicationBundle\DependencyInjection;

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\HttpKernel\DependencyInjection\Extension;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

class FortuneApplicationExtension extends Extension
{
    public function load(array $configs, ContainerBuilder $container)
    {
        $fileLocator = new FileLocator(__DIR__.'/../Resources/config');
        $loader = new XmlFileLoader($container, $fileLocator);

        $loader-&gt;load('services.xml');
    }
}
</code></pre>

<p>As you can see, we told the extension to look for a configuration file. Here it
is:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;!-- File: src/Fortune/ApplicationBundle/Resources/config/services.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="fortune_application.quote_factory"
            class="Fortune\ApplicationBundle\Entity\QuoteFactory"
        &gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_gateway"
            class="Fortune\ApplicationBundle\Entity\QuoteGateway"
        &gt;
            &lt;argument&gt;/tmp/fortune_database.txt&lt;/argument&gt;
        &lt;/service&gt;
        &lt;service id="fortune_application.quote_repository"
            class="Fortune\ApplicationBundle\Entity\QuoteRepository"
        &gt;
            &lt;argument type="service" id="fortune_application.quote_gateway" /&gt;
            &lt;argument type="service" id="fortune_application.quote_factory" /&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>Now <code>QuoteRepository</code> is available in the controller:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    public function submitAction(Request $request)
    {
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);
        if (empty($postedValues['content'])) {
            $answer = array('message' =&gt; 'Missing required parameter: content');

            return new JsonResponse($answer, Response::HTTP_UNPROCESSABLE_ENTITY);
        }
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quote = $quoteRepository-&gt;insert($postedValues['content']);

        return new JsonResponse($quote, Response::HTTP_CREATED);
    }
}
</code></pre>

<p>We can now make sure that everything is fine by running the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p><strong>Note</strong>: for more information about Symfony2 Dependency Injection Component
<a href="/2014/01/29/sf2-di-component-by-example.html">you can read this article</a>.</p>

<h2 id="listing-quotes">Listing quotes</h2>

<p>It's now time to fulfill the second user story, starting with a functional test:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Tests/Controller/QuoteControllerTest.php

namespace Fortune\ApplicationBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class QuoteControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), $headers, $content);

        return $client-&gt;getResponse();
    }

    private function get($uri)
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $client = static::createClient();
        $client-&gt;request('GET', $uri, array(), array(), $headers);

        return $client-&gt;getResponse();
    }

    public function testSubmitNewQuote()
    {
        $response = $this-&gt;post('/api/quotes', array('content' =&gt; '&lt;KnightOfNi&gt; Ni!'));

        $this-&gt;assertSame(Response::HTTP_CREATED, $response-&gt;getStatusCode());
    }

    public function testSubmitEmptyQuote()
    {
        $response = $this-&gt;post('/api/quotes', array('content' =&gt; ''));

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY, $response-&gt;getStatusCode());
    }

    public function testSubmitNoQuote()
    {
        $response = $this-&gt;post('/api/quotes', array());

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY, $response-&gt;getStatusCode());
    }

    public function testListingAllQuotes()
    {
        $response = $this-&gt;get('/api/quotes');

        $this-&gt;assertSame(Response::HTTP_OK, $response-&gt;getStatusCode());
    }
}
</code></pre>

<p>The next step is to update the configuration:</p>

<pre><code># File: app/config/routing.yml
submit_quote:
    path: /api/quotes
    methods:
        - POST
    defaults:
        _controller: FortuneApplicationBundle:Quote:submit

list_quotes:
    path: /api/quotes
    methods:
        - GET
    defaults:
        _controller: FortuneApplicationBundle:Quote:list
</code></pre>

<p>Then we write the action:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    public function submitAction(Request $request)
    {
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);

        if (empty($postedValues['content'])) {
            $answer = array('message' =&gt; 'Missing required parameter: content');

            return new JsonResponse($answer, Response::HTTP_UNPROCESSABLE_ENTITY);
        }
        $quote = $quoteRepository-&gt;insert($postedValues['content']);

        return new JsonResponse($quote, Response::HTTP_CREATED);
    }

    public function listAction(Request $request)
    {
        $quoteRepository = $this-&gt;container-&gt;get('fortune_application.quote_repository');
        $quotes = $quoteRepository-&gt;findAll();

        return new JsonResponse($quotes, Response::HTTP_OK);
    }
}
</code></pre>

<p>And finally we run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>Everything is fine, we can commit:</p>

<pre><code>git add -A
git ci -m 'Added listing of quotes'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Services is where the logic should be. Those manipulate entities, which carry
the data. We used the repository design pattern which is very handy for APIs:
it calls a gateway which retrieves raw data and then convert it using a factory,
so the controller only needs to comunicate with the repository. Finally, we saw
that "Dependency Injection" is just a fancy term for "passing arguments".</p>

<p>In the next article, we'll learn use database persistence, using
<a href="http://www.doctrine-project.org/projects/orm.html">Doctrine2 ORM</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 2: Test Driven Development]]></title>
            <link href="/2014/08/13/master-sf2-part-2-tdd.html"/>
            <updated>2014-08-13T00:00:00+01:00</updated>
            <id>/2014/08/13/master-sf2-part-2-tdd.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the second article of the series on mastering the
<a href="http://symfony.com/">Symfony2</a> framework. Have a look at the first one:
<a href="/2014/08/05/master-sf2-part-1-bootstraping.html">Bootstraping</a>.</p>

<p>In the first article we bootstraped our project with the following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Fortune
│       └── ApplicationBundle
│           └── FortuneApplicationBundle.php
└── web
    └── app.php
</code></pre>

<p>Here's the <a href="https://github.com/gnugat/mastering-symfony2">repository where you can find the actual code</a>.</p>

<p>In this one we'll implement the first User Story, by writing tests first.</p>

<p><strong>Note</strong>: writing tests before writing any code is part of the
<a href="/2014/02/19/test-driven-development.html">Test Driven Development (TDD) methodology</a>.</p>

<h2 id="defining-the-user-story">Defining the User Story</h2>

<p>With the help of our Scrum Master, our Product Owner (Nostradamus) managed to
write the following user story:</p>

<pre><code>As a User
I want to be able to submit a new quote
In order to make it available
</code></pre>

<h2 id="writing-the-test">Writing the test</h2>

<p>Our first reflex will be to write a functional test. First create the directory:</p>

<pre><code>mkdir -p src/Fortune/ApplicationBundle/Tests/Controller
</code></pre>

<p>Then the test class:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Tests/Controller/QuoteControllerTest.php

namespace Fortune\ApplicationBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class QuoteControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), $headers, $content);

        return $client-&gt;getResponse();
    }

    public function testSubmitNewQuote()
    {
        $response = $this-&gt;post('/api/quotes', array('content' =&gt; '&lt;KnightOfNi&gt; Ni!'));

        $this-&gt;assertSame(Response::HTTP_CREATED, $response-&gt;getStatusCode());
    }
}
</code></pre>

<h2 id="configuring-the-route">Configuring the route</h2>

<p>Now we need to link the <code>/quotes</code> URL to a controller, so let's edit the
configuration:</p>

<pre><code># File: app/config/routing.yml
submit_quote:
    path: /api/quotes
    methods:
        - POST
    defaults:
        _controller: FortuneApplicationBundle:Quote:submit
</code></pre>

<h2 id="creating-the-controller">Creating the controller</h2>

<p>There wasn't any controllers until now, so we create the directory:</p>

<pre><code>mkdir src/Fortune/ApplicationBundle/Controller
</code></pre>

<p>And finally the controller class:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    public function submitAction(Request $request)
    {
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);

        $answer['quote']['content'] = $postedValues['content'];

        return new JsonResponse($answer, Response::HTTP_CREATED);
    }
}
</code></pre>

<p>Now let's run our tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p><a href="https://www.youtube.com/watch?v=lFeLDc2CzOs">All green</a>! This makes us
confident enough to commit our work:</p>

<pre><code>git add -A
git commit -m 'Created submission of quotes'
</code></pre>

<h2 id="testing-bad-cases">Testing bad cases</h2>

<p>The submitted content shouldn't be empty. Let's add a test for the bad cases:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Tests/Controller/QuoteControllerTest.php

namespace Fortune\ApplicationBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class QuoteControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), $headers, $content);

        return $client-&gt;getResponse();
    }

    public function testSubmitNewQuote()
    {
        $response = $this-&gt;post('/api/quotes', array('content' =&gt; '&lt;KnightOfNi&gt; Ni!'));

        $this-&gt;assertSame(Response::HTTP_CREATED, $response-&gt;getStatusCode());
    }

    public function testSubmitEmptyQuote()
    {
        $response = $this-&gt;post('/api/quotes', array('content' =&gt; ''));

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY, $response-&gt;getStatusCode());
    }

    public function testSubmitNoQuote()
    {
        $response = $this-&gt;post('/api/quotes', array());

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY, $response-&gt;getStatusCode());
    }
}
</code></pre>

<h2 id="checking-bad-cases">Checking bad cases</h2>

<p>Now let's fix the new tests:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/Controller/QuoteController.php

namespace Fortune\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class QuoteController extends Controller
{
    public function submitAction(Request $request)
    {
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);

        if (empty($postedValues['content'])) {
            $answer = array('message' =&gt; 'Missing required parameter: content');

            return new JsonResponse($answer, Response::HTTP_UNPROCESSABLE_ENTITY);
        }
        $answer['quote']['content'] = $postedValues['content'];

        return new JsonResponse($answer, Response::HTTP_CREATED);
    }
}
</code></pre>

<p>Finally run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>All green! Let's call it a day and commit our work:</p>

<pre><code>git add -A
git commit -m 'Managed submission of empty/no quotes'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>For those who didn't practice a lot with Symfony2, this article should have
demonstrated how quick and simple it is to implement the first User Story
(test and code alike).</p>

<p>In the next article, we'll learn how to work with services.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Master Symfony2 - part 1: Bootstraping]]></title>
            <link href="/2014/08/05/master-sf2-part-1-bootstraping.html"/>
            <updated>2014-08-05T00:00:00+01:00</updated>
            <id>/2014/08/05/master-sf2-part-1-bootstraping.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>You know the basics of the <a href="http://symfony.com/">Symfony2</a> framework
(<a href="https://getcomposer.org/">Composer</a>, empty application, bundle, controller and
functional test with <a href="http://phpunit.de/">PHPUnit</a>) and you want to learn more
about how to extend it (and understanding what you're doing)?</p>

<p>Then this series of articles is for you :) .</p>

<p>If you don't feel confident about the prerequisites, have a look at
<a href="/2014/06/18/learn-sf2-composer-part-1.html">the Learn Symfony2 series</a>.
Don't worry, we'll start with a bit of practicing before starting to learn
anything new.</p>

<p>In the first article of this series, we'll discover our cutomer's needs and
we'll bootstrap our application.</p>

<h2 id="our-use-case%3A-creating-a-fortune-application">Our use case: creating a Fortune application</h2>

<p>In order to have real world examples, we'll need a use case. The Knight of Ni
were pretty satisfied with our previous work, and they recommended us to
Nostradamus!</p>

<p>Nostradamus is a fortune teller and wants to jump on the internet bandwagon. He
wants us to create a
<a href="http://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune application</a>
where users can submit quotes.</p>

<p>Our first task will be to create an empty application so we can start working.
We could use the <a href="http://symfony.com/distributions">Symfony Standard Edition</a>,
but in order to understand what really happens behind the scene we'll use an
emptier distribution.</p>

<h2 id="installing-symfony2-emptier-edition">Installing Symfony2 Emptier Edition</h2>

<p>First make sure to have the last version of <a href="https://getcomposer.org/">Composer</a>
installed:</p>

<pre><code>curl -sS https://getcomposer.org/installer | php
sudo mv composer.phar /usr/local/bin/composer
</code></pre>

<p>Then ask Composer to create the boilerplate of our application, using the
<a href="https://github.com/gnugat/sf2-emptier">Symfony2 Emptier Edition</a>:</p>

<pre><code>composer create-project 'gnugat/sf2-emptier' fortune '0.1.*'
cd fortune
</code></pre>

<p>This distribution is similar to the empty application we created in the
<a href="/2014/06/25/learn-sf2-empty-app-part-2.html">learn Symfony2 series</a>.
It contains the following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_prod.yml
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   ├── parameters.yml.dist
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── LICENSE
├── README.md
└── web
    └── app.php
</code></pre>

<p>Remove the documentation files:</p>

<pre><code>rm README.md LICENSE
</code></pre>

<p>Change the <code>composer.json</code> information:</p>

<pre><code>{
    "name": "nostradamus/fortune",
    "license": "proprietary",
    "type": "project",
    "description": "A collection of quotes",
    "autoload": {
        "psr-4": { "": "src/" }
    },
    "require": {
        "php": "&gt;=5.3.17",

        "symfony/symfony": "~2.4"
    },
    "require-dev": {
        "phpunit/phpunit": "~4.1"
    }
}
</code></pre>

<p>Next you'll have to configure the project specific parameters:</p>

<pre><code>cp app/config/parameters.yml.dist app/config/parameters.yml
</code></pre>

<p>Don't forget to edit <code>app/config/parameters.yml</code> and change the value of the
secret parameter:</p>

<pre><code>parameters:
    secret: hazuZRqYGdRrL8ATdB8kAqBZ
</code></pre>

<p><strong>Tip</strong>: Use <a href="https://www.random.org/passwords/?num=1&amp;len=24&amp;format=html&amp;rnd=new">random.org</a>
to generate your secret token.</p>

<p><strong>Note</strong>: For security reason, this parameter file is ignored by git. It means
that this file should be created on each installation.</p>

<p>Let's commit our hard work:</p>

<pre><code>git init
git add -A
git add -f app/logs/.gitkeep app/cache/.gitkeep
git commit -m 'Created a Symfony2 Emptier application'
</code></pre>

<h2 id="creating-the-application-bundle">Creating the Application Bundle</h2>

<p>We will also need an Application bundle. First we create the directories:</p>

<pre><code>mkdir -p src/Fortune/ApplicationBundle
</code></pre>

<p>Then the Bundle class:</p>

<pre><code>&lt;?php
// File: src/Fortune/ApplicationBundle/FortuneApplicationBundle.php

namespace Fortune\ApplicationBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;

class FortuneApplicationBundle extends Bundle
{
}
</code></pre>

<p>And finally register it in the application's kernel:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Fortune\ApplicationBundle\FortuneApplicationBundle(), // &lt;-- Here!
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>We're now ready to get started with our real concern, so let's commit our work:</p>

<pre><code>git add -A
git commit -m 'Created ApplicationBundle'
</code></pre>

<h3 id="apache-configuration">Apache configuration</h3>

<p>In order for your website to be browsed, you'll need to configure your web
server. This configuration is well explained
<a href="http://symfony.com/doc/current/cookbook/configuration/web_server_configuration.html">in the documentation</a>,
so here's a dump of an apache vhost:</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerName fortune.local

    DocumentRoot /home/loic.chardonnet/Projects/gnugat/fortune/web

    ErrorLog "/home/loic.chardonnet/Projects/gnugat/fortune/app/logs/apache_errors.log"
    CustomLog "/home/loic.chardonnet/Projects/gnugat/fortune/app/logs/apache_accesses.log" common

    &lt;Directory /home/loic.chardonnet/Projects/gnugat/fortune/web&gt;
        Options Indexes FollowSymLinks MultiViews
        AllowOverride None
        Order allow,deny
        allow from all
        &lt;IfModule mod_rewrite.c&gt;
            RewriteEngine On
            RewriteCond %{REQUEST_FILENAME} !-f
            RewriteRule ^(.*)$ /app.php [QSA,L]
        &lt;/IfModule&gt;
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</code></pre>

<p>If you run into some permission problem (like writing in <code>cache</code> and <code>logs</code>),
you might consider to change <code>APACHE_RUN_USER</code> and <code>APACHE_RUN_GROUP</code>
environment variables present in <code>/etc/apache2/envvars</code> to your own user and
group.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Using Composer's <code>create-project</code> command with a Symfony2 Distribution is the
quickest way to bootstrap a project.</p>

<p>In the next article, we will start to work on our first User Story.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - Conclusion]]></title>
            <link href="/2014/07/23/learn-sf2-conclusion.html"/>
            <updated>2014-07-23T00:00:00+01:00</updated>
            <id>/2014/07/23/learn-sf2-conclusion.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the conclusion of the series on learning
<a href="http://symfony.com/">the Symfony2 framework</a>.
Have a look at the five first ones:</p>

<ol>
<li><a href="/2014/06/18/learn-sf2-composer-part-1.html">Composer</a></li>
<li><a href="/2014/06/25/learn-sf2-empty-app-part-2.html">Empty application</a></li>
<li><a href="/2014/07/02/learn-sf2-bundles-part-3.html">Bundles</a></li>
<li><a href="/2014/07/12/learn-sf2-controllers-part-4.html">Controllers</a></li>
<li><a href="/2014/07/20/learn-sf2-tests-part-5.html">Tests</a></li>
</ol>

<p>In the previous articles we created a tested application for the Knight of Ni
with the following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config_test.yml
│   │   ├── config.yml
│   │   └── routing.yml
│   ├── logs
│   │   └── .gitkeep
│   └── phpunit.xml.dist
├── composer.json
├── composer.lock
├── src
│   └── Knight
│       └── ApplicationBundle
│           ├── Controller
│           │   └── ApiController.php
│           ├── KnightApplicationBundle.php
│           └── Tests
│               └── Controller
│                   └── ApiControllerTest.php
├── .gitignore
└── web
    └── app.php
</code></pre>

<p>Running <code>composer install</code> should create a <code>vendor</code> directory, which we ignored
with git.</p>

<p>Here's the <a href="https://github.com/gnugat/learning-symfony2/tree/5-tests">repository where you can find the actual code</a>.</p>

<p>This article will be like a cheat sheet of what we saw in the previous ones.</p>

<h2 id="composer">Composer</h2>

<p><a href="https://getcomposer.org/">Composer</a> will help you install and update third
party libraries.</p>

<p>Download it once for all and install it in your global binaries:</p>

<pre><code>curl -sS https://getcomposer.org/installer | php
sudo mv ./composer.phar /usr/local/bin/composer
</code></pre>

<p>It should then be executable like this: <code>composer</code>.</p>

<ul>
<li>install a third party library: <code>composer require [--dev] &lt;vendor/name:version&gt;</code></li>
<li>download the project's third party libraries: <code>composer install</code></li>
<li>update the project's third party libraries: <code>composer update</code></li>
</ul>

<p>The available third party libraries can be found on
<a href="https://packagist.org/">Packagist</a>.</p>

<p>Here's an explanation of <a href="https://igor.io/2013/01/07/composer-versioning.html">Composer version constraints by Igor</a>.</p>

<p>In these articles, we create a project from scratch, but the recommended way of
starting a Symfony2 application is to use the Composer bootstrap command:
<code>composer create-project &lt;vendor/name&gt; &lt;path-to-install&gt;</code></p>

<p>You could use the <a href="https://github.com/symfony/symfony-standard">Symfony Standard Edition</a>
(<code>symfony/framework-standard-edition</code>), or any other distribution.</p>

<p>I'd advise you to use an empty boilerplate with the
<a href="https://github.com/gnugat/symfony-empty">Symfony Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-framework-empty-edition &lt;path-to-install&gt;
</code></pre>

<p><em>Tip</em>: For the production server, use this command to install the project's
dependencies (the third party libraries):</p>

<pre><code>composer install --no-dev --optimize
</code></pre>

<h2 id="bundles">Bundles</h2>

<p>They integrate your code with the framework. More specifically, they configure
the Kernel's dependency injection container.</p>

<p><em>Note</em>: To learn more about Dependency Injection, have a look at the following
articles:</p>

<ul>
<li><a href="/2014/01/22/ioc-di-and-service-locator.html">Inversion of Control, Dependency Injection, Dependency Injection Container and Service Locator</a></li>
<li><a href="/2014/01/29/sf2-di-component-by-example.html">Symfony2 Dependency Injection component, by example</a></li>
</ul>

<p>The only bundle you'll need to create is the <code>ApplicationBundle</code>, where all your
code will be. Here's how to create a bundle:</p>

<ol>
<li>create its directory: <code>mkdir -p src/&lt;Vendor&gt;/&lt;Name&gt;Bundle</code></li>
<li>create its class: <code>$EDITOR src/&lt;Vendor&gt;/&lt;Name&gt;Bundle/&lt;Vendor&gt;&lt;Name&gt;Bundle.php</code></li>
<li>register it in the kernel: <code>$EDITOR app/AppKernel.php</code></li>
</ol>

<p>A Bundle class looks like this:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/KnightApplicationBundle.php

namespace Knight\ApplicationBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;

class KnightApplicationBundle extends Bundle
{
}
</code></pre>

<h2 id="application">Application</h2>

<p>In your application, there's only a few files related to the Symfony2 framework.
Here's the list of the ones you'll usually edit.</p>

<h3 id="the-application%27s-kernel">The application's kernel</h3>

<p>The <code>app/AppKernel.php</code> file is where the bundles are registered and where the
configuration is loaded. You'll only need to edit it when you install a new
bundle.</p>

<p>Here's how we would proceed: first install the bundle via Composer:</p>

<pre><code>composer require [--dev] &lt;vendor/name:version&gt;
</code></pre>

<p>Then register it in the application's kernel:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),

            // Add your bundles here!
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            $bundles[] = new Sensio\Bundle\DistributionBundle\SensioDistributionBundle();
            $bundles[] = new Sensio\Bundle\GeneratorBundle\SensioGeneratorBundle();

            // Or here, if you want it to only be available in dev or test environment
        }

        return $bundles;
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<h3 id="the-routing-configuration">The routing configuration</h3>

<p>The <code>app/config/routing.yml</code> file is where you will link a controller's action
to an URL. Here's an example:</p>

<pre><code># File: app/config/routing.yml
ni:
    path: /api/ni
    methods:
        - POST
    defaults:
        _controller: KnightApplicationBundle:Api:ni

question_to_cross_the_bridge:
    path: /api/question/{number}
    methods:
        - GET
    defaults:
        _controller: KnightApplicationBundle:Api:question
</code></pre>

<p>As you can see, you can tell the routing to use placeholders, which will be then
available in the controller via the Request object:</p>

<pre><code>$request-&gt;query-&gt;get('number'); // query is an instance of ParameterBag
</code></pre>

<h3 id="controllers%2C-your-entry-point">Controllers, your entry point</h3>

<p>Each route is associated to a controller's action.</p>

<p>A controller is a class located in <code>src/&lt;Vendor&gt;/ApplicationBundle/Controller</code>,
suffixed with <code>Controller</code>.</p>

<p>An action is a controller's public method, suffixed with <code>Action</code>, which takes
a <code>Request $request</code> parameter and must return an instance of the <code>Response</code>
object:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Controller/ApiController.php

namespace Knight\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class ApiController extends Controller
{
    public function niAction(Request $request)
    {
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);

        $answer = array('answer' =&gt; 'Ecky-ecky-ecky-ecky-pikang-zoop-boing-goodem-zoo-owli-zhiv');
        $statusCode = Response::HTTP_OK;
        if (!isset($postedValues['offering']) || 'shrubbery' !== $postedValues['offering']) {
            $answer['answer'] = 'Ni';
            $statusCode = Response::HTTP_UNPROCESSABLE_ENTITY;
        }

        return new JsonResponse($answer, $statusCode);
    }
}
</code></pre>

<p><em>Note</em>: you can create sub-directories in <code>src/&lt;Vendor&gt;/ApplicationBundle/Controller</code>,
allowing you to categorize your controllers. In the routing, this would look
like this: <code>KnightApplicationBundle:Subdirectory\Controller:action</code>.</p>

<h3 id="functional-tests">Functional tests</h3>

<p>Of course you can use any test framework with a Symfony2 project. PHPUnit is one
of them, and a popular one, so we'll use it for our examples.</p>

<p>Functional tests mirror the controllers and check if the status code is
successful. If you're building an API, you can check more precisely the status
code:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Tests/Controller/ApiControllerTest.php

namespace Knight\ApplicationBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class ApiControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), array(), $content);

        return $client-&gt;getResponse();
    }

    public function testOfferingTheRightThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'shrubbery'));

        $this-&gt;assertSame(Response::HTTP_OK , $response-&gt;getStatusCode());
    }

    public function testOfferingTheWrongThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'hareng'));

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY , $response-&gt;getStatusCode());
    }
}
</code></pre>

<p>The <code>WebTestCase</code> class is provided by the framework: it creates an application
(just like we do in <code>web/app.php</code>), so you can send requests and test the
response.</p>

<h3 id="where-to-put-your-own-code">Where to put your own code</h3>

<p>You can put your code anywhere in <code>src/&lt;Vendor&gt;/ApplicationBundle</code>.</p>

<p>Who said you needed to decouple your code from Symfony2? You can already write
decoupled code!</p>

<p>A convention is to create directories named after the type of objects it holds.
For example the <code>Controller</code> contains controller classes (which are suffixed
with <code>Controller</code>). You don't have to follow it though (except for controllers
and commands): use your best judgement!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Symfony2 gets out of your way, the only class from the framework we need to use
is the controller, the request and the response.</p>

<p>The workflow is really simple:</p>

<ol>
<li>Symfony2 converts the HTTP request into a <code>Request</code> object</li>
<li>the routing allows to execute a controller related to the current URL</li>
<li>the controller receives the <code>Request</code> object as a parameter and must return a
<code>Response</code> object</li>
<li>Symfony2 converts the <code>Response</code> object into the HTTP response</li>
</ol>

<h3 id="what-should-we-do-now%3F">What should we do now?</h3>

<p>Practice.</p>

<p>We now know the strict minimum about Symfony2, and the only way to learn more is
to practice, encounter new use cases, find answers in the
<a href="http://symfony.com/doc/current/index.html">documentation</a> and ask questions on
<a href="http://stackoverflow.com/questions/tagged/symfony2">StackOverflow</a> (if they
haven't been already asked).</p>

<p>If you really want to master Symfony2, then stay tuned: I'll start writing a new
series of articles!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - part 5: Tests]]></title>
            <link href="/2014/07/20/learn-sf2-tests-part-5.html"/>
            <updated>2014-07-20T00:00:00+01:00</updated>
            <id>/2014/07/20/learn-sf2-tests-part-5.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fifth article of the series on learning
<a href="http://symfony.com/">the Symfony2 framework</a>.
Have a look at the four first ones:</p>

<ol>
<li><a href="/2014/06/18/learn-sf2-composer-part-1.html">Composer</a></li>
<li><a href="/2014/06/25/learn-sf2-empty-app-part-2.html">Empty application</a></li>
<li><a href="/2014/07/02/learn-sf2-bundles-part-3.html">Bundles</a></li>
<li><a href="/2014/07/12/learn-sf2-controllers-part-4.html">Controllers</a></li>
</ol>

<p>In the previous articles we created an application for the Knight of Ni with the
following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   ├── config.yml
│   │   └── routing.yml
│   └── logs
│       └── .gitkeep
├── composer.json
├── composer.lock
├── src
│   └── Knight
│       └── ApplicationBundle
│           ├── Controller
│           │   └── ApiController.php
│           └── KnightApplicationBundle.php
├── .gitignore
└── web
    └── app.php
</code></pre>

<p>Running <code>composer install</code> should create a <code>vendor</code> directory, which we ignored
with git.</p>

<p>Here's the <a href="https://github.com/gnugat/learning-symfony2/tree/4-controllers">repository where you can find the actual code</a>.</p>

<p>In this article, we'll create functional tests using PHPUnit.</p>

<h2 id="installing-phpunit">Installing PHPUnit</h2>

<p><a href="http://phpunit.de/">PHPUnit</a> is a popular test framework.
Its name is deceptive: you can write any kind of test with it (unit, functional,
end to end, anything).</p>

<p>Let's install it in our project:</p>

<pre><code>composer require --dev "phpunit/phpunit:~4.1"
</code></pre>

<p>The <code>--dev</code> options will prevent Composer from installing PHPUnit when running
<code>composer install --no-dev</code>: this is use in production (download is costly).</p>

<p>We will need to create a configuration file to tell PHPUnit to execute the tests
found in <code>src/Knight/ApplicationBundle/Tests</code>, and to use Composer as an
autoloader:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- File: app/phpunit.xml.dist --&gt;

&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit
    backupGlobals="false"
    colors="true"
    syntaxCheck="false"
    bootstrap="../vendor/autoload.php"&gt;

    &lt;testsuites&gt;
        &lt;testsuite name="Functional Test Suite"&gt;
            &lt;directory&gt;../src/Knight/ApplicationBundle/Tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;

&lt;/phpunit&gt;
</code></pre>

<p><em>Note</em>: <a href="http://symfony.com/doc/current/cookbook/bundles/best_practices.html#directory-structure">By convention</a>
you should put your tests in <code>src/Knight/ApplicationBundle/Tests</code>. It's not hard
coded though, but if you want people to find things where they expect them to be
you better follow them ;) .</p>

<p>This file is suffixed with <code>.dist</code> because we intend to allow developer to
override the configuration by creating a <code>app/phpunit.xml</code> file. Only the
distribution file should be commited, though:</p>

<pre><code>echo '/app/phpunit.xml' &gt;&gt; .gitignore
git add -A
git commit -m 'Installed PHPUnit'
</code></pre>

<h2 id="environments">Environments</h2>

<p>For our functional tests, we will be using the <code>WebTestCase</code> class: it
instanciates our <code>AppKernel</code> with the <code>test</code> environment. It also uses a
<code>test.client</code> service, which is disabled by default.</p>

<p>In order to enable this service, we must change the configuration:</p>

<pre><code># File: app/config/config.yml
framework:
    secret: "Three can keep a secret, if two of them are dead."
    router:
        resource: %kernel.root_dir%/config/routing.yml

    # test: ~
</code></pre>

<p>Sometimes, you don't want your configuration to be the same for your tests and
your production server. That's what environments are for. Let's put this test
specific configuration in a different file:</p>

<pre><code># File: app/config/config_test.yml
imports:
    - { resource: config.yml }

framework:
    test: ~
</code></pre>

<p><em>Note</em>: the <code>imports</code> parameter allows you to include other configuration files.
You can then overwrite the included parameters, or add new ones.</p>

<p>We should also change the <code>registerContainerConfiguration</code> method of the
<code>AppKernel</code> class in order to load the test configuration, depending on the
environment:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Knight\ApplicationBundle\KnightApplicationBundle(),
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $file = 'config';
        if ('test' === $this-&gt;getEnvironment()) {
            $file .= '_test';
        }
        $loader-&gt;load(__DIR__."/config/$file.yml");
    }
}
</code></pre>

<p>Let's commit our work:</p>

<pre><code>git add -A
git commit -m 'Added test configuration'
</code></pre>

<h2 id="functional-tests">Functional tests</h2>

<p>Our test must check that the application behaves as expected. We won't be
checking that it actually fulfills our business expectations. This means that
checking the HTTP status code is entirely sufficient.</p>

<p>Let's create the directory:</p>

<pre><code>mkdir -p src/Knight/ApplicationBundle/Tests/Controller
</code></pre>

<p><em>Note</em>: Again, <a href="http://symfony.com/doc/current/book/testing.html#unit-tests">by convention</a>,
your test directory structure must mirror the one found in the bundle.</p>

<p>And then our first functional test:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Tests/Controller/ApiControllerTest.php

namespace Knight/ApplicationBundle/Tests/Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

class ApiControllerTest extends WebTestCase
{
    public function testOfferingTheRightThing()
    {
        $method = 'POST';
        $uri = '/api/ni';
        $parameters = array();
        $files = array();
        $server = array();
        $content = json_encode(array(
            'offering' =&gt; 'shrubbery',
        ));

        $client = static::createClient();
        $client-&gt;request($method, $uri, $parameters, $files, $server, $content);
        $response = $client-&gt;getResponse();

        $this-&gt;assertTrue($response-&gt;isSuccessful());
    }
}
</code></pre>

<p>To make sure the test pass, run the following command:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>Composer has installed a binary in <code>vendor/bin</code>, and the <code>-c</code> option allows you
to tell PHPUnit where the configuration is (in <code>./app</code>).</p>

<p>This looks a bit long because of the content parameter... We can improve this
with helper methods:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Tests/Controller/ApiControllerTest.php

namespace Knight/ApplicationBundle/Tests/Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

class ApiControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), array(), $content);

        return $client-&gt;getResponse();
    }

    public function testOfferingTheRightThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'shrubbery'));

        $this-&gt;assertTrue($response-&gt;isSuccessful());
    }
}
</code></pre>

<p>Make sure the test still pass:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>The Response's <code>isSuccessful</code> method only checks that the status code is 200ish.</p>

<p>Here's a test for failure cases:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Tests/Controller/ApiControllerTest.php

namespace Knight/ApplicationBundle/Tests/Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

class ApiControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), array(), $content);

        return $client-&gt;getResponse();
    }

    public function testOfferingTheRightThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'shrubbery'));

        $this-&gt;assertTrue($response-&gt;isSuccessful());
    }

    public function testOfferingTheWrongThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'hareng'));

        $this-&gt;assertFalse($response-&gt;isSuccessful());
    }
}
</code></pre>

<p>Run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p><em>Note</em>: At this point running the tests should become a habit. Make sure to run
them whenever you finish a change, and to run them before commiting anything.</p>

<h2 id="rest-api-functional-tests">Rest API functional tests</h2>

<p>In my humble opinion, checking if the status code is 200ish and not checking the
response content is entirely sufficient for functional tests.</p>

<p>When creating REST API, it can prove useful to test more precisely the status
code. Our application is a REST API, so let's do this:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Tests/Controller/ApiControllerTest.php

namespace Knight/ApplicationBundle/Tests/Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class ApiControllerTest extends WebTestCase
{
    private function post($uri, array $data)
    {
        $content = json_encode($data);
        $client = static::createClient();
        $client-&gt;request('POST', $uri, array(), array(), array(), $content);

        return $client-&gt;getResponse();
    }

    public function testOfferingTheRightThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'shrubbery'));

        $this-&gt;assertSame(Response::HTTP_OK , $response-&gt;getStatusCode());
    }

    public function testOfferingTheWrongThing()
    {
        $response = $this-&gt;post('/api/ni', array('offering' =&gt; 'hareng'));

        $this-&gt;assertSame(Response::HTTP_UNPROCESSABLE_ENTITY , $response-&gt;getStatusCode());
    }
}
</code></pre>

<p>Run the tests:</p>

<pre><code>./vendor/bin/phpunit -c app
</code></pre>

<p>All green! That's comforting enough for us to commit our work and call it a day!</p>

<pre><code>git add -A
git commit -m 'Added tests'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Running <code>./vendor/bin/phpunit -c app</code> is less cumbersome than having to run
manually HTTPie (like in the previous article)!</p>

<p>Writing functional tests is easy and quick, the only thing you need to do is
check if the HTTP response's status code is successful (and for REST API you
need to check the precise HTTP response's status code).</p>

<p>The next article will be the conclusion of this series, I hope you enjoyed it!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - part 4: Controllers]]></title>
            <link href="/2014/07/12/learn-sf2-controllers-part-4.html"/>
            <updated>2014-07-12T00:00:00+01:00</updated>
            <id>/2014/07/12/learn-sf2-controllers-part-4.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fourth article of the series on learning
<a href="http://symfony.com/">the Symfony2 framework</a>.
Have a look at the three first ones:</p>

<ol>
<li><a href="/2014/06/18/learn-sf2-composer-part-1.html">Composer</a></li>
<li><a href="/2014/06/25/learn-sf2-empty-app-part-2.html">Empty application</a></li>
<li><a href="/2014/07/02/learn-sf2-bundles-part-3.html">Bundles</a></li>
</ol>

<p>In the previous articles we created a one-bundled empty application with the
following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   └── config.yml
│   └── logs
│       └── .gitkeep
├── composer.json
├── composer.lock
├── src
│   └── Knight
│       └── ApplicationBundle
│           └── KnightApplicationBundle.php
├── .gitignore
└── web
    └── app.php
</code></pre>

<p>Running <code>composer install</code> should create a <code>vendor</code> directory, which we ignored
with git.</p>

<p>Here's the <a href="https://github.com/gnugat/learning-symfony2/releases/tag/3-bundles">repository where you can find the actual code</a>.</p>

<p>In this article, we'll learn more about the routing and the controllers.</p>

<h2 id="discovering-routing-and-controller">Discovering routing and controller</h2>

<p>In order to get familiar with the routing and controllers, we will create a
route which returns nothing. The first thing to do is to configure the router:</p>

<pre><code># File: app/config/app.yml
framework:
    secret: "Three can keep a secret, if two of them are dead."
    router:
        resource: %kernel.root_dir%/config/routing.yml
</code></pre>

<p>We can now write our routes in a separate file:</p>

<pre><code># File: app/config/routing.yml
what_john_snow_knows:
    path: /api/ygritte
    methods:
        - GET
    defaults:
        _controller: KnightApplicationBundle:Api:ygritte
</code></pre>

<p>As you can see, a route has:</p>

<ul>
<li>a name (<code>what_john_snow_knows</code>)</li>
<li>a path (<code>/api/ygritte</code>)</li>
<li>one or many HTTP verbs (<code>GET</code>)</li>
<li>a controller <code>Knight\ApplicationBundle\Controller\ApiController::ygritteAction()</code></li>
</ul>

<p><em>Note</em>: the <code>_controller</code> parameter is a shortcut composed of three parts, which
are the name of the bundle, then the unprefixed controller name and finally the
unprefixed method name.</p>

<p>Now we need to create the following directory:</p>

<pre><code>mkdir src/Knight/ApplicationBundle/Controller
</code></pre>

<p>And to create the controller class:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Controller/ApiController.php

namespace Knight\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class ApiController extends Controller
{
    public function ygritteAction(Request $request)
    {
        return new Response('', Response::HTTP_NO_CONTENT);
    }
}
</code></pre>

<p>To test it, I'd advise you to use a HTTP client. Let's install
<a href="http://httpie.org">HTTPie, the CLI HTTP client</a>:</p>

<pre><code>sudo apt-get install python-pip
sudo pip install --upgrade httpie
</code></pre>

<p>We can now test our webservice:</p>

<pre><code>http GET knight.local/api/ygritte
</code></pre>

<p>The first line should be <code>HTTP/1.1 204 No Content</code>.</p>

<h2 id="posting-data">Posting data</h2>

<p>Our scrum master and product owner managed to write a user story for us:</p>

<pre><code>As a Knight of Ni
I want a webservice which says "ni"
In order to get a shrubbery
</code></pre>

<p>This means we're going to need the following route:</p>

<pre><code># File: app/config/routing.yml
ni:
    path: /api/ni
    methods:
        - POST
    defaults:
        _controller: KnightApplicationBundle:Api:ni
</code></pre>

<p>Our controller will retrieve the posted value (named <code>offering</code>), check if it
is a <code>shrubbery</code> and send back a response containing either <code>Ni</code> (on error) or
<code>Ecky-ecky-ecky-ecky-pikang-zoop-boing-goodem-zoo-owli-zhiv</code> (on success):</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/Controller/ApiController.php

namespace Knight\ApplicationBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\JsonResponse;

class ApiController extends Controller
{
    public function niAction(Request $request)
    {
        $postedContent = $request-&gt;getContent();
        $postedValues = json_decode($postedContent, true);

        $answer = array('answer' =&gt; 'Ecky-ecky-ecky-ecky-pikang-zoop-boing-goodem-zoo-owli-zhiv');
        $statusCode = Response::HTTP_OK;
        if (!isset($postedValues['offering']) || 'shrubbery' !== $postedValues['offering']) {
            $answer['answer'] = 'Ni';
            $statusCode = Response::HTTP_UNPROCESSABLE_ENTITY;
        }

        return new JsonResponse($answer, $statusCode);
    }
}
</code></pre>

<p>The <code>JsonResponse</code> class will convert the array into JSON and set the proper
HTTP headers.</p>

<p>If we try to submit something fishy like this:</p>

<pre><code>http POST knight.local/api/ni offering=hareng
</code></pre>

<p>Then we should have a response similar to:</p>

<pre><code>HTTP/1.1 422 Unprocessable Entity
Cache-Control: no-cache
Content-Type: application/json
Date: Thu, 10 Jul 2014 15:23:00 GMT
Server: Apache
Transfer-Encoding: chunked

{
    "answer": "Ni"
}
</code></pre>

<p>And when we submit the correct offering:</p>

<pre><code>http POST knight.local/api/ni offering=shrubbery
</code></pre>

<p>Then we should have something similar to:</p>

<pre><code>HTTP/1.1 200 OK
Cache-Control: no-cache
Content-Type: application/json
Date: Thu, 10 Jul 2014 21:42:00 GMT
Server: Apache
Transfer-Encoding: chunked

{
    "answer": "Ecky-ecky-ecky-ecky-pikang-zoop-boing-goodem-zoo-owli-zhiv"
}
</code></pre>

<h2 id="request%27s-api">Request's API</h2>

<p>Here's part of the Request's API:</p>

<pre><code>&lt;?php

namespace Symfony\Component\HttpFoundation;

class Request
{
    public $request; // Request body parameters ($_POST)
    public $query; // Query string parameters ($_GET)
    public $files; // Uploaded files ($_FILES)
    public $cookies; // $_COOKIE
    public $headers; // Taken from $_SERVER

    public static function createFromGlobals():
    public static function create(
        $uri,
        $method = 'GET',
        $parameters = array(),
        $cookies = array(),
        $files = array(),
        $server = array(),
        $content = null
    );

    public function getContent($asResource = false);
}
</code></pre>

<p>We used <code>createFromGlobals</code> in our front controller (<code>web/app.php</code>), it does
excalty what it says: it initializes the Request from the PHP superglobals
(<code>$_POST</code>, <code>$_GET</code>, etc).</p>

<p>The <code>create</code> method is really handful in tests as we won't need to override the
values in PHP's superglobals.</p>

<p>The attributes here listed are all instances of
<code>Symfony\Component\HttpFoundation\ParameterBag</code>, which is like an object
oriented array with <code>set</code>, <code>has</code> and <code>get</code> methods (amongst others).</p>

<p>When you submit a form, your browser automatically sets the HTTP request's
header <code>Content-Type</code> to <code>application/x-www-form-urlencoded</code>, and the form
values are sent in the request's content like this:</p>

<pre><code>offering=hareng
</code></pre>

<p>PHP understands this and will put the values in the <code>$_POST</code> superglobal. This
mean you could retrieve it like this:</p>

<pre><code>$request-&gt;request-&gt;get('offering');
</code></pre>

<p>However, when we submit something in JSON with the <code>Content-Type</code> set to
<code>application/json</code>, PHP doesn't populate <code>$_POST</code>. You need to retrieve the raw
data with <code>getContent</code> and to convert it using <code>json_decode</code>, as we did in our
controller.</p>

<h2 id="response%27s-api">Response's API</h2>

<p>Here's a part of the Response's API:</p>

<pre><code>&lt;?php

namespace Symfony\Component\HttpFoundation;

class Response
{
    const HTTP_OK = 200;
    const HTTP_CREATED = 201;
    const HTTP_NO_CONTENT = 204;
    const HTTP_UNAUTHORIZED = 401;
    const HTTP_FORBIDDEN = 403;
    const HTTP_NOT_FOUND = 404;
    const HTTP_UNPROCESSABLE_ENTITY = 422; // RFC4918

    public $headers; // @var Symfony\Component\HttpFoundation\ResponseHeaderBag

    public function __construct($content = '', $status = 200, $headers = array())

    public function getContent();
    public function getStatusCode();

    public function isSuccessful();
}
</code></pre>

<p>There's a lot of HTTP status code constants, so I've selected only those I'd use
the most.</p>

<p>You can set and get the Response's headers via a public property which is also
a <code>ParameterBag</code>.</p>

<p>The constructor allows you to set the content, status code and headers.</p>

<p>The three other methods are mostly used in tests. There's a lot of <code>is</code> methods
to check the type of the request, but usually you'll just want to make sure the
response is successful.</p>

<p>You can find other types of responses:</p>

<ul>
<li><code>JsonResponse</code>: sets the <code>Content-Type</code> and converts the content into JSON</li>
<li><code>BinaryFileResponse</code>: sets headers and attaches a file to the response</li>
<li><code>RedirectResponse</code>: sets the target location for a redirection</li>
<li><code>StreamedResponse</code>: useful for streaming large files</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Symfony2 is an HTTP framework which primary's public API are the controllers:
those receive a Request as parameter and return a Response. All you have to do
is to create a controller, write some configuration in order to link
it to an URL and you're done!</p>

<p>Do not forget to commit your work:</p>

<pre><code>git add -A
git commit -m 'Created Ni route and controller'
</code></pre>

<p>The next article should be about tests: stay tuned!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - part 3: Bundles]]></title>
            <link href="/2014/07/02/learn-sf2-bundles-part-3.html"/>
            <updated>2014-07-02T00:00:00+01:00</updated>
            <id>/2014/07/02/learn-sf2-bundles-part-3.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the third article of the series on learning
<a href="http://symfony.com/">the Symfony2 framework</a>.
Have a look at the two first ones:</p>

<ul>
<li><a href="/2014/06/18/learn-sf2-composer-part-1.html">1: Composer</a></li>
<li><a href="/2014/06/25/learn-sf2-empty-app-part-2.html">2: Empty application</a></li>
</ul>

<p>In the previous articles we began to create an empty application with the
following files:</p>

<pre><code>.
├── app
│   ├── AppKernel.php
│   ├── cache
│   │   └── .gitkeep
│   ├── config
│   │   └── config.yml
│   └── logs
│       └── .gitkeep
├── composer.json
├── composer.lock
├── .gitignore
└── web
    └── app.php
</code></pre>

<p>Running <code>composer install</code> should create a <code>vendor</code> directory, which we ignored
with git.</p>

<p>Here's the <a href="https://github.com/gnugat/learning-symfony2/releases/tag/2-empty-application">repository where you can find the actual code</a>.</p>

<p>We'll now see what a bundle is.</p>

<h2 id="creating-the-application-bundle">Creating the application bundle</h2>

<p>We'll need some use case in order for our code snippets to make sense. So here
it is: the Knights Who Say 'Ni', demand a webservice! It shall say 'ni' if the
user do not appease it. To do so, the user should post a shrubbery!</p>

<p>Let's create our application bundle, in order to have a place where we can put
our code. To do so we need to create the directory:</p>

<pre><code>mkdir -p src/Knight/ApplicationBundle
</code></pre>

<p>Then the class extending <code>Symfony\Component\HttpKernel\Bundle\Bundle</code>:</p>

<pre><code>&lt;?php
// File: src/Knight/ApplicationBundle/KnightApplicationBundle.php

namespace Knight\ApplicationBundle;

use Symfony\Component\HttpKernel\Bundle\Bundle;

class KnightApplicationBundle extends Bundle
{
}
</code></pre>

<p>Finally we register the bundle into our application:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Knight\ApplicationBundle\KnightApplicationBundle(), // &lt;-- Here!
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config.yml');
    }
}
</code></pre>

<p>Let's commit our work:</p>

<pre><code>git add -A
git commit -m 'Created Application bundle'
</code></pre>

<h2 id="bundles-allow-you-to-extend-the-application%27s-dic">Bundles allow you to extend the application's DIC</h2>

<p>The <code>KnightApplicationBundle</code> class extends the following one:</p>

<pre><code>&lt;?php

namespace Symfony\Component\HttpKernel\Bundle;

use Symfony\Component\DependencyInjection\ContainerAware;
use Symfony\Component\Console\Application;

abstract class Bundle extends ContainerAware implements BundleInterface
{
    public function getContainerExtension();
    public function registerCommands(Application $application);
}
</code></pre>

<p><em>Note</em>: Only the part we're interested in is shown here.</p>

<p>Those two methods make the bundle capable of autodiscovering its commands and
its Dependency Injection Container's (DIC) extension, if the following directory
directory structure is used:</p>

<pre><code>.
├── Command
│   └── *Command.php
├── DependencyInjection
│   └── KnightApplicationExtension.php
└── KnightApplicationBundle.php
</code></pre>

<p><em>Note</em>: the only file required in a bundle is the <code>KnightApplicationBundle.php</code>
one.</p>

<p>The name of a bundle (in our example <code>KnightApplication</code>) is composed of:</p>

<ul>
<li>the vendor name (here our customer's name: <code>Knight</code>)</li>
<li>the actual bundle name (<code>Application</code>)</li>
</ul>

<p>For your own sake, choose a small one-word name for you vendor name and for your
bundle name (there's no hard rules but that's my advice).</p>

<p>The <code>KnightApplicationExtension</code> class allows you to manipulate the DIC (more
often you'll load a configuration file which can be located in
<code>Resources/config/services.xml</code>).</p>

<p>And that's precisely the purpose of bundles: registering services in the
application's DIC.</p>

<h3 id="side-note-about-dic-and-services">Side note about DIC and services</h3>

<p>Services and Dependency Injection isn't in the scope of this series. However if
you want to discover what it is all about, have a look at these two articles:</p>

<ul>
<li><a href="/2014/01/22/ioc-di-and-service-locator.html">Inversion of Control, Dependency Injection, Dependency Injection Container and Service Locator</a></li>
<li><a href="/2014/01/29/sf2-di-component-by-example.html">Symfony2 Dependency Injection component, by example</a></li>
</ul>

<p><em>Note</em>: this is a kindly reminder about the nature of Symfony2 Components. Those
are third party libraries which can be used on their own outside of the
framework.</p>

<h3 id="side-note-about-commands">Side note about commands</h3>

<p>The Symfony2 Console Component allows you to create CLI applications. This
application can have one or many commands. To learn more about them, have a look
at this article:</p>

<ul>
<li><a href="/2014/04/09/sf2-console-component-by-example.html">Symfony2 Console component, by example</a></li>
</ul>

<p><em>Note</em>: commands aren't in the scope of this article, but they're worth
mentioning.</p>

<h2 id="two-kinds-of-bundles">Two kinds of bundles</h2>

<p>There's two kinds of bundle:</p>

<ul>
<li>third party application integration ones (reusable, shared between
applications)</li>
<li>application's ones (non reusable and dedicated to your business model)</li>
</ul>

<p>Let's take the <a href="https://github.com/KnpLabs/snappy">KnpLabs snappy library</a>: it
allows you to generate a PDF from a HTML page and can be used in any
applications (non-symfony ones, and even framework-less ones).</p>

<p>The class allowing this generation is
<code>Knp\Bundle\SnappyBundle\Snappy\LoggableGenerator</code>: its construction is a bit
tiresome. To fix this, we can define its construction inside the DIC and
fortunately there's already a bundle doing it for us:
<a href="https://github.com/KnpLabs/KnpSnappyBundle">KnpSnappyBundle</a>.</p>

<p>That's a good example of the first kind of bundles.</p>

<p>Now about the second kind: in our Symfony2 application, we'll need to integrate
our own code to it, one day or another. We could go the long and painful way
(writing a lot of boilerplate code and configurations), or we could use a bundle
to do automatically the job for us!</p>

<p>Sometimes, we'll find applications which have many bundles in order to
categorize them into modules. This isn't necessary and it's a bit tiresome if
you ask me: we can simply create folders in a unique bundle to categorize our
modules.</p>

<p>The creation of many bundles necessitates some extra manual steps. It also makes
little sense as a bundle is supposed to be a decoupled unit: if we create a
UserBundle, FrontendBundle, BlogBundle and ForumBundle, we'll find ourselves
with bundles depending on one another, often with cyclic dependencies and we'll
waste time wondering where to put new classes (which can rely on 3 bundles).</p>

<p>My advice: create a single bundle for your application. If later on you find
that inside it you created a set of classes which makes sense in other projects
(Symfony2 and non-Symfon2 ones alike), then maybe you can extract them to
create a third party library. And then you might create a bundle to integrate
it inside Symfony2 applications.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Bundles are a way to extend the Dependency Injection Container: they're the glue
layer between your code and Symfony2 applications.</p>

<p>They follow conventions which aren't hard coded (you can override anything),
allowing them to autodiscover some convenient classes.</p>

<p>Thanks for reading, in the next article, we'll create controllers!</p>

<h3 id="resources">Resources</h3>

<p>Here's a good article about how reusable bundles should be created:</p>

<ul>
<li><a href="http://elnur.pro/use-only-infrastructural-bundles-in-symfony/">Use only infrastructural bundles in Symfony2, by Elnur Abdurrakhimov</a></li>
</ul>

<p>You don't like the conventions and you're ready to write a lot of boilerplate
code and configuration? Here you go (I'd not advise you to do so, though):</p>

<ul>
<li><a href="http://stackoverflow.com/questions/9999433/should-everything-really-be-a-bundle-in-symfony-2-x/10001019#10001019">Should everything really be a bundle in Symfony2?</a></li>
<li><a href="http://danielribeiro.org/blog/yes-you-can-have-low-coupling-in-a-symfony-standard-edition-application/">Yes, you can have low coupling in a Symfony2 application</a></li>
<li><a href="http://elnur.pro/symfony-without-bundles/">Symfony2 without bundles, by Elnur Abdurrakhimov, by Daniel Ribeiro</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2013/10/symfony2-some-things-i-dont-like-about-bundles/">Symfony2 some things I dont like about bundles, by Matthias Noback</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2013/10/symfony2-console-commands-as-services-why/">Symfony2 console commands as services why, by Matthias Noback</a></li>
<li><a href="http://www.slideshare.net/matthiasnoback/high-quality-symfony-bundles-tutorial-dutch-php-conference-2014">Naked bundles, slides by Matthias Noback</a></li>
</ul>

<p>I'm only putting these links because I like how they explain how Symfony2 works
behind the hood, but I wouldn't apply them in a real world application as it
makes too much fuss to no avail (that's my humble opinion anyway).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - part 2: Empty application]]></title>
            <link href="/2014/06/25/learn-sf2-empty-app-part-2.html"/>
            <updated>2014-06-25T00:00:00+01:00</updated>
            <id>/2014/06/25/learn-sf2-empty-app-part-2.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the second article of the series on learning
<a href="http://symfony.com/">the Symfony2 framework</a>.
Have a look at the first one: <a href="/2014/06/18/learn-sf2-composer-part-1.html">Composer</a>.</p>

<p>In the first article we began to create an empty project with the following
files:</p>

<pre><code>.
├── composer.json
├── composer.lock
└── .gitignore
</code></pre>

<p>Running <code>composer install</code> should create a <code>vendor</code> directory, which we ignored
in git.</p>

<p>Here's the <a href="https://github.com/gnugat/learning-symfony2/tree/1-composer">repository where you can find the actual code</a>.</p>

<p>We'll now see how to create an empty Symfony2 application.</p>

<h2 id="the-front-controller">The front controller</h2>

<p>First things first, we will create an index file which will act as a front
controller: it will be the only entry point of our application and will decide
which page to display.</p>

<p>Create its directory:</p>

<pre><code>mkdir web
</code></pre>

<p>Then the file:</p>

<pre><code>&lt;?php
// File: web/app.php

use Symfony\Component\HttpFoundation\Request;

require_once __DIR__.'/../vendor/autoload.php';
require_once __DIR__.'/../app/AppKernel.php';

$kernel = new AppKernel('prod', false);
$request = Request::createFromGlobals();
$response = $kernel-&gt;handle($request);
$response-&gt;send();
$kernel-&gt;terminate($request, $response);
</code></pre>

<p>First it includes Composer's autoloader: it will require every files needed.</p>

<p>Then we create an instance of our Kernel with the production environment and
the debug utilities disabled. This class acts like a web server: it takes a
HTTP request as input and returns a HTTP response as output.</p>

<p><code>Request::createFromGlobals()</code> creates a representation of the HTTP request.
It is filled from PHP's variable super globals (<code>$_GET</code>, <code>$_POST</code>, etc).</p>

<p>The kernel then handles the request. To keep explanations short, let's simply
say that it will find the controller associated to the requested URL. It is the
controller's responsibility to return a representation of the HTTP response (see
<code>Symfony\Component\HttpFoundation\Response</code>).</p>

<p>The <code>$response-&gt;send()</code> method will simply call the PHP <code>header</code> function and
print a string representing the response's body (usually HTML, JSON or anything
you want).</p>

<p>Finally the <code>$kernel-&gt;terminate()</code> method will call any tasks which registered
to the <code>kernel.terminate</code> event. This alows you to return a response as fast as
possible and then execute some actions like sending emails.</p>

<p><em>Note</em>: events aren't in the scope of this article, but they're worth
mentioning.</p>

<h2 id="creating-the-application%27s-kernel">Creating the application's kernel</h2>

<p><a href="http://symfony.com/doc/current/components/http_kernel/introduction.html">The HttpKernel component</a>
provides you with a <code>Kernel</code> class, which we will extend.</p>

<p>Create the following directory:</p>

<pre><code>mkdir app
</code></pre>

<p>And then the kernel file:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        return array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
        );
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config.yml');
    }
}
</code></pre>

<p>This class will load the project's configuration. This is also where you
register the project's bundles. We'll talk more about bundles in the next
article, for now the only thing you need to know is that they're like plugins.</p>

<p>The Kernel has the responsibility to look at every registered bundle to retrieve
their configuration.</p>

<p>The <code>FrameworkBundle</code> defines some services and allows you to choose what to
enable via configuration.</p>

<p><em>Note</em>: Services are objects which do one thing and do it well. They provide
exactly what they're called: a service. We'll learn more about them in one of
the next article.</p>

<p>We need to put some configuration in order to be able to make it work properly.</p>

<p>Create its directory:</p>

<pre><code>mkdir app/config
</code></pre>

<p>And the the YAML file:</p>

<pre><code># File: app/config/config.yml
framework:
    secret: "Three can keep a secret, if two of them are dead."
</code></pre>

<p>The <code>secret</code> parameter is used as a seed to generate random strings (for e.g.
CSRF tokens).</p>

<p>Now that we have our application structure, let's commit it:</p>

<pre><code>git add -A
git commit -m 'Created application structure'
</code></pre>

<h3 id="logs-and-cache">Logs and cache</h3>

<p>You'll also need to create <code>logs</code> and <code>cache</code> directories:</p>

<pre><code>mkdir app/{cache,logs}
touch app/{cache,logs}/.gitkeep
</code></pre>

<p>Git doesn't allow to commit empty directory, hence the <code>.gitkeep</code> files.</p>

<p>Because files in these directories are temporaries, we'll ignore them:</p>

<pre><code>echo '/app/cache/*' &gt;&gt; .gitignore
echo '/app/logs/*' &gt;&gt; .gitignore
git add -A
git add -f app/cache/.gitkeep
git add -f app/logs/.gitkeep
git commit -m 'Created temporary directories'
</code></pre>

<h3 id="apache-configuration">Apache configuration</h3>

<p>In order for your website to be browsed, you'll need to configure your web
server. This configuration is well explained
<a href="http://symfony.com/doc/current/cookbook/configuration/web_server_configuration.html">in the documentation</a>,
so here's a dump of an apache vhost:</p>

<pre><code>&lt;VirtualHost *:80&gt;
    ServerName knight.local

    DocumentRoot /home/loic.chardonnet/Projects/gnugat/knight/web

    ErrorLog "/home/loic.chardonnet/Projects/gnugat/knight/app/logs/apache_errors.log"
    CustomLog "/home/loic.chardonnet/Projects/gnugat/knight/app/logs/apache_accesses.log" common

    &lt;Directory /home/loic.chardonnet/Projects/gnugat/knight/web&gt;
        Options Indexes FollowSymLinks MultiViews
        AllowOverride None
        Order allow,deny
        allow from all
        &lt;IfModule mod_rewrite.c&gt;
            RewriteEngine On
            RewriteCond %{REQUEST_FILENAME} !-f
            RewriteRule ^(.*)$ /app.php [QSA,L]
        &lt;/IfModule&gt;
    &lt;/Directory&gt;
&lt;/VirtualHost&gt;
</code></pre>

<p>If you run into some permission problem (like writing in <code>cache</code> and <code>logs</code>),
you might consider to change <code>APACHE_RUN_USER</code> and <code>APACHE_RUN_GROUP</code>
environment variables present in <code>/etc/apache2/envvars</code> to your own user and
group.</p>

<h2 id="conclusion">Conclusion</h2>

<p>A Symfony2 application follows this pattern: a front controller associate an URL
to a controller which takes a HTTP request and returns a HTTP response.</p>

<p>The next article will be all about bundles, so stay tuned :) .</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Learn Symfony2 - part 1: Composer]]></title>
            <link href="/2014/06/18/learn-sf2-composer-part-1.html"/>
            <updated>2014-06-18T00:00:00+01:00</updated>
            <id>/2014/06/18/learn-sf2-composer-part-1.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>You don't know anything about the <a href="http://symfony.com/">Symfony2</a> framework,
and you'd like a quick guide to learn how to use it, and how it works?</p>

<p>Then this article is for you :) .</p>

<p>Don't get me wrong: one day or another you'll have to read the
<a href="http://symfony.com/doc/current/index.html">documentation</a>, and you'll have to
practice a lot in order to master it. But for now this guide should be a good
start for you.</p>

<p>In the first article of this series, you'll learn about
<a href="https://getcomposer.org/">Composer</a>, which helps you with third party library
installation and updates.</p>

<h2 id="creating-the-project">Creating the project</h2>

<p>In order to understand how Symfony2 works, we won't use the
<a href="http://symfony.com/distributions">Symfony Standard Edition</a>, but rather start
from scratch with the bare minimum.</p>

<p>Let's create our project:</p>

<pre><code>mkdir knight
cd knight
git init
</code></pre>

<h2 id="getting-composer">Getting Composer</h2>

<p>When developing a project the last thing you want is to waste your time
re-inventing the wheel, so you install third party libraries. Those libraries
have their own life cycle: they might release some bug fixes and new features
after you installed them, so you'll need to update them sometimes.</p>

<p><a href="https://getcomposer.org/">Composer</a> makes these things so easy you'll never
have to worry again about versions. First download it:</p>

<pre><code>curl -sS https://getcomposer.org/installer | php
sudo mv composer.phar /usr/local/bin/composer
</code></pre>

<p>And we're done! If only every project were so easy to install... :)</p>

<h2 id="installing-and-updating-symfony2">Installing and updating Symfony2</h2>

<p>Actually, Symfony2 is only a name regrouping many libraries which can be used
individually (you can even use them in other frameworks, CMS or projects like
<a href="http://symfony.com/projects/drupal">Drupal</a>,
<a href="http://symfony.com/projects/phpbb">phpBB</a>,
<a href="http://symfony.com/projects/laravel">Laravel</a>,
<a href="http://symfony.com/projects/ezpublish">eZ Publish</a>,
<a href="http://symfony.com/projects/orocrm">OroCRM</a> and
<a href="http://symfony.com/projects/piwik">Piwik</a> did).</p>

<p><em>Note</em>: Symfony2 libraries are called <code>components</code>.</p>

<p>Composer was made to install libraries, so let's use it:</p>

<pre><code>composer require 'symfony/symfony:~2.5' # install every single libraries in sf2
</code></pre>

<p>This command will do the following steps:</p>

<ol>
<li>create a <code>composer.json</code> configuration file if it doesn't already exist</li>
<li>add <code>symfony/symfony: ~2.5</code> in it (useful for further <code>composer install</code>)</li>
<li>actually download symfony inside the <code>vendor/symfony/symfony</code> directory</li>
<li>create a <code>composer.lock</code> file</li>
</ol>

<p>Later on, to update those dependencies you'll just have to run
<code>composer update</code>.</p>

<p><em>Note</em>: a library on which you depend upon is called a <code>dependency</code>.</p>

<p>This will look in the <code>composer.lock</code> file to know which version has been
installed (e.g. 2.5.0) and then checks if there's any new version available.
For more information about how Composer handles versions, see
<a href="https://igor.io/2013/01/07/composer-versioning.html">Igor's article</a>.</p>

<p>This means that you can totally ignore the <code>vendor</code> directory:</p>

<pre><code>echo '/vendor/*' &gt;&gt; .gitignore
</code></pre>

<p>If your team wants to install your project, they'll just have to clone your
repository and then run <code>composer install</code> which runs into the following steps:</p>

<ol>
<li>read the <code>composer.json</code> file to see the list of dependencies</li>
<li>read the <code>composer.lock</code> file to check the version installed by the commiter</li>
<li>download the dependencies with the version specified in the lock (even if new
ones are available)</li>
</ol>

<p>If a dependency is listed in <code>composer.json</code> but not in <code>composer.lock</code>,
Composer will download the last matching version and add it to the lock.</p>

<p>This means that everyone will have the same version installed! If you allow only
one person to run <code>composer update</code> you can guarantee this.</p>

<h2 id="autloading">Autloading</h2>

<p>Because Composer knows where each classes of the installed libraries are, it
provides a nice feature:
<a href="http://www.php.net/manual/en/language.oop5.autoload.php">autoloading</a>.</p>

<p>Simply put, each time a class is called, Composer will automatically include the
file where it's declared.</p>

<p>Your own code too can benefit from it. We just need to edit the <code>composer.json</code>
file:</p>

<pre><code>{
    "require": {
        "symfony/symfony": "~2.5"
    },
    "autoload": {
        "psr-4": {
            "": "src/"
        }
    }
}
</code></pre>

<p>And run the following command to take the changes into account:</p>

<pre><code>composer update
</code></pre>

<p>This tells Composer that we're going to follow the
<a href="http://www.php-fig.org/psr/psr-4/">PSR-4</a> standard and that we're going to put
our sources in the <code>src</code> directory.</p>

<p><em>Note</em>: PSR 4 requires you to:</p>

<ul>
<li>create one class per file</li>
<li>give the same name to your file and your class</li>
<li>use the path of the class for the namespace</li>
</ul>

<p>For example: the file <code>src/Knight/ApplicationBundle/KnightApplicationBundle.php</code>
contains a class named <code>KnightApplicationBundle</code> located in the namespace
<code>Knight\ApplicationBundle</code>.</p>

<p>Don't worry too much about it for now.</p>

<h2 id="conclusion">Conclusion</h2>

<p>And that's everything you need to know about Composer for now. Let's commit our
work:</p>

<pre><code>git add -A
git commit -m 'Installed Symfony2'
</code></pre>

<p>I hope this could help you, stay tuned for the next articles!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony2 Console component, by example]]></title>
            <link href="/2014/04/09/sf2-console-component-by-example.html"/>
            <updated>2014-04-09T00:00:00+01:00</updated>
            <id>/2014/04/09/sf2-console-component-by-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see
  <a href="/2016/03/02/ultimate-symfony-console.html">The Ultimate Developer Guide to Symfony - Console</a></p>
</blockquote>

<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p><a href="http://symfony.com/">Symfony2</a> is a set of libraries which help you in your
everyday tasks. You can even stack them together and create a framework with it:</p>

<ul>
<li><a href="https://github.com/symfony/symfony-standard">Symfony standard edition</a></li>
<li><a href="https://github.com/gnugat/symfony-empty">Symfony empty edition</a></li>
<li><a href="http://silex.sensiolabs.org/">Silex</a></li>
</ul>

<p>Many frameworks already use a lot of components from Symfony2:</p>

<ul>
<li><a href="http://laravel.com/">Laravel</a></li>
<li><a href="https://drupal.org/">Drupal</a></li>
<li><a href="http://ez.no/">eZ Publish</a></li>
<li><a href="http://phpunit.de/">PHPUnit</a></li>
<li><a href="https://www.phpbb.com/">phpBB</a></li>
<li><a href="https://getcomposer.org/">Composer</a></li>
</ul>

<p>In this article, we'll see the
<a href="http://symfony.com/doc/master/components/console/introduction.html">Console Component</a>,
which allows you to build Command Line Interface (CLI) applications. Symfony 2.5
will be released in may 2014, with great new features for the Console, so I'll
speak about this version here.</p>

<ul>
<li><a href="#introduction">Introduction</a>

<ul>
<li><a href="#application">Application</a></li>
<li><a href="#command">Command</a></li>
<li><a href="#input">Input</a></li>
<li><a href="#output">Output</a></li>
<li><a href="#consolelogger">ConsoleLogger</a></li>
</ul></li>
<li><a href="#standalone-example">Standalone example</a>

<ul>
<li><a href="#creating-the-application">Creating the application</a></li>
<li><a href="#creating-the-command">Creating the command</a></li>
<li><a href="#registering-the-command">Registering the command</a></li>
<li><a href="#using-the-filesystem-component">Using the Filesystem component</a></li>
<li><a href="#thin-controller-many-small-services">Thin controller, many small services</a></li>
<li><a href="#registering-the-services">Registering the services</a></li>
</ul></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>This component allows you to focus on one thing: creating commands. It takes
care of all the coloring output, input gathering and command containing stuff.</p>

<p>The big picture is: you have an <code>Application</code> which contains a set of
<code>Command</code>s. When ran, the <code>Application</code> will create an <code>Input</code> object which
contains <code>Option</code>s and <code>Argument</code>s provided by the user, and will feed it to
the right <code>Command</code>.</p>

<p>The code being the best documentation, we'll now see the strict minimum classes
you should know, with the methods you'll likely use.</p>

<h3 id="application">Application</h3>

<p>All you need to know about the <code>Application</code> is this:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class Application
{
    public function __construct($name = 'UNKNOWN', $version = 'UNKNOWN');
    public function add(Command $command);
    public function setDefaultCommand($commandName); // New in 2.5!
    public function run(InputInterface $input = null, OutputInterface $output = null);
}
</code></pre>

<p>Minimum usage:</p>

<pre><code>#!/usr/bin/env php
&lt;?php

use Symfony\Component\Console\Application;

$application = new Application();
$application-&gt;run();
</code></pre>

<p>By running this script, you should be able to see a colorful output which lists
the available commands (<code>list</code> is the default command, and a <code>help</code> is also
available).</p>

<h3 id="command">Command</h3>

<p>The <code>Command</code> class is the controller of your CLI application:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Command;

use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;

class Command
{
    protected function configure();
    protected function execute(InputInterface $input, OutputInterface $output);
    protected function interact(InputInterface $input, OutputInterface $output);

    // To be called in configure
    public function setName($name);
    public function addArgument($name, $mode = null, $description = '', $default = null);
    public function addOption($name, $shortcut = null, $mode = null, $description = '', $default = null);
    public function setDescription($description);
    public function setHelp($help);
    public function setAliases($aliases);
}
</code></pre>

<p>Basically you create a class which extends <code>Command</code>. You need to implement 2
methods:</p>

<ul>
<li><code>configure</code>: the configuration of the command's name, arguments, options, etc</li>
<li><code>execute</code>: where you process the input, call your services and write to the
output</li>
</ul>

<p>The <code>interact</code> method is called before the <code>execute</code> one: it allows you to ask
questions to the user to set more input arguments and options.</p>

<p>Here's my stand on arguments and options modes:</p>

<ul>
<li>an argument should always be required (<code>InputArgument::REQUIRED</code>)</li>
<li>a flag is an option without value (<code>InputOption::VALUE_NONE</code>)</li>
<li>an option should always have a required value (<code>InputOption::VALUE_REQUIRED</code>),
don't forget to provide a default one</li>
</ul>

<h3 id="input">Input</h3>

<p>The container of the arguments and options given by the user:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Input;

interface InputInterface
{
    public function getArgument($name);
    public function getOption($name);
}
</code></pre>

<p>The <code>Application</code> validates a part of the input: it checks if the command
actually accepts the given arguments and options (is the value required? Does
the <code>hello:world</code> command have a <code>--yell</code> option? etc), but you still need to
validate the input against your business rules (the <code>--number</code> option should
be an integer, the <code>name</code> argument should be escaped to avoid SQL injection,
etc).</p>

<h3 id="output">Output</h3>

<p>A convenient object which allows you to write on the console output:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Output;

abstract class Output implements OutputInterface
{
    public function writeln($messages, $type = self::OUTPUT_NORMAL);
}
</code></pre>

<p>The <code>writeln</code> method allows you to write a new line (with a newline character at
the end). If the given <code>message</code> is an array, it will print each elements on a
new line.</p>

<p>The tags allow you to color some parts:</p>

<ul>
<li>green text for informative messages (usage example: <code>&lt;info&gt;foo&lt;/info&gt;</code>)</li>
<li>yellow text for comments (usage example: <code>&lt;comment&gt;foo&lt;/comment&gt;</code>)</li>
<li>black text on a cyan background for questions (usage example: <code>&lt;question&gt;foo&lt;/question&gt;</code>)</li>
<li>white text on a red background for errors (usage example: <code>&lt;error&gt;foo&lt;/error&gt;</code>)</li>
</ul>

<h3 id="consolelogger">ConsoleLogger</h3>

<p>Another brand new class from the version 2.5:</p>

<pre><code>&lt;?php

namespace Symfony\Component\Console\Logger;

use Psr\Log\AbstractLogger;
use Symfony\Component\Console\Output\OutputInterface;

class ConsoleLogger extends AbstractLogger
{
    public function __construct(
        OutputInterface $output,
        array $verbosityLevelMap = array(),
        array $formatLevelMap = array()
    );

    public function log($level, $message, array $context = array());
}
</code></pre>

<p>As you can see, it uses the <code>OutputInterface</code> provided by the <code>Application</code>.
You should inject this logger into your services, this will allow them to write
messages on the standard output of the console while keeping them decoupled from
this component (so you can use these services in a web environment).</p>

<p>Oh, and the good news is: it colors the output and decides whether or not to
print it depending on the verbosity and level of log! An error message would
always be printed in red, an informative message would be printed in green if
you pass the <code>-vv</code> option.</p>

<h2 id="standalone-example">Standalone example</h2>

<p>Just like any other component, the Console can be used as a standalone library.</p>

<p>In this example, we'll create a tool which will create a <code>LICENSE</code> file, just
like <a href="https://github.com/gnugat/fossil">fossil</a> (the <a href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html">bootstraper of markdown files for your FOSS projetcs</a>).</p>

<h3 id="creating-the-application">Creating the application</h3>

<p>To begin, let's install the component using <a href="https://getcomposer.org/">Composer</a>:</p>

<pre><code>$ curl -sS https://getcomposer.org/installer | php # Downloading composer
$ ./composer.phar require "symfony/console:~2.5@dev"
</code></pre>

<p>Then create an empty application:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

require __DIR__.'/vendor/autoload.php';

use Symfony\Component\Console\Application;

$application = new Application('Fossil', '2.0.0');
$application-&gt;run();
</code></pre>

<h3 id="creating-the-command">Creating the command</h3>

<p>Our command has two arguments:</p>

<ul>
<li>the name for the copyright</li>
<li>the year for the copyright</li>
</ul>

<p>It can also take the path of the project as an option (we'll provide the
current directory as default value).</p>

<p>Let's create it:</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class LicenseCommand extends Command
{
    protected function configure()
    {
        $this-&gt;setName('license');
        $this-&gt;setDescription('Bootstraps the license file of your project');

        $this-&gt;addArgument('author', InputArgument::REQUIRED);
        $this-&gt;addArgument('year', InputArgument::REQUIRED);

        $this-&gt;addOption('path', 'p', InputOption::VALUE_REQUIRED, '', getcwd());
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
    }
}
</code></pre>

<h3 id="registering-the-command">Registering the command</h3>

<p>Our command doesn't do anything yet, but we can already register it in our
application:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

require __DIR__.'/vendor/autoload.php';

use Symfony\Component\Console\Application;
use Gnugat\Fossil\LicenseCommand;

$command = new LicenseCommand();

$application = new Application('Fossil', '2.0.0');
$application-&gt;add($command);
$application-&gt;run();
</code></pre>

<p>In order for it to run, you'll need to register the namespace in the autoloader
by editing the <code>composer.json</code> file at the root of the project:</p>

<pre><code>{
    "require": {
        "symfony/console": "~2.5@dev"
    },
    "autoload": {
        "psr-4": { "": "src" }
    }
}
</code></pre>

<p>Then you need to run <code>./composer.phar update</code> to update the configuration.</p>

<h3 id="using-the-filesystem-component">Using the Filesystem component</h3>

<p>In <code>fossil</code>, <a href="https://github.com/gnugat/fossil/tree/master/skeletons">templates</a>
are retrieved using the
<a href="http://symfony.com/doc/current/components/finder.html">Finder component</a>, their
values are replaced using <a href="http://twig.sensiolabs.org/">Twig</a> and written using the
<a href="http://symfony.com/doc/current/components/filesystem.html">Filesystem component</a>.</p>

<p>In order to keep this article short, we'll:</p>

<ul>
<li>use a fictive license which requires only the copyright line</li>
<li>simply store the <code>LICENSE</code> template in the command</li>
<li>inject the values using <code>implode</code></li>
</ul>

<p>This means that you have to install the new component:</p>

<pre><code>$ ./composer.phar require "symfony/filesystem:~2.4"
</code></pre>

<p>And then you need to fill the <code>execute</code> method:</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;

class LicenseCommand extends Command
{
    // configure method...

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $filesystem = new Filesystem();
        $filesystem-&gt;dumpFile($path, $license.PHP_EOL);

        $output-&gt;writeln(sprintf('Created the file %s', $path));
    }
}
</code></pre>

<p>Now running <code>./fossil license "Loïc Chardonnet" "2013-2014" -p="/tmp"</code> will
output the message "Created the file /tmp/LICENSE", which should be what really
happened.</p>

<h3 id="thin-controller%2C-many-small-services">Thin controller, many small services</h3>

<p>I'm not a big fan of putting logic in my commands, so generally I use services
to do the actual job:</p>

<pre><code>&lt;?php
// File src/Gnugat/Fossil/DocumentationWriter.php

namespace Gnugat\Fossil;

use Symfony\Component\Filesystem\Filesystem;
use Psr\Log\LoggerInterface;

class DocumentationWriter
{
    private $filesystem;
    private $logger;

    public function __construct(Filesystem $filesystem, LoggerInterface $logger)
    {
        $this-&gt;filesystem = $filesystem;
        $this-&gt;logger = $logger;
    }

    public function write($path, $content)
    {
        $this-&gt;filesystem-&gt;dumpFile($path, $content);
        $this-&gt;logger-&gt;notice(sprintf('Created file %s', $path));
    }
}
</code></pre>

<p>As you can see, the <code>DocumentationWriter</code> isn't very big. It might seem
overkill, but now it's easy to write tests which will check if the <code>LICENSE</code>
file has been created. Also, in <code>fossil</code> the class does a bit more work: it
checks if the file already exists, and takes a "force overwrite" option into
account.</p>

<p>You'll also notice that we inject a logger to notice the user of what happens.
We need to install the PSR-3 logger interface:</p>

<pre><code>$ composer require "psr/log:~1.0"
</code></pre>

<p>Our command will now be much thinner, just like any controller should be (MVC
can also be applied in CLI):</p>

<pre><code>&lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Gnugat\Fossil\DocumentationWriter;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Logger\ConsoleLogger;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;

class LicenseCommand extends Command
{
    // configure method...

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $filesystem = new Filesystem();
        $logger = new ConsoleLogger($output);
        $documentationWriter = new DocumentationWriter($filesystem, $logger);

        $documentationWriter-&gt;write($path, $license.PHP_EOL);
    }
}
</code></pre>

<p>To be fair, our command is longer. But it <strong>is</strong> thinner as it now has less
responsibilities:</p>

<ul>
<li>it retrieves the input</li>
<li>creates the dependencies</li>
<li>calls the services</li>
</ul>

<p>If you run again <code>./fossil license "Loïc Chardonnet" "2013-2014" -p="/tmp"</code>,
you won't see anything: <code>ConsoleLogger</code> hides informative messages by default.
You need to pass the verbose option to see the message:</p>

<pre><code>$ ./fossil license -v "Loïc Chardonnet" "2013-2014" -p="/tmp"
</code></pre>

<h3 id="registering-the-services">Registering the services</h3>

<p>The dependency creation isn't a responsibility a controller should have. We'll
delegate this to the
<a href="http://symfony.com/doc/current/components/dependency_injection/introduction.html">Dependency Injection component</a>:</p>

<pre><code>$ ./composer.phar require "symfony/dependency-injection:~2.4"
</code></pre>

<p>We'll also install the
<a href="http://symfony.com/doc/current/components/config/introduction.html">Config component</a>:</p>

<pre><code>$ ./composer.phar require "symfony/config:~2.4"
</code></pre>

<p>If you don't know yet this component, go read
<a href="/2014/01/29/sf2-di-component-by-example.html">this helpful article</a>.</p>

<p>We'll create a XML file to configure the registration of our services:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: config/services.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="symfony.application"
            class="Symfony\Component\Console\Application"&gt;
            &lt;argument key="name"&gt;Fossil&lt;/argument&gt;
            &lt;argument key="version"&gt;2.0.0&lt;/argument&gt;
            &lt;call method="add"&gt;
                 &lt;argument type="service" id="fossil.license_command" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="fossil.license_command" class="Gnugat\Fossil\LicenseCommand"&gt;
            &lt;argument type="service" id="fossil.documentation_writer" /&gt;
        &lt;/service&gt;

        &lt;service id="fossil.documentation_writer" class="Gnugat\Fossil\DocumentationWriter"&gt;
            &lt;argument type="service" id="symfony.filesystem" /&gt;
            &lt;argument type="service" id="symfony.console_logger" /&gt;
        &lt;/service&gt;

        &lt;service id="symfony.filesystem" class="Symfony\Component\Filesystem\Filesystem"&gt;
        &lt;/service&gt;

        &lt;service id="symfony.console_logger" class="Symfony\Component\Console\Logger\ConsoleLogger"&gt;
            &lt;argument type="service" id="symfony.console_output" /&gt;
        &lt;/service&gt;

        &lt;service id="symfony.console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>As you can see, I've delegated <strong>every</strong> construction to the DIC (Dependency
Injection Container), even the construction of the application. Now the command
looks like this:</p>

<pre><code>    &lt;?php
// File: src/Gnugat/Fossil/LicenseCommand.php

namespace Gnugat\Fossil;

use Gnugat\Fossil\DocumentationWriter;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class LicenseCommand extends Command
{
    private $documentationWriter;

    public function __construct(DocumentationWriter $documentationWriter)
    {
        $this-&gt;documentationWriter = $documentationWriter;

        parent::__construct();
    }

    protected function configure()
    {
        $this-&gt;setName('license');
        $this-&gt;setDescription('Bootstraps the license file of your project');

        $this-&gt;addArgument('author', InputArgument::REQUIRED);
        $this-&gt;addArgument('year', InputArgument::REQUIRED);

        $this-&gt;addOption('path', 'p', InputOption::VALUE_REQUIRED, '', getcwd());
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $path = $input-&gt;getOption('path').'/LICENSE';
        $license = implode(' ', array(
            'Copyright (c)',
            $input-&gt;getArgument('author'),
            $input-&gt;getArgument('year'),
        ));

        $this-&gt;documentationWriter-&gt;write($path, $license.PHP_EOL);
    }
}
</code></pre>

<p>And the console now contains the DIC initialization:</p>

<pre><code>#!/usr/bin/env php
&lt;?php
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

require __DIR__.'/vendor/autoload.php';

$container = new ContainerBuilder();
$loader = new XmlFileLoader($container, new FileLocator(__DIR__.'/config'));
$loader-&gt;load('services.xml');

$output = $container-&gt;get('symfony.console_output');

$application = $container-&gt;get('symfony.application');
$application-&gt;run(null, $output);
</code></pre>

<p>And voilà! You now know how to create CLI applications :) .</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Console component allows you to create CLI applications. The commands are a
thin layer which gathers the input and call services. Those services can then
output messages to the user using a special kind of logger.</p>

<p>Although this article was a bit long, I might have missed something here, so
if you have any feedbacks/questions, be sure to contact me on
<a href="https://twitter.com/epiloic">Twitter</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony2 Dependency Injection component, by example]]></title>
            <link href="/2014/01/29/sf2-di-component-by-example.html"/>
            <updated>2014-01-29T00:00:00+00:00</updated>
            <id>/2014/01/29/sf2-di-component-by-example.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see
  <a href="/2016/02/24/ultimate-symfony-dependency-injection.html">The Ultimate Developer Guide to Symfony - Dependency Injection</a></p>
</blockquote>

<p>In <a href="/2014/01/22/ioc-di-and-service-locator.html">the previous article</a>
we've seen among other things the definition of Dependency Injection (DI) and of
the Dependency Injection Container (DIC).</p>

<p>In this article we'll see the Symfony2's DI component which provides a powerful
DIC. Here's the summary:</p>

<ul>
<li>putting the construction of your services into configuration</li>
<li>how to use it to wire your application</li>
</ul>

<p>You don't use Symfony2? Don't worry, this article is all about using this
component as a standalone library (you can use it in your
CakePHP/Zend/Home-made-framework application).</p>

<h2 id="construction-configuration">Construction configuration</h2>

<p>DI is all about passing arguments to the constructor of an object. Because
constructing all those object might become a burden, the DIC is here to
take this responsibility and centralize it.</p>

<p>Let's replace <a href="http://pimple.sensiolabs.org/">Pimple</a> by
<a href="http://symfony.com/doc/current/components/dependency_injection/index.html">Symfony2 DI component</a>
in the code sample from the previous article:</p>

<pre><code>&lt;?php

use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\DependencyInjection\ContainerBuilder;

$container = new ContainerBuilder();

// This is a parameter definition
$container-&gt;setParameter('verbosity_level_map', array(
    OutputInterface::VERBOSITY_NORMAL =&gt; Logger::NOTICE,
    OutputInterface::VERBOSITY_VERBOSE =&gt; Logger::INFO,
    OutputInterface::VERBOSITY_VERY_VERBOSE =&gt; Logger::DEBUG,
    OutputInterface::VERBOSITY_DEBUG =&gt; Logger::DEBUG,
);

// register takes the service name, and then its fully qualified classname as a string
$container-&gt;register(
    'console_output',
    'Symfony\Component\Console\Output\ConsoleOutput'
);
$container-&gt;register(
    'output_formatter',
    'Gnugat\Fossil\ApplicationLayer\OutputFormatter'
);

// You can inject:
// * dependencies which have been declared previously
// * arguments
// * parameters which have been declared previously
// * setter dependencies
$container
    -&gt;register('console_handler', 'Symfony\Bridge\Monolog\Handler\ConsoleHandler')
    -&gt;addArgument(new Reference('console_output'))
    -&gt;addArgument(true)
    -&gt;addArgument('%verbosity_level_map%')
    -&gt;addMethodCall('setFormatter', array(new Reference('output_formatter')));
;

$container
    -&gt;register('logger', 'Monolog\Logger')
    -&gt;addArgument('default.logger')
    -&gt;addMethodCall('pushHandler', array(new Reference('console_handler')));
;

$container-&gt;register('filesystem', 'Symfony\Component\Filesystem\Filesystem');

$container
    -&gt;register('documentation_writer', 'Gnugat\Fossil\MarkdownFile\DocumentationWriter')
    -&gt;addArgument(new Reference('filesystem'))
    -&gt;addArgument(new Reference('logger'))
;
</code></pre>

<p>If you think about it, the construction of objects is a configuration thing:
you need to define for each object their dependencies. Symfony2's DI component
allows you to put all those definition inside a configuration file:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;
&lt;!-- File: dic_config.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;parameters&gt;
        &lt;parameter key="verbosity_Level_map" type="collection"&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_NORMAL"&gt;Monolog\Logger::NOTICE&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_VERBOSE"&gt;Monolog\Logger::INFO&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_VERY_VERBOSE"&gt;Monolog\Logger::DEBUG&lt;/parameter&gt;
            &lt;parameter key="Symfony\Component\Console\Output\OutputInterface::VERBOSITY_DEBUG"&gt;Monolog\Logger::DEBUG&lt;/parameter&gt;
        &lt;/parameter&gt;
    &lt;/parameters&gt;

    &lt;services&gt;
        &lt;service id="console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;

        &lt;service id="output_formatter"
            class="Gnugat\Fossil\ApplicationLayer\OutputFormatter"&gt;
        &lt;/service&gt;

        &lt;service id="console_handler"
            class="Symfony\Bridge\Monolog\Handler\ConsoleHandler"&gt;
            &lt;argument type="service" id="console.output" /&gt;
            &lt;argument key="bubble"&gt;true&lt;/argument&gt;
            &lt;argument&gt;%verbosity_Level_map%&lt;/argument&gt;
            &lt;call method="setFormatter"&gt;
                 &lt;argument type="service" id="output_formatter" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="logger" class="Monolog\Logger"&gt;
            &lt;argument&gt;default.logger&lt;/argument&gt;
            &lt;call method="pushHandler"&gt;
                 &lt;argument type="service" id="console_handler" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="filesystem"
            class="Symfony\Component\Filesystem\Filesystem"&gt;
        &lt;/service&gt;

        &lt;service id="documentation_writer"
            class="Gnugat\Fossil\MarkdownFile\DocumentationWriter"&gt;
            &lt;argument type="service" id="filesystem" /&gt;
            &lt;argument type="service" id="logger" /&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>And here's the code sample allowing you to feed the DIC with this configuration:</p>

<pre><code>&lt;?php

// File: front_controller.php

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$documentationWriter = $container-&gt;get('documentation_writer');
$documentationWriter-&gt;write('/tmp/example.txt', 'Hello world');
</code></pre>

<p>The construction of our objects has been completely removed from the code and
has been put into a configuration file. Actually, we've replaced object
constructions by container initialization, which is way more concise.</p>

<h3 id="configuration-format">Configuration format</h3>

<p>The Symfony2's DI component <a href="http://symfony.com/doc/current/components/dependency_injection/configurators.html">allows many configuration formats</a>:</p>

<ul>
<li>plain PHP (like in our first code sample)</li>
<li>XML (like in our second code sample)</li>
<li><a href="http://www.yaml.org/">YAML</a></li>
</ul>

<p>I wouldn't advise you to use YAML format, as it needs to introduce
<a href="http://symfony.com/doc/current/components/dependency_injection/parameters.html#yaml">special formating in order to support advanced options</a>
like:</p>

<ul>
<li>prefixing services ID's with <code>@</code></li>
<li>prefixing services ID's which aren't mandatory with <code>@?</code></li>
<li>prefixing <code>@</code> with <code>@</code> in order to escape them</li>
<li><a href="http://symfony.com/doc/current/book/service_container.html#using-the-expression-language">prefixing expressions with <code>@=</code></a></li>
</ul>

<p>Not to mention the fact that it doesn't support every options (for instance
<a href="http://symfony.com/doc/current/components/dependency_injection/parameters.html#constants-as-parameters">you cannot declare constants as parameters</a>)</p>

<p>On the other hand, the only thing XML doesn't support is concatenation:</p>

<pre><code>&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;

$container = new ContainerBuilder();
// Needs to be done in plain PHP
$container-&gt;setParameter('skeletons_path', __DIR__.'/skeletons');
</code></pre>

<p>XML can be easily validated and it also can be read by many software like IDE's
which can use it in order to provide you with blissful autocompletion.</p>

<p>If you're concerned about performances (reading XML might be slower than
requiring directly plain PHP), Symfony2's DI component allows you to convert it
into plain PHP and dump it into a cache file which you can then include in
your application: <a href="http://symfony.com/doc/current/components/dependency_injection/compilation.html#dumping-the-configuration-for-performance">take a look at the documentation</a>.</p>

<h2 id="wiring-your-application">Wiring your application</h2>

<p>There's a fantastic conclusion we can deduce from the above section: we can
reduce the lines of codes of our projects simply by extracting object
construction and putting it into configuration files.</p>

<p>Object construction is part of the "wiring layer" of your application: it
doesn't solve your "business problem", nor does it solve your
"application problem". It simply is the boilerplate code necessary to write
those.</p>

<p>Let's explore the impact of wiring your application using Symfony2's DI
component. You might not have noticed it, but the code samples used in the
previous article as well as in this one all come from <a href="https://github.com/gnugat/fossil">fossil</a>,
a command which allows you to bootstrap markdown files of your projects
(<a href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html">cf this article</a>).
It uses Symfony2's Console component which requires some boilerplate code in
order to create the application:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Gnugat\Fossil\DocCommand;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\Console\Application;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$documentationWriter = $container-&gt;get('documentation_writer');

$docCommand = new DocCommand($documentationWriter);

$application = new Application('Fossil', '2.0.0');
$application-&gt;add($docCommand);

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>Can you imagine what this front controller can become if we were to add more
commands? You'd rather not? Me neither, that's why I advise you to put all this
boilerplate code into a configuration file:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: dic_config.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;services&gt;
        &lt;service id="console_output"
            class="Symfony\Component\Console\Output\ConsoleOutput"&gt;
        &lt;/service&gt;

        &lt;service id="output_formatter"
            class="Gnugat\Fossil\ApplicationLayer\OutputFormatter"
        &lt;/service&gt;

        &lt;service id="console_handler"
            class="Symfony\Bridge\Monolog\Handler\ConsoleHandler"
            &lt;argument type="service" id="console.output" /&gt;
            &lt;argument key="bubble"&gt;true&lt;/argument&gt;
            &lt;argument&gt;%verbosity_Level_map%&lt;/argument&gt;
            &lt;call method="setFormatter"&gt;
                 &lt;argument type="service" id="output_formatter" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="logger" class="Monolog\Logger"&gt;
            &lt;argument&gt;default.logger&lt;/argument&gt;
            &lt;call method="pushHandler"&gt;
                 &lt;argument type="service" id="console_handler" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;

        &lt;service id="filesystem"
            class="Symfony\Component\Filesystem\Filesystem"
        &lt;/service&gt;

        &lt;service id="documentation_writer"
            class="Gnugat\Fossil\MarkdownFile\DocumentationWriter"
            &lt;argument type="service" id="filesystem" /&gt;
            &lt;argument type="service" id="logger" /&gt;
        &lt;/service&gt;

        &lt;service id="doc_command" class="Gnugat\Fossil\DocCommand"&gt;
            &lt;argument type="service" id="documentation_writer" /&gt;
        &lt;/service&gt;

        &lt;service id="application"
            class="Symfony\Component\Console\Application"&gt;
            &lt;argument key="name"&gt;Fossil&lt;/argument&gt;
            &lt;argument key="version"&gt;2.0.0&lt;/argument&gt;
            &lt;call method="add"&gt;
                 &lt;argument type="service" id="doc_command" /&gt;
            &lt;/call&gt;
        &lt;/service&gt;
    &lt;/services&gt;
&lt;/container&gt;
</code></pre>

<p>Which allows us to reduce our front controller:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__);

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic_config.xml');

$application = $container-&gt;get('application');

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>Now our concern is the size of the <code>dic_config.xml</code> file which will keep growing
each time we create new services. Don't panic! You can split it into many files
using the <code>imports</code> tag:</p>

<pre><code>&lt;?xml version="1.0" ?&gt;

&lt;!-- File: config/dic.xml --&gt;

&lt;container xmlns="http://symfony.com/schema/dic/services"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://symfony.com/schema/dic/services http://symfony.com/schema/dic/services/services-1.0.xsd"&gt;
    &lt;imports&gt;
        &lt;import resource="01-application.xml" /&gt;
        &lt;import resource="02-documentation_writer.xml" /&gt;
    &lt;/imports&gt;
&lt;/container&gt;
</code></pre>

<p>We created a <code>config</code> directory to put all those XML files, which means we
should change our front controller to:</p>

<pre><code>&lt;?php

// This is the front controller of the application
// File: fossil

use Symfony\Component\Config\FileLocator;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Loader\XmlFileLoader;

$container = new ContainerBuilder();
$configurationDirectory = new FileLocator(__DIR__.'/config');

$loader = new XmlFileLoader($container, $configurationDirectory);
$loader-&gt;load('dic.xml');

$application = $container-&gt;get('application');

$output = $container-&gt;get('console_output');

$application-&gt;run(null, $output);
</code></pre>

<p>The creation of the <code>config/01-application.xml</code> and
<code>config/02-documentation_writer.xml</code> files is left as an exercise for the
reader.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Symfony2's Dependency Injection component can be used outside of a Symfony2
application. It provides a powerful DIC which can be initialized using
configuration files. This means that boilerplate code (also called "wiring
layer") can be removed from your code and put in configuration files, hooray!</p>

<p>I hope you enjoyed this article, be sure to
<a href="https://twitter.com/epiloic">tweet me what you think about it</a> ;) .</p>

<h3 id="nota-bene">Nota bene</h3>

<p>We've used the component as a standalone library, but everything we've done
here is possible inside a Symfony2 fullstack application.</p>

<p>There's also some tips I'd like to share with you:</p>

<h3 id="doctrine-repositories-as-services">Doctrine repositories as services</h3>

<p>The construction of Doctrine repositories is fully handled by the EntityManager,
which means:</p>

<ol>
<li>you cannot inject them as dependencies in your own services</li>
<li>you cannot inject dependencies into them</li>
</ol>

<p><a href="https://gist.github.com/gnugat/8314217">Or can you?</a></p>

<h3 id="service-locator">Service locator</h3>

<p><a href="/2014/01/22/ioc-di-and-service-locator.html">The previous article</a>
spoke about service locator, which is all about using DIC as a dependency. If
you still don't see what it means, take a look at <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Component/DependencyInjection/ContainerAware.php">Symfony2 ContainerAware classes</a>.</p>

<p>For example, a <a href="https://github.com/symfony/symfony/blob/master/src/Symfony/Bundle/FrameworkBundle/Controller/Controller.php">Symfony2 controller</a>
uses the DIC as a Service Locator. In this specific case it might be justified,
as the controller shouldn't contain any logic: its purpose is to pass the
request's parameters to some services, and to feed their return values as the
response's parameters.</p>

<p>Keep in mind that in your own code, there's a 99.99% chance that using Service
Locator is a unjustified decision ;) .</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Bootstrap the markdown files of your FOSS project]]></title>
            <link href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html"/>
            <updated>2014-01-15T00:00:00+00:00</updated>
            <id>/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: Fossil is currently unmaintained.</p>
</blockquote>

<p>The one thing that will make developers use your Free or Open Source Software
(FOSS) project is its documentation. Without it, how can they know what it does,
or how to install it?</p>

<p>Last summer <a href="http://williamdurand.fr/2013/07/04/on-open-sourcing-libraries/">William Durand wrote an article about it</a>,
describing the minimum files your FOSS project should have, and what they should
contain.</p>

<p>After reading his article, maybe you did the same thing as me: you took your
courage with both hands and wrote thoroughly a decent documentation for the
project you were working on at the time.</p>

<p>Because it was tedious, you decided to copy those markdown files into your new
projects and adapt them.</p>

<p>But this too was tedious...</p>

<p>To solve this problem once for all I created <strong><a href="https://github.com/gnugat/fossil">fossil</a></strong>:
it will bootstrap the markdown files of your FOSS projects, and it will even
create an installer for you!</p>

<p>It generates the following files out of skeletons:</p>

<ul>
<li><code>CHANGELOG.md</code></li>
<li><code>CONTRIBUTING.md</code></li>
<li><code>LICENSE</code></li>
<li><code>README.md</code></li>
<li><code>VERSIONING.md</code></li>
<li><code>bin/installer.sh</code></li>
<li><code>doc</code> (or <code>Resources/doc</code> if the project is a bundle) directory:

<ul>
<li><code>01-introduction.md</code></li>
<li><code>02-installation.md</code></li>
<li><code>03-usage.md</code></li>
<li><code>04-tests.md</code></li>
</ul></li>
</ul>

<p>The best thing about it: you can run it on your new FOSS projects as well as
with your existing ones! By default it does not replace existing files (if you
want to, simply use the <code>-f</code> option).</p>

<p><strong>Fossil</strong> supports different kind of projects: applications, libraries and
Symfony2 bundles. Here's a quick usage guide.</p>

<h2 id="applications">Applications</h2>

<p>The <code>doc</code> command allows you to generate the markdown files of your
applications, which can be a web application or a CLI tool just like <strong>fossil</strong>.</p>

<p>As you can see in the following example, it only requires 2 arguments:</p>

<pre><code>fossil doc 'acme/application' 'The ACME company'
</code></pre>

<h3 id="the-github-repository-argument">The <a href="https://github.com/">Github</a> repository argument</h3>

<p>Applications are installed by cloning the github repository, which makes it as
easy to update as to run <code>git pull</code>.</p>

<p>This argument is used in the installer script as well as in the installation
instructions.</p>

<p>You don't need to write the whole github URL, simply give the username and the
project name in the following format: <code>username/project-name</code></p>

<h3 id="the-license-author-argument">The license author argument</h3>

<p>While the copyright's date can be computed, you need to provide the author's
name to generate the <code>LICENSE</code> file.</p>

<p>For now it only generates MIT licenses, but pull requests are welcomed :) .</p>

<h3 id="the-path-option">The path option</h3>

<p>By default the files are created in the current directory, but you can target a
specific path:</p>

<pre><code>fossil doc 'acme/application' 'The ACME company' -p '/tmp/application'
</code></pre>

<h3 id="the-force-overwrite-option">The force overwrite option</h3>

<p>As mentioned earlier, <strong>fossil</strong> won't replace existing files by default: for
instance if your project already has a <code>README.md</code> and a <code>LICENSE</code> file it will
only generate the other ones.</p>

<p>But if you want to throw them away, you can use this option:</p>

<pre><code>fossil doc 'acme/project' 'The ACME company' -f
</code></pre>

<h2 id="libraries">Libraries</h2>

<p>The <code>doc:library</code> command has the exact same arguments and options as the <code>doc</code>
one:</p>

<pre><code>fossil doc:library 'acme/library' 'The ACME company'
</code></pre>

<p>You can use the shortcut <code>d:l</code>:</p>

<pre><code>fossil d:l 'acme/library' 'The ACME company'
</code></pre>

<p>The difference between an application and a library lies in its installation:
the library is installed using <a href="http://getcomposer.org/">composer</a>.</p>

<h3 id="the-composer-package-option">The composer package option</h3>

<p>By default <strong>fossil</strong> assumes the composer package's name is the same as the
Github repository name (in the example it would be <code>acme/library</code>).
If it's not your case, use the following option:</p>

<pre><code>fossil d:l 'acme/library' 'The ACME company' -c 'acme/composer-package'
</code></pre>

<h2 id="symfony2-bundles">Symfony2 Bundles</h2>

<p>The <code>doc:bundle</code> command has almost the same arguments and options as the
<code>doc:library</code> one. It has an additional argument:</p>

<pre><code>fossil doc:bundle 'acme/demo-bundle' 'The ACME company' 'Acme\DemoBundle\AcmeDemoBundle'
</code></pre>

<p>You can use the shortcut <code>d:b</code>:</p>

<pre><code>fossil d:b 'acme/demo-bundle' 'The ACME company' 'Acme\DemoBundle\AcmeDemoBundle'
</code></pre>

<p>The difference between a library and a bundle is the documentation directory,
which is in <code>Resources/doc</code> instead of <code>doc</code>.</p>

<h3 id="the-fully-qualified-classname-argument">The fully qualified classname argument</h3>

<p>Another difference is the installation: the bundle needs to be added in the
application's kernel.</p>

<p>This will be detailed in the documentation, but it will also be taken care of
by the installer.</p>

<p>That's right, you read it right: when developers will run the installer, not
only will it download the bundle using composer, but it will also add its fully
qualified classname in the <code>app/AppKernel.php</code> file! Hooray!</p>

<p>The application's kernel will look like this afterwards:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            // Other bundles...
            new Acme\DemoBundle\AcmeDemoBundle(),
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            // Other bundles...
        }

        return $bundles;
    }
}
</code></pre>

<p><em>Note</em>: because of the backslashes you should escape this argument using
quotes, just like in the example.</p>

<h3 id="the-development-tool-option">The development tool option</h3>

<p>By using this option, the bundle will be registered in the application only if
it runs in development or test environment:</p>

<pre><code>fossil d:b 'acme/demo-bundle' 'The ACME company' 'Acme\DemoBundle\AcmeDemoBundle' -d
</code></pre>

<p>The application's kernel will look like this afterwards:</p>

<pre><code>&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            // Other bundles...
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            // Other bundles...
            $bundles[] = new Acme\DemoBundle\AcmeDemoBundle();
        }

        return $bundles;
    }
}
</code></pre>

<h2 id="you-still-need-to-write-the-documentation">You still need to write the documentation</h2>

<p>After running <strong>fossil</strong> you still need to provide some information (for
instance the elevator pitch in <code>README.md</code>) by editing those files:</p>

<ul>
<li><code>README.md</code></li>
<li><code>doc/01-introduction.md</code></li>
<li><code>doc/03-usage.md</code></li>
<li><code>doc/04-tests.md</code></li>
</ul>

<p>But is that enough? While I think <strong>fossil</strong> automates as much things as
possible, there's still some part of your project that needs specific
documentation.</p>

<p>For example you could add recipes which describe common tasks, or a glossary
defining technical or business terms used in your project.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Bootstrap the markdown files of your new and your old FOSS projects using
<strong><a href="https://github.com/gnugat/fossil">fossil</a></strong>, and then complete the
documentation so everyone can see how awesome your work is!</p>

<p>Happy hacking!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Technology scouting]]></title>
            <link href="/2014/01/08/technology-scouting.html"/>
            <updated>2014-01-08T00:00:00+00:00</updated>
            <id>/2014/01/08/technology-scouting.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see <a href="/2014/11/21/read-it-later.html">Read it Later</a></p>
</blockquote>

<p>As a curious person I'm constantly trying to learn new practices and to discover
tools which might help me, by collecting information via technology scouting and
then reading it.</p>

<p>In this article, I will present how to do so effectively.</p>

<h2 id="collecting-information">Collecting information</h2>

<p>Whenever you find an interesting link, send it to <a href="http://getpocket.com/">Pocket</a>
so you can read it later.</p>

<h3 id="blogs">Blogs</h3>

<p>To find interesting links subscribe to blog RSS feeds using
<a href="https://ifttt.com/">If This Then That</a>: it will send new entries directly to
pocket.</p>

<p>Here are some blogs I personnally follow (caution, they're not really sorted):</p>

<ul>
<li><a href="http://williamdurand.fr/">William Durand's blog</a></li>
<li><a href="http://www.mountaingoatsoftware.com/blog">Mountain Goat Software</a></li>
<li><a href="http://blog.karolsojko.com/">Karol Sójko's blog</a></li>
<li><a href="http://blog.8thlight.com/">8th light</a></li>
<li><a href="http://richardmiller.co.uk/">Richard Miller's blog</a></li>
<li><a href="http://verraes.net/#blog">Mathias Verraes's blog</a></li>
<li><a href="http://www.whitewashing.de/">Benjamin Eberlei's blog</a></li>
<li><a href="http://nedroid.com/">Nedroid</a></li>
<li><a href="https://igor.io/">Igor Wiedler's blog</a></li>
</ul>

<h3 id="twitter">Twitter</h3>

<p>You can also use <a href="https://twitter.com/">Twitter</a>:</p>

<ol>
<li>create a private list which will serve as a pool</li>
<li>add any author which might post interresting messages</li>
<li>after a week or so, add the author to a public list</li>
</ol>

<p>The lists only show messages (not retweets) and conversations between people
you follow. They also allow you to create categories.</p>

<p>If you want, you can have a look at
<a href="https://twitter.com/epiloic/lists/">my own public lists</a>.</p>

<h3 id="github">Github</h3>

<p>Last but not least, <a href="https://github.com/">Github</a> can also be a great source of
discoveries: by following someone which stars or watch a lot of projects you
will have them listed on your homepage.</p>

<p>Here's my advice: <a href="https://github.com/pborreli">Pascal Borreli</a> contributes to
many repositories, you should start to follow him.</p>

<h2 id="reading-it">Reading it</h2>

<p>Collecting resources is a thing, getting it read is another one. Just like
<a href="http://verraes.net/2012/12/how-to-read-more-books/">Mathias Verraes advised it</a>,
you should get an e-reader: you can send the pages you gathered on Pocket and
then read them everywhere.</p>

<p>Pocket allows you to remove the articles you found not so interresting after
all, it also allows you to archive the good ones and to favorite the great ones.</p>

<p>Speaking of reading and e-readers, books are another good way of discovering new
things. Do not underestimate them. Here's a list of books I'd recommend:</p>

<ul>
<li><a href="http://git-scm.com/book">Pro Git</a></li>
<li>Clean Code, by Robert C. Martin</li>
<li>Agile Software Development, Principles, Patterns, and Practices, by Robert C. Martin</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>The point is: current tools won't last and there's a lot of practices you're
not aware of. If you want to improve yourself and keep up with other developers,
you have to try your best to discover new practices (which might be rather old
actually) and new trending tools.</p>

<p>I hope you found this article enjoyable and helpful.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Carew, the static site generator]]></title>
            <link href="/2014/01/01/carew-static-site-generator.html"/>
            <updated>2014-01-01T00:00:00+00:00</updated>
            <id>/2014/01/01/carew-static-site-generator.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This article has been re-written - see <a href="/2016/01/15/sculpin.html">Scuplin</a></p>
</blockquote>

<p>Frameworks are a real help when building web applications which serve business
logic. But what about static websites?</p>

<p>Those only contain pages which could be directly written in HTML. The only
problem with this approach is that HTML isn't writter friendly compared to
Markdown.</p>

<p>Also, we could say that static websites like blogs do have some logic behind the
scenes:</p>

<ul>
<li>posts can have a state (is it published yet?)</li>
<li>posts can be tagged, in order to make them easier to find</li>
</ul>

<p>But still, a framework might be too much for this task.</p>

<p>Static site generators are a way to solve this problem:</p>

<ol>
<li>simply write your pages in markdown</li>
<li>launch a command to generate HTML from it</li>
</ol>

<p><a href="http://carew.github.io/">Carew</a> is one of them (among
  <a href="http://jekyllrb.com/">Jekyll</a>,
  <a href="http://hyde.github.io/">Hyde</a>,
  <a href="https://github.com/obensonne/poole">Poole</a>
  and <a href="https://github.com/spjwebster/lanyon">Lanyon</a>):
it is written in PHP, allows you to use the template engine
<a href="http://twig.sensiolabs.org/">Twig</a> in your markdown and it provides a theme
using <a href="http://getbootstrap.com/2.3.2/">Bootstrap</a>.</p>

<p>This blog post will focus on Carew, as
<a href="https://github.com/gnugat/gnugat.github.io">this very blog is written with it</a>.</p>

<h2 id="carew-and-github">Carew and Github</h2>

<p>A common way to quickly publish static sites is to use
<a href="http://pages.github.com/">Github Pages</a> which works as follow:</p>

<ol>
<li>create a repository, the name should follow this format: <code>&lt;username&gt;.github.io</code></li>
<li>add, commit and push the content of the <code>web</code> directory directly at the
root of your repo</li>
<li>the site is now available at this address: <code>http://&lt;username&gt;.github.io</code></li>
</ol>

<p><a href="http://carew.github.io/cookbook/hosting.html">Learn more about hosting a website built with Carew on the official website</a>.</p>

<h2 id="creation">Creation</h2>

<p>Creating your site using Carew is very simple, just follow these steps:</p>

<pre><code>$ php composer.phar create-project carew/boilerplate &lt;project&gt; -s dev
$ cd &lt;project&gt;
$ bin/carew build
</code></pre>

<p>Examples pages (which sources are located in <code>pages</code> and <code>posts</code>) are converted
from markdown to HTML in the <code>web</code> directory.</p>

<h2 id="customization">Customization</h2>

<p>Before writing any page or post, edit the configuration wich is located inside
the <code>config.yml</code> file.</p>

<p>Then edit the <code>pages/index.md</code> and <code>pages/about.md</code> pages with your own content.</p>

<p>Finally, remove the content of the <code>posts</code> folder and create your first blog
post using this command:</p>

<pre><code>$ bin/carew generate:post [--date='YYYY-MM-DD'] title
</code></pre>

<p><a href="http://carew.github.io/cookbook/configuration.html">See the configuration documentation on the official website</a>.</p>

<h2 id="front-matters">Front matters</h2>

<p>Each markdown file starts with a header:</p>

<pre><code>---
layout: post # no need for this line when writing a regular page
title: Will be used by `&lt;title&gt;&lt;/title&gt;` and `&lt;h1&gt;&lt;/h1&gt;`
tags:
    - first tag
    - carew
---
</code></pre>

<p>Carew generates a page listing all existing tags. You can create a link to this
page with the following snippet:</p>

<pre><code>{{ link('tags', 'The page with all the tags') }}.
</code></pre>

<p><a href="http://carew.github.io/documentation.html#front-matter">Learn more about Front matters on the official website</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Carew is really simple to use, in this article we've covered the minimum you
should know to create pages, blog posts and tags.</p>

<p>I hope you enjoyed this article and that it helped you a little.</p>

<p>If you want to learn more, for example to customize its behaviour or its theme,
please refer to <a href="http://carew.github.io/documentation.html">the official documentation</a>.</p>
]]></content>
        </entry>
    </feed>