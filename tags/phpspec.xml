<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="https://gnugat.github.io/feed/atom.xml" rel="self"/>
    <link href="https://gnugat.github.io/"/>
    <updated>2016-09-30T08:16:32+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Locating refactoring]]></title>
            <link href="https://gnugat.github.io/2016/09/28/mars-rover-locating-refactoring.html"/>
            <updated>2016-09-28T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/09/28/mars-rover-locating-refactoring.html</id>
            <content type="html"><![CDATA[<p>In this series we're building the software of a Mars Rover, according to
the <a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It allows us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>We've already developed the first use case about landing the rover on mars,
and the second one about driving it. We're now developing the last one,
requesting its location:</p>

<blockquote>
  <p>Mars rover will be requested to give its current location (<code>x</code> and <code>y</code>
  coordinates and the orientation).</p>
</blockquote>

<p>In this article we're going to create the locating logic:</p>

<pre><code>git checkout 5-location
</code></pre>

<h2 id="location">Location</h2>

<p>Our <code>LocateRover</code> command object relies on a <code>FindLatestLocation</code> service. They
both currently return an array containing the coordinates and orientation of
our rover. Since <code>FindLatestLocation</code> is an interface, we can't control what's
being actually returned... This could be fixed by specifying a <code>Location</code>
object as a return type, and it would make things more explicit.</p>

<p>Since Our <code>Location</code> object will contain <code>Coordinates</code> and <code>Orientation</code>, we
might want to create it in the <code>navigation</code> packages, where those two other
objects are alreay:</p>

<pre><code>cd packages/navigation
</code></pre>

<p>We can now start writing <code>Location</code>'s test:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\Navigation\Location'
</code></pre>

<p>This should have bootstrapped the following
<code>spec/MarsRover/Navigation/LocationSpec.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\Location;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class LocationSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(Location::class);
    }
}
</code></pre>

<p>We can then edit it to specify that it should contain <code>Coordinates</code> and
<code>Orientation</code>:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\Coordinates;
use MarsRover\Navigation\Orientation;
use PhpSpec\ObjectBehavior;

class LocationSpec extends ObjectBehavior
{
    const X = 23;
    const Y = 42;
    const ORIENTATION = Orientation::NORTH;

    function it_has_coordinates()
    {
        $coordinates = new Coordinates(self::X, self::Y);
        $orientation = new Orientation(self::ORIENTATION);
        $this-&gt;beConstructedWith($coordinates, $orientation);

        $this-&gt;getCoordinates()-&gt;shouldBe($coordinates);
    }

    function it_has_orientation()
    {
        $coordinates = new Coordinates(self::X, self::Y);
        $orientation = new Orientation(self::ORIENTATION);
        $this-&gt;beConstructedWith($coordinates, $orientation);

        $this-&gt;getOrientation()-&gt;shouldBe($orientation);
    }
}
</code></pre>

<p>That sounds simple enough, we can run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>And of course they fail because <code>Location</code> doesn't exist yet. to help us write
it, phpspec bootstrapped the following <code>src/MarsRover/Navigation/Location.php</code>
file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class Location
{
    private $coordinates;

    private $orientation;

    public function __construct(Coordinates $coordinates, Orientation $orientation)
    {
        $this-&gt;coordinates = $coordinates;
        $this-&gt;orientation = $orientation;
    }

    public function getCoordinates()
    {
    }

    public function getOrientation()
    {
    }
}
</code></pre>

<p>Let's complete it:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class Location
{
    private $coordinates;
    private $orientation;

    public function __construct(
        Coordinates $coordinates,
        Orientation $orientation
    ) {
        $this-&gt;coordinates = $coordinates;
        $this-&gt;orientation = $orientation;
    }

    public function getCoordinates() : Coordinates
    {
        return $this-&gt;coordinates;
    }

    public function getOrientation() : Orientation
    {
        return $this-&gt;orientation;
    }
}
</code></pre>

<p>This should be enough to make our tests pass:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! We can now commit our work:</p>

<pre><code>git add -A
git commit -m '5: Created Location'
</code></pre>

<h2 id="refactoring-landrover">Refactoring LandRover</h2>

<p>This <code>Location</code> value object looks great! Why didn't we create it in the first
place? That'll be pragmatism for you: don't create something you might need in
the future, create something you need now. But now that's it's here, we can
refactor <code>LocateRover</code> to use it.</p>

<p>First let's update its test:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\Location;
use MarsRover\Navigation\Orientation;
use PhpSpec\ObjectBehavior;

class LandRoverSpec extends ObjectBehavior
{
    const X = 23;
    const Y = 42;
    const ORIENTATION = Orientation::NORTH;

    function it_has_location()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $location = $this-&gt;getLocation();
        $location-&gt;shouldHaveType(Location::class);
        $coordinates = $location-&gt;getCoordinates();
        $coordinates-&gt;getX()-&gt;shouldBe(self::X);
        $coordinates-&gt;getY()-&gt;shouldBe(self::Y);
        $location-&gt;getOrientation()-&gt;get()-&gt;shouldBe(self::ORIENTATION);
    }
}
</code></pre>

<p>Then its code:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class LandRover
{
    private $location;

    public function __construct($x, $y, $orientation)
    {
        $this-&gt;location = new Location(
            new Coordinates($x, $y),
            new Orientation($orientation)
        );
    }

    public function getLocation() : Location
    {
        return $this-&gt;location;
    }
}
</code></pre>

<p>And finally <code>LandRoverHandler</code>:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

use MarsRover\EventSourcing\{
    AnEventHappened,
    EventStore
};

class LandRoverHandler
{
    private $anEventHappened;
    private $eventStore;

    public function __construct(
        AnEventHappened $anEventHappened,
        EventStore $eventStore
    ) {
        $this-&gt;anEventHappened = $anEventHappened;
        $this-&gt;eventStore = $eventStore;
    }

    public function handle(LandRover $landRover)
    {
        $location = $landRover-&gt;getLocation();
        $coordinates = $location-&gt;getCoordinates();
        $orientation = $location-&gt;getOrientation();
        $roverLanded = $this-&gt;anEventHappened-&gt;justNow(Events::ROVER_LANDED, [
            'x' =&gt; $coordinates-&gt;getX(),
            'y' =&gt; $coordinates-&gt;getY(),
            'orientation' =&gt; $orientation-&gt;get(),
        ]);
        $this-&gt;eventStore-&gt;log($roverLanded);
    }
}
</code></pre>

<p>Let's check the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! That should be enough to commit:</p>

<pre><code>git add -A
git commit -m '5: Used Location in LandRover'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>While we've been playing with the notion of <code>Location</code> since the very first
use case, it's only now that we really need it that we created it.</p>

<p>It encapsulates X and Y coordinates as well as an orientation.</p>

<h2 id="what%27s-next%3F">What's next?</h2>

<p><code>Location</code> is currently in the <code>navigation</code> package, but we also need it in
the <code>location</code> package... To fix this we have the following solutions:</p>

<ul>
<li>add <code>navigation</code> as a dependency of <code>location</code></li>
<li>merge together <code>navigation</code> and <code>location</code></li>
<li>create a new <code>geolocation</code> package, with <code>Location</code>, <code>Coordinates</code> and
<code>Orientation</code></li>
</ul>

<p>Since we want to keep <code>navigation</code> and <code>location</code> separate, we'll opt for the
third option and create this new package in the next article.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Locating handler]]></title>
            <link href="https://gnugat.github.io/2016/09/21/mars-rover-locating-handler.html"/>
            <updated>2016-09-21T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/09/21/mars-rover-locating-handler.html</id>
            <content type="html"><![CDATA[<p>In this series we're building the software of a Mars Rover, according to
the <a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It allows us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>We've already developed the first use case about landing the rover on mars,
and the second one about driving it. We're now developing the last one,
requesting its location:</p>

<blockquote>
  <p>Mars rover will be requested to give its current location (<code>x</code> and <code>y</code>
  coordinates and the orientation).</p>
</blockquote>

<p>In this article we're going to create the locating logic:</p>

<pre><code>cd packages/location
git checkout 5-location
</code></pre>

<h2 id="locate-rover">Locate Rover</h2>

<p>As usual, we're going to use our
<a href="/2016/06/29/mars-rover-landing.html#twisting-command-bus">Command Bus twist</a>:</p>

<ul>
<li>create a Command object that contains and validates input parameters</li>
<li>create a Command Handler object that receives the Command and does the
actual logic</li>
</ul>

<p>However in this case we don't have any input parameters: we only want the
location of the rover. So do we really need to create an empty <code>LocateRover</code>
class?</p>

<p>If in the future we want to handle many rovers (a Rover name or ID parameter)
or if we want to know the location of a rover at a given time (time parameter),
then having this empty class can make sense: we can then fill it later.</p>

<p>However, in this tutorial anyway, we don't have such a need so we can be
pragmatic about it and just omit it.</p>

<h2 id="locateroverhandler">LocateRoverHandler</h2>

<p>Let's start straight away by creating the <code>LocateRoverHandler</code>. We're starting
by bootstraping the test class:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\Location\LocateRoverHandler'
</code></pre>

<p>This should create the following
<code>spec/MarsRover/Location/LocateRoverHandlerSpec.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Location;

use MarsRover\Location\LocateRoverHandler;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class LocateRoverHandlerSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(LocateRoverHandler::class);
    }
}
</code></pre>

<p>We'll need a service which is able to replay all the landing and driving events
to compute the latest location of the rover. Let's call it <code>FindLatestLocation</code>.
Or maybe it'd be faster if we computed that latest location on the go, while
we receive each landing and driving event? In that case our <code>FindLatestLocation</code>
would just need to retrieve those values from a sort of cache.</p>

<p>It sounds like we can have many ways of finding the rover location, and
commiting to one right now only to find out later that another implementation
was better would be a shame. So let's delay our decision and rely on an
interface for now:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Location;

use MarsRover\Location\Service\FindLatestLocation;
use PhpSpec\ObjectBehavior;

class LocateRoverHandlerSpec extends ObjectBehavior
{
    const X = 23;
    const Y = 42;
    const ORIENTATION = 'north';

    const LOCATION = [
        'x' =&gt; self::X,
        'y' =&gt; self::Y,
        'orientation' =&gt; self::ORIENTATION,
    ];

    function it_finds_a_rover_latest_location(
        FindLatestLocation $findLatestLocation
    ) {
        $this-&gt;beConstructedWith($findLatestLocation);

        $findLatestLocation-&gt;find()-&gt;willReturn(self::LOCATION);

        $this-&gt;handle()-&gt;shouldBe(self::LOCATION);
    }
}
</code></pre>

<p>It might be our smallest Handler of all. Since it only uses one service, we
might start wondering if it was worth to have a handler at all (we could just
use the <code>FindLatestLocation</code> service directly), after all we did skip the
Command for similar reasons.</p>

<p>However, if we throw away our handler, we'll lose our "automated use case
documentation": the service is an interface and cannot be tested. So let's keep
it. Let's run the tests now:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>They fail because <code>LocateRoverHandler</code> doesn't exist, but phpspec bootstrapped
it for us in the <code>src/MarsRover/Location/LocateRoverHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Location;

use MarsRover\Location\Service\FindLatestLocation;

class LocateRoverHandler
{
    private $findLatestLocation;

    public function __construct(FindLatestLocation $findLatestLocation)
    {
        $this-&gt;findLatestLocation = $findLatestLocation;
    }

    public function handle()
    {
    }
}
</code></pre>

<p>Thanks to the <a href="https://github.com/memio/spec-gen">SpecGen extension</a>, phpspec
was able to detect Dependency Injection, and bootstrapped a constructor with
an attribute initialization for us. How nice!</p>

<p>We'll just need to complete the <code>handle</code> method:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Location;

use MarsRover\Location\Service\FindLatestLocation;

class LocateRoverHandler
{
    private $findLatestLocation;

    public function __construct(FindLatestLocation $findLatestLocation)
    {
        $this-&gt;findLatestLocation = $findLatestLocation;
    }

    public function handle()
    {
        return $this-&gt;findLatestLocation-&gt;find();
    }
}
</code></pre>

<p>Overall, the code looks very similar to the test. Let's run them again:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! We can commit our work:</p>

<pre><code>git add -A
git commit -m '5: Created LocateRoverHandler'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Locating the rover is as simple as retrieving it from somewhere. We've
delegated the decision on where this "somewhere" is because there are many
valid solutions (replaying all the events from the EventStore, a cache, etc).</p>

<p>Delegating those decisions can be done by creating an interface, it allows us
to create as many implementations as we want, without having to modify the
logic we've just written.</p>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>The Test Driven Development cycle wouldn't be complete without a refactoring
step. In the next article we'll create a <code>Location</code> value object, to make our
<code>FindLatestLocation</code> and <code>LocateRoverHandler</code> classes return something more
explicit.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Driving event]]></title>
            <link href="https://gnugat.github.io/2016/09/07/mars-rover-driving-event.html"/>
            <updated>2016-09-07T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/09/07/mars-rover-driving-event.html</id>
            <content type="html"><![CDATA[<p>In this series we're building the software of a Mars Rover, according to
the <a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It allows us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>We've already developed the first use case about landing the rover on mars,
and we've started the second one about driving it:</p>

<blockquote>
  <p>Once a rover has been landed on Mars it is possible to drive them, using
  instructions such as <code>move_forward</code> (keeps orientation, but moves along the
  <code>x</code> or <code>y</code> axis) or <code>turn_left</code> / <code>turn_right</code> (keeps the same coordinates,
  but changes the orientation).</p>
</blockquote>

<p>In this article we're going to create the actual driving logic, using
Event Sourcing:</p>

<pre><code>cd packages/navigation
git checkout 4-driving
</code></pre>

<h2 id="driveroverhandler">DriveRoverHandler</h2>

<p>Following our <a href="/2016/06/29/mars-rover-landing.html#twisting-command-bus">Command Bus twist</a>,
we're now going to create the <code>DriveRoverHandler</code> class that's going to take
care of the actual logic associated to the <code>DriveRover</code> use case. We're
starting by bootstraping the test class:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\Navigation\DriveRoverHandler'
</code></pre>

<p>This should create the following
<code>spec/MarsRover/Navigation/DriveRoverHandlerSpec.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\DriveRoverHandler;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class DriveRoverHandlerSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(DriveRoverHandler::class);
    }
}
</code></pre>

<p><a href="/2016/06/15/mars-rover-introduction.html#event-sourcing">Event Sourcing</a> is
all about recording significant actions. Driving a rover seems significant
enough, so that's what <code>DriveRoverHandler</code> should do:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\EventSourcing\AnEventHappened;
use MarsRover\EventSourcing\Event;
use MarsRover\EventSourcing\EventStore;
use MarsRover\Navigation\DriveRover;
use MarsRover\Navigation\Instruction;
use PhpSpec\ObjectBehavior;

class DriveRoverHandlerSpec extends ObjectBehavior
{
    const DRIVING_INSTRUCTION = Instruction::MOVE_FORWARD;

    const EVENT_NAME = 'rover_driven';
    const EVENT_DATA = [
        'instruction' =&gt; self::DRIVING_INSTRUCTION,
    ];

    function it_drives_a_rover_with_given_instruction(
        AnEventHappened $anEventHappened,
        Event $roverDriven,
        EventStore $eventStore
    ) {
        $this-&gt;beConstructedWith($anEventHappened, $eventStore);
        $driveRover = new DriveRover(
            self::DRIVING_INSTRUCTION
        );

        $anEventHappened-&gt;justNow(
            self::EVENT_NAME,
            self::EVENT_DATA
        )-&gt;willReturn($roverDriven);
        $eventStore-&gt;log($roverDriven)-&gt;shouldBeCalled();

        $this-&gt;handle($driveRover);
    }
}
</code></pre>

<p>It's very similar to what we've done for <code>LandRoverHandler</code>, all we've done
is create and event specific to driving the rover with its instructions
and "logged" it in an `EventStore. Let's run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>They fail because <code>DriveRoverHandler</code> doesn't exists, but phpspec bootstrapped
it for us in the <code>src/MarsRover/Navigation/DriveRoverHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

use MarsRover\EventSourcing\AnEventHappened;
use MarsRover\EventSourcing\EventStore;

class DriveRoverHandler
{
    private $anEventHappened;

    private $eventStore;

    public function __construct(AnEventHappened $anEventHappened, EventStore $eventStore)
    {
        $this-&gt;anEventHappened = $anEventHappened;
        $this-&gt;eventStore = $eventStore;
    }

    public function handle(DriveRover $driveRover)
    {
    }
}
</code></pre>

<p>Thanks to the <a href="https://github.com/memio/spec-gen">SpecGen extension</a>, phpspec
was able to detect Dependency Injection, and bootstrapped a constructor with
an attribute initialization for us. How nice!</p>

<p>We'll just need to complete the <code>handle</code> method:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

use MarsRover\EventSourcing\{
    AnEventHappened,
    EventStore
};

class DriveRoverHandler
{
    const EVENT_NAME = 'rover_driven';

    private $anEventHappened;
    private $eventStore;

    public function __construct(
        AnEventHappened $anEventHappened,
        EventStore $eventStore
    ) {
        $this-&gt;anEventHappened = $anEventHappened;
        $this-&gt;eventStore = $eventStore;
    }

    public function handle(DriveRover $driveRover)
    {
        $roverDriven = $this-&gt;anEventHappened-&gt;justNow(self::EVENT_NAME, [
            'instruction' =&gt; $driveRover-&gt;getInstruction()-&gt;get(),
        ]);
        $this-&gt;eventStore-&gt;log($roverDriven);
    }
}
</code></pre>

<p>Overall, the code looks very similar to the test. Let's run them again:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! We're going to do a quick refactoring to move the event name in
the <code>src/MarsRover/Navigation/Events.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class Events
{
    const ROVER_LANDED = 'rover_landed';
    const ROVER_DRIVEN = 'rover_driven';
}
</code></pre>

<p>Then use it in the code:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

use MarsRover\EventSourcing\{
    AnEventHappened,
    EventStore
};

class DriveRoverHandler
{
    private $anEventHappened;
    private $eventStore;

    public function __construct(
        AnEventHappened $anEventHappened,
        EventStore $eventStore
    ) {
        $this-&gt;anEventHappened = $anEventHappened;
        $this-&gt;eventStore = $eventStore;
    }

    public function handle(DriveRover $driveRover)
    {
        $roverDriven = $this-&gt;anEventHappened-&gt;justNow(Events::ROVER_DRIVEN, [
            'instruction' =&gt; $driveRover-&gt;getInstruction()-&gt;get(),
        ]);
        $this-&gt;eventStore-&gt;log($roverDriven);
    }
}
</code></pre>

<p>and finally in the test:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\EventSourcing\AnEventHappened;
use MarsRover\EventSourcing\Event;
use MarsRover\EventSourcing\EventStore;
use MarsRover\Navigation\DriveRover;
use MarsRover\Navigation\Events;
use MarsRover\Navigation\Instruction;
use PhpSpec\ObjectBehavior;

class DriveRoverHandlerSpec extends ObjectBehavior
{
    const DRIVING_INSTRUCTION = Instruction::MOVE_FORWARD;

    const EVENT_NAME = Events::ROVER_DRIVEN;
    const EVENT_DATA = [
        'instruction' =&gt; self::DRIVING_INSTRUCTION,
    ];

    function it_drives_a_rover_with_given_instruction(
        AnEventHappened $anEventHappened,
        Event $roverDriven,
        EventStore $eventStore
    ) {
        $this-&gt;beConstructedWith($anEventHappened, $eventStore);
        $driveRover = new DriveRover(
            self::DRIVING_INSTRUCTION
        );

        $anEventHappened-&gt;justNow(
            self::EVENT_NAME,
            self::EVENT_DATA
        )-&gt;willReturn($roverDriven);
        $eventStore-&gt;log($roverDriven)-&gt;shouldBeCalled();

        $this-&gt;handle($driveRover);
    }
}
</code></pre>

<p>We can run the tests one last time:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>Still green! We can commit our work:</p>

<pre><code>git add -A
git commit -m '4: Created DriveRoverHandler'
git checkout master
git merge --no-ff 4-driving
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>With Event Sourcing, the logic associated to our "Driving a Rover on Mars" use
case is quite simple: we just record it as an event.</p>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>In the next article, we'll create a new package to take care of the last use
case: "Requesting the Rover's location".</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Driving instruction]]></title>
            <link href="https://gnugat.github.io/2016/08/17/mars-rover-driving-instruction.html"/>
            <updated>2016-08-17T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/08/17/mars-rover-driving-instruction.html</id>
            <content type="html"><![CDATA[<p>In this series we're building the software of a Mars Rover, according to
the <a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It allows us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>We've already developed the first use case about landing the rover on mars,
and we've started the second one about driving it:</p>

<blockquote>
  <p>Once a rover has been landed on Mars it is possible to drive them, using
  instructions such as <code>move_forward</code> (keeps orientation, but moves along the
  <code>x</code> or <code>y</code> axis) or <code>turn_left</code> / <code>turn_right</code> (keeps the same coordinates,
  but changes the orientation).</p>
</blockquote>

<p>In this article we're going to refactor <code>DriveRover</code>:</p>

<pre><code>cd packages/navigation
git checkout -b 4-driving
</code></pre>

<h2 id="responsibilities">Responsibilities</h2>

<p>By having a look at <code>DriveRover</code>, we can guess that it has 1 reason to change:
the list of instruction might grow bigger.</p>

<p>This hints toward one new class: <code>Instruction</code>. Let's get cracking!</p>

<h2 id="instruction">Instruction</h2>

<p>First let's bootstrap the test class using <a href="http://phpspec.net">phpspec</a>:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\Navigation\Instruction'
</code></pre>

<p>This will create the following <code>spec/MarsRover/Navigation/InstructionSpec.php</code>
file:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\Instruction;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class InstructionSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(Instruction::class);
    }
}
</code></pre>

<p>We can edit it reusing what we've done in <code>DriveRover</code> test class, only with
more information about the possible instruction:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use PhpSpec\ObjectBehavior;

class InstructionSpec extends ObjectBehavior
{
    const MOVE_FORWARD = 'move_forward';
    const TURN_LEFT = 'turn_left';
    const TURN_RIGHT = 'turn_right';

    const INVALID_INSTRUCTION = 'wake_up_polly_parrot';

    function it_can_be_move_forward()
    {
        $this-&gt;beConstructedWith(self::MOVE_FORWARD);

        $this-&gt;get()-&gt;shouldBe(self::MOVE_FORWARD);
    }

    function it_can_be_turn_left()
    {
        $this-&gt;beConstructedWith(self::TURN_LEFT);

        $this-&gt;get()-&gt;shouldBe(self::TURN_LEFT);
    }

    function it_can_be_turn_right()
    {
        $this-&gt;beConstructedWith(self::TURN_RIGHT);

        $this-&gt;get()-&gt;shouldBe(self::TURN_RIGHT);
    }

    function it_cannot_be_anything_else()
    {
        $this-&gt;beConstructedWith(self::INVALID_INSTRUCTION);

        $this-&gt;shouldThrow(
            \InvalidArgumentException::class
        )-&gt;duringInstantiation();
    }
}
</code></pre>

<p>Since this test is dedicated to instructions, we feel more free than in
<code>DriveRover</code> to describe all the possible instructions. If we run the tests
now, phpspec will bootstrap the <code>Instruction</code> class for us:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>Indeed, it created the <code>src/MarsRover/Navigation/Instruction.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class Instruction
{
    public function __construct($argument)
    {
    }

    public function get()
    {
    }
}
</code></pre>

<p>All that's left for us to do is complete it, we can reuse the code in
<code>DriveRover</code>:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class Instruction
{
    const MOVE_FORWARD = 'move_forward';
    const TURN_LEFT = 'turn_left';
    const TURN_RIGHT = 'turn_right';

    const VALID_INSTRUCTIONS = [
        self::MOVE_FORWARD,
        self::TURN_LEFT,
        self::TURN_RIGHT,
    ];

    private $instruction;

    public function __construct($instruction)
    {
        if (false === in_array($instruction, self::VALID_INSTRUCTIONS, true)) {
            throw new \InvalidArgumentException(
                'Instruction should be one of: '
                .implode(', ', self::VALID_INSTRUCTIONS)
            );
        }
        $this-&gt;instruction = $instruction;
    }

    public function get() : string
    {
        return $this-&gt;instruction;
    }
}
</code></pre>

<p>We can now run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! <code>Instruction</code> is ready to be used in <code>DriveRover</code>, so let's update
its test:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\Instruction;
use PhpSpec\ObjectBehavior;

class DriveRoverSpec extends ObjectBehavior
{
    const DRIVING_INSTRUCTION = Instruction::MOVE_FORWARD;

    function it_has_a_driving_instruction()
    {
        $this-&gt;beConstructedWith(
            self::DRIVING_INSTRUCTION
        );

        $this-&gt;getInstruction()-&gt;get()-&gt;shouldBe(self::DRIVING_INSTRUCTION);
    }
}
</code></pre>

<p>We no longer need to check for invalid instructions as we trust <code>Instruction</code>
to take care of it for us. Now let's update its code:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class DriveRover
{
    private $instruction;

    public function __construct($instruction)
    {
        $this-&gt;instruction = new Instruction($instruction);
    }

    public function getInstruction() : Instruction
    {
        return $this-&gt;instruction;
    }
}
</code></pre>

<p>And that should make our tests pass:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! We can refactor <code>Instruction</code> test class a bit, by reusing
<code>Instruction</code> constants:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\Instruction;
use PhpSpec\ObjectBehavior;

class InstructionSpec extends ObjectBehavior
{
    const MOVE_FORWARD = Instruction::MOVE_FORWARD;
    const TURN_LEFT = Instruction::TURN_LEFT;
    const TURN_RIGHT = Instruction::TURN_RIGHT;

    const INVALID_INSTRUCTION = 'wake_up_polly_parrot';

    function it_can_be_move_forward()
    {
        $this-&gt;beConstructedWith(self::MOVE_FORWARD);

        $this-&gt;get()-&gt;shouldBe(self::MOVE_FORWARD);
    }

    function it_can_be_turn_left()
    {
        $this-&gt;beConstructedWith(self::TURN_LEFT);

        $this-&gt;get()-&gt;shouldBe(self::TURN_LEFT);
    }

    function it_can_be_turn_right()
    {
        $this-&gt;beConstructedWith(self::TURN_RIGHT);

        $this-&gt;get()-&gt;shouldBe(self::TURN_RIGHT);
    }

    function it_cannot_be_anything_else()
    {
        $this-&gt;beConstructedWith(self::INVALID_INSTRUCTION);

        $this-&gt;shouldThrow(
            \InvalidArgumentException::class
        )-&gt;duringInstantiation();
    }
}
</code></pre>

<p>Let's run the tests one last time:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All <em>grin</em> ;) . That's enough for us to commit our work:</p>

<pre><code>git add -A
git commit -m '4: Created Instruction'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We've refactored <code>DriveRover</code> by extracting an <code>Instruction</code> value object. It
allowed us to write more tests to describe all the possible values.</p>

<h2 id="what%27s-next">What's next</h2>

<p>In the next article, we'll write the actual driving logic.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Driving]]></title>
            <link href="https://gnugat.github.io/2016/08/10/mars-rover-driving.html"/>
            <updated>2016-08-10T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/08/10/mars-rover-driving.html</id>
            <content type="html"><![CDATA[<p>In this series we're building the software of a Mars Rover, according to
the <a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It allows us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>We just finished developing the first use case, so we can now get cracking on
the second one, Driving the rover:</p>

<blockquote>
  <p>Once a rover has been landed on Mars it is possible to drive them, using
  instructions such as <code>move_forward</code> (keeps orientation, but moves along the
  <code>x</code> or <code>y</code> axis) or <code>turn_left</code> / <code>turn_right</code> (keeps the same coordinates,
  but changes the orientation).</p>
</blockquote>

<h2 id="drive-rover">Drive Rover</h2>

<p>Again, we start by creating a class with the name of our use case. It will
take care of doing a simple validation on the input provided by the user:</p>

<pre><code>cd packages/navigation
git checkout -b 4-driving
</code></pre>

<p>Using <a href="http://www.phpspec.net/en/stable/">phpspec</a>, we bootstrap the test
class:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\Navigation\DriveRover'
</code></pre>

<p>This should generate this <code>spec/MarsRover/Navigation/DriveRoverSpec.php</code> class:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\DriveRover;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class DriveRoverSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(DriveRover::class);
    }
}
</code></pre>

<p>This leaves us the task of editing it to start describing input parameters:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use PhpSpec\ObjectBehavior;

class DriveRoverSpec extends ObjectBehavior
{
    const DRIVING_INSTRUCTION = 'move_forward';

    function it_has_a_driving_instruction()
    {
        $this-&gt;beConstructedWith(
            self::DRIVING_INSTRUCTION
        );

        $this-&gt;getInstruction()-&gt;shouldBe(self::DRIVING_INSTRUCTION);
    }
}
</code></pre>

<p>We can now run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>This will generate the <code>src/MarsRover/Navigation/DriveRover.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class DriveRover
{
    private $argument;

    public function __construct($argument)
    {
        $this-&gt;argument = $argument;
    }

    public function getInstruction()
    {
    }
}
</code></pre>

<p>All we need to do is to edit it:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class DriveRover
{
    private $instruction;

    public function __construct($instruction)
    {
        $this-&gt;instruction = $instruction;
    }

    public function getInstruction() : string
    {
        return $this-&gt;instruction;
    }
}
</code></pre>

<p>Let's check the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! Now let's add some unhappy scenarios to our tests:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use PhpSpec\ObjectBehavior;

class DriveRoverSpec extends ObjectBehavior
{
    const DRIVING_INSTRUCTION = 'move_forward';
    const INVALID_DRIVING_INSTRUCTION = 'wake_up_polly_parrot';

    function it_has_a_driving_instruction()
    {
        $this-&gt;beConstructedWith(
            self::DRIVING_INSTRUCTION
        );

        $this-&gt;getInstruction()-&gt;shouldBe(self::DRIVING_INSTRUCTION);
    }

    function it_cannot_have_invalid_instruction()
    {
        $this-&gt;beConstructedWith(
            self::INVALID_DRIVING_INSTRUCTION
        );

        $this-&gt;shouldThrow(
            \InvalidArgumentException::class
        )-&gt;duringInstantiation();
    }
}
</code></pre>

<p>We can run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>They fail! So let's complete the code:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class DriveRover
{
    const VALID_INSTRUCTIONS = [
        'move_forward',
        'turn_left',
        'turn_right',
    ];

    private $instruction;

    public function __construct($instruction)
    {
        if (false === in_array($instruction, self::VALID_INSTRUCTIONS, true)) {
            throw new \InvalidArgumentException(
                'Instruction should be one of: '
                .implode(', ', self::VALID_INSTRUCTIONS)
            );
        }
        $this-&gt;instruction = $instruction;
    }

    public function getInstruction() : string
    {
        return $this-&gt;instruction;
    }
}
</code></pre>

<p>And re-run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! We can now commit our work:</p>

<pre><code>git add -A
git commit -m '4: Created DriveRover'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We've followed again the TDD methodology: write the test, then the code. We
took care of describing first the happy scenario and then unhappy scenarios to
cover all the cases.</p>

<p>We've also used the same twist on the Command Bus pattern: we created a Command
class that describes the use case (drive the rover) and does a simple
validation on the input.</p>

<h2 id="what%27s-next">What's next</h2>

<p>In the next article, we'll proceed to the third step of TDD: refactoring
<code>DriveRover</code> by extracting <code>Instruction</code> in its own class.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Event Sourcing code]]></title>
            <link href="https://gnugat.github.io/2016/08/03/mars-rover-event-sourcing-code.html"/>
            <updated>2016-08-03T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/08/03/mars-rover-event-sourcing-code.html</id>
            <content type="html"><![CDATA[<p>In this series we're building the software of a Mars Rover, according to the
<a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It will allow us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>Up until now, we've implemented the first use case, "Landing a rover on Mars":</p>

<blockquote>
  <p>Mars Rovers need first to be landed at a given position. A position is
  composed of coordinates (<code>x</code> and <code>y</code>, which are both integers) and an
  orientation (a string being one of <code>north</code>, <code>east</code>, <code>west</code> or <code>south</code>).</p>
</blockquote>

<p>We've also created an <code>event-sourcing</code> package with the following interfaces:</p>

<ul>
<li><code>Event</code>, a Data Transfer Object (DTO) that contains the name and the data</li>
<li><code>AnEventHappened</code>, which is actually an <code>Event</code> factory</li>
<li><code>EventStore</code>, a service responsible for "logging" <code>Event</code>s</li>
</ul>

<p>In this article, we're going to implement them.</p>

<h2 id="event">Event</h2>

<p>Let's start by asking <a href="http://phpspec.net/">phpspec</a> to generate the test
class:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\EventSourcing\Event'
</code></pre>

<p>It should have generated the following
<code>spec/MarsRover/EventSourcing/EventSpec.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\EventSourcing;

use MarsRover\EventSourcing\Event;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class EventSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(Event::class);
    }
}
</code></pre>

<p>We're going to start writing test methods that describe what kind of data this
DTO holds:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\EventSourcing;

use PhpSpec\ObjectBehavior;

class EventSpec extends ObjectBehavior
{
    const NAME = 'something_happened';
    const DATA = [
        'message' =&gt; 'We are the knights who say Ni!',
    ];

    function let(\DateTime $receivedAt)
    {
        $this-&gt;beConstructedWith(
            self::NAME,
            self::DATA,
            $receivedAt
        );
    }

    function it_has_a_name()
    {
        $this-&gt;getName()-&gt;shouldBe(self::NAME);
    }

    function it_has_data()
    {
        $this-&gt;getData()-&gt;shouldBe(self::DATA);
    }

    function it_has_been_received_at_a_date_and_time(\DateTime $receivedAt)
    {
        $this-&gt;getReceivedAt()-&gt;shouldBe($receivedAt);
    }
}
</code></pre>

<p>We can now run the tests to bootstrap the class:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>It will overwrite the existing <code>src/MarsRover/EventSourcing/Event.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\EventSourcing;

use DateTimeInterface;

class Event
{
    public function __construct($argument1, array $argument2, DateTimeInterface $dateTime)
    {
    }

    public function getName()
    {
    }

    public function getData()
    {
    }

    public function getReceivedAt()
    {
    }
}
</code></pre>

<p>We can edit it to make the tests pass:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\EventSourcing;

class Event
{
    private $name;
    private $data;
    private $receivedAt;

    public function __construct(
        string $name,
        array $data,
        \DateTimeInterface $receivedAt
    ) {
        $this-&gt;name = $name;
        $this-&gt;data = $data;
        $this-&gt;receivedAt = $receivedAt;
    }

    public function getName() : string
    {
        return $this-&gt;name;
    }

    public function getData() : array
    {
        return $this-&gt;data;
    }

    public function getReceivedAt() : \DateTimeInterface
    {
        return $this-&gt;receivedAt;
    }
}
</code></pre>

<p>Let's check if everything is alright:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>And it is! Time to commit our work:</p>

<pre><code>git add -A
git commit -m '3: Created Event'
</code></pre>

<h2 id="aneventhappened">AnEventHappened</h2>

<p>The next class to implement is <code>AnEventHappened</code>. Let's create its test:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\EventSourcing\AnEventHappened'
</code></pre>

<p>It should generate the <code>spec/MarsRover/EventSourcing/AnEventHappenedSpec.php</code>
file:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\EventSourcing;

use MarsRover\EventSourcing\AnEventHappened;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class AnEventHappenedSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(AnEventHappened::class);
    }
}
</code></pre>

<p>We can start describing this factory by writing test methods:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\EventSourcing;

use MarsRover\EventSourcing\Event;
use PhpSpec\ObjectBehavior;

class AnEventHappenedSpec extends ObjectBehavior
{
    const NAME = 'something_happened';
    const DATA = [
        'message' =&gt; 'And now for something completly different',
    ];

    function it_can_create_events()
    {
        $this-&gt;justNow(self::NAME, self::DATA)-&gt;shouldHaveType(Event::class);
    }
}
</code></pre>

<p>Running the tests will generate the class:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>It should have overwritten the
<code>src/MarsRover/EventSourcing/AnEventHappened.php</code> file with:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\EventSourcing;

class AnEventHappened
{
    public function justNow($argument1, $argument2)
    {
    }
}
</code></pre>

<p>We can now complete it:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\EventSourcing;

class AnEventHappened
{
    public function justNow(string $name, array $data) : Event
    {
        return new Event($name, $data, new \DateTime());
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! Time to commit:</p>

<pre><code>git add -A
git commit -m 'Created AnEventHappened'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We replaced the generated interfaces for <code>AnEventHappened</code> and <code>Event</code> with
classes, which have been tested.</p>

<p><code>EventStore</code> could log events in a log file, or in a database, or send them as
messages to a queue to be treated later... For that reason we'll keep the
interface.</p>

<p>We're going to delay its implementations for later, when the rover will be
almost done.</p>

<p>If we run the tests from the project's root, we'll see that it runs tests for
both <code>navigation</code> and <code>event-sourcing</code> in one go. This is one advantage of
MonoRepo: it makes it easy to make sure that changes in a package don't break
the other that depend on it.</p>

<p>We can now merge our branch:</p>

<pre><code>cd ../../
git checkout master
git merge --no-ff 3-event-sourcing
</code></pre>

<h2 id="what%27s-next">What's next</h2>

<p>In the next article we'll start developing the second use case: Driving the
rover.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Event Sourcing package]]></title>
            <link href="https://gnugat.github.io/2016/07/27/mars-rover-event-sourcing-package.html"/>
            <updated>2016-07-27T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/07/27/mars-rover-event-sourcing-package.html</id>
            <content type="html"><![CDATA[<p>In this series we're building the software of a Mars Rover, according to the
<a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It will allow us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>Up until now, we've implemented the first use case, "Landing a rover on Mars":</p>

<blockquote>
  <p>Mars Rovers need first to be landed at a given position. A position is
  composed of coordinates (<code>x</code> and <code>y</code>, which are both integers) and an
  orientation (a string being one of <code>north</code>, <code>east</code>, <code>west</code> or <code>south</code>).</p>
</blockquote>

<p>In order to do so, we've:</p>

<ul>
<li>created a <a href="/2016/06/22/mars-rover-initialization.html">navigation package</a></li>
<li>created <a href="/2016/06/29/mars-rover-landing.html">LandRover for input validation</a></li>
<li>refactored it by:

<ul>
<li>extracting <a href="/2016/07/06/mars-rover-landing-coordinates.html">Coordinates</a></li>
<li>extracting <a href="/2016/07/13/mars-rover-landing-orientation.html">Orientation</a></li>
</ul></li>
<li>created <a href="/2016/07/20/mars-rover-landing-event.html">LandRoverHandler for the actual logic</a></li>
</ul>

<p>In the last article, we wrote some Event Sourcing code:</p>

<ul>
<li><code>Event</code>, a Data Transfer Object (DTO) that contains the name and the data</li>
<li><code>AnEventHappened</code>, which is actually an <code>Event</code> factory</li>
<li><code>EventStore</code>, a service responsible for "logging" <code>Event</code>s</li>
</ul>

<p>In this article, we're going to extract them from the <code>navigation</code> package and
put them in their own <code>event-sourcing</code> package.</p>

<h2 id="creating-the-%60event-sourcing%60-package">Creating the <code>event-sourcing</code> package</h2>

<p>We can start by creating the directory:</p>

<pre><code>git checkout -b 3-event-sourcing
mkdir -p packages/event-sourcing
cd packages/event-sourcing
</code></pre>

<p>Composer needs us to set up the package by creating a <code>composer.json</code> file:</p>

<pre><code>{
    "name": "mars-rover/event-sourcing",
    "license": "MIT",
    "type": "library",
    "description": "Mars Rover - Event Sourcing",
    "autoload": {
        "psr-4": { "MarsRover\\EventSourcing\\": "src/MarsRover/EventSourcing" }
    },
    "require": {
        "php": "^7.0"
    },
    "require-dev": {
        "memio/spec-gen": "^0.6"
    }
}
</code></pre>

<p>We've decided to use <a href="http://phpspec.net/">phpspec</a> as a test framework, and
to get the most of it we'd like to use its <a href="http://memio.github.io/spec-gen">SpecGen</a>
extension. To do so we need to create the <code>phpspec.yml.dist</code> file:</p>

<pre><code>extensions:
    Memio\SpecGen\MemioSpecGenExtension: ~
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For more information about phpspec
  <a href="/2015/08/03/phpspec.html">see this article</a>.</p>
</blockquote>

<p>Finally, we can configure this package's git by creating a <code>.gitignore</code> file:</p>

<pre><code># Configuration
/phpspec.yml

# Third Party libraries
/vendor/
/composer.lock
</code></pre>

<p>With this we've finished creating our package. We can run Composer:</p>

<pre><code>composer install --optimize-autoloader
</code></pre>

<p>That should be enough for a second commit:</p>

<pre><code>git add -A
git commit -m '3: Created Event Sourcing package'
</code></pre>

<h2 id="adding-%60event-sourcing%60-to-the-project">Adding <code>event-sourcing</code> to the project</h2>

<p>Let's go back to the project's root:</p>

<pre><code>cd ../../
</code></pre>

<p>All we need to do is to add a new line in the <code>require</code> section of our
<code>composer.json</code> file:</p>

<pre><code>{
    "name": "mars-rover/mars-rover",
    "license": "MIT",
    "type": "project",
    "description": "Mars Rover",
    "repositories": [
        {
            "type": "path",
            "url": "./packages/*"
        }
    ],
    "require": {
        "mars-rover/event-sourcing": "*@dev",
        "mars-rover/navigation": "*@dev",
        "php": "^7.0"
    },
    "require-dev": {
        "phpspec/phpspec": "^3.0@beta"
    }
}
</code></pre>

<p>Actually, we also need to add a new section in <code>phpspec.yml.dist</code>:</p>

<pre><code>suites:
    event-sourcing:
        namespace: 'MarsRover\EventSourcing'
        src_path: packages/event-sourcing/src
        spec_path: packages/event-sourcing

    navigation:
        namespace: 'MarsRover\Navigation'
        src_path: packages/navigation/src
        spec_path: packages/navigation
</code></pre>

<p>And that's it! We are now able to run Composer and then phpspec:</p>

<pre><code>composer update --optimize-autoloader
vendor/bin/phpspec run
</code></pre>

<p>That should be enough for a second commit:</p>

<pre><code>git add -A
git commit -m '3: Added event-sourcing package to main project'
</code></pre>

<h2 id="event-sourcing-files">Event Sourcing files</h2>

<p>It's now time to move Event Sourcing files from <code>navigation</code> to
<code>event-sourcing</code>:</p>

<pre><code>cd packages/event-sourcing
mkdir -p src/MarsRover/EventSourcing
mv ../navigation/src/MarsRover/Navigation/{EventStore.php,Event.php,AnEventHappened.php} ./src/MarsRover/EventSourcing/
</code></pre>

<p>We then need to change namespaces:</p>

<pre><code>sed -i 's/Navigation/EventSourcing/g' ./src/MarsRover/EventSourcing/*
</code></pre>

<p>To continue those namespace changes we'll have to move back to the <code>navigation</code>
package:</p>

<pre><code>cd ../navigation
</code></pre>

<p>Then rename the namespaces:</p>

<pre><code>sed -i 's/Navigation\\Event;/EventSourcing\\Event;/g' ./spec/MarsRover/Navigation/*
sed -i 's/Navigation\\EventStore;/EventSourcing\\EventStore;/g' ./spec/MarsRover/Navigation/*
sed -i 's/Navigation\\AnEventHappened;/EventSourcing\\AnEventHappened;/g' ./spec/MarsRover/Navigation/*
</code></pre>

<p>We'll also need to add use statements to
<code>./src/MarsRover/Navigation/LandRoverHandler.php</code>:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

use MarsRover\EventSourcing\{
    AnEventHappened,
    EventStore
};

class LandRoverHandler
{
    private $anEventHappened;
    private $eventStore;

    public function __construct(
        AnEventHappened $anEventHappened,
        EventStore $eventStore
    ) {
        $this-&gt;anEventHappened = $anEventHappened;
        $this-&gt;eventStore = $eventStore;
    }

    public function handle(LandRover $landRover)
    {
        $roverLanded = $this-&gt;anEventHappened-&gt;justNow(Events::ROVER_LANDED, [
            'x' =&gt; $landRover-&gt;getCoordinates()-&gt;getX(),
            'y' =&gt; $landRover-&gt;getCoordinates()-&gt;getY(),
            'orientation' =&gt; $landRover-&gt;getOrientation()-&gt;get(),
        ]);
        $this-&gt;eventStore-&gt;log($roverLanded);
    }
}
</code></pre>

<p>Since <code>navigation</code> now relies on <code>event-sourcing</code> classes, we need to add it in
<code>composer.json</code>:</p>

<pre><code>{
    "name": "mars-rover/navigation",
    "license": "MIT",
    "type": "library",
    "description": "Mars Rover - Navigation",
    "autoload": {
        "psr-4": { "MarsRover\\Navigation\\": "src/MarsRover/Navigation" }
    },
    "repositories": [
        {
            "type": "path",
            "url": "../*"
        }
    ],
    "require": {
        "mars-rover/event-sourcing": "*@dev",
        "php": "^7.0"
    },
    "require-dev": {
        "memio/spec-gen": "^0.6"
    }
}
</code></pre>

<p>As we can see, it's quite similar to what we've done in the project's root:
we've added a <code>repositories</code> section with the path to packages (<code>../</code>) and
then added <code>mars-rover/event-sourcing</code> to the <code>require</code> section, with the
version <code>*@dev</code> (any version, including unstable ones).</p>

<p>Let's run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! We can now succesfully commit our new package:</p>

<pre><code>cd ../../
git add -A
git commit -m '3: Moved Event Sourcing classes to their own package'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We identified <code>AnEventHappened</code>, <code>Event</code> and <code>EventStore</code> as objects that
could be in their own package, so we created <code>event-sourcing</code> and moved them
in it. This also meant we had to add this package to the project's root and to
navigation.</p>

<h2 id="what%27s-next">What's next</h2>

<p>In the next article, we'll implement <code>AnEventHappened</code> and <code>Event</code>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Landing event]]></title>
            <link href="https://gnugat.github.io/2016/07/20/mars-rover-landing-event.html"/>
            <updated>2016-07-20T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/07/20/mars-rover-landing-event.html</id>
            <content type="html"><![CDATA[<p>In this series we're going to build the software of a Mars Rover, according to
the <a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It will allow us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>Previously we've created a
<a href="/2016/06/22/mars-rover-initialization.html">navigation package</a>, and in it
a <code>LandRover</code> class that
<a href="/2016/06/29/mars-rover-landing.html">validates input parameters</a> for our
first use case:</p>

<blockquote>
  <p>Mars Rovers need first to be landed at a given position. A position is
  composed of coordinates (<code>x</code> and <code>y</code>, which are both integers) and an
  orientation (a string being one of <code>north</code>, <code>east</code>, <code>west</code> or <code>south</code>).</p>
</blockquote>

<p>We've then refactored it to extract
<a href="/2016/07/06/mars-rover-landing-coordinates.html">coordinates</a>
and <a href="/2016/07/13/mars-rover-landing-orientation.html">orientation</a>
in their own classes.</p>

<p>In this article we're going to create the actual landing logic, using
Event Sourcing:</p>

<pre><code>cd packages/navigation
git checkout 2-landing
</code></pre>

<h2 id="landroverhandler">LandRoverHandler</h2>

<p>Following our <a href="/2016/06/29/mars-rover-landing.html#twisting-command-bus">Command Bus twist</a>,
we're now going to create the <code>LandRoverHandler</code> class that's going to take
care of the actual logic associated to the <code>LandRover</code> use case. We're starting
by bootstraping the test class:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\Navigation\LandRoverHandler'
</code></pre>

<p>this should create the following
<code>spec/MarsRover/Navigation/LandRoverHandlerSpec.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\LandRoverHandler;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class LandRoverHandlerSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(LandRoverHandler::class);
    }
}
</code></pre>

<p><a href="/2016/06/15/mars-rover-introduction.html#event-sourcing">Event Sourcing</a> is
all about recording significant actions. Landing a rover seems significant
enough, so that's what <code>LandRoverHandler</code> should do:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\AnEventHappened;
use MarsRover\Navigation\Event;
use MarsRover\Navigation\EventStore;
use MarsRover\Navigation\LandRover;
use MarsRover\Navigation\Orientation;
use PhpSpec\ObjectBehavior;

class LandRoverHandlerSpec extends ObjectBehavior
{
    const X = 23;
    const Y = 42;
    const ORIENTATION = Orientation::NORTH;

    const EVENT_NAME = 'rover_landed';
    const EVENT_DATA = [
        'x' =&gt; self::X,
        'y' =&gt; self::Y,
        'orientation' =&gt; self::ORIENTATION,
    ];

    function it_lands_a_rover_at_given_location(
        AnEventHappened $anEventHappened,
        Event $roverLanded,
        EventStore $eventStore
    ) {
        $this-&gt;beConstructedWith($anEventHappened, $eventStore);
        $landRover = new LandRover(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $anEventHappened-&gt;justNow(
            self::EVENT_NAME,
            self::EVENT_DATA
        )-&gt;willReturn($roverLanded);
        $eventStore-&gt;log($roverLanded)-&gt;shouldBeCalled();

        $this-&gt;handle($landRover);
    }
}
</code></pre>

<p>In this test, we rely on:</p>

<ul>
<li><code>Event</code>, a Data Transfer Object (DTO) that contains the name and the data</li>
<li><code>AnEventHappened</code>, which is actually an <code>Event</code> factory</li>
<li><code>EventStore</code>, a service responsible for "logging" <code>Event</code>s</li>
</ul>

<p>We could have done without the factory and create directly <code>Event</code> in
<code>LandRoverHandler</code>, but then we'd have no way to check in our tests that it
was constructed with the right data.</p>

<p>Those classes don't exist yet, we've made them up to build a coherent
<strong>story</strong>. Let's run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>They fail because of the missing classes... But phpspec bootstrapped them for
us!</p>

<p>It created the <code>src/MarsRover/Navigation/AnEventHappened.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

interface AnEventHappened
{

    public function justNow($argument1, $argument2);
}
</code></pre>

<p>It also created the <code>src/MarsRover/Navigation/Event.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

interface Event
{
}
</code></pre>

<p>And it created the <code>src/MarsRover/Navigation/EventStore.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

interface EventStore
{

    public function log($argument1);
}
</code></pre>

<p>As we can see, when we reference a non existence class, phpspec generates an
interface for us. It also generates methods, if we've described method calls
in our test.</p>

<p>For now we'll leave them like this, and have a look at the generated
<code>src/MarsRover/Navigation/LandRoverHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class LandRoverHandler
{
    private $anEventHappened;

    private $eventStore;

    public function __construct(AnEventHappened $anEventHappened, EventStore $eventStore)
    {
        $this-&gt;anEventHappened = $anEventHappened;
        $this-&gt;eventStore = $eventStore;
    }

    public function handle(LandRover $landRover)
    {
    }
}
</code></pre>

<p>Thanks to the <a href="https://github.com/memio/spec-gen">SpecGen extension</a>, phpspec
was able to detect Dependency Injection, and bootstrapped a constructor with
an attribute initialization for us. How nice!</p>

<p>We'll just need to complete the <code>handle</code> method:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class LandRoverHandler
{
    const EVENT_NAME = 'rover_landed';

    private $anEventHappened;
    private $eventStore;

    public function __construct(
        AnEventHappened $anEventHappened,
        EventStore $eventStore
    ) {
        $this-&gt;anEventHappened = $anEventHappened;
        $this-&gt;eventStore = $eventStore;
    }

    public function handle(LandRover $landRover)
    {
        $roverLanded = $this-&gt;anEventHappened-&gt;justNow(self::EVENT_NAME, [
            'x' =&gt; $landRover-&gt;getCoordinates()-&gt;getX(),
            'y' =&gt; $landRover-&gt;getCoordinates()-&gt;getY(),
            'orientation' =&gt; $landRover-&gt;getOrientation()-&gt;get(),
        ]);
        $this-&gt;eventStore-&gt;log($roverLanded);
    }
}
</code></pre>

<p>Overall, the code looks very similar to the test. Let's run them:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! We might want to use the same event name in both the code and the
test, so let's create a <code>src/MarsRover/Navigation/Events.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class Events
{
    const ROVER_LANDED = 'rover_landed';
}
</code></pre>

<p>Then use it in the code:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class LandRoverHandler
{
    private $anEventHappened;
    private $eventStore;

    public function __construct(
        AnEventHappened $anEventHappened,
        EventStore $eventStore
    ) {
        $this-&gt;anEventHappened = $anEventHappened;
        $this-&gt;eventStore = $eventStore;
    }

    public function handle(LandRover $landRover)
    {
        $roverLanded = $this-&gt;anEventHappened-&gt;justNow(Events::ROVER_LANDED, [
            'x' =&gt; $landRover-&gt;getCoordinates()-&gt;getX(),
            'y' =&gt; $landRover-&gt;getCoordinates()-&gt;getY(),
            'orientation' =&gt; $landRover-&gt;getOrientation()-&gt;get(),
        ]);
        $this-&gt;eventStore-&gt;log($roverLanded);
    }
}
</code></pre>

<p>and finally in the test:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\AnEventHappened;
use MarsRover\Navigation\Event;
use MarsRover\Navigation\Events;
use MarsRover\Navigation\EventStore;
use MarsRover\Navigation\LandRover;
use MarsRover\Navigation\Orientation;
use PhpSpec\ObjectBehavior;

class LandRoverHandlerSpec extends ObjectBehavior
{
    const X = 23;
    const Y = 42;
    const ORIENTATION = Orientation::NORTH;

    const EVENT_NAME = Events::ROVER_LANDED;
    const EVENT_DATA = [
        'x' =&gt; self::X,
        'y' =&gt; self::Y,
        'orientation' =&gt; self::ORIENTATION,
    ];

    function it_lands_a_rover_at_given_location(
        AnEventHappened $anEventHappened,
        Event $roverLanded,
        EventStore $eventStore
    ) {
        $this-&gt;beConstructedWith($anEventHappened, $eventStore);
        $landRover = new LandRover(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $anEventHappened-&gt;justNow(
            self::EVENT_NAME,
            self::EVENT_DATA
        )-&gt;willReturn($roverLanded);
        $eventStore-&gt;log($roverLanded)-&gt;shouldBeCalled();

        $this-&gt;handle($landRover);
    }
}
</code></pre>

<p>We can run the tests one last time:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>Still green! We can commit our work:</p>

<pre><code>git add -A
git commit -m '2: Created LandRoverHandler'
git checkout master
git merge --no-ff 2-landing
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>With Event Sourcing, the logic associated to our "Landing a Rover on Mars" use
case is quite simple: we just record it as an event.</p>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>In the next article, we'll extract Event Sourcing logic from the <code>navigation</code>
package and put it in its own <code>event-sourcing</code> one.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Landing orientation]]></title>
            <link href="https://gnugat.github.io/2016/07/13/mars-rover-landing-orientation.html"/>
            <updated>2016-07-13T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/07/13/mars-rover-landing-orientation.html</id>
            <content type="html"><![CDATA[<p>In this series we're going to build the software of a Mars Rover, according to
the <a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It will allow us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>Previously we've created a
<a href="/2016/06/22/mars-rover-initialization.html">navigation package</a>, and in it
a <code>LandRover</code> class that
<a href="/2016/06/29/mars-rover-landing.html">validates input parameters</a> for our
first use case:</p>

<blockquote>
  <p>Mars Rovers need first to be landed at a given position. A position is
  composed of coordinates (<code>x</code> and <code>y</code>, which are both integers) and an
  orientation (a string being one of <code>north</code>, <code>east</code>, <code>west</code> or <code>south</code>).</p>
</blockquote>

<p>We've also started to refactor it by
<a href="/2016/07/06/mars-rover-landing-coordinates.html">extracting coordinates in their own class</a>.</p>

<p>In this article we're going to further refactor <code>LandRover</code>:</p>

<pre><code>cd packages/navigation
git checkout 2-landing
</code></pre>

<h2 id="responsibilities">Responsibilities</h2>

<p>By having a look at <code>LandRover</code>, we can guess that it has 2 reasons to change:</p>

<ul>
<li>coordinates <code>x</code> and <code>y</code> might become floats, or have an additional <code>z</code></li>
<li>orientation might become an angular degree, or have a vertical orientation</li>
</ul>

<p>This hints toward two new classes, extracted from <code>LandRover</code>: <code>Coordinates</code>
and <code>Orientation</code>. In this article we'll take care of <code>Orientation</code>.</p>

<h2 id="orientation">Orientation</h2>

<p>Let's start by bootstraping <code>Orientation</code> test class using
<a href="http://www.phpspec.net/en/stable/">phpspec</a>:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\Navigation\Orientation'
</code></pre>

<p>It should create the <code>spec/MarsRover/Navigation/OrientationSpec.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\Orientation;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class OrientationSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(self::class);
    }
}
</code></pre>

<p>Instead of reusing tests from <code>LandRover</code>, we'll try to describe all the
possible orientations:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use PhpSpec\ObjectBehavior;

class OrientationSpec extends ObjectBehavior
{
    const NORTH = 'north';
    const EAST = 'east';
    const WEST = 'west';
    const SOUTH = 'south';

    function it_can_face_north()
    {
        $this-&gt;beConstructedWith(self::NORTH);

        $this-&gt;get()-&gt;shouldBe(self::NORTH);
    }

    function it_can_face_east()
    {
        $this-&gt;beConstructedWith(self::EAST);

        $this-&gt;get()-&gt;shouldBe(self::EAST);
    }

    function it_can_face_west()
    {
        $this-&gt;beConstructedWith(self::WEST);

        $this-&gt;get()-&gt;shouldBe(self::WEST);
    }

    function it_can_face_south()
    {
        $this-&gt;beConstructedWith(self::SOUTH);

        $this-&gt;get()-&gt;shouldBe(self::SOUTH);
    }

    function it_cannot_face_anywhere_else()
    {
        $this-&gt;beConstructedWith('Somehwere else');

        $this
            -&gt;shouldThrow(\InvalidArgumentException::class)
            -&gt;duringInstantiation()
        ;
    }
}
</code></pre>

<p>Now we can run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>They fail because <code>src/MarsRover/Navigation/Orientation.php</code> doesn't exist,
so phpspec bootstrapped it for us:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class Orientation
{
    private $argument;

    public function __construct($argument)
    {
        $this-&gt;argument = $argument;
    }

    public function get()
    {
    }
}
</code></pre>

<p>We can edit it:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class Orientation
{
    const NORTH = 'north';
    const EAST = 'east';
    const WEST = 'west';
    const SOUTH = 'south';

    const ALLOWED_ORIENTATIONS = [
        self::NORTH,
        self::EAST,
        self::WEST,
        self::SOUTH,
    ];

    private $orientation;

    public function __construct($orientation)
    {
        if (false === in_array($orientation, self::ALLOWED_ORIENTATIONS, true)) {
            throw new \InvalidArgumentException(
                'Orientation must be one of: '
                .implode(', ', self::ALLOWED_ORIENTATIONS)
            );
        }
        $this-&gt;orientation = $orientation;
    }

    public function get() : string
    {
        return $this-&gt;orientation;
    }
}
</code></pre>

<p>And run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! It's important to note that tests should also be refactored.
We're going to use <code>Orientation</code> constants in the tests:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\Orientation;
use PhpSpec\ObjectBehavior;

class OrientationSpec extends ObjectBehavior
{
    function it_can_face_north()
    {
        $this-&gt;beConstructedWith(Orientation::NORTH);

        $this-&gt;get()-&gt;shouldBe(Orientation::NORTH);
    }

    function it_can_face_east()
    {
        $this-&gt;beConstructedWith(Orientation::EAST);

        $this-&gt;get()-&gt;shouldBe(Orientation::EAST);
    }

    function it_can_face_west()
    {
        $this-&gt;beConstructedWith(Orientation::WEST);

        $this-&gt;get()-&gt;shouldBe(Orientation::WEST);
    }

    function it_can_face_south()
    {
        $this-&gt;beConstructedWith(Orientation::SOUTH);

        $this-&gt;get()-&gt;shouldBe(Orientation::SOUTH);
    }

    function it_cannot_face_anywhere_else()
    {
        $this-&gt;beConstructedWith('Somehwere else');

        $this
            -&gt;shouldThrow(\InvalidArgumentException::class)
            -&gt;duringInstantiation()
        ;
    }
}
</code></pre>

<p>Running the tests again:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>Still green! We can now update <code>LandRover</code> tests to use <code>Orientation</code>:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\Orientation;
use PhpSpec\ObjectBehavior;

class LandRoverSpec extends ObjectBehavior
{
    const X = 23;
    const Y = 42;
    const ORIENTATION = Orientation::NORTH;

    function it_has_coordinates()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $coordinates = $this-&gt;getCoordinates();
        $coordinates-&gt;getX()-&gt;shouldBe(self::X);
        $coordinates-&gt;getY()-&gt;shouldBe(self::Y);
    }

    function it_has_an_orientation()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $this-&gt;getOrientation()-&gt;get()-&gt;shouldBe(self::ORIENTATION);
    }
}
</code></pre>

<p>We've removed orientation checking from <code>LandRover</code> tests, as we now trust
<code>Orientation</code> to do the job. Now We can use <code>Orientation</code> in <code>LandRover</code>:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class LandRover
{
    private $coordinates;
    private $orientation;

    public function __construct($x, $y, $orientation)
    {
        $this-&gt;coordinates = new Coordinates($x, $y);
        $this-&gt;orientation = new Orientation($orientation);
    }

    public function getCoordinates() : Coordinates
    {
        return $this-&gt;coordinates;
    }

    public function getOrientation() : Orientation
    {
        return $this-&gt;orientation;
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! We can now commit our work:</p>

<pre><code>git add -A
git commit -m '2: Created Orientation'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Once again we've completed the full TDD cycle: first test, then code and
finally refactor.</p>

<p>Before we started to extract <code>Coordinates</code> and <code>Orientation</code>, <code>LandRover</code> tests
were starting to get long and so we didn't bother to go too much into details.
This refactoring allowed us to get more confidence and add more testing cases.</p>

<p>phpspec has been really helpful by boostraping tests, and then when running the
tests by bootstraping code: it makes the whole TDD cycle more natural. But
it also allows us to have runnable self-checking specifications:</p>

<pre><code>vendor/bin/phpspec run --format=pretty
</code></pre>

<p>This should now output:</p>

<pre><code><br />      MarsRover\Navigation\Coordinates

  12  ✔ has x coordinate
  22  ✔ cannot have non integer x coordinate
  34  ✔ has y coordinate
  44  ✔ cannot have non integer y coordinate

      MarsRover\Navigation\LandRover

  14  ✔ has coordinates
  27  ✔ has an orientation

      MarsRover\Navigation\Orientation

  10  ✔ can face north
  17  ✔ can face east
  24  ✔ can face west
  31  ✔ can face south
  38  ✔ cannot face anywhere else


3 specs
11 examples (11 passed)
12ms
</code></pre>

<h2 id="what%27s-next">What's next</h2>

<p>In the next article we'll create the actual landing logic, using Event Sourcing.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Landing coordinates]]></title>
            <link href="https://gnugat.github.io/2016/07/06/mars-rover-landing-coordinates.html"/>
            <updated>2016-07-06T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/07/06/mars-rover-landing-coordinates.html</id>
            <content type="html"><![CDATA[<p>In this series we're going to build the software of a Mars Rover, according to
the <a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It will allow us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>Previously we've created a
<a href="/2016/06/22/mars-rover-initialization.html">navigation package</a>, and in it
a <code>LandRover</code> class that
<a href="/2016/06/29/mars-rover-landing.html">validates input parameters</a> for our
first use case:</p>

<blockquote>
  <p>Mars Rovers need first to be landed at a given position. A position is
  composed of coordinates (<code>x</code> and <code>y</code>, which are both integers) and an
  orientation (a string being one of <code>north</code>, <code>east</code>, <code>west</code> or <code>south</code>).</p>
</blockquote>

<p>In this article we're going to refactor <code>LandRover</code>:</p>

<pre><code>cd packages/navigation
git checkout 2-landing
</code></pre>

<h2 id="responsibilities">Responsibilities</h2>

<p>By having a look at <code>LandRover</code>, we can guess that it has 2 reasons to change:</p>

<ul>
<li>coordinates <code>x</code> and <code>y</code> might become floats, or have an additional <code>z</code></li>
<li>orientation might become an angular degree, or have a vertical orientation</li>
</ul>

<p>This hints toward two new classes, extracted from <code>LandRover</code>: <code>Coordinates</code>
and <code>Orientation</code>. In this article we'll take care of <code>Coordinates</code>.</p>

<h2 id="coordinates">Coordinates</h2>

<p>First let's bootstrap the test class, using
<a href="http://www.phpspec.net/en/stable/">phpspec</a>:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\Navigation\Coordinates'
</code></pre>

<p>This will create the <code>spec/MarsRover/Navigation/CoordinatesSpec.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\Coordinates;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class CoordinatesSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(Coordinates::class);
    }
}
</code></pre>

<p>We can edit it, by using what we've done in <code>LandRover</code> test class:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use PhpSpec\ObjectBehavior;

class CoordinatesSpec extends ObjectBehavior
{
    const X = 23;
    const Y = 42;

    function it_has_x_coordinate()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y
        );

        $this-&gt;getX()-&gt;shouldBe(self::X);
    }

    function it_cannot_have_non_integer_x_coordinate()
    {
        $this-&gt;beConstructedWith(
            'Nobody expects the Spanish Inquisition!',
            self::Y
        );

        $this-&gt;shouldThrow(
            \InvalidArgumentException::class
        )-&gt;duringInstantiation();
    }

    function it_has_y_coordinate()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y
        );

        $this-&gt;getY()-&gt;shouldBe(self::Y);
    }

    function it_cannot_have_non_integer_y_coordinate()
    {
        $this-&gt;beConstructedWith(
            self::X,
            'No one expects the Spanish Inquisition!'
        );

        $this-&gt;shouldThrow(
            \InvalidArgumentException::class
        )-&gt;duringInstantiation();
    }
}
</code></pre>

<p>If we run the tests now, it will bootsrap the <code>Coordinates</code> class:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>And it indeed created the <code>src/MarsRover/Navigation/Coordinates.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class Coordinates
{
    private $argument1;

    private $argument2;

    public function __construct($argument1, $argument2)
    {
        $this-&gt;argument1 = $argument1;
        $this-&gt;argument2 = $argument2;
    }

    public function getX()
    {
    }

    public function getY()
    {
    }
}
</code></pre>

<p>This leaves us with the task of completing it, reusing what's been done in
<code>LandRover</code> class:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class Coordinates
{
    private $x;
    private $y;

    public function __construct($x, $y)
    {
        if (false === is_int($x)) {
            throw new \InvalidArgumentException(
                'X coordinate must be an integer'
            );
        }
        $this-&gt;x = $x;
        if (false === is_int($y)) {
            throw new \InvalidArgumentException(
                'Y coordinate must be an integer'
            );
        }
        $this-&gt;y = $y;
    }

    public function getX() : int
    {
        return $this-&gt;x;
    }

    public function getY() : int
    {
        return $this-&gt;y;
    }
}
</code></pre>

<p>We can run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! Now all we have to do is update <code>LandRover</code> test class to use
<code>Coordinates</code>:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use PhpSpec\ObjectBehavior;

class LandRoverSpec extends ObjectBehavior
{
    const X = 23;
    const Y = 42;
    const ORIENTATION = 'north';

    function it_has_coordinates()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $coordinates = $this-&gt;getCoordinates();
        $coordinates-&gt;getX()-&gt;shouldBe(self::X);
        $coordinates-&gt;getY()-&gt;shouldBe(self::Y);
    }

    function it_has_an_orientation()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $this-&gt;getOrientation()-&gt;shouldBe(self::ORIENTATION);
    }

    function it_cannot_have_a_non_cardinal_orientation()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            'A hareng!'
        );

        $this-&gt;shouldThrow(
            \InvalidArgumentException::class
        )-&gt;duringInstantiation();
    }
}
</code></pre>

<p>We no longer need to check for invalid <code>x</code> and <code>y</code> values, as we trust
<code>Coordinates</code> to take care of them for us. We can now update <code>LandRover</code> class:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class LandRover
{
    const VALID_ORIENTATIONS = ['north', 'east', 'west', 'south'];

    private $coordinates;
    private $orientation;

    public function __construct($x, $y, $orientation)
    {
        $this-&gt;coordinates = new Coordinates($x, $y);
        if (false === in_array($orientation, self::VALID_ORIENTATIONS, true)) {
            throw new \InvalidArgumentException(
                'Orientation must be one of: '
                .implode(', ', self::VALID_ORIENTATIONS)
            );
        }
        $this-&gt;orientation = $orientation;
    }

    public function getCoordinates() : Coordinates
    {
        return $this-&gt;coordinates;
    }

    public function getOrientation() : string
    {
        return $this-&gt;orientation;
    }
}
</code></pre>

<p>And that should make our test pass:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! That's enough for us to commit our work:</p>

<pre><code>git add -A
git commit -m '2: Created Coordinates'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We've followed the full cycle of TDD: test, code and refactor. Using phpspec
has been really helpful as it bootstraped the test classes and then their code
classes for us.</p>

<h2 id="what%27s-next">What's next</h2>

<p>In the next article, we'll extract <code>Orientation</code> from <code>LandRover</code>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Landing]]></title>
            <link href="https://gnugat.github.io/2016/06/29/mars-rover-landing.html"/>
            <updated>2016-06-29T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/06/29/mars-rover-landing.html</id>
            <content type="html"><![CDATA[<p>In this series we're going to build the software of a Mars Rover, according to
the <a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It will allow us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>Previously we've created a
<a href="/2016/06/22/mars-rover-initialization.html">navigation package</a>, we can now
start developing the first use case:</p>

<blockquote>
  <p>Mars Rovers need first to be landed at a given position. A position is
  composed of coordinates (<code>x</code> and <code>y</code>, which are both integers) and an
  orientation (a string being one of <code>north</code>, <code>east</code>, <code>west</code> or <code>south</code>).</p>
</blockquote>

<h2 id="twisting-command-bus">Twisting Command Bus</h2>

<p>The <a href="/2016/05/11/towards-cqrs-command-bus.md">Command Bus design pattern</a>
is composed of 3 classes:</p>

<ul>
<li>a <code>Command</code> class which validates use case input and with a name that
communicates imperative intention (e.g. <code>LandRover</code>)</li>
<li>associated to it (one to one relationship) is the <code>CommandHandler</code>,
which does the actual logic for the use case</li>
<li>a <code>CommandBus</code> that takes a <code>Command</code> and executes the appropriate
<code>CommandHandler</code>, and that allows for middlewares</li>
</ul>

<p>We're going to twist this design pattern for the Mars Rover by omiting the
<code>CommandBus</code> class, as we don't really need middlewares or to find the
appropriate <code>CommandHandler</code> for a given <code>Command</code>.</p>

<p>Let's start by creating the <code>Command</code> class that'll take care of the input
parameter validation:</p>

<pre><code>cd packages/navigation
git checkout -b 2-landing
</code></pre>

<h2 id="land-rover">Land Rover</h2>

<p>We're going to bootstrap the test class for <code>LandRover</code>, using
<a href="http://www.phpspec.net/en/stable/">phpspec</a>:</p>

<pre><code>vendor/bin/phpspec describe 'MarsRover\Navigation\LandRover'
</code></pre>

<p>This should generate this <code>spec/MarsRover/Navigation/LandRoverSpec.php</code> class:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use MarsRover\Navigation\LandRover;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class LandRoverSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType(LandRover::class);
    }
}
</code></pre>

<p>This leaves us the task of editing it to start describing input parameters:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use PhpSpec\ObjectBehavior;

class LandRoverSpec extends ObjectBehavior
{
    const X = 23;
    const Y = 42;
    const ORIENTATION = 'north';

    function it_has_x_coordinate()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $this-&gt;getX()-&gt;shouldBe(self::X);
    }

    function it_has_y_coordinate()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $this-&gt;getY()-&gt;shouldBe(self::Y);
    }

    function it_has_an_orientation()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $this-&gt;getOrientation()-&gt;shouldBe(self::ORIENTATION);
    }
}
</code></pre>

<p>We can now run the tests:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>This will generate the <code>src/MarsRover/Navigation/LandRover.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class LandRover
{
    private $argument1;

    private $argument2;

    private $argument3;

    public function __construct($argument1, $argument2, $argument3)
    {
        $this-&gt;argument1 = $argument1;
        $this-&gt;argument2 = $argument2;
        $this-&gt;argument3 = $argument3;
    }

    public function getX()
    {
    }

    public function getY()
    {
    }

    public function getOrientation()
    {
    }
}
</code></pre>

<p>All we need to do is to edit it:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class LandRover
{
    private $x;
    private $y;
    private $orientation;

    public function __construct($x, $y, $orientation)
    {
        $this-&gt;x = $x;
        $this-&gt;y = $y;
        $this-&gt;orientation = $orientation;
    }

    public function getX() : int
    {
        return $this-&gt;x;
    }

    public function getY() : int
    {
        return $this-&gt;y;
    }

    public function getOrientation() : string
    {
        return $this-&gt;orientation;
    }
}
</code></pre>

<p>Let's run the tests again:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! But our job isn't finished yet, we haven't described invalid input
parameters:</p>

<pre><code class="php">&lt;?php

namespace spec\MarsRover\Navigation;

use PhpSpec\ObjectBehavior;

class LandRoverSpec extends ObjectBehavior
{
    const X = 23;
    const Y = 42;
    const ORIENTATION = 'north';

    function it_has_x_coordinate()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $this-&gt;getX()-&gt;shouldBe(self::X);
    }

    function it_cannot_have_non_integer_x_coordinate()
    {
        $this-&gt;beConstructedWith(
            'Nobody expects the Spanish Inquisition!',
            self::Y,
            self::ORIENTATION
        );

        $this-&gt;shouldThrow(
            \InvalidArgumentException::class
        )-&gt;duringInstantiation();
    }

    function it_has_y_coordinate()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $this-&gt;getY()-&gt;shouldBe(self::Y);
    }

    function it_cannot_have_non_integer_y_coordinate()
    {
        $this-&gt;beConstructedWith(
            self::X,
            'No one expects the Spanish Inquisition!',
            self::ORIENTATION
        );

        $this-&gt;shouldThrow(
            \InvalidArgumentException::class
        )-&gt;duringInstantiation();
    }

    function it_has_an_orientation()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            self::ORIENTATION
        );

        $this-&gt;getOrientation()-&gt;shouldBe(self::ORIENTATION);
    }

    function it_cannot_have_a_non_cardinal_orientation()
    {
        $this-&gt;beConstructedWith(
            self::X,
            self::Y,
            'A hareng!'
        );

        $this-&gt;shouldThrow(
            \InvalidArgumentException::class
        )-&gt;duringInstantiation();
    }
}
</code></pre>

<p>Running the tests again:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>They fail, because we need to check input parameters:</p>

<pre><code class="php">&lt;?php

namespace MarsRover\Navigation;

class LandRover
{
    const VALID_ORIENTATIONS = ['north', 'east', 'west', 'south'];

    private $x;
    private $y;
    private $orientation;

    public function __construct($x, $y, $orientation)
    {
        if (false === is_int($x)) {
            throw new \InvalidArgumentException(
                'X coordinate must be an integer'
            );
        }
        $this-&gt;x = $x;
        if (false === is_int($y)) {
            throw new \InvalidArgumentException(
                'Y coordinate must be an integer'
            );
        }
        $this-&gt;y = $y;
        if (false === in_array($orientation, self::VALID_ORIENTATIONS, true)) {
            throw new \InvalidArgumentException(
                'Orientation must be one of: '
                .implode(', ', self::VALID_ORIENTATIONS)
            );
        }
        $this-&gt;orientation = $orientation;
    }

    public function getX() : int
    {
        return $this-&gt;x;
    }

    public function getY() : int
    {
        return $this-&gt;y;
    }

    public function getOrientation() : string
    {
        return $this-&gt;orientation;
    }
}
</code></pre>

<p>Let's run the tests again:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>All green! We can now commit our work:</p>

<pre><code>git add -A
git commit -m '2: Created LandRover'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We've followed the first steps of TDD: write a test then write the code.</p>

<p>Using phpspec makes this process easier as the code gets bootstrapped for us
once we've written the test.</p>

<p>Since we write those tests first, in a descriptive way (test method names
are sentences), we can use them as runnable self-checking specifications!
phpspec allows us to display them explicitly:</p>

<pre><code>vendor/bin/phpspec run --format=pretty
</code></pre>

<p>This should display:</p>

<pre><code><br />      MarsRover\Navigation\LandRover

  13  ✔ has x coordinate
  24  ✔ cannot have non integer x coordinate
  37  ✔ has y coordinate
  48  ✔ cannot have non integer y coordinate
  61  ✔ has an orientation
  72  ✔ cannot have a non cardinal orientation


1 specs
6 examples (6 passed)
10ms
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <code>navigation</code> tests can also be run from the MonoRepo:</p>

<pre><code>cd ../../
composer update --optimize-autoloader
vendor/bin/phpspec run
</code></pre>
</blockquote>

<h2 id="what%27s-next">What's next</h2>

<p>In the next article we'll complete the TDD cycle by refactoring <code>LandRover</code>:
we'll extract <code>x</code> and <code>y</code> coordinates into their own class.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Mars Rover, Initialization]]></title>
            <link href="https://gnugat.github.io/2016/06/22/mars-rover-initialization.html"/>
            <updated>2016-06-22T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2016/06/22/mars-rover-initialization.html</id>
            <content type="html"><![CDATA[<p>In this series we're going to build the software of a Mars Rover, according to
the <a href="/2016/06/15/mars-rover-introduction.html">following specifications</a>.
It will allow us to practice the followings:</p>

<ul>
<li>Monolithic Repositories (MonoRepo)</li>
<li>Command / Query Responsibility Segregation (CQRS)</li>
<li>Event Sourcing (ES)</li>
<li>Test Driven Development (TDD)</li>
</ul>

<p>But first, we need to initialize our project.</p>

<h2 id="creating-the-repository">Creating the repository</h2>

<p>Let's start by creating a new git repository:</p>

<pre><code>mkdir rover
cd rover
git init
</code></pre>

<p>Since we're going to use <a href="https://getcomposer.org/">Composer</a>, we can create
a <code>composer.json</code> file:</p>

<pre><code>{
    "name": "mars-rover/mars-rover",
    "license": "MIT",
    "type": "project",
    "description": "Mars Rover",
    "require": {
        "php": "^7.0"
    }
}
</code></pre>

<p>We're then going to ignore some third party library related stuff by
creating <code>.gitignore</code>:</p>

<pre><code># Third Party libraries
/vendor/
</code></pre>

<p>With this we've finished creating our repository. We can run composer:</p>

<pre><code>composer install --optimize-autoloader
</code></pre>

<p>That should be enough for a first commit:</p>

<pre><code>git add composer.json .gitignore
git commit -m '0: Created project'
</code></pre>

<h2 id="creating-the-%60navigation%60-package">Creating the <code>navigation</code> package</h2>

<p>By having a look at the <a href="/2016/06/15/mars-rover-introduction.html#identifying-use-cases">use cases</a>,
we can see that there's going to be "write-only" dedicated ones and "read-only"
dedicated ones:</p>

<ol>
<li>Landing a Rover on Mars: is write only</li>
<li>Driving a Rover: is write only</li>
<li>Requesting the Rover's location: is read only</li>
</ol>

<p>Since we'd like to follow the CQRS principle, we'll put the "write-only"
logic in a different package than the "read-only" logic. Landing and Driving
is all about navigation, so we'll create a <code>navigation</code> package:</p>

<pre><code>git checkout -b 1-navigation
mkdir -p packages/navigation
cd packages/navigation
</code></pre>

<p>Composer needs us to set up the package by creating a <code>composer.json</code> file:</p>

<pre><code>{
    "name": "mars-rover/navigation",
    "license": "MIT",
    "type": "library",
    "description": "Mars Rover - Navigation",
    "autoload": {
        "psr-4": { "MarsRover\\Navigation\\": "src/MarsRover/Navigation" }
    },
    "require": {
        "php": "^7.0"
    },
    "require-dev": {
        "memio/spec-gen": "^0.6"
    }
}
</code></pre>

<p>We've decided to use <a href="http://phpspec.net/">phpspec</a> as a test framework, and
to get the most of it we'd like to use its <a href="http://memio.github.io/spec-gen">SpecGen</a>
extension. To do so we need to create the <code>phpspec.yml.dist</code> file:</p>

<pre><code>extensions:
    Memio\SpecGen\MemioSpecGenExtension: ~
</code></pre>

<blockquote>
  <p><strong>Note</strong>: For more information about phpspec
  <a href="/2015/08/03/phpspec.html">see this article</a>.</p>
</blockquote>

<p>Finally, we can configure this package's git by creating a <code>.gitignore</code> file:</p>

<pre><code># Configuration
/phpspec.yml

# Third Party libraries
/vendor/
/composer.lock
</code></pre>

<p>With this we've finished creating our package. We can run Composer:</p>

<pre><code>composer install --optimize-autoloader
</code></pre>

<p>That should be enough for a second commit:</p>

<pre><code>git add -A
git commit -m '1: Created Navigation package'
</code></pre>

<h2 id="adding-%60navigation%60-to-the-project">Adding <code>navigation</code> to the project</h2>

<p>Let's go back to the project's root:</p>

<pre><code>cd ../../
</code></pre>

<p>One benefit of MonoRepos is to be able to run all packages tests in one
command. To do so, we need to require <code>navigation</code> in our project's
<code>composer.json</code> file:</p>

<pre><code>{
    "name": "mars-rover/mars-rover",
    "license": "MIT",
    "type": "project",
    "description": "Mars Rover",
    "repositories": [
        {
            "type": "path",
            "url": "./packages/*"
        }
    ],
    "require": {
        "mars-rover/navigation": "*@dev",
        "php": "^7.0"
    }
}
</code></pre>

<p>By default, Composer looks for packages only in <a href="https://packagist.org/">Packagist</a>.
By adding the new <code>repositories</code> section we can tell it to also check locally
in <code>./packages</code>, allowing us to add them in the <code>require</code> section.</p>

<p>Composer needs us to tell it what version of the package we'd like, but in
MonoRepos all packages share the same version, so we simply use <code>*</code> (any).
But to be able to use the latest changes, and not only the tagged one, we
have to specify the development stability (<code>@dev</code>).</p>

<p>Since we've decided to use phpspec for our test, we're also going to need to
require it in the project's development dependencies:</p>

<pre><code>composer require --dev phpspec/phpspec:^3.0
</code></pre>

<p>By default phpspec is going to look for test in the project's root. We need to
create a <code>phpspec.yml.dist</code> file to tell it to use <code>navigation</code>'s ones:</p>

<pre><code>suites:
    navigation:
        namespace: 'MarsRover\Navigation'
        src_path: packages/navigation/src
        spec_path: packages/navigation
</code></pre>

<p>We'll also update <code>.gitignore</code> to ignore local configuration:</p>

<pre><code># Configuration
/phpspec.yml

# Third Party libraries
/vendor/
</code></pre>

<p>And that's it! We are now able to run Composer and then phpspec:</p>

<pre><code>composer update --optimize-autoloader
./vendor/bin/phpspec run
</code></pre>

<p>That should be enough for a last commit:</p>

<pre><code>git add -A
git commit -m '1: Added navigation package to main project'
</code></pre>

<p>Let's merge it to master:</p>

<pre><code>git checkout master
git merge --no-ff 1-navigation
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>With Composer we can create many packages inside a single repository. With this
MonoRepo, we can then execute all the tests in one command.</p>

<h2 id="what%27s-next">What's next</h2>

<p>In the next article we'll tackle down the "Landing a Rover on Mars" use case,
allowing us to showcase an example of Event Sourcing and TDD.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Decouple from Libraries]]></title>
            <link href="https://gnugat.github.io/2015/10/12/decouple-from-libraries.html"/>
            <updated>2015-10-12T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2015/10/12/decouple-from-libraries.html</id>
            <content type="html"><![CDATA[<p>Libraries are similar to frameworks: they solve infrastructure problems (e.g.
requesting remote endpoints or querying databases). They also don't directly
add any value to our projects: the business need will not be fulfilled by
connecting to a database.</p>

<p>They also share the same Backward Compatibility (BC) break issue, since they will
change to solve their own concerns, regardless of our projects.</p>

<p>Here's a true story with <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>: we
started to use version 2 in our project and spread direct calls to it in different places.
After a while we've decided to use <a href="http://flysystem.thephpleague.com/">Flysystem</a>
and its <a href="http://aws.amazon.com/sdkforphp">SDK for Amazon S3</a> but we had a problem:
it required Guzzle 3.
This means tracking down every usage of Guzzle in the project and adapting the
calls to the new version. It's a dawnting task, especially when the project doesn't
have strong enough tests.</p>

<p>Later on, when Amazon S3 SDK stabilized, it started to require Guzzle 5...</p>

<p><a href="http://knowyourmeme.com/memes/rage-guy-fffffuuuuuuuu"><img src="http://i0.kym-cdn.com/photos/images/newsfeed/000/000/578/1234931504682.jpg" alt="Screaming with anger" /></a></p>

<p>Does that mean that we shouldn't use any libraries? Should we just don't care and
continue to use them in the same way?</p>

<p>This article will explain how to avoid both extremes, by decoupling from the library.
It can be done by using the Inversion of Control principle: instead of relying
on the library we rely on interfaces and provide an implementation that uses the library.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>In <a href="/2015/09/30/decouple-from-frameworks.html">the previous article</a>,
we started to create an endpoint allowing us to subit new quotes for a
<a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a> application.</p>

<p>We're now going to create a SDK for it:</p>

<pre><code>mkdir fortune-sdk
cd fortune-sdk
</code></pre>

<p>To do so, we'll create the <code>composer.json</code> file:</p>

<pre><code>{
    "name": "acme/fortune-sdk",
    "description": "A PHP SDK for Fortune",
    "type": "library",
    "license": "MIT",
    "autoload": {
        "psr-4": {
            "Acme\\FortuneSdk\\": "src/Acme/FortuneSdk"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "Acme\\FortuneSdk\\Fixtures\\": "fixtures",
            "Acme\\FortuneSdk\\Tests\\": "tests"
        }
    },
    "require": {
        "php": "&gt;=5.4",
    },
    "require-dev": {
        "phpspec/phpspec": "^2.3",
        "phpunit/phpunit": "^4.5",
        "symfony/console": "^2.3",
        "symfony/yaml": "^2.2"
    }
}
</code></pre>

<p>Then create a test script:</p>

<pre><code>#!/usr/bin/env sh

# bin/test.sh

composer --quiet --no-interaction update --optimize-autoloader &gt; /dev/null

vendor/bin/phpspec --no-interaction run -f dot &amp;&amp; vendor/bin/phpunit
</code></pre>

<p>And finally configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/4.1/en/appendixes.configuration.html --&gt;
&lt;phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://schema.phpunit.de/4.1/phpunit.xsd"
         backupGlobals="false"
         colors="true"
         bootstrap="vendor/autoload.php"
&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="Fortune SDK Test Suite"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="request-handler">Request Handler</h2>

<p>Since Guzzle might completly change next year, we're going to abstract it behind
our own HTTP client:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Remote/RequestHandler.php

namespace Acme\FortuneSdk\Remote;

use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;

interface RequestHandler
{
    /**
     * @param RequestInterface $request
     *
     * @return ResponseInterface
     *
     * @throws ClientException If client throws an unexpected exception (e.g. connection error, etc)
     */
    public function handle(RequestInterface $request);
}
</code></pre>

<p>We've decided to use the new PSR-7 standard:</p>

<pre><code>composer require psr/http-message:^1.0
</code></pre>

<p>We'll hide any errors behind our own exception:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Remote/ClientException.php

namespace Acme\FortuneSdk\Remote;

use RuntimeException;

class ClientException extends RuntimeException
{
}
</code></pre>

<p>Its first implementation will be with Guzzle 6:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Remote/RequestHandler/GuzzleSixRequestHandler.php

namespace Acme\FortuneSdk\Remote\RequestHandler;

use Acme\FortuneSdk\Remote\ClientException;
use Acme\FortuneSdk\Remote\RequestHandler;
use Exception;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\BadResponseException;
use Psr\Http\Message\RequestInterface;

class GuzzleSixRequestHandler implements RequestHandler
{
    private $client;

    public function __construct(Client $client)
    {
        $this-&gt;client = $client;
    }

    public function handle(RequestInterface $request)
    {
        try {
            return $this-&gt;client-&gt;send($request);
        } catch (BadResponseException $e) {
            return $e-&gt;getResponse();
        } catch (Exception $e) {
            throw new ClientException('Client threw an unexpected exception', 0, $e);
        }
    }
}
</code></pre>

<p>And that's it. When Guzzle 7 will be released, we'll just have to create a new
implementation and throw away the old one instead of having to replace it everywhere
in our project. We can even change our mind and use a completly different HTTP client
(Buzz, etc).</p>

<p>Since we've started to softly depend on Guzzle, we need to install it with Composer:</p>

<pre><code>composer require guzzlehttp/guzzle:^6.0
</code></pre>

<h2 id="functional-test">Functional test</h2>

<p>We can now create a functional test describing our service:</p>

<pre><code class="php">&lt;?php

// tests/Quote/SubmitNewQuoteTest.php

namespace Acme\FortuneSdk\Tests\Quote;

use Acme\FortuneSdk\Quote\SubmitNewQuote\RemoteSubmitNewQuote;
use Acme\FortuneSdk\Fixtures\FixturesRequestHandler;
use PHPUnit_Framework_TestCase;

class SubmitNewQuoteTest extends PHPUnit_Framework_TestCase
{
    const URL = 'http://example.com';
    const QUOTE = 'Nobody expects the Spanish Inquisition!';

    private $submitNewQuote;

    protected function setUp()
    {
        $requestHandler = new FixturesRequestHandler();
        $this-&gt;submitNewQuote = new RemoteSubmitNewQuote($requestHandler, self::URL);
    }

    /**
     * @test
     */
    public function it_can_submit_a_new_quote()
    {
        $quote = $this-&gt;submitNewQuote-&gt;submit(self::QUOTE);

        self::assertSame(self::QUOTE, $quote['quote']);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>sh ./bin/test.sh
</code></pre>

<p>It fails because <code>FixturesRequestHandler</code> doesn't exist. It's an implementation
of <code>RequestHandler</code> designed for our tests: even if the endpoint actually existed,
relying on network calls in our tests would only make them brittle
(because it's slow and unreliable).</p>

<p>Let's create it:</p>

<pre><code class="php">&lt;?php

// fixtures/FixturesRequestHandler.php

namespace Acme\FortuneSdk\Fixtures;

use Acme\FortuneSdk\Remote\RequestHandler;
use Psr\Http\Message\RequestInterface;
use Zend\Diactoros\Response;
use Zend\Diactoros\Stream;

class FixturesRequestHandler implements RequestHandler
{
    private $routes;

    public function __construct()
    {
        $this-&gt;routes = array(
            array(
                'controller' =&gt; new Controller\Quote\SubmitNewQuoteController(),
                'pattern' =&gt; '#/quotes#',
                'methods' =&gt; array('POST'),
            ),
        );
    }

    public function handle(RequestInterface $request)
    {
        $path = $request-&gt;getUri()-&gt;getPath();
        $method = $request-&gt;getMethod();
        foreach ($this-&gt;routes as $route) {
            if (1 === preg_match($route['pattern'], $path)) {
                if (false === in_array($method, $route['methods'], true)) {
                    $body = new Stream('php://temp', 'w');
                    $body-&gt;write(json_encode(array(
                        'message' =&gt; "Method \"$method\" for route \"$path\" not supported (supported methods are: ".implode(', ', $route['methods']).")",
                    )));

                    return new Response($body, 405, array('Content-Type' =&gt; 'application/json'));
                }
                try {
                    return $route['controller']-&gt;handle($request);
                } catch (FixturesException $e) {
                    $body = new Stream('php://temp', 'w');
                    $body-&gt;write($e-&gt;getMessage());

                    return new Response($body, $e-&gt;getCode(), array('Content-Type' =&gt; 'application/json'));
                }
            }
        }
        $body = new Stream('php://temp', 'w');
        $body-&gt;write(json_encode(array(
            'message' =&gt; "Route \"$path\" not found",
        )));

        return new Response($body, 404, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>We've decided to rely on Zend Diactoros to build the request, since it is the de
facto implementation of PSR-7:</p>

<pre><code>composer require zendframework/zend-diactoros:^1.0
</code></pre>

<p>We've open the possibility of managing many endpoints with this class. We now need
to define a controller for the quote submission one:</p>

<pre><code class="php">&lt;?php

// fixtures/Controller/Quote/SubmitNewQuoteController.php

namespace Acme\FortuneSdk\Fixtures\Controller\Quote;

use Acme\FortuneSdk\Remote\RequestHandler;
use Acme\FortuneSdk\Fixtures\FixturesException;
use Psr\Http\Message\RequestInterface;
use Zend\Diactoros\Response;
use Zend\Diactoros\Stream;

class SubmitNewQuoteController implements RequestHandler
{
    public function handle(RequestInterface $request)
    {
        $submitNewQuote = json_decode($request-&gt;getBody()-&gt;__toString(), true);
        if (false === isset($submitNewQuote['quote'])) {
            throw FixturesException::make('Missing required "quote" parameter', 422);
        }
        $quote = (string) $submitNewQuote['quote'];
        if ('' === $quote) {
            throw FixturesException::make('Invalid "quote" parameter: must not be empty', 422);
        }
        $body = new Stream('php://temp', 'w');
        $body-&gt;write(json_encode(array(
            'id' =&gt; '',
            'quote' =&gt; $quote
        )));

        return new Response($body, 201, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>Finally we need to write the exception class:</p>

<pre><code class="php">&lt;?php

// fixtures/FixturesException.php

namespace fixtures\Acme\FortuneSdk\Fixtures;

use DomainException;

class FixturesException extends DomainException
{
    /**
     * @param string $message
     * @param int    $statusCode
     *
     * @return FixturesException
     */
    public static function make($message, $statusCode)
    {
        return new self(json_encode(array('message' =&gt; $message)), $statusCode);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>sh ./bin/test.sh
</code></pre>

<p>They now fail because <code>SubmitNewQuote</code> doesn't exist.</p>

<h2 id="submitnewquote">SubmitNewQuote</h2>

<p>First of all, we'll define our service as an interface:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Quote/SubmitNewQuote.php

namespace Acme\FortuneSdk\Quote;

interface SubmitNewQuote
{
    public function submit($quote);
}
</code></pre>

<p>This will allow developers using our SDK to create their own implementation for testing
or extension purpose.
It will also allow us to create Composite implementation: we can have a remote
implementation that does the actual work, wrapped in a lazy cache implementation
itself wrapped in a log implementation.</p>

<p>Here we'll just take care of the remote one, let's bootstrap its test:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\FortuneSdk\Quote\SubmitNewQuote\RemoteSubmitNewQuote'
</code></pre>

<p>And now we can write the tests:</p>

<pre><code class="php">&lt;?php

// spec/Acme/FortuneSdk/Quote/SubmitNewQuote.php

namespace spec\Acme\FortuneSdk\Quote\SubmitNewQuote;

use Acme\FortuneSdk\Remote\RequestHandler;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamInterface;

class RemoteSubmitNewQuoteSpec extends ObjectBehavior
{
    const URL = 'http://example.com';
    const QUOTE = 'Nobody expects the Spanish Inquisition!';

    function let(RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($requestHandler, self::URL);
    }

    function it_is_a_submit_new_quote()
    {
        $this-&gt;shouldImplement('Acme\FortuneSdk\Quote\SubmitNewQuote');
    }

    function it_calls_the_remote_endpoint(
        RequestHandler $requestHandler,
        ResponseInterface $response,
        StreamInterface $stream
    ) {
        $quote = array(
            'quote' =&gt; self::QUOTE,
        );

        $request = Argument::type('Psr\Http\Message\RequestInterface');
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $response-&gt;getBody()-&gt;willReturn($stream);
        $stream-&gt;__toString()-&gt;willReturn(json_encode($quote));

        $this-&gt;submit(self::QUOTE)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>In this test, we've used a wildcard to represent the request since the service is
going to create it. This is at the cost of not knowing how it is built.</p>

<p>If we absolutely want to have control over this, we need to delegate the request
construction to a factory, it then becomes possible to mock the request and check
how it is built:</p>

<pre><code class="php">&lt;?php

// spec/Acme/FortuneSdk/Quote/SubmitNewQuote.php

namespace spec\Acme\FortuneSdk\Quote\SubmitNewQuote;

use Acme\FortuneSdk\Remote\RequestFactory;
use Acme\FortuneSdk\Remote\RequestHandler;
use PhpSpec\ObjectBehavior;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use Psr\Http\Message\StreamInterface;

class RemoteSubmitNewQuoteSpec extends ObjectBehavior
{
    const URL = 'http://example.com';
    const QUOTE = 'Nobody expects the Spanish Inquisition!';

    function let(RequestFactory $requestFactory, RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($requestFactory, $requestHandler, self::URL);
    }

    function it_is_a_submit_new_quote()
    {
        $this-&gt;shouldImplement('Acme\FortuneSdk\Quote\SubmitNewQuote');
    }

    function it_calls_the_remote_endpoint(
        RequestFactory $requestFactory,
        RequestHandler $requestHandler,
        RequestInterface $request,
        ResponseInterface $response,
        StreamInterface $stream
    ) {
        $quote = array(
            'quote' =&gt; self::QUOTE,
        );

        $requestFactory-&gt;make(self::URL.'/v1/quotes', 'POST', json_encode($quote), array(
            'Content-Type' =&gt; 'application/json'
        ))-&gt;willReturn($request);
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $response-&gt;getBody()-&gt;willReturn($stream);
        $stream-&gt;__toString()-&gt;willReturn(json_encode($quote));

        $this-&gt;submit(self::QUOTE)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>The choice between the first solution and the second one really depends on our preferences
and on what we're trying to achieve. For the sake of this article, we'll stick
to the first one (to avoid having to create the factory class and change the functional test,
this article is already long enough!).</p>

<p>Let's run our tests to bootstrap the code:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>Now we can write the actual code:</p>

<pre><code class="php">&lt;?php

// src/Acme/FortuneSdk/Quote/SubmitNewQuote/RemoteSubmitNewQuote.php

namespace Acme\FortuneSdk\Quote\SubmitNewQuote;

use Acme\FortuneSdk\Quote\SubmitNewQuote;
use Acme\FortuneSdk\Remote\RequestHandler;
use Zend\Diactoros\Request;
use Zend\Diactoros\Stream;

class RemoteSubmitNewQuote implements SubmitNewQuote
{
    private $requestHandler;
    private $url;

    public function __construct(RequestHandler $requestHandler, $url)
    {
        $this-&gt;requestHandler = $requestHandler;
        $this-&gt;url = $url;
    }

    public function submit($quote)
    {
        $body = new Stream('php://memory', 'w');
        $body-&gt;write(json_encode(array(
            'quote' =&gt; $quote,
        )));
        $request = new Request($this-&gt;url.'/v1/quotes', 'POST', $body, array(
            'Content-Type' =&gt; 'application/json'
        ));
        $quote = json_decode($this-&gt;requestHandler-&gt;handle($request)-&gt;getBody()-&gt;__toString(), true);

        return $quote;
    }
}
</code></pre>

<p>This should be sufficient to make our tests pass:</p>

<pre><code>sh ./bin/test.sh
</code></pre>

<p>All green!</p>

<p>We now have a SDK that provides a <code>SubmitNewQuote</code> service allowing us to submit new quotes.
Since we've mocked the network connection, we can't be sure that our SDK actually works.
Manual testing can be sufficient in this case: we can build a Command Line Interface (CLI)
client and check by ourselves if everything is fine, once in a while.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Inversion of Control is a principle that can come handy when dealing with third party library,
especially the ones that change often like Guzzle. It can be applied easily:
instead of making our high level classes rely on concrete low level ones, we just
need to introduce an interface.</p>

<p>Once again, all projects are different and this solution might not apply in every
case. If we're building an application that we expect to maintain for a couple of years
it can be worth it to protect ourselves from external changes.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Decouple from Frameworks]]></title>
            <link href="https://gnugat.github.io/2015/09/30/decouple-from-frameworks.html"/>
            <updated>2015-09-30T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2015/09/30/decouple-from-frameworks.html</id>
            <content type="html"><![CDATA[<p>Frameworks solve infrastructure problems, for example how to create a HTTP or CLI application.
While necessary, those concerns don't add any value to your project: the business
need will not be fulfilled by creating an empty application.</p>

<p>As always, different responsibilities mean also different reasons to change: frameworks
have a history of Backward Compatibility (BC) breaks and they do so regardless of your
project.</p>

<p>Take for example <a href="http://symfony.com/">Symfony</a>: it only started to follow <a href="http://semver.org/">Semantic Versioning</a>
from version 2.3. The upgrade to version 3 has been made easier by allowing developers
to know what was deprecated, but the removal of those features still means a lot of
work in your application.
The arrival of the <a href="http://www.php-fig.org/psr/psr-7/">new standard PSR-7</a> brings
a lot of questions on the future of Symfony: for now it <a href="http://symfony.com/blog/psr-7-support-in-symfony-is-here">allows to choose</a>
between <code>symfony/http-foundation</code> and <code>psr/http-message</code>, but if Symfony doesn't
want to fall back behind (<a href="http://framework.zend.com/blog/announcing-the-zend-framework-3-roadmap.html">Zend 3 is fully based on PSR-7</a>)
it might have to introduce another big BC break (event listeners with the Request
and Response <a href="http://evertpot.com/psr-7-issues/">are not possible the way they are now with PSR-7</a>).</p>

<p>Migrating Symfony applications (from symfony1, from symfony 2.0, etc) is so hard
that it is a business on its own.</p>

<p>Does that mean that we shouldn't use any frameworks? Should we just don't care and
embrace fully frameworks?</p>

<p>This article will explain how to avoid both extremes, by decoupling from the framework.
It can be done by restricting the framework to its infrastructure responsibilities
(HTTP, CLI), by only using its entry points (Controller, Command) and by using
the Command Bus pattern.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>We're going to build part of a <a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a>
application for our example, more precisely we're going to build an endpoint allowing us to
submit quotes.</p>

<p>To do so, we'll bootstrap a symfony application using the <a href="https://github.com/gnugat/symfony-empty-edition">Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition fortune
cd fortune
</code></pre>

<p>We'll need to install our test frameworks:</p>

<pre><code>composer require --dev phpunit/phpunit
composer require --dev phpspec/phpspec
</code></pre>

<p>Then add them to our test script:</p>

<pre><code>#!/usr/bin/env sh

# bin/test.sh

echo ''
echo '// Building test environment'

rm -rf app/cache/test app/logs/*test.log
composer --quiet --no-interaction install --optimize-autoloader  &gt; /dev/null
php app/console --env=test --quiet cache:clear

echo ''
echo ' [OK] Test environment built'
echo ''

vendor/bin/phpspec --format=dot &amp;&amp; vendor/bin/phpunit
</code></pre>

<p>Finally we'll configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="app/bootstrap.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="System Tests"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="request-listener">Request listener</h2>

<p>Our endpoint will receive JSON encoded content. PHP does not populate <code>$_POST</code> with
this data, causing an empty <code>$request-&gt;request</code>. We can create an event listener
to fix this issue:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/JsonRequestListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class JsonRequestListener
{
    public function onKernelRequest(GetResponseEvent $event)
    {
        $request = $event-&gt;getRequest();
        $hasBeenSubmited = in_array($request-&gt;getMethod(), array('PATCH', 'POST', 'PUT'), true);
        $isJson = (1 === preg_match('#application/json#', $request-&gt;headers-&gt;get('Content-Type')));
        if (!$hasBeenSubmited || !$isJson) {
            return;
        }
        $data = json_decode($request-&gt;getContent(), true);
        if (JSON_ERROR_NONE !== json_last_error()) {
            $event-&gt;setResponse(new Response('{"error":"Invalid or malformed JSON"}', 400, array('Content-Type' =&gt; 'application/json')));
        }
        $request-&gt;request-&gt;add($data ?: array());
    }
}
</code></pre>

<p>This logic is infrastructure related, so it makes sense to keep it in <code>AppBundle</code>.</p>

<p>To enable it, configure it in the Dependency Injection Container:</p>

<pre><code># app/config/services/event_listener.yml

services:
    app.json_request_listener:
        class: AppBundle\EventListener\JsonRequestListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<p>We also need to make sure files in <code>app/config/services</code> are imported:</p>

<pre><code class="php">&lt;?php
// app/config/importer.php

use Symfony\Component\Finder\Finder;

$finder = new Finder();
$files = $finder-&gt;files()-&gt;name('*.yml')-&gt;in(__DIR__.'/services');
foreach ($files as $file) {
    $loader-&gt;import($file-&gt;getRealpath());
}
</code></pre>

<h2 id="controller">Controller</h2>

<p>Our first step will be to describe how the endpoint should work, with a test:</p>

<pre><code class="php">&lt;?php
// tests/AppBundle/Controller/QuoteControllerTest.php

namespace tests\AppBundle\Controller;

use AppKernel;
use PHPUnit_Framework_TestCase;
use Symfony\Component\HttpFoundation\Request;

class QuoteControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new AppKernel('test', false);
        $this-&gt;app-&gt;boot();
    }

    /**
     * @test
     */
    public function it_submits_a_new_quote()
    {
        $headers = array('CONTENT_TYPE' =&gt; 'application/json');
        $request = Request::create('/v1/quotes', 'POST', array(), array(), array(), $headers, json_encode(array(
            'quote' =&gt; 'Nobody expects the spanish inquisition',
        )));

        $response = $this-&gt;app-&gt;handle($request);

        self::assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Testing only the status code is called "Smoke Testing" and is a very
  efficient way to check if the application is broken.
  Testing the content would be tedious and would make our test fragile as it might change often.</p>
</blockquote>

<p>Let's run it:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>The tests fail because the controller doesn't exist. Let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Controller/QuoteController.php

namespace AppBundle\Controller;

use Acme\Fortune\Quote\SubmitNewQuote;
use Acme\Fortune\Quote\SubmitNewQuoteHandler;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

class QuoteController
{
    private $submitNewQuoteHandler;

    public function __construct(SubmitNewQuoteHandler $submitNewQuoteHandler)
    {
        $this-&gt;submitNewQuoteHandler = $submitNewQuoteHandler;
    }

    public function submitNewAction(Request $request)
    {
        $sumbitNewQuote = new SubmitNewQuote(
            $request-&gt;request-&gt;get('quote')
        );
        $newQuote = $this-&gt;submitNewQuoteHandler-&gt;handle($sumbitNewQuote);

        return new Response(json_encode($newQuote), 201, array('Content-Type' =&gt; 'application/json'));
    }
}
</code></pre>

<p>Now we need to configure the controller as a service:</p>

<pre><code># app/config/services/controller.yml

services:
    app.quote_controller:
        class: AppBundle\Controller\QuoteController
        arguments:
            - "@app.submit_new_quote_handler"
</code></pre>

<p>Then we need to configure the route:</p>

<pre><code># app/config/routings/quote.yml

submit_new_quote:
    path: /v1/quotes
    defaults:
        _controller: app.quote_controller:submitNew
    methods:
        - POST
</code></pre>

<p>This file needs to be imported:</p>

<pre><code># app/config/routing.yml

quote:
    resource: routings/quote.yml
</code></pre>

<p>Finally we can run the test again:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>It now fails for a different reason: <code>SubmitNewQuote</code> and its handler class don't exist.</p>

<h2 id="command-from-commandbus">Command (from CommandBus)</h2>

<p><code>SubmitNewQuote</code> is a Data Transfer Object (DTO): its responsibility is to wrap
input parameters in a well named class (in this case a class that describes the action intended).
It's also the best place to do some basic validation on the input parameters.</p>

<blockquote>
  <p><strong>Note</strong>: In the Command Bus pattern, <code>SubmitNewQuote</code> would be a Command (different from the CLI Command).</p>
</blockquote>

<p>We'll write a test for this, but first we'll bootstrap the test class:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\Fortune\Quote\SubmitNewQuote'
</code></pre>

<p>Now we can decribe the different validation rules:</p>

<pre><code class="php">&lt;?php
// spec/Acme/Fortune/Quote/SubmitNewQuoteSpec.php

namespace spec\Acme\Fortune\Quote;

use PhpSpec\ObjectBehavior;

class SubmitNewQuoteSpec extends ObjectBehavior
{
    const QUOTE = 'Nobody expects the spanish inquisition';

    function it_fails_if_required_quote_parameter_is_missing()
    {
        $this-&gt;beConstructedWith(null);

        $this-&gt;shouldThrow('Acme\Fortune\Exception\ValidationFailedException')-&gt;duringInstantiation();
    }

    function it_fails_if_quote_parameter_is_empty()
    {
        $this-&gt;beConstructedWith('');

        $this-&gt;shouldThrow('Acme\Fortune\Exception\ValidationFailedException')-&gt;duringInstantiation();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Since this class has nothing to do with Symfony, we don't put it in <code>AppBundle</code>.
  By keeping it in its own namespace, we protect it from framework directory tree changes,
  for example before <code>AppBundle</code> the norm was <code>Acme\FortuneBundle</code>. We also allow ourselves
  to move it to another framework (e.g. Laravel, Zend, etc).</p>
</blockquote>

<p>Let's run the tests:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>It fails because the exception doesn't exist yet:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Exception/ValidationFailedException.php

namespace Acme\Fortune\Exception;

class ValidationFailedException extends FortuneException
{
}
</code></pre>

<p>We're making it a sub type of <code>FortuneException</code>: that way we can catch all exceptions
related to our code (all other exceptions can be considered as Internal Server Errors).</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Exception/FortuneException.php

namespace Acme\Fortune\Exception;

use DomainException;

class FortuneException extends DomainException
{
}
</code></pre>

<p>Now we need to create the Command:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Quote/SubmitNewQuote.php

namespace Acme\Fortune\Quote;

use Acme\Fortune\Exception\ValidationFailedException;

class SubmitNewQuote
{
    public function __construct($quote)
    {
        if (null === $quote) {
            throw new ValidationFailedException('Missing required "quote" parameter');
        }
        if ('' === $quote) {
            throw new ValidationFailedException('Invalid "quote" parameter: must not be empty');
        }
        $this-&gt;quote = (string) $quote;
    }
}
</code></pre>

<p>Running the tests again:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>Everything seems fine.</p>

<h2 id="exception-listener">Exception listener</h2>

<p>Instead of catching exceptions in our controllers we can create an event listener:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/EventListener/FortuneExceptionListener.php

namespace AppBundle\EventListener;

use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;

class FortuneExceptionListener
{
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof FortuneException) {
            return;
        }
        $content = json_encode(array('error' =&gt; $exception-&gt;getMessage()));
        $statusCode = Response::HTTP_UNPROCESSABLE_ENTITY;
        $event-&gt;setResponse(new Response($content, $statusCode, array('Content-Type' =&gt; 'application/json')));
    }
}
</code></pre>

<p>This lowers the risk of forgetting to catch an exception and it also keeps our controller slim.</p>

<p>Let's enable it in the DIC:</p>

<pre><code># app/config/services/event_listener.yml

services:
    app.fortune_exception_listener:
        class: AppBundle\EventListener\FortuneExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException }

    app.json_request_listener:
        class: AppBundle\EventListener\JsonRequestListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }
</code></pre>

<h2 id="command-handler">Command Handler</h2>

<p><code>SubmitNewQuoteHandler</code>'s responsibility is to validate <code>SubmitNewQuote</code> data against
business rules (e.g. no quote duplicates, author must exist, etc) and to call the
appropriate services to process it.
Reading its code feels like reading the details of a use case:</p>

<blockquote>
  <p>To handle the submission of a new quote,
  we need to generate a unique identifier
  and then we need to save the new quote.</p>
</blockquote>

<p>Let's bootstrap its test:</p>

<pre><code>vendor/bin/phpspec describe 'Acme\Fortune\Quote\SubmitNewQuoteHandler'
</code></pre>

<p>Then edit the test:</p>

<pre><code class="php">&lt;?php
// spec/Acme/Fortune/Quote/SubmitNewQuoteHandlerSpec.php

namespace spec\Acme\Fortune\Quote;

use Acme\Fortune\Quote\SubmitNewQuote;
use Acme\Fortune\Quote\Service\SaveNewQuote;
use Acme\Fortune\Quote\Service\UniqueIdentifierGenerator;
use PhpSpec\ObjectBehavior;

class SubmitNewQuoteHandlerSpec extends ObjectBehavior
{
    const ID = '921410e8-eb98-4f99-ba98-055d46980511';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    function let(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $this-&gt;beConstructedWith($saveNewQuote, $uniqueIdentifierGenerator);
    }

    function it_saves_new_quote(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $submitNewQuote = new SubmitNewQuote(self::QUOTE);
        $quote = array(
            'id' =&gt; self::ID,
            'quote' =&gt; self::QUOTE,
        );

        $uniqueIdentifierGenerator-&gt;generate()-&gt;willReturn(self::ID);
        $saveNewQuote-&gt;save($quote)-&gt;shouldBeCalled();

        $this-&gt;handle($submitNewQuote)-&gt;shouldBe($quote);
    }
}
</code></pre>

<p>Let's run the tests:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>After generating interfaces for <code>SaveNewQuote</code> and <code>UniqueIdentifierGenerator</code>
and after bootstrapping the code for <code>SubmitNewQuoteHandler</code>, the test will fail
because we need to complete it:</p>

<pre><code class="php">&lt;?php
// src/Acme/Fortune/Quote/SubmitNewQuoteHandler.php

namespace Acme\Fortune\Quote;

use Acme\Fortune\Quote\Service\SaveNewQuote;
use Acme\Fortune\Quote\Service\UniqueIdentifierGenerator;

class SubmitNewQuoteHandler
{
    private $saveNewQuote;
    private $uniqueIdentifierGenerator;

    public function __construct(SaveNewQuote $saveNewQuote, UniqueIdentifierGenerator $uniqueIdentifierGenerator)
    {
        $this-&gt;saveNewQuote = $saveNewQuote;
        $this-&gt;uniqueIdentifierGenerator = $uniqueIdentifierGenerator;
    }

    public function handle(SubmitNewQuote $sumbitNewQuote)
    {
        $quote = array(
            'id' =&gt; $this-&gt;uniqueIdentifierGenerator-&gt;generate(),
            'quote' =&gt; $sumbitNewQuote-&gt;quote,
        );
        $this-&gt;saveNewQuote-&gt;save($quote);

        return $quote;
    }
}
</code></pre>

<p>Now we can configure the service:</p>

<pre><code class="php"># app/config/services/quote.yml

services:
    app.submit_new_quote_handler:
        class: Acme\Fortune\Quote\SubmitNewQuoteHandler
        arguments:
            - "@app.save_new_quote"
            - "@app.unique_identifier_generator"
</code></pre>

<p>Finally can run the tests one last time:</p>

<pre><code>./bin/test.sh
</code></pre>

<p>Allmost green!</p>

<p>They fail because <code>app.save_new_quote</code> and <code>app.unique_identifier_generator</code> don't
exist yet. They will be the topic of another article ;) .</p>

<h2 id="conclusion">Conclusion</h2>

<p>By restricting frameworks to their entry points (Controllers, Commands, etc) and
using the Command Bus to define our project entry points (domain boundaries) we
are able to decouple from the framework, allowing us to restrict the impact of BC breaks.</p>

<p>Of course, all projects are different and this solution might not be possible everywhere.
RAD development is a robust solution for web agencies, especially if they are chosen
to bootstrap a project as fast as possible and then need to pass the project over
to their customer after a short period.</p>

<p>On the other hand some companies are creating projects they will have to maintain
for decades and those are also in need of delivering a first version early.
Decoupling from the framework isn't something that slows down development, and there
are ways to still release early (e.g. define Minimum Valuable Product and deliver
small features iterations by iterations).</p>

<blockquote>
  <p><strong>Note</strong>: There are a couple of bundles that provides Symfony with a Command Bus, among them:</p>
  
  <ul>
  <li><a href="/2015/09/09/tactician.html">Tactician</a></li>
  <li><a href="/2015/08/04/simple-bus.html">SimpleBus</a></li>
  </ul>
</blockquote>

<p>If you're interrested on the subject, here's some resources:</p>

<ul>
<li>The framework as an implementation detail
(<a href="http://www.slideshare.net/marcello.duarte/the-framework-as-an-implementation-detail">slides</a>
and <a href="https://www.youtube.com/watch?v=0L_9NutiJlc">video</a>),
by <a href="http://marcelloduarte.net/">Marcello Duarte</a>
and <a href="http://everzet.com/">Konstantin Kudryashov</a></li>
<li><a href="https://blog.8thlight.com/uncle-bob/2014/05/11/FrameworkBound.html">Framework bound</a>,
by <a href="https://sites.google.com/site/unclebobconsultingllc/">Robert Cecil Martin</a></li>
<li><a href="http://kristopherwilson.com/2013/11/27/decoupling-the-framework/">Decoupling the Framework</a>,
by <a href="https://twitter.com/mrkrstphr">Kristopher Wilson</a></li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[PHPUnit with phpspec]]></title>
            <link href="https://gnugat.github.io/2015/09/23/phpunit-with-phpspec.html"/>
            <updated>2015-09-23T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2015/09/23/phpunit-with-phpspec.html</id>
            <content type="html"><![CDATA[<p><a href="https://phpunit.de/">PHPUnit</a> is a port of <a href="http://junit.org/">jUnit</a>, its name
might be deceptive: it allows you to write any type of tests (unit, but also functional,
system, integration, end to end, acceptance, etc).</p>

<p><a href="http://www.phpspec.net">phpspec</a> was at first a port of <a href="http://rspec.info/">rspec</a>,
it can be considered as a unit test framework that enforces practices it considers best.</p>

<blockquote>
  <p><strong>Note</strong>: <a href="/2015/08/03/phpspec.html">read more about phpspec</a>.</p>
</blockquote>

<p>In this article, we'll see how to use both tools together in a same project.</p>

<h2 id="fortune%3A-our-example">Fortune: our example</h2>

<p>We're going to build part of a <a href="https://en.wikipedia.org/wiki/Fortune_%28Unix%29">fortune</a>
application for our example, more precisely we're going to build a CLI allowing us to save quotes.</p>

<p>To do so, we'll bootstrap a symfony application using the <a href="https://github.com/gnugat/symfony-empty-edition">Empty Edition</a>:</p>

<pre><code>composer create-project gnugat/symfony-empty-edition fortune
cd fortune
</code></pre>

<p>We'll need to install our test frameworks:</p>

<pre><code>composer require --dev phpunit/phpunit
composer require --dev phpspec/phpspec
</code></pre>

<p>Finally we'll configure PHPUnit:</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;!-- phpunit.xml.dist --&gt;
&lt;!-- http://phpunit.de/manual/current/en/appendixes.configuration.html --&gt;
&lt;phpunit backupGlobals="false" colors="true" syntaxCheck="false" bootstrap="app/bootstrap.php"&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="System Tests"&gt;
            &lt;directory&gt;tests&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<h2 id="the-command">The command</h2>

<p>Our first step will be to write a <strong>system test</strong> describing the command:</p>

<pre><code class="php">&lt;?php
// tests/Command/SaveQuoteCommandTest.php

namespace AppBundle\Tests\Command;

use AppKernel;
use PHPUnit_Framework_TestCase;
use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Tester\ApplicationTester;

class SaveQuoteCommandTest extends PHPUnit_Framework_TestCase
{
    const EXIT_SUCCESS = 0;

    private $app;

    protected function setUp()
    {
        $kernel = new AppKernel('test', false);
        $application = new Application($kernel);
        $application-&gt;setAutoExit(false);
        $this-&gt;app = new ApplicationTester($application);
    }

    /**
     * @test
     */
    public function it_saves_a_new_quote()
    {
        $exitCode = $this-&gt;app-&gt;run(array(
            'quote:save',
            'quote' =&gt; 'Nobody expects the spanish inquisition',
        ));

        self::assertSame(self::EXIT_SUCCESS, $exitCode, $this-&gt;app-&gt;getDisplay());
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Testing only the exit code is called "Smoke Testing" and is a very
  efficient way to check if the application is broken.
  Testing the output would be tedious and would make our test fragile as it might change often.</p>
</blockquote>

<p>Let's run it:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>The tests fails because the command doesn't exist. Let's fix that:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Command/SaveQuoteCommand.php

namespace AppBundle\Command;

use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Output\OutputInterface;

class SaveQuoteCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this-&gt;setName('quote:save');
        $this-&gt;addArgument('quote', InputArgument::REQUIRED);
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $output-&gt;writeln('');
        $output-&gt;writeln('// Saving quote');

        $this-&gt;getContainer()-&gt;get('app.save_new_quote')-&gt;save(
            $input-&gt;getArgument('quote')
        );

        $output-&gt;writeln('');
        $output-&gt;writeln(' [OK] Quote saved');
        $output-&gt;writeln('');
    }
}
</code></pre>

<p>Then run the test again:</p>

<pre><code>vendor/bin/phpunit
</code></pre>

<p>It now fails for a different reason: the service used doesn't exist.</p>

<h2 id="the-service">The service</h2>

<p>The second step is to write the unit test for the service. With phpspec we can
first bootstrap it:</p>

<pre><code>vendor/bin/phpspec describe 'AppBundle\Service\SaveNewQuote'
</code></pre>

<p>Then we need to edit it:</p>

<pre><code class="php">&lt;?php
// spec/AppBundle/Service/SaveNewQuoteSpec.php

namespace spec\AppBundle\Service;

use PhpSpec\ObjectBehavior;
use Symfony\Component\Filesystem\Filesystem;

class SaveNewQuoteSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/quotes.txt';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem, self::FILENAME);
    }

    function it_saves_new_quote(Filesystem $filesystem)
    {
        $filesystem-&gt;dumpFile(self::FILENAME, self::QUOTE)-&gt;shouldBeCalled();

        $this-&gt;save(self::QUOTE);
    }
}
</code></pre>

<p>Time to run the suite:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>phpspec will detect that the tested class doesn't exist and will bootstrap it for us,
so we just have to edit it:</p>

<pre><code class="php">&lt;?php
// src/AppBundle/Service/SaveNewQuote.php

namespace AppBundle\Service;

use Symfony\Component\Filesystem\Filesystem;

class SaveNewQuote
{
    private $filesystem;
    private $filename;

    public function __construct(Filesystem $filesystem, $filename)
    {
        $this-&gt;filesystem = $filesystem;
        $this-&gt;filename = $filename;
    }

    public function save($quote)
    {
        $this-&gt;filesystem-&gt;dumpFile($this-&gt;filename, $quote);
    }
}
</code></pre>

<p>Again, we're going to run our unit test:</p>

<pre><code>vendor/bin/phpspec run
</code></pre>

<p>It's finally green! Our final step will be to define our service in the Dependency Injection
Container:</p>

<pre><code># app/config/config.yml

imports:
    - { resource: parameters.yml }
    - { resource: importer.php }

framework:
    secret: "%secret%"

services:
    app.save_new_quote:
        class: AppBundle\Service\SaveNewQuote
        arguments:
            - "@filesystem"
            - "%kernel.root_dir%/cache/quotes"
</code></pre>

<p>To make sure everything is fine, let's clear the cache and run the test:</p>

<pre><code>rm -rf app/cache/*
vendor/bin/phpunit
</code></pre>

<p>It's <a href="https://www.youtube.com/watch?v=lFeLDc2CzOs">Super Green</a>!</p>

<h2 id="conclusion">Conclusion</h2>

<p>As we can see, PHPUnit and phpspec can work perfectly well together.</p>

<p>Of course we could write our unit test in a similar manner with PHPUnit:</p>

<pre><code>&lt;?php
// tests/Service/SaveNewQuoteTest.php

namespace AppBundle\Tests\Service;

use AppBundle\Service\SaveNewQuote;
use PHPUnit_Framework_TestCase;

class SaveNewQuoteTest extends PHPUnit_Framework_TestCase
{
    const FILENAME = '/tmp/quotes.txt';
    const QUOTE = 'Nobody expects the spanish inquisition!';

    private $filesystem;
    private $saveNewQuote;

    protected function setUp()
    {
        $this-&gt;filesystem = $this-&gt;prophesize('Symfony\Component\Filesystem\Filesystem');
        $this-&gt;saveNewQuote = new SaveNewQuote($this-&gt;filesystem-&gt;reveal(), self::FILENAME);
    }

    /**
     * @test
     * @group unit
     */
    public function it_saves_new_quote()
    {
        $this-&gt;filesystem-&gt;dumpFile(self::FILENAME, self::QUOTE)-&gt;shouldBeCalled();

        $this-&gt;saveNewQuote-&gt;save(self::QUOTE);
    }
}
</code></pre>

<p>And run it separately:</p>

<pre><code>vendor/bin/phpunit --group=unit
</code></pre>

<p>But then we would lose all the advantages of phpspec:</p>

<ul>
<li>it adds less overhead (this same test runs in ~20ms with phpspec, and ~80ms with PHPUnit)</li>
<li>it tells you when it thinks you're doing something wrong (typically by making it harder/impossible for you to do it)</li>
<li>it bootstraps things for you if you follow the TDD workflow (test first, then code)</li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[phpspec]]></title>
            <link href="https://gnugat.github.io/2015/08/03/phpspec.html"/>
            <updated>2015-08-03T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2015/08/03/phpspec.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Reference</strong>: This article is intended to be as complete as possible and is kept up to date.</p>
</blockquote>

<p><a href="http://www.phpspec.net">phpspec</a> is a highly opinionated unit test framework:
it was conceived to practice <a href="http://dannorth.net/introducing-bdd/">specBDD</a>
(test method names should be sentences) and
<a href="http://martinfowler.com/articles/mocksArentStubs.html">Mockist TDD</a>
(collaborators should always be mocked) and tries to enforce some testing practices
(see <a href="https://twitter.com/_md">Marcello Duarte</a>'s <a href="http://techportal.inviqa.com/2014/09/11/my-top-ten-favourite-phpspec-limitations/">top 10 favourite phpspec limitations</a>).</p>

<p>The <a href="http://blog.astrumfutura.com/2008/01/the-phpspec-zend-framework-app-testing-manifesto-zf-integration/">first version</a>
was created by <a href="https://twitter.com/padraicb">Pádraic Brady</a> as a port of <a href="http://rspec.info/">rspec</a>,
but Marcello Duarte and <a href="https://twitter.com/everzet">Konstantin Kudryashov</a>
took over and released a second version which added code generation.
<a href="https://twitter.com/CiaranMcNulty">Ciaran McNulty</a> then took the lead from v2.1
and added many features like collaborator generation, better exception specification
and currently for version 2.3 better constructor specification.</p>

<h2 id="usage-example">Usage example</h2>

<p>Let's have a look at how phpspec works. For this we'll need to have a project configured with
<a href="https://getcomposer.org/download">Composer</a>. Here's the <code>composer.json</code> file:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>We can install phpspec with the following:</p>

<pre><code>composer require --dev phpspec/phpspec:^2.2
</code></pre>

<p>Let's say we want to create a class that edits text files. We can call this class
<code>TextEditor</code>:</p>

<pre><code>phpspec describe 'Vendor\Project\TextEditor'
</code></pre>

<blockquote>
  <p><strong>Tip</strong>: make your vendor's binaries available by adding <code>vendor/bin</code> to your <code>$PATH</code>.
  <code>export PATH="vendor/bin:$PATH"</code>.</p>
</blockquote>

<p>We should now have the <code>spec/Vendor/Project/TextEditorSpec.php</code> file, bootstraped
for us by phpspec:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class TextEditorSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\TextEditor');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: this test can only be used to test the <code>TextEditor</code> class.</p>
</blockquote>

<p>Our first use case will be about creating a file if it doesn't already exist.
Those are filesystem operations, so we decide to delegate the actual logic to a
<code>Filesystem</code> class (we'll create it later).</p>

<p>So our first step will be to create a set up method (it will be executed before
every test method) that initializes our object:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/TextEditorSpec.php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }
}
</code></pre>

<p>Arguments passed to test methods are actually test doubles (phpspec uses the typehint
to know what to mock).</p>

<p>Now we can create the actual test method:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/TextEditorSpec.php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_can_force_file_creation_if_it_does_not_already_exists(File $file, Filesystem $filesystem)
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>This is roughly the equivalent of the following with <a href="https://phpunit.de/">PHPUnit</a>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project\Tests;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorTest extends PHPUnit_Framewor_TestCase
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    private $prophet;
    private $filesystem;
    private $textEditor;

    protected function setUp()
    {
        $this-&gt;prophet = new \Prophecy\Prophet();
        $this-&gt;filesystem = $this-&gt;prophet-&gt;prophesize('Vendor\Project\Service\Filesystem');
        $this-&gt;textEditor = new TextEditor($filesystem-&gt;reveal());
    }

    protected function tearDown()
    {
        $this-&gt;prophet-&gt;checkPredictions();
    }

    /**
     * @test
     */
    public function it_can_force_file_creation_if_it_does_not_already_exists()
    {
        $file = $this-&gt;prophet-&gt;prophesize('Vendor\Project\File');
        $this-&gt;filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $this-&gt;filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        self::assertSame($file, $this-&gt;textEditor-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION));
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We tried to make the test method as descriptive as possible (e.g. not <code>testOpen()</code>).
  This is the whole point of specBDD (specification Behavior Driven Development).</p>
</blockquote>

<p>phpspec uses the mocking library prophecy (also available in PHPUnit since version 4.4),
which tries to be as less verbose as possible: to describe interractions, test doubles
can almost be used as the actual object, except we need to add a <code>-&gt;willreturn()</code> or
<code>-&gt;shouldBeCalled()</code> call afterwards.</p>

<blockquote>
  <p><strong>Note</strong>: By mocking all collaborators, we are forced to think how our object interracts with them.
  This is the whole point of Mockist TDD (Mockist Test Driven Development).</p>
</blockquote>

<p>Now that we have a test, we are going to execute the test suite (as advocated by TDD):</p>

<pre><code>phpspec run
</code></pre>

<p>It will ask the following 7 questions:</p>

<ol>
<li>Would you like me to generate an interface <code>Vendor\Project\Service\Filesystem</code> for you?</li>
<li>Would you like me to generate an interface <code>Vendor\Project\File</code> for you?</li>
<li>Would you like me to generate a method signature <code>Vendor\Project\Service\Filesystem::exists()</code> for you?</li>
<li>Would you like me to generate a method signature <code>Vendor\Project\Service\Filesystem::create()</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\TextEditor</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\TextEditor::__construct()</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\TextEditor::open()</code> for you?</li>
</ol>

<p>By accepting everytime, phpspec will bootstrap the following
<code>src/Vendor/Project/Vendor/TextEditor.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class TextEditor
{

    public function __construct($argument1)
    {
        // TODO: write logic here
    }

    public function open($argument1, $argument2)
    {
        // TODO: write logic here
    }
}
</code></pre>

<p>In our specification, we make use of non existing class (<code>File</code> and <code>Filesystem</code>)
but phpspec also bootstraped them for us, for example <code>src/Vendor/Project/Vendor/Filesystem.php</code>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project\Service;

interface Filesystem
{

    public function exists($argument1);

    public function create($argument1);
}
</code></pre>

<p>This is extremely usefull to kickstart our TDD cycle!</p>

<p>Once the code is written, we'll execute the test suite again, and then we'll add more
use cases to the test class (e.g. what happens if the file already exists?).</p>

<p>For further usage example, have a look at: <a href="tags/phpspec">articles tagged with phpspec</a>.</p>

<h2 id="specgen">SpecGen</h2>

<p>phpspec's code generator is a big part of its value, but it could do more for us.
Hence the <a href="https://github.com/memio/spec-gen">SpecGen</a> extension!</p>

<p>We can install it as follow:</p>

<pre><code>composer require --dev memio/spec-gen:^0.4
echo 'extensions:' &gt; phpspec.yml
echo '  - Memio\SpecGen\MemioSpecGenExtension' &gt;&gt; phpspec.yml
</code></pre>

<p>If we remove the code generated by phpspec:</p>

<pre><code>rm src/Vendor/Project/TextEditor.php
</code></pre>

<p>And re-run the tests:</p>

<pre><code>phpspec run
</code></pre>

<p>Then the generated class will be:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open($argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="emergent-design">Emergent Design</h2>

<p>Test are more than simple regression checks: when a class is hard to test it indicates
that it does too many things or is too coupled.</p>

<p>They can also be used as a design tool: in our test method we can define exactly how
we would like to use the future object. We can even decide on the go that some logic
could be done by collaborators that don't exist yet and start defining how we like to
interract with them.</p>

<p>This is what Emergent Design is all about: the design emerges on the go from the tests.
Then they stop being simple tests, they become specifications: a live documentation
of your code, which never become out of date.</p>

<h2 id="tips">Tips</h2>

<p>Here are some personal tips:</p>

<ul>
<li>use <code>willReturn</code> if you need the returned value of a collaborator (official name: Mock)</li>
<li>use <code>shouldBeCalled</code> to check that a collaborator is called (official name: Stub)</li>
<li>do not chain <code>willReturn</code> and <code>shouldBeCalled</code>, you have to pick one!</li>
<li>create a <code>it_is_a_</code> test method with a <code>shouldImplement</code> check when testing implementations</li>
<li>the <code>shouldBe</code> matcher is usually the only one you need</li>
<li>if you have a lot (how many? that's your call) of test methods, maybe it's time to split your object</li>
<li>if you copy paste the same block of code in many test methods, maybe it's time extract it into an object</li>
</ul>

<p>If the tested object (official name: System Under Test, SUT) creates a value object and passes
it to a collaborator you have two choices:</p>

<ul>
<li>pass <code>Argument::type('MyValueObject')</code></li>
<li>create a factory and add it as a dependency</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>phpspec is a nice unit testing framework, with many advantages:</p>

<ul>
<li>it's fast: on average projects the test suite is run in less than a second</li>
<li>it's a good pair-programming partner: when something is hard to test, it means that there is a better diffrent way to do it</li>
<li>it's a time saver: the code bootstrapping feature is a must have!</li>
<li>it isn't verbose: tests can be read as documented code examples</li>
</ul>

<p>Give it a try!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[SpecGen v0.3]]></title>
            <link href="https://gnugat.github.io/2015/05/28/spec-gen-0-3.html"/>
            <updated>2015-05-28T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2015/05/28/spec-gen-0-3.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> v0.3 inserts a property for each constructor argument.</p>
</blockquote>

<p>SpecGen is a <a href="http://phpspec.net">phpspec</a> extension which enhance its code generator.
With the latest release, v0.3, we get the following features:</p>

<ul>
<li>method generation:

<ul>
<li>it inserts method at the end of the class</li>
<li>it typehints object, array and callable arguments</li>
<li>it names object arguments after their type</li>
<li>it names scalar arguments after a generic name (<code>argument</code>)</li>
<li>it adds number on names that could collide (e.g. <code>$argument1, $argument2</code>)</li>
</ul></li>
<li>constructor generation, same as method except:

<ul>
<li>it inserts constructor at the begining of the class</li>
<li>it inserts properties with initialization for each constructor arguments</li>
</ul></li>
</ul>

<p>Here's a simple example to demonstrate how helpful it can be.</p>

<h2 id="example">Example</h2>

<p>First of all, we need to set up a project with <a href="https://getcomposer.org/download">Composer</a>.
Let's write the following <code>composer.json</code>:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>Then we can install phpspec with SpecGen by running those commands:</p>

<pre><code>composer require --dev phpspec/phpspec:~2.2
composer require --dev memio/spec-gen:~0.3
echo 'extensions:' &gt; phpspec.yml
echo '  - Memio\SpecGen\MemioSpecGenExtension' &gt;&gt; phpspec.yml
</code></pre>

<p>In our example, we'll specify a <code>TextEditor</code> service, it should be able to
create new files by relying on <code>Filesystem</code>, another service.</p>

<p>This can be done as follow:</p>

<pre><code>phpspec describe 'Vendor\Project\TextEditor'
````

&gt; **Tip**: make your vendor's binaries available by adding `vendor/bin` to your `$PATH`.
&gt; `export PATH="vendor/bin:$PATH"`.

This should generate a `spec\Vendor\Project\TextEditorSpec.php` file:

```php
&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class TextEditorSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\TextEditor');
    }
}
</code></pre>

<p>It needs to be edited to fit our needs:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use Vendor\Project\Service\Filesystem;
use Vendor\Project\File;
use PhpSpec\ObjectBehavior;

class TextEditorSpec extends ObjectBehavior
{
    const FILENAME = '/tmp/file.txt';
    const FORCE_FILE_CREATION = true;

    function let(Filesystem $filesystem)
    {
        $this-&gt;beConstructedWith($filesystem);
    }

    function it_creates_new_files(File $file, Filesystem $filesystem)
    {
        $filesystem-&gt;exists(self::FILENAME)-&gt;willReturn(false);
        $filesystem-&gt;create(self::FILENAME)-&gt;willReturn($file);

        $this-&gt;open(self::FILENAME, self::FORCE_FILE_CREATION)-&gt;shouldBe($file);
    }
}
</code></pre>

<p>The Test Driven Development cycle advises us to run the test suite now:</p>

<pre><code>phpspec run
</code></pre>

<p>This will bootstrap the following code:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Service\Filesystem;

class TextEditor
{
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function open($argument1, $argument2)
    {
    }
}
</code></pre>

<p>It created a <code>filesystem</code> property to mirror the constructor arguments. Neat!</p>

<h2 id="what%27s-next%3F">What's next?</h2>

<p>In our example phpspec also generated the collaborators (<code>File</code> and <code>Filesystem</code>).
These don't beneficiate from SpecGen help yet, so the next release (v0.4) will
probably be about using it for collaborators.</p>

<p>Other features that could be implemented would be PHPdoc generation, or avoiding the
<code>Interface</code> / <code>Abstract</code> suffix/prefix in interface and abstract object argument names.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[SpecGen v0.2]]></title>
            <link href="https://gnugat.github.io/2015/05/20/spec-gen-0-2.html"/>
            <updated>2015-05-20T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2015/05/20/spec-gen-0-2.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> v0.2 inserts use statements.</p>
</blockquote>

<p>SpecGen v0.2 has been released, it introduces a small change: use statement insertion.</p>

<h2 id="it-inserts-use-statements">It inserts use statements</h2>

<p>Let's go back to the sources of the example used in the <a href="/2015/05/13/memio-spec-gen.html">previous article</a>
and clean it a little bit:</p>

<pre><code>rm -rf src
</code></pre>

<p>Given the following specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Message\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Message\Response');
    }
}
</code></pre>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following file, with a use statement:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Message\Request;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="it-doesn%27t-insert-use-statements-twice">It doesn't insert use statements twice</h2>

<p>Given the following new step in our specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Message\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Message\Response');
    }

    function it_supports_request(Request $request)
    {
        $this-&gt;supports($request)-&gt;shouldBe(true);
    }
}
</code></pre>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following file, without new use statements:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

use Vendor\Project\Message\Request;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }

    public function supports(Request $request)
    {
    }
}
</code></pre>

<h2 id="it-doesn%27t-insert-use-statement-for-same-namespace">It doesn't insert use statement for same namespace</h2>

<p>Let's clear everything:</p>

<pre><code>rm -rf src
</code></pre>

<p>Given the following specification:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_a_request_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: <code>Request</code> and <code>RequestHandler</code> are both in the same namespace.</p>
</blockquote>

<p>When we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>Then we should get the following, without any use statements:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<h2 id="behind-the-hood">Behind the hood</h2>

<p>This small feature was the occasion to refactor SpecGen a bit! This resulted in the
introduction of <code>CodeEditor</code>, a facade for a home made <code>CommandBus</code> and for
<a href="http://gnugat.github.io/redaktilo">Redaktilo</a>'s <code>Editor</code>.</p>

<p>With these, the code to generate a method and insert a use statement looks like this:</p>

<pre><code class="php">$file = $this-&gt;codeEditor-&gt;open($fileName);
$this-&gt;codeEditor-&gt;handle(new InsertUseStatements($file, $fullyQualifiedNames));
$this-&gt;codeEditor-&gt;handle(new InsertMethod($file, $method));
$this-&gt;codeEditor-&gt;save($file);
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>While some improvements can still be done (use statements in alphabetical order,
typehint interfaces only), the version 0.3 will mainly be about the introduction
of a new generator: insertion of properties when the method is a constructor.</p>

<p>Stay tuned!</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Memio SpecGen v0.1]]></title>
            <link href="https://gnugat.github.io/2015/05/13/memio-spec-gen.html"/>
            <updated>2015-05-13T00:00:00+01:00</updated>
            <id>https://gnugat.github.io/2015/05/13/memio-spec-gen.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: <a href="http://github.com/memio/spec-gen">SpecGen</a> is a <a href="http://phpspec.net">phpspec</a>
  extension that improves its code generator. Currently available: type hinted method arguments.</p>
</blockquote>

<p>With <a href="http://memio.github.io/memio">Memio v1.0 released</a>, it is now possible to
create powerful code generators without re-inventing the wheel.
<a href="http://github.com/memio/spec-gen">SpecGen</a> is the first project to use this library, let's
see what it can do for us.</p>

<h2 id="phpspec">phpspec</h2>

<p>First of all we'll talk about <a href="http://phpspec.net">phpspec</a>, which is an exciting
project that provides many benefits:</p>

<ul>
<li>a testing tool (allows to write specifications, which are kind of unit tests)</li>
<li>a "best practice" enforcer (for e.g. cannot test private methods to force us to split code into smaller public APIs)</li>
<li>a time saver (bootstraps tests and code)</li>
</ul>

<blockquote>
  <p><strong>Note</strong>: See <a href="http://techportal.inviqa.com/2014/09/11/my-top-ten-favourite-phpspec-limitations/">My top 10 favourite phpsepc limitations</a>.</p>
</blockquote>

<p>It makes Test Driven Development cycles even more meaningful:</p>

<ol>
<li>bootstrap test by thinking on a class name</li>
<li>write a test by thinking how the class should behave</li>
<li>bootstrap the corresponding code by running the whole test suite</li>
<li>write code as quick as possible without thinking about best practices or design patterns (be pragmatic)</li>
<li>run the test suite to check if the code fulfills the test's specifications</li>
<li>refactor the code (manage the technical debt)</li>
<li>run the test suite to check for regressions</li>
<li>repeat!</li>
</ol>

<p>phpspec's code generator is a big part of its value. Let's see if we can improve it.</p>

<h2 id="phpspec-example">phpspec example</h2>

<p>Let's have a look at how phpspec works. For this we'll need to have a project configured with
<a href="https://getcomposer.org/download">Composer</a>:</p>

<pre><code>{
    "name": "vendor/project",
    "autoload": {
        "psr-4": {
            "Vendor\\Project\\": "src/Vendor/Project"
        }
    },
    "require": {},
    "require-dev": {}
}
</code></pre>

<p>We can install phpspec with the following:</p>

<pre><code>composer require --dev phpspec/phpspec:~2.2
</code></pre>

<p>Let's say we want to create a class that handles requests, conforming to the HTTP protocol
(take a <code>Request</code>, return a <code>Response</code>). We can call this class <code>RequestHandler</code>:</p>

<pre><code>phpspec describe 'Vendor\Project\RequestHandler'
</code></pre>

<blockquote>
  <p><strong>Tip</strong>: make your vendor's binaries available by adding <code>vendor/bin</code> to your <code>$PATH</code>.
  <code>export PATH="vendor/bin:$PATH"</code>.</p>
</blockquote>

<p>We should now have the <code>spec/Vendor/Project/RequestHandlerSpec.php</code> file, bootstraped
for us by phpspec:</p>

<pre><code class="php">&lt;?php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_is_initializable()
    {
        $this-&gt;shouldHaveType('Vendor\Project\RequestHandler');
    }
}
</code></pre>

<p>We can directly start by writing our first specification (test method) in it:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response(Request $request)
    {
        $this-&gt;handle($request)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We tried to make the test method as descriptive as possible (e.g. not <code>testHandler()</code>).
  This is the whole point of specBDD (specification Behavior Driven Development).</p>
</blockquote>

<p>With this we can start to boostrap the code by simply running the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>It will ask the following 3 questions:</p>

<ol>
<li>Would you like me to generate an interface <code>Vendor\Project\Request</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\RequestHandler</code> for you?</li>
<li>Do you want me to create <code>Vendor\Project\RequestHandler::handle()</code> for you?</li>
</ol>

<p>By accepting everytime, phpspec will bootstrap the following
<code>src/Vendor/Project/Vendor/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{

    public function handle($argument1)
    {
        // TODO: write logic here
    }
}
</code></pre>

<p>In our specification, we make use of a non existing <code>Request</code> class, and phpspec
also bootstraped it for us in <code>src/Vendor/Project/Vendor/Request.php</code>:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

interface Request
{
}
</code></pre>

<p>This is extremely usefull to kickstart our TDD cycle!</p>

<h2 id="memio-specgen">Memio SpecGen</h2>

<p>SpecGen is a phpspec extension, it makes use of Memio (the PHP code generator library)
to make the above bootstraping even more awesome.</p>

<p>Here's how to install it:</p>

<pre><code>composer require --dev memio/spec-gen:~0.1
</code></pre>

<p>We also need to register it as a phpspec extension by writing the following <code>phpspec.yml</code> file:</p>

<pre><code>extensions:
  - Memio\SpecGen\MemioSpecGenExtension
</code></pre>

<p>Its first release, v0.1 (unstable for now), improves the method generation with:</p>

<ul>
<li>type hinted arguments</li>
<li>object arguments named after their type</li>
<li>putting each arguments on their own lines if the inline alternative would have been longer than 120 characters</li>
</ul>

<p>To be fair, this is exactly what already <a href="https://ciaranmcnulty.com/">Ciaran McNulty</a>'s
<a href="https://github.com/ciaranmcnulty/phpspec-typehintedmethods">Typehinted Methods extension</a>
provides, so why would we choose SpecGen? Well simply because it intends to do much more:</p>

<ul>
<li>insertion of <code>use</code> statements</li>
<li>constructor generation (each argument will have a corresponding property and a property initialization)</li>
<li>PHPdoc</li>
<li>???</li>
<li>profit!</li>
</ul>

<h2 id="memio-specgen-example">Memio SpecGen example</h2>

<p>Let's give it a try by first removing the code we boostrapped until now:</p>

<pre><code>rm -rf src
</code></pre>

<p>In order to demonstrate more type hints, we'll add more arguments:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;
use Vendor\Project\Request;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response(Request $request)
    {
        $parameters = array();
        $isEnabled = true;
        $this-&gt;handle($request, $parameters, $isEnabled)-&gt;shouldHaveType('Vendor\Project\Response');
    }
}
</code></pre>

<p>We can now run the test suite to bootstrap the code:</p>

<pre><code>phpspec run
</code></pre>

<p>This should create the following <code>src/Vendor/Project/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function handle(Request $request, array $argument1, $argument2)
    {
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: for now <code>use</code> statements aren't generated. In our example it doesn't
  matter since <code>Request</code> is in the same namespace as <code>RequestHandler</code>.</p>
</blockquote>

<p>Let's remove again the generated code:</p>

<pre><code>rm -rf src
</code></pre>

<p>Now we'd like to see this multiline feature by adding many arguments to our specifiction:</p>

<pre><code class="php">&lt;?php
// File: spec/Vendor/Project/RequestHandlerSpec.php

namespace spec\Vendor\Project;

use PhpSpec\ObjectBehavior;

class RequestHandlerSpec extends ObjectBehavior
{
    function it_takes_arequest_and_returns_a_response()
    {
        $this-&gt;myMethod(1, 2, 3, 4, 5, 6, 7, 8);
    }
}
</code></pre>

<p>Again, we run the test suite:</p>

<pre><code>phpspec run
</code></pre>

<p>This should bootstrap the following <code>src/Vendor/Project/RequestHandler.php</code> file:</p>

<pre><code class="php">&lt;?php

namespace Vendor\Project;

class RequestHandler
{
    public function myMethod(
        $argument1,
        $argument2,
        $argument3,
        $argument4,
        $argument5,
        $argument6,
        $argument7,
        $argument8
    )
    {
    }
}
</code></pre>

<p>And that's it!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Memio SpecGen improves phpspec's generator by adding better named, type hinted
and PSR-2 compliant method arguments.</p>

<p>Note that this kind of improvement has to be done in extension. They cannot be
done directly in phpspec because it tries to enforce best practices, and one of
them is to type hint only against interfaces. As it happens, the current extensions
can also type hint against implementations, depending on how the developers write
their specifications.</p>

<p>The next versions will bring even more exciting features, such as constructor and PHPdoc
generation.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 3.3: Consuming, remote calls]]></title>
            <link href="https://gnugat.github.io/2015/03/25/sf-ws-part-3-3-consuming-remote.html"/>
            <updated>2015-03-25T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2015/03/25/sf-ws-part-3-3-consuming-remote.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the seventh article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the six first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
<li><a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">2.3 Creation, refactoring</a></li>
<li><a href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html">3.1 Consuming, RequestHandler</a></li>
<li><a href="/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html">3.2 Consuming, Guzzle</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-cs">following repository</a>.</p>

<p>In the previous article, we've created a Guzzle RequestHandler: we are now able
to make remote calls using a third party library, but without the cost of coupling
ourselves to it. If Guzzle 6 is released we'll have to change only one class, instead
of everywhere in our application.</p>

<p>In this article, we'll create the actual remote calls.</p>

<h2 id="credential-configuration">Credential configuration</h2>

<p>The web service we want to call requires us to authenticate. Those credentials
shouldn't be hardcoded, we'll create new parameters for them (same goes for the URL):</p>

<pre><code># File: app/config/parameters.yml.dist
    ws_url: http://example.com
    ws_username: username
    ws_password: ~
</code></pre>

<p>We can then set those values in the actual parameter file:</p>

<pre><code># File: app/config/parameters.yml
    ws_url: "http://ws.local/app_dev.php"
    ws_username: spanish_inquisition
    ws_password: "NobodyExpectsIt!"
</code></pre>

<p>Note that because our password contains a character which is reserved in YAML (<code>!</code>),
we need to put the value between double quotes (same goes for <code>%</code> and <code>@</code>).</p>

<p>Let's commit this:</p>

<pre><code>git add -A
git commit -m 'Added credentials configuration'
</code></pre>

<h2 id="profile-gateway">Profile Gateway</h2>

<p>We can create a <a href="http://martinfowler.com/eaaCatalog/gateway.html">Gateway</a>
specialized in calling the profile web service:</p>

<pre><code>./bin/phpspec describe 'AppBundle\Profile\ProfileGateway'
</code></pre>

<p>Usually we categorize our Symfony applications by Pattern: we'd create a <code>Gateway</code>
directory with all the Gateway service. However this can become quite cubersome
when the application grows, services are usually linked to a model meaning that
we'd have to jump from the <code>Model</code> (or <code>Entity</code>) directory to the <code>Gateway</code> one,
then go to the <code>Factory</code> directory, etc...</p>

<p>Here we've chosen an alternative: group services by model. All <code>Profile</code> services
can be found in the same directory.</p>

<p>Let's write the Gateway's specification:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/Profile/ProfileGatewaySpec.php

namespace spec\AppBundle\Profile;

use AppBundle\RequestHandler\RequestHandler;
use AppBundle\RequestHandler\Response;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class ProfileGatewaySpec extends ObjectBehavior
{
    const URL = 'http://example.com';
    const USERNAME = 'spanish inquisition';
    const PASSWORD = 'nobody expects it';

    const ID = 42;
    const NAME = 'Arthur';

    function let(RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($requestHandler, self::URL, self::USERNAME, self::PASSWORD);
    }

    function it_creates_profiles(RequestHandler $requestHandler, Response $response)
    {
        $profile = array(
            'id' =&gt; self::ID,
            'name' =&gt; self::NAME,
        );

        $request = Argument::type('AppBundle\RequestHandler\Request');
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $response-&gt;getBody()-&gt;willReturn($profile);

        $this-&gt;create(self::NAME)-&gt;shouldBe($profile);
    }
}
</code></pre>

<p>We can now generate the code's skeleton:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>It constructs a <code>Request</code> object, gives it to <code>RequestHandler</code> and then returns the
<code>Response</code>'s body:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Profile/ProfileGateway.php

namespace AppBundle\Profile;

use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;

class ProfileGateway
{
    private $requestHandler;
    private $url;
    private $username;
    private $password;

    public function __construct(RequestHandler $requestHandler, $url, $username, $password)
    {
        $this-&gt;requestHandler = $requestHandler;
        $this-&gt;username = $username;
        $this-&gt;password = $password;
    }

    public function create($name)
    {
        $request = new Request('POST', $this-&gt;url.'/api/v1/profiles');
        $request-&gt;setHeader('Authorization', 'Basic '.base64_encode($this-&gt;username.':'.$this-&gt;password));
        $request-&gt;setHeader('Content-Type', 'application/json');
        $request-&gt;setBody(json_encode(array('name' =&gt; $name)));

        $response = $this-&gt;requestHandler-&gt;handle($request);

        return $response-&gt;getBody();
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Managing URLs can become quite tricky when the number of routes grows.
  Sometimes we'll want HTTPS, sometimes HTTP. Sometimes we'll want the first version
  of the API, sometimes the pre production one. And what should we do when we'll
  need query parameters?</p>
  
  <p>Usually I don't bother with those until the need is actually there, then I create
  a <code>UrlGenerator</code> which works a bit like Symfony's one and relies on a configuration array.</p>
</blockquote>

<p>Let's check our tests:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green!</p>

<pre><code>git add -A
git commit -m 'Created ProfileGateway'
</code></pre>

<h2 id="create-profile-command">Create Profile Command</h2>

<p>Our application happens to be a Command Line Interface (CLI). We want to write a
command to create profiles, and as usual we'll begin with a test:</p>

<pre><code class="php">&lt;?php
// File: tests/Command/CreateProfileCommandTest.php

namespace AppBundle\Tests\Command;

use PHPUnit_Framework_TestCase;
use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Component\Console\Output\NullOutput;
use Symfony\Component\Console\Input\ArrayInput;

class CreateProfileCommandTest extends PHPUnit_Framework_TestCase
{
    private $app;
    private $output;

    protected function setUp()
    {
        $kernel = new \AppKernel('test', false);
        $this-&gt;app = new Application($kernel);
        $this-&gt;app-&gt;setAutoExit(false);
        $this-&gt;output = new NullOutput();
    }

    public function testItRunsSuccessfully()
    {
        $input = new ArrayInput(array(
            'commandName' =&gt; 'app:profile:create',
            'name' =&gt; 'Igor',
        ));

        $exitCode = $this-&gt;app-&gt;run($input, $this-&gt;output);

        $this-&gt;assertSame(0, $exitCode);
    }
}
</code></pre>

<p>Let's make this test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Command/CreateProfileCommand.php

namespace AppBundle\Command;

use Symfony\Bundle\FrameworkBundle\Command\ContainerAwareCommand;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;

class CreateProfileCommand extends ContainerAwareCommand
{
    protected function configure()
    {
        $this-&gt;setName('app:profile:create');
        $this-&gt;setDescription('Create a new profile');

        $this-&gt;addArgument('name', InputArgument::REQUIRED);
    }

    protected function execute(InputInterface $input, OutputInterface $output)
    {
        $profileGateway = $this-&gt;getContainer()-&gt;get('app.profile_gateway');

        $profile = $profileGateway-&gt;create($input-&gt;getArgument('name'));

        $output-&gt;writeln(sprintf('Profile #%s "%s" created', $profile['id'], $profile['name']));
    }
}
</code></pre>

<p>We'll need to define <code>ProfileGateway</code> as a service:</p>

<pre><code># File: app/config/services.yml
imports:
    - { resource: services/request_handler.yml }

services:
    app.profile_gateway:
        class: AppBundle\Profile\ProfileGateway
        arguments:
            - "@app.request_handler"
            - "%ws_url%"
            - "%ws_username%"
            - "%ws_password%"
</code></pre>

<p>By having a look <code>ProfileGateway</code> we can spot a mistake, the initialization or URL
is missing from the constructor:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Profile/ProfileGateway.php

    public function __construct(RequestHandler $requestHandler, $url, $username, $password)
    {
        $this-&gt;requestHandler = $requestHandler;
        $this-&gt;username = $username;
        $this-&gt;password = $password;
        $this-&gt;url = $url;
    }
</code></pre>

<p>Another mistake lies in <code>JsonResponseListener</code>, each Guzzle header is an array:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Listener/JsonResponseListener.php

        $contentType = $response-&gt;getHeader('Content-Type');
        if (false === strpos($contentType[0], 'application/json')) {
            return;
        }
</code></pre>

<p>With these fixes, the test should pass:</p>

<pre><code>phpunit -c app
</code></pre>

<blockquote>
  <p><strong>Note</strong>: if we get a <code>You have requested a non-existent service "app.profile_gateway"</code>
  error, we might need to clear the cache for test environment: <code>php app/console cache:clear --env=test</code>.</p>
  
  <p><strong>Note</strong>: if we get a Guzzle exception, we need to check that the previous application installed
  ("ws.local"), and that its database is created:</p>

<pre><code>cd ../ws
php app/console doctrine:database:create
php app/console doctrine:schema:create
cd ../cs
</code></pre>
</blockquote>

<p>We can now save our work:</p>

<pre><code>git add -A
git commit -m 'Created CreateProfileCommand'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We have now an application that consumes a web service. We have decoupled it from
third party libraries using RequestHandler and isolated the endpoint logic in a
Gateway class.</p>

<p>There's a lot to say about the test we wrote: it makes a network call which is slow, unreliable
and it isn't immutable. If we try to run again our test, it will fail!
To fix this we have many possibilities:</p>

<ul>
<li>mock the endpoints, it will make the tests faster and immutable but if the endpoints change our tests will still pass</li>
<li>cleanup the created profile by aking another network call, it will make the test even slower</li>
</ul>

<p>At this point it depends on how confident we are in the web services and what we want to test.</p>

<p>We should also write more test on edge cases: what happens with the wrong credentials?
What happens if the endpoints cannot be reached (request timeout, connection timeout, etc)?
What happens when we try to create a profile which already exists?</p>

<p>As it happens, this is also the conclusion of this series on managing Web Services in a
Symfony environment. There's a lot more to say for example about caching remote resources
in a local database, about self discovering APIs and about micro services, but I feel
those should each have their own series of article :) .</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 3.2: Consuming, Guzzle]]></title>
            <link href="https://gnugat.github.io/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html"/>
            <updated>2015-03-18T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the sixth article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the five first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
<li><a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">2.3 Creation, refactoring</a></li>
<li><a href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html">3.1 Consuming, RequestHandler</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-cs">following repository</a>.</p>

<p>In the previous article, we've bootstrapped an application with a RequestHandler,
allowing us to be decoupled from the third part library we'll choose to request
remote endpoints.</p>

<p>In this article, we'll create a Guzzle 5 implementation.</p>

<h2 id="guzzle-request-handler">Guzzle Request Handler</h2>

<p>As usual, we first describe the class we want to create:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Middleware\GuzzleRequestHandler'
</code></pre>

<p>Our Guzzle implementation will translate our <code>Request</code> into a guzzle one, and a
guzzle response into our <code>Response</code>:</p>

<pre><code class="php">&lt;?php
// spec/AppBundle/RequestHandler/Middleware/GuzzleRequestHandlerSpec.php

namespace spec\AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Request;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Message\RequestInterface;
use GuzzleHttp\Message\ResponseInterface;
use GuzzleHttp\Stream\StreamInterface;
use PhpSpec\ObjectBehavior;

class GuzzleRequestHandlerSpec extends ObjectBehavior
{
    const VERB = 'POST';
    const URI = '/api/v1/profiles';

    const HEADER_NAME = 'Content-Type';
    const HEADER_VALUE = 'application/json';

    const BODY = '{"username":"King Arthur"}';

    function let(ClientInterface $client)
    {
        $this-&gt;beConstructedWith($client);
    }

    function it_is_a_request_handler()
    {
        $this-&gt;shouldImplement('AppBundle\RequestHandler\RequestHandler');
    }

    function it_uses_guzzle_to_do_the_actual_request(
        ClientInterface $client,
        RequestInterface $guzzleRequest,
        ResponseInterface $guzzleResponse,
        StreamInterface $stream
    )
    {
        $request = new Request(self::VERB, self::URI);
        $request-&gt;setHeader(self::HEADER_NAME, self::HEADER_VALUE);
        $request-&gt;setBody(self::BODY);

        $client-&gt;createRequest(self::VERB, self::URI, array(
            'headers' =&gt; array(self::HEADER_NAME =&gt; self::HEADER_VALUE),
            'body' =&gt; self::BODY,
        ))-&gt;willReturn($guzzleRequest);
        $client-&gt;send($guzzleRequest)-&gt;willReturn($guzzleResponse);
        $guzzleResponse-&gt;getStatusCode()-&gt;willReturn(201);
        $guzzleResponse-&gt;getHeaders()-&gt;willReturn(array('Content-Type' =&gt; 'application/json'));
        $guzzleResponse-&gt;getBody()-&gt;willReturn($stream);
        $stream-&gt;__toString()-&gt;willReturn('{"id":42,"username":"King Arthur"}');

        $this-&gt;handle($request)-&gt;shouldHaveType('AppBundle\RequestHandler\Response');
    }
}
</code></pre>

<p>Time to boostrap this implementation:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And to actually write it:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Middleware/GuzzleRequestHandler.php

namespace AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;
use AppBundle\RequestHandler\Response;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Message\RequestInterface;
use GuzzleHttp\Message\ResponseInterface;
use GuzzleHttp\Stream\StreamInterface;

class GuzzleRequestHandler implements RequestHandler
{
    private $client;

    public function __construct(ClientInterface $client)
    {
        $this-&gt;client = $client;
    }

    public function handle(Request $request)
    {
        $guzzleRequest = $this-&gt;client-&gt;createRequest($request-&gt;getVerb(), $request-&gt;getUri(), array(
            'headers' =&gt; $request-&gt;getHeaders(),
            'body' =&gt; $request-&gt;getBody(),
        ));
        $guzzleResponse = $this-&gt;client-&gt;send($guzzleRequest);
        $response = new Response($guzzleResponse-&gt;getStatusCode());
        $response-&gt;setHeaders($guzzleResponse-&gt;getHeaders());
        $response-&gt;setBody($guzzleResponse-&gt;getBody()-&gt;__toString());

        return $response;
    }
}
</code></pre>

<p>Let's check it:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Brilliant!</p>

<pre><code>git add -A
git commit -m 'Created GuzzleRequestHandler'
</code></pre>

<h2 id="event-middleware">Event Middleware</h2>

<p>In the future we'd like to be able to hook in the <code>RequestHandler</code>'s workflow,
for example if the Response's body is in JSON, convert it into an array.</p>

<p>This kind of thing can be done by sending events, in our case when a Response is received:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/ReceivedResponse.php

namespace AppBundle\RequestHandler\Event;

use AppBundle\RequestHandler\Response;
use Symfony\Component\EventDispatcher\Event;

class ReceivedResponse extends Event
{
    private $response;

    public function __construct(Response $response)
    {
        $this-&gt;response = $response;
    }

    public function getResponse()
    {
        return $this-&gt;response;
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: This is a simple Data Transfer Object (DTO), it doesn't contain any
  logic and never will. This means that we don't have to write any tests for it.</p>
</blockquote>

<p>We could add an <code>EventDispatcher</code> in <code>GuzzleRequestHandler</code>, or we could create
a middleware: a RequestHandler that dispatches events and then calls another RequestHandler
(e.g. <code>GuzzleRequestHandler</code>):</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Middleware\EventRequestHandler'
</code></pre>

<p>This way if we want to throw away <code>GuzzleRequestHandler</code> and replace it with something
else, we don't have to write again the dispatching code. Here's the specification:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/RequestHandler/Middleware/EventRequestHandlerSpec.php

namespace spec\AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;
use AppBundle\RequestHandler\Response;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;

class EventRequestHandlerSpec extends ObjectBehavior
{
    function let(EventDispatcherInterface $eventDispatcher, RequestHandler $requestHandler)
    {
        $this-&gt;beConstructedWith($eventDispatcher, $requestHandler);
    }

    function it_is_a_request_handler()
    {
        $this-&gt;shouldImplement('AppBundle\RequestHandler\RequestHandler');
    }

    function it_dispatches_events(
        EventDispatcherInterface $eventDispatcher,
        Request $request,
        RequestHandler $requestHandler,
        Response $response
    )
    {
        $requestHandler-&gt;handle($request)-&gt;willReturn($response);
        $receivedResponse = Argument::type('AppBundle\RequestHandler\Event\ReceivedResponse');
        $eventDispatcher-&gt;dispatch('request_handler.received_response', $receivedResponse)-&gt;shouldBeCalled();

        $this-&gt;handle($request)-&gt;shouldBe($response);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We could improve this middleware by dispatching an event before giving
  the request to the RequestHandler. We could also catch exceptions coming from
  the RequestHandler and dispatch an event.</p>
</blockquote>

<p>Time to bootstrap the code:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And to make the test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Middleware/EventRequestHandler.php

namespace AppBundle\RequestHandler\Middleware;

use AppBundle\RequestHandler\Event\ReceivedResponse;
use AppBundle\RequestHandler\Request;
use AppBundle\RequestHandler\RequestHandler;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;

class EventRequestHandler implements RequestHandler
{
    private $eventDispatcher;
    private $requestHandler;

    public function __construct(EventDispatcherInterface $eventDispatcher, RequestHandler $requestHandler)
    {
        $this-&gt;eventDispatcher = $eventDispatcher;
        $this-&gt;requestHandler = $requestHandler;
    }

    public function handle(Request $request)
    {
        $response = $this-&gt;requestHandler-&gt;handle($request);
        $this-&gt;eventDispatcher-&gt;dispatch('request_handler.received_response', new ReceivedResponse($response));

        return $response;
    }
}
</code></pre>

<p>Did we succeed?</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Yes, we did:</p>

<pre><code>git add -A
git commit -m 'Created EventRequestHandler'
</code></pre>

<h2 id="json-response-listener">Json Response Listener</h2>

<p>When a Response contains a JSON body, we need to:</p>

<ul>
<li>check the content type</li>
<li>decode the body</li>
<li>check that the JSON syntax is valid</li>
</ul>

<p>With this in mind, we can describe the listerner:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Listener\JsonResponseListener'
</code></pre>

<p>Now we can write the specification:</p>

<pre><code class="php">&lt;?php
// src: spec/AppBundle/RequestHandler/Listener/JsonResponseListenerSpec.php

namespace spec\AppBundle\RequestHandler\Listener;

use AppBundle\RequestHandler\Event\ReceivedResponse;
use AppBundle\RequestHandler\Response;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class JsonResponseListenerSpec extends ObjectBehavior
{
    function it_handles_json_response(ReceivedResponse $receivedResponse, Response $response)
    {
        $receivedResponse-&gt;getResponse()-&gt;willReturn($response);
        $response-&gt;getHeader('Content-Type')-&gt;willReturn('application/json');
        $response-&gt;getBody()-&gt;willReturn('{"data":[]}');
        $response-&gt;setBody(array('data' =&gt; array()))-&gt;shouldBeCalled();

        $this-&gt;onReceivedResponse($receivedResponse);
    }

    function it_does_not_handle_non_json_response(ReceivedResponse $receivedResponse, Response $response)
    {
        $receivedResponse-&gt;getResponse()-&gt;willReturn($response);
        $response-&gt;getHeader('Content-Type')-&gt;willReturn('text/html');
        $response-&gt;getBody()-&gt;shouldNotBeCalled();

        $this-&gt;onReceivedResponse($receivedResponse);
    }

    function it_fails_to_handle_invalid_json(ReceivedResponse $receivedResponse, Response $response)
    {
        $receivedResponse-&gt;getResponse()-&gt;willReturn($response);
        $response-&gt;getHeader('Content-Type')-&gt;willReturn('application/json');
        $response-&gt;getBody()-&gt;willReturn('{"data":[');

        $exception = 'Exception';
        $this-&gt;shouldThrow($exception)-&gt;duringOnReceivedResponse($receivedResponse);
    }
}
</code></pre>

<p>Time to implement the code:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Listener/JsonResponseListener.php

namespace AppBundle\RequestHandler\Listener;

use AppBundle\RequestHandler\Event\ReceivedResponse;
use Exception;

class JsonResponseListener
{
    public function onReceivedResponse(ReceivedResponse $receivedResponse)
    {
        $response = $receivedResponse-&gt;getResponse();
        $contentType = $response-&gt;getHeader('Content-Type');
        if (false === strpos($response-&gt;getHeader('Content-Type'), 'application/json')) {
            return;
        }
        $body = $response-&gt;getBody();
        $json = json_decode($body, true);
        if (json_last_error()) {
            throw new Exception("Invalid JSON: $body");
        }
        $response-&gt;setBody($json);
    }
}
</code></pre>

<p>Is it enough to make the tests pass?</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Yes, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created JsonResponseListener'
</code></pre>

<h2 id="creating-services">Creating services</h2>

<p>In order to be able to use this code in our Symfony application, we need to
define those classes as services. Since we'll have a lot of definitions, we'll
create a <code>services</code> directory:</p>

<pre><code>mkdir app/config/services
</code></pre>

<p>We'll update <code>services.yml</code> to include our new file:</p>

<pre><code># File: app/config/services.yml
imports:
    - { resource: services/request_handler.yml }
</code></pre>

<p>And finally we'll create the <code>request_handler.yml</code> file:</p>

<pre><code>touch app/config/services/request_handler.yml
</code></pre>

<p>The first service we'll define is Guzzle:</p>

<pre><code>#file: app/config/services/request_handler.yml
services:
    guzzle.client:
        class: GuzzleHttp\Client
</code></pre>

<p>This allows us to define the GuzzleRequestHandler:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.guzzle_request_handler:
        class: AppBundle\RequestHandler\Middleware\GuzzleRequestHandler
        arguments:
            - "@guzzle.client"
</code></pre>

<p>We want to wrap each of these GuzzleRequestHandler calls with events, so we define
EventRequestHandler like this:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.event_request_handler:
        class: AppBundle\RequestHandler\Middleware\EventRequestHandler
        arguments:
            - "@event_dispatcher"
            - "@app.guzzle_request_handler"
</code></pre>

<p>In the future we might add more middlewares (e.g. RetryRequestHandler, StopwatchRequestHandler, etc),
so we want to avoid using a service that points directly to an implementation. We
can define an alias:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.request_handler:
        alias: app.event_request_handler
</code></pre>

<p>Finally, we want to define our listener:</p>

<pre><code>#file: app/config/services/request_handler.yml

    app.request_handler.json_response_listener:
        class: AppBundle\RequestHandler\Listener\JsonResponseListener
        tags:
            - { name: kernel.event_listener, event: request_handler.received_response, method: onReceivedResponse }
</code></pre>

<p>And that's it!</p>

<pre><code>git add -A
git commit -m 'Defined RequestHandler as a service'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We can now send remote request using Guzzle, without coupling ourself to the library.
We even implemented an EventRequestHandler to allow extension points, it also provides
us an example on how to write more RequestHandler middlewares.</p>

<p>In the next article we'll start using RequestHandler in a specific kind of service:
Gateways.</p>

<h3 id="http-adapter">HTTP Adapter</h3>

<p>You might be interested in <a href="https://github.com/egeloen/ivory-http-adapter">Ivory HttpAdapter</a>,
a library very similar to our RequestHandler: it sends remote request through a
given client (it supports many of them). It also provides events to hook into its workflow!</p>

<p>Personnaly, I'd rather create my own RequestHandler, as my purpose is to decouple
the application from an external library like Guzzle: using a third party library
to do so seems a bit ironic.
As you can see there's little effort involved, and it has the advantage of providing
the strict minimum the application needs.</p>

<h3 id="psr-7">PSR-7</h3>

<p><a href="https://github.com/php-fig/fig-standards/blob/master/proposed/http-message.md">PSR-7</a>
is a standard currently under review: it defines how frameworks should ideally
implement the HTTP protocole.</p>

<p>Since it's not yet accepted, it is subject to change so I wouldn't recommend to follow it yet.
Our RequestHandler kind of implement the HTTP protocole, but I'd rather not make
it PSR-7 compliant, as it requires the implementation of many features we don't
really need.</p>

<p>To get a balanced opinion on the matter, I'd recommend you to read:</p>

<ul>
<li><a href="https://mwop.net/blog/2015-01-26-psr-7-by-example.html">PSR-7 By Example</a></li>
<li><a href="http://evertpot.com/psr-7-issues/">PSR-7 is imminent, and here's my issues with it.</a></li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 3.1: Consuming, RequestHandler]]></title>
            <link href="https://gnugat.github.io/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html"/>
            <updated>2015-03-11T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fifth article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the four first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
<li><a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">2.3 Creation, refactoring</a></li>
</ul>

<p>Our purpose in this third section is to create an application that consumes the
<a href="https://github.com/gnugat-examples/sf-ws">previously created web services</a>.</p>

<p>But for now, we'll just bootstrap it, and start to create a RequestHandler!</p>

<h2 id="installation">Installation</h2>

<p>We will follow the exact same steps as in <a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">the chapter 2.1</a>:</p>

<ol>
<li>Installing the standard edition</li>
<li>Twitching for tests</li>
</ol>

<p>Instead of calling our application <code>ws</code>, we'll call it <code>cs</code> (like Consuming Service).</p>

<h2 id="making-remote-calls-with-guzzle">Making remote calls with Guzzle</h2>

<p>Is the application boostrapped yet? If it is, then we can continue.</p>

<p>In order to consume web services, we need to be able to make remote requests. PHP
provides some native functions for this (<code>file_get_contents</code>, <code>stream_socket_client</code>,
<code>fopen</code>, etc) and we can find many libraries as well (<a href="https://github.com/kriswallsmith/Buzz">Buzz</a>,
<a href="http://phphttpclient.com/">HTTP Full</a>, <a href="http://reactphp.org/">React</a>, etc).</p>

<p>For this series, we'll use <a href="http://guzzle.readthedocs.org/en/latest/">Guzzle</a>:</p>

<pre><code>composer require guzzlehttp/guzzle:~5.0
</code></pre>

<p>Let's commit it for now:</p>

<pre><code>git add -A
git commit -m 'Installed Guzzle'
</code></pre>

<h2 id="creating-a-request-handler">Creating a Request Handler</h2>

<p>Sometimes we need to decouple our application from the third party libraries it depends on.</p>

<p>For example let's say that we were using Guzzle 4, but we'd like to use Amazon Web Service (AWS)
S3 in our project. The issue? It's version 2 depends on Guzzle 3 and its version 3
depends on Guzzle 5. We now need to upgrade our usage of Guzzle everywhere in our
application.</p>

<p><a href="http://knowyourmeme.com/photos/141710-true-story"><img src="http://i0.kym-cdn.com/photos/images/newsfeed/000/141/710/7nTnr.png?1309357850" alt="True story" /></a></p>

<p>To minimize this, we can centralize the usage of Guzzle in one single file. In order
to be able to do so, we'll create a RequestHandler:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/RequestHandler.php

namespace AppBundle\RequestHandler;

interface RequestHandler
{
    // @return Response
    public function handle(Request $request);
}
</code></pre>

<p>In our application we can rely on this interface: we own it and it has few chances to change.
We'll now create an object that describes the request to send:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Request'
</code></pre>

<p>A minimalistic raw HTTP request looks like the following:</p>

<pre><code>GET /api/v1/profiles HTTP/1.1
</code></pre>

<p>Since we don't really care about the protocol's version we can define the constructor
with two arguments:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/RequestSpec.php

    function it_has_a_verb_and_an_uri()
    {
        $this-&gt;beConstructedWith('GET', '/api/v1/profiles');

        $this-&gt;getVerb()-&gt;shouldBe('GET');
        $this-&gt;getUri()-&gt;shouldBe('/api/v1/profiles');
    }
</code></pre>

<p>Running the specifications will bootstrap the class for us:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>We can now make the test pass by writing the code:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Request.php

namespace AppBundle\RequestHandler;

class Request
{
    private $verb;
    private $uri;

    public function __construct($verb, $uri)
    {
        $this-&gt;verb = $verb;
        $this-&gt;uri = $uri;
    }

    public function getVerb()
    {
        return $this-&gt;verb;
    }

    public function getUri()
    {
        return $this-&gt;uri;
    }
}
</code></pre>

<p>Let's check if it's enough for now:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created Request'
</code></pre>

<h2 id="request-headers">Request headers</h2>

<p>A request usually has headers:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/RequestSpec.php

    function it_can_have_headers()
    {
        $this-&gt;beConstructedWith('GET', '/api/v1/profiles');
        $this-&gt;setHeader('Content-Type', 'application/json');

        $this-&gt;getHeaders()-&gt;shouldBe(array('Content-Type' =&gt; 'application/json'));
    }
</code></pre>

<p>Let's boostrap them:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And complete the code:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Request.php

    private $headers = array();

    public function setHeader($name, $value)
    {
        $this-&gt;headers[$name] = $value;
    }

    public function getHeaders()
    {
        return $this-&gt;headers;
    }
</code></pre>

<p>This makes the test pass:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>That's worth a commit:</p>

<pre><code>git add -A
git commit -m 'Added headers to Request'
</code></pre>

<h2 id="request-body">Request body</h2>

<p>The last addition to our request will be the possibility to add a body:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/RequestSpec.php

    function it_can_have_a_body()
    {
        $this-&gt;beConstructedWith('GET', '/api/v1/profiles');
        $this-&gt;setBody('{"wound":"just a flesh one"}');

        $this-&gt;getBody()-&gt;shouldBe('{"wound":"just a flesh one"}');
    }
</code></pre>

<p>As usual we bootstrap it:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And then we complete it:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Request.php

    private $body;

    public function setBody($body)
    {
        $this-&gt;body = $body;
    }

    public function getBody()
    {
        return $this-&gt;body;
    }
</code></pre>

<p>Let's make our console green:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Let's make our console grin:</p>

<pre><code>git add -A
git commit -m 'Added body to Request'
</code></pre>

<h2 id="creating-a-response">Creating a Response</h2>

<p><code>RequestHandler</code> should return a <code>Response</code> object:</p>

<pre><code>./bin/phpspec describe 'AppBundle\RequestHandler\Response'
</code></pre>

<p>A minimalistic raw HTTP response looks like the following:</p>

<pre><code>HTTP/1.1 204 NO CONTENT
</code></pre>

<p>Since we don't care about both the protocol's version and the reason, we can
define the constructor with a single argument:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/ResponseSpec.php

    function it_has_a_status_code()
    {
        $this-&gt;beConstructedWith(204);

        $this-&gt;getStatusCode()-&gt;shouldBe(204);
    }
</code></pre>

<p>Running the specifications will bootstrap the class for us:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>We can now make the test pass by writing the code:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/RequestHandler/Response.php

namespace AppBundle\RequestHandler;

class Response
{
    private $statusCode;

    public function __construct($statusCode)
    {
        $this-&gt;statusCode = $statusCode;
    }

    public function getStatusCode()
    {
        return $this-&gt;statusCode;
    }
}
</code></pre>

<p>Let's check if it's enough for now:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created Response'
</code></pre>

<h2 id="response-headers">Response headers</h2>

<p>A response can also have headers:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/ResponseSpec.php

    function it_can_have_headers()
    {
        $this-&gt;beConstructedWith(204);
        $this-&gt;setHeaders(array('Content-Type' =&gt; 'application/json'));

        $this-&gt;getHeader('Content-Type')-&gt;shouldBe('application/json');
    }
</code></pre>

<p>Let's boostrap them:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And complete the code:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Response.php

    private $headers = array();

    public function setHeaders(array $headers)
    {
        $this-&gt;headers = $headers;
    }

    public function getHeader($name)
    {
        return (isset($this-&gt;headers[$name]) ? $this-&gt;headers[$name] : null);
    }
</code></pre>

<p>This makes the test pass:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>That's worth a commit:</p>

<pre><code>git add -A
git commit -m 'Added headers to Response'
</code></pre>

<h2 id="response-body">Response body</h2>

<p>Last but not least, the response's body:</p>

<pre><code class="php">// File: spec/AppBundle/RequestHandler/ResponseSpec.php

    function it_can_have_a_body()
    {
        $this-&gt;beConstructedWith(200);
        $this-&gt;setBody('{"wound":"just a flesh one"}');

        $this-&gt;getBody()-&gt;shouldBe('{"wound":"just a flesh one"}');
    }
</code></pre>

<p>As usual we bootstrap it:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And then we complete it:</p>

<pre><code class="php">// File: src/AppBundle/RequestHandler/Response.php

    private $body;

    public function setBody($body)
    {
        $this-&gt;body = $body;
    }

    public function getBody()
    {
        return $this-&gt;body;
    }
</code></pre>

<p>Let's make our console green:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Let's make our console grin:</p>

<pre><code>git add -A
git commit -m 'Added body to Response'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>We've bootstrapped an application, and created a RequestHandler which will help us
to avoid coupling with Guzzle. In the <a href="/2015/03/18/sf-ws-part-3-2-consuming-guzzle.html">next article</a>,
we'll talk about middleware and start to create some RequestHandler
implementations (yes, more than one!).</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 2.3: Creation, refactoring]]></title>
            <link href="https://gnugat.github.io/2015/03/04/sf-ws-part-2-3-creation-refactoring.html"/>
            <updated>2015-03-04T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2015/03/04/sf-ws-part-2-3-creation-refactoring.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the fourth article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the three first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
<li><a href="/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html">2.2 Creation, the pragmatic way</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-ws">following repository</a>.</p>

<p>In the previous post we've created a first endpoint by taking a few shortcuts.
As we wouldn't want to get technical debt, we're going to refactor it.</p>

<h2 id="the-controller-responsibility">The controller responsibility</h2>

<p>In order to <a href="https://speakerdeck.com/richardmiller/avoiding-the-mud">avoid the mud</a>,
we need to remove the logic from the controller. But which logic?</p>

<p>In <a href="https://symfony.com">Symfony</a>, controllers receive a Request and return a Response
(this follows the HTTP protocol). It is also the glue between the framework and our application.</p>

<p>From this we can assume that its responsibility is to:</p>

<ol>
<li>extract the parameters from the Request</li>
<li>give it to our application</li>
<li>get a result and build the Response with it</li>
</ol>

<p>The request's parameters could be legion, we woudln't like to have a method with too many arguments.
A way to solve this would be to create a Data Transfer Object (DTO): we would put all those parameters
in it and give it to the appropriate service.</p>

<h2 id="command-bus">Command Bus</h2>

<p>The Command Bus pattern is very fitting for this purpose: the DTO is called a Command, its name should
communicate our intention (in our example <code>CreateProfile</code>). It also has the responsibility of
validating user's input (for example converting IDs into integers).</p>

<p>Each Command is associated to only one CommandHandler service which do the actual logic.</p>

<p>Finally, there's the CommandBus: it finds the appropriate CommandHandler for the given Command
and executes it. It also executes some routines before and after the call (for example we can flush doctrine
after each commands).</p>

<blockquote>
  <p><strong>Note</strong>: CommandHandlers don't return anything.</p>
</blockquote>

<p>If you want to find out more on the Command Bus pattern, I'd recommend you to
have a look at this series by Matthias Noback:</p>

<ol>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/a-wave-of-command-buses/">a wave of command buses</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/responsibilities-of-the-command-bus/">responsibilities of the command bus</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/from-commands-to-events/">from commands to events</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/some-questions-about-the-command-bus/">some questions about the command bus</a></li>
<li><a href="http://php-and-symfony.matthiasnoback.nl/2015/01/collecting-events-and-the-events-aware-command-bus/">collectiong events and the event dispatching comand bus</a></li>
</ol>

<p>Since commands are all about sending a message, you can also read Mathias Verraes article on
<a href="http://verraes.net/2015/01/messaging-flavours">Messaging flavours</a>. He also wrote a nice
article on <a href="http://verraes.net/2015/02/form-command-model-validation/">Form, Command and Model validation</a>.</p>

<h2 id="simplebus">SimpleBus</h2>

<p><a href="http://simplebus.github.io/MessageBus">SimpleBus</a> is a small library that fits our purpose:</p>

<pre><code>composer require simple-bus/doctrine-orm-bridge
composer require simple-bus/symfony-bridge
</code></pre>

<blockquote>
  <p><strong>Note</strong>: It requires at least PHP 5.4.</p>
</blockquote>

<p>You need to register the bundle in our application's kernel:</p>

<pre><code class="php">&lt;?php
// File: app/AppKernel.php

use Symfony\Component\HttpKernel\Kernel;
use Symfony\Component\Config\Loader\LoaderInterface;

class AppKernel extends Kernel
{
    public function registerBundles()
    {
        $bundles = array(
            new Symfony\Bundle\FrameworkBundle\FrameworkBundle(),
            new Symfony\Bundle\SecurityBundle\SecurityBundle(),
            new Symfony\Bundle\TwigBundle\TwigBundle(),
            new Symfony\Bundle\MonologBundle\MonologBundle(),
            new Symfony\Bundle\SwiftmailerBundle\SwiftmailerBundle(),
            new Symfony\Bundle\AsseticBundle\AsseticBundle(),
            new Doctrine\Bundle\DoctrineBundle\DoctrineBundle(),
            new Sensio\Bundle\FrameworkExtraBundle\SensioFrameworkExtraBundle(),
            new SimpleBus\SymfonyBridge\SimpleBusCommandBusBundle(),
            new SimpleBus\SymfonyBridge\SimpleBusEventBusBundle(),
            new SimpleBus\SymfonyBridge\DoctrineOrmBridgeBundle(),
            new AppBundle\AppBundle(),
        );

        if (in_array($this-&gt;getEnvironment(), array('dev', 'test'))) {
            $bundles[] = new Symfony\Bundle\DebugBundle\DebugBundle();
            $bundles[] = new Symfony\Bundle\WebProfilerBundle\WebProfilerBundle();
            $bundles[] = new Sensio\Bundle\DistributionBundle\SensioDistributionBundle();
            $bundles[] = new Sensio\Bundle\GeneratorBundle\SensioGeneratorBundle();
        }

        return $bundles;
    }

    public function registerContainerConfiguration(LoaderInterface $loader)
    {
        $loader-&gt;load(__DIR__.'/config/config_'.$this-&gt;getEnvironment().'.yml');
    }
}
</code></pre>

<p>Let's commit this installation:</p>

<pre><code>git add -A
git commit -m 'Installed SimpleBus'
</code></pre>

<h2 id="create-profile">Create Profile</h2>

<p>We didn't create a <code>ProfileRepository</code> earlier, but we're going to need it now:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Entity/ProfileRepository.php

namespace AppBundle\Entity;

use Doctrine\ORM\EntityRepository;

class ProfileRepository extends EntityRepository
{
}
</code></pre>

<p>We should name the Command after the action we want to do. In our case we want
to create a profile:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle\CommandBus/CreateProfile.php

namespace AppBundle\CommandBus;

use SimpleBus\Message\Message;

class CreateProfile implements Message
{
    public $name;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }
}
</code></pre>

<p>We then need a CommandHandler to do the actual creation. Since there will be some logic,
let's create a specification:</p>

<pre><code>./bin/phpspec describe 'AppBundle\CommandBus\CreateProfileHandler'
</code></pre>

<p>And now we can describe it:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/CommandBus/CreateProfileHandlerSpec.php

namespace spec\AppBundle\CommandBus;

use AppBundle\CommandBus\CreateProfile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class CreateProfileHandlerSpec extends ObjectBehavior
{
    const NAME = 'John Cleese';

    function let(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;beConstructedWith($objectManager, $profileRepository);
    }

    function it_creates_a_profile(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $profileRepository-&gt;findOneBy(array('name' =&gt; self::NAME))-&gt;willReturn(null);
        $createdProfile = Argument::type('AppBundle\Entity\Profile');
        $objectManager-&gt;persist($createdProfile)-&gt;shouldBeCalled();

        $this-&gt;handle(new CreateProfile(self::NAME));
    }
}
</code></pre>

<p>This allows us to generate the code's skeleton:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>And to finally write the code to make the test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/CommandBus/CreateProfileHandler.php

namespace AppBundle\CommandBus;

use AppBundle\Entity\Profile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use SimpleBus\Message\Handler\MessageHandler;
use SimpleBus\Message\Message;

class CreateProfileHandler implements MessageHandler
{
    private $objectManager;
    private $profileRepository;

    public function __construct(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;objectManager = $objectManager;
        $this-&gt;profileRepository = $profileRepository;
    }

    public function handle(Message $message)
    {
        $profile = $this-&gt;profileRepository-&gt;findOneBy(array('name' =&gt; $message-&gt;name));
        $newProfile = new Profile($message-&gt;name);
        $this-&gt;objectManager-&gt;persist($newProfile);
    }
}
</code></pre>

<p>Let's check the tests:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>All green, we can commit:</p>

<pre><code>git add -A
git commit -m 'Created CreateProfileHandler'
</code></pre>

<h2 id="name-duplication">Name duplication</h2>

<p>Domain validation (e.g. name duplication check) should be handled by the CommandHandler
(previously it was done in the controller):</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/CommandBus/CreateProfileHandlerSpec.php

namespace spec\AppBundle\CommandBus;

use AppBundle\CommandBus\CreateProfile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use PhpSpec\ObjectBehavior;
use Prophecy\Argument;

class CreateProfileHandlerSpec extends ObjectBehavior
{
    const NAME = 'John Cleese';

    function let(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;beConstructedWith($objectManager, $profileRepository);
    }

    function it_creates_a_profile(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $profileRepository-&gt;findOneBy(array('name' =&gt; self::NAME))-&gt;willReturn(null);
        $createdProfile = Argument::type('AppBundle\Entity\Profile');
        $objectManager-&gt;persist($createdProfile)-&gt;shouldBeCalled();

        $this-&gt;handle(new CreateProfile(self::NAME));
    }

    function it_cannot_create_the_profile_if_the_name_has_already_been_registered(ProfileRepository $profileRepository)
    {
        $profile = Argument::type('AppBundle\Entity\Profile');
        $profileRepository-&gt;findOneBy(array('name' =&gt; self::NAME))-&gt;willReturn($profile);

        $domainException = '\DomainException';
        $this-&gt;shouldThrow($domainException)-&gt;duringHandle(new CreateProfile(self::NAME));
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: We try to be as descriptive as necessary in the test methods (a bad example
  would have been <code>testThrowsDomainException</code>).</p>
</blockquote>

<p>Here's the code to make the test pass:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/CommandBus/CreateProfileHandler.php

namespace AppBundle\CommandBus;

use AppBundle\Entity\Profile;
use AppBundle\Entity\ProfileRepository;
use Doctrine\Common\Persistence\ObjectManager;
use SimpleBus\Message\Handler\MessageHandler;
use SimpleBus\Message\Message;

class CreateProfileHandler implements MessageHandler
{
    private $objectManager;
    private $profileRepository;

    public function __construct(ObjectManager $objectManager, ProfileRepository $profileRepository)
    {
        $this-&gt;objectManager = $objectManager;
        $this-&gt;profileRepository = $profileRepository;
    }

    public function handle(Message $message)
    {
        $profile = $this-&gt;profileRepository-&gt;findOneBy(array('name' =&gt; $message-&gt;name));
        if (null !== $profile) {
            throw new \DomainException(sprintf('The name "%s" is already taken', $message-&gt;name));
        }
        $newProfile = new Profile($message-&gt;name);
        $this-&gt;objectManager-&gt;persist($newProfile);
    }
}
</code></pre>

<p>Let's check the tests:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>They pass!</p>

<pre><code>git add -A
git commit -m 'Added check on name duplication'
</code></pre>

<h2 id="input-validation">Input validation</h2>

<p>Input validation (e.g. presence of name parameter) should be done in the Command
(previously it was done in the controller):</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle\CommandBus/CreateProfile.php

namespace AppBundle\CommandBus;

use SimpleBus\Message\Message;

class CreateProfile implements Message
{
    public $name;

    public function __construct($name)
    {
        if (null === $name) {
            throw new \DomainException('The "name" parameter is missing from the request\'s body');
        }
        $this-&gt;name = $name;
    }
}
</code></pre>

<p>Let's commit it:</p>

<pre><code>git add -A
git commit -m 'Added check on name presence in the request'
</code></pre>

<h2 id="domainexceptionlistener">DomainExceptionListener</h2>

<p>Our Command and CommandHandler both throw a DomainException, we can catch it in an
exception listener and create a nice response:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/EventListener/DomainExceptionListener.php

namespace AppBundle\EventListener;

use DomainException;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent;

class DomainExceptionListener
{
    /**
     * @param GetResponseForExceptionEvent $event
     */
    public function onKernelException(GetResponseForExceptionEvent $event)
    {
        $exception = $event-&gt;getException();
        if (!$exception instanceof DomainException) {
            return;
        }
        $error = $exception-&gt;getMessage();
        $event-&gt;setResponse(new JsonResponse(array('error' =&gt; $error), 422));
    }
}
</code></pre>

<p>It needs to be registerd in the Dependency Injection Container:</p>

<pre><code># File: app/config/services.yml
services:
    app.submit_json_listener:
        class: AppBundle\EventListener\SubmitJsonListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.forbidden_exception_listener:
        class: AppBundle\EventListener\ForbiddenExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }

    app.domain_exception_listener:
        class: AppBundle\EventListener\DomainExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }
</code></pre>

<p>We can save it:</p>

<pre><code>git add -A
git commit -m 'Created DomainExceptionListener'
</code></pre>

<h2 id="using-the-command">Using the command</h2>

<p>Now that our CommandHandler is ready, we'll define it as a service with its repository:</p>

<pre><code># File: app/config/services.yml
services:
    app.submit_json_listener:
        class: AppBundle\EventListener\SubmitJsonListener
        tags:
            - { name: kernel.event_listener, event: kernel.request, method: onKernelRequest }

    app.forbidden_exception_listener:
        class: AppBundle\EventListener\ForbiddenExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }

    app.domain_exception_listener:
        class: AppBundle\EventListener\DomainExceptionListener
        tags:
            - { name: kernel.event_listener, event: kernel.exception, method: onKernelException, priority: 10 }

    app.profile_repository:
        class: AppBundle\Entity\ProfileRepository
        factory_service: doctrine.orm.default_entity_manager
        factory_method: getRepository
        arguments: ['AppBundle:Profile']

    app.create_profile_handler:
        class: AppBundle\CommandBus\CreateProfileHandler
        arguments:
            - "@doctrine.orm.entity_manager"
            - "@app.profile_repository"
        tags:
            - { name: command_handler, handles: AppBundle\CommandBus\CreateProfile }
</code></pre>

<p>And call it in the controller:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use AppBundle\CommandBus\CreateProfile;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $name = $request-&gt;request-&gt;get('name');

        $this-&gt;get('command_bus')-&gt;handle(new CreateProfile($name));
        $createdProfile = $this-&gt;get('app.profile_repository')-&gt;findOneBy(array('name' =&gt; $name));

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Since the CommandHandler doesn't return anything, we need to call the repository
  to get the created profile.</p>
</blockquote>

<p>As it happens, we've forgotten to set <code>ProfileRepository</code> in <code>Profile</code>'s <code>Entity</code> annotation.
Let's fix it now:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Entity/Profile.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Table(name="profile")
 * @ORM\Entity(repositoryClass="AppBundle\Entity\ProfileRepository")
 */
class Profile
{
    /**
     * @ORM\Column(name="id", type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    private $id;

    /**
     * @ORM\Column(name="name", type="string", unique=true)
     */
    private $name;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }

    public function toArray()
    {
        return array(
            'id' =&gt; $this-&gt;id,
            'name' =&gt; $this-&gt;name,
        );
    }
}
</code></pre>

<p>Did we break anything?</p>

<pre><code>make test
</code></pre>

<p>No, all tests are super green!</p>

<pre><code>git add -A
git commit -m 'Used CreateProfileHandler in controller'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Technical debt is something we should be able to manage. When the time comes to refactor,
design patterns can be a helpful tool.</p>

<p>CommandBus is a nice pattern which allows us to remove imperative logic from the controllers.
It's easy to write unit test for CommandHandlers, and they can be reused
(creating a profile is surely something we can need elsewhere in our application).</p>

<p>This article concludes the second part of this series on web services in a Symfony environment.
In the <a href="/2015/03/11/sf-ws-part-3-1-consuming-request-handler.html">next one</a>,
we'll start a new application which consumes the one we just created.</p>

<blockquote>
  <p><strong>Note</strong>: The web service we described also had a removal endpoint. Since there's not much else
  to learn, it won't be created in this series.</p>
</blockquote>

<h3 id="going-further">Going further</h3>

<p>A lot of things can be improved in the current application, here's some tips for those
who'd like to practice:</p>

<ul>
<li>name duplication is actually a "Conflict" type of error, not "Unprocessable Entity"</li>
<li>we could use Symfony's validation component (use <code>validator</code> in the CommandHandler and set annotations in the Command)</li>
<li>we could create a CommandBus that always validate the Command using Symfony's validation component</li>
<li>we can create our own DomainException to avoid catching ones that could be thrown by third party libraries</li>
</ul>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Symfony / Web Services - part 2.2: Creation, the pragmatic way]]></title>
            <link href="https://gnugat.github.io/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html"/>
            <updated>2015-01-28T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2015/01/28/sf-ws-part-2-2-creation-pragmatic.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>Deprecated</strong>: This series has been re-written - see
  <a href="/2016/02/03/ultimate-symfony-http-kernel.html">The Ultimate Developer Guide to Symfony</a></p>
</blockquote>

<p>This is the third article of the series on managing Web Services in a
<a href="https://symfony.com">Symfony</a> environment. Have a look at the two first ones:</p>

<ul>
<li><a href="/2015/01/14/sf-ws-part-1-introduction.html">1. Introduction</a></li>
<li><a href="/2015/01/21/sf-ws-part-2-1-creation-bootstrap.html">2.1 Creation bootstrap</a></li>
</ul>

<p>You can check the code in the <a href="https://github.com/gnugat-examples/sf-ws">following repository</a>.</p>

<p>In this post we'll see how to create profiles:</p>

<ul>
<li><a href="#creating-the-controller">The controller</a></li>
<li><a href="#the-profile-entity">The profile entity</a></li>
<li><a href="#linking-with-the-database">Linking with the database</a></li>
<li><a href="#managing-errors">Managing errors</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="creating-the-controller">Creating the controller</h2>

<p>First things first, we'll write a functional test:</p>

<pre><code class="php">&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends \PHPUnit_Framework_TestCase
{
    private $app;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', false);
        $this-&gt;app-&gt;boot();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }
}
</code></pre>

<p>The test should fail, because the route hasn't been found (<code>404 NOT FOUND</code>):</p>

<pre><code>phpunit -c app
</code></pre>

<p>Flabergast! The test fails with a <code>PHP Fatal error:  Class 'AppKernel' not found</code>!
Let's fix this by adding the forgotten PHP tag opening in the bootstrap file:</p>

<pre><code class="php">&lt;?php
// File: app/bootstrap.php

require __DIR__.'/bootstrap.php.cache';
require __DIR__.'/AppKernel.php';
</code></pre>

<p>Let's check how the tests react:</p>

<pre><code>phpunit -c app
</code></pre>

<p>Another failure: the database doesn't exist. We need to create it for the test
environment:</p>

<pre><code>php app/console doctrine:database:create --env=test
</code></pre>

<p>Let's run the tests once again:</p>

<pre><code>phpunit -c app
</code></pre>

<p>This time the test fails for the right reason: the page doesn't exist.
To fix this, we'll create an empty controller:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $name = $request-&gt;request-&gt;get('name');
        $createdProfile = array();

        return new JsonResponse($createdProfile, 201);
    }
}
</code></pre>

<p>This should make the test pass:</p>

<pre><code>phpunit -c app
</code></pre>

<p>If an error occurs (404 not found), then it might be because of the cache:</p>

<pre><code>php app/console cache:clear --env=test
phpunit -c app
</code></pre>

<p>Running tests is becoming cumbersome, let's make it easy using a Makefile:</p>

<pre><code># Makefile
test:
    php app/console cache:clear --env=test
    php app/console doctrine:database:create --env=test
    phpunit -c app
    php app/console doctrine:database:drop --force --env=test
</code></pre>

<blockquote>
  <p><strong>Note</strong>: mind the tabs, make doesn't support space indentation.</p>
</blockquote>

<p>In order for this to work we'll need to drop the database (because it already exists):</p>

<pre><code>php app/console doctrine:database:drop --force --env=test
</code></pre>

<p>Tests can now be run using:</p>

<pre><code>make test
</code></pre>

<p>Everything's fine, we can commit our work:</p>

<pre><code>git add -A
git commit -m 'Created profile creation endpoint'
</code></pre>

<h2 id="the-profile-entity">The profile entity</h2>

<p>At this point, we'll need to store the profile in a database. For this purpose,
we'll use MySQL and Doctrine, so we'll need to create a profile entity.</p>

<p>We'll first generate a skeleton of its specification using <a href="http://phpspec.net">phpspec</a>:</p>

<pre><code>./bin/phpspec describe 'AppBundle\Entity\Profile'
</code></pre>

<p>Then we'll edit the specification:</p>

<pre><code class="php">&lt;?php
// File: spec/AppBundle/Entity/ProfileSpec.php

namespace spec\AppBundle\Entity;

use PhpSpec\ObjectBehavior;

class ProfileSpec extends ObjectBehavior
{
    const NAME = 'Arthur Dent';

    function let()
    {
        $this-&gt;beConstructedWith(self::NAME);
    }

    function it_can_be_converted_to_array()
    {
        $this-&gt;toArray()-&gt;shouldBe(array(
            'id' =&gt; null,
            'name' =&gt; self::NAME,
        ));
    }
}
</code></pre>

<p>Since we're happy with this step, we'll generate a skeleton of the code:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>Of course we need to edit it:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Entity/Profile.php

namespace AppBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Table(name="profile")
 * @ORM\Entity
 */
class Profile
{
    /**
     * @ORM\Column(name="id", type="integer")
     * @ORM\Id
     * @ORM\GeneratedValue(strategy="AUTO")
     */
    private $id;

    /**
     * @ORM\Column(name="name", type="string", unique=true)
     */
    private $name;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }

    public function toArray()
    {
        return array(
            'id' =&gt; $this-&gt;id,
            'name' =&gt; $this-&gt;name,
        );
    }
}
</code></pre>

<p>Let's check if it satisfies our specification:</p>

<pre><code>./bin/phpspec run
</code></pre>

<p>It does! With this we can generate our database:</p>

<pre><code>php app/console doctrine:database:create
php app/console doctrine:schema:create
</code></pre>

<p>Let's update our Makefile:</p>

<pre><code># Makefile
prod:
    php app/console cache:clear --env=prod
    php app/console doctrine:database:create --env=prod
    php app/console doctrine:schema:create --env=prod

dev:
    php app/console cache:clear --env=dev
    php app/console doctrine:database:create --env=dev
    php app/console doctrine:schema:create --env=dev

test:
    php app/console cache:clear --env=test
    php app/console doctrine:database:create --env=test
    php app/console doctrine:schema:create --env=test
    phpunit -c app
    bin/phpspec run
    php app/console doctrine:database:drop --force --env=test
</code></pre>

<p>This allows us to also run phpspec for tests. Installing a project should be as
simple as:</p>

<pre><code>make
</code></pre>

<p>And for development we can use:</p>

<pre><code>make dev
</code></pre>

<blockquote>
  <p><strong>Note</strong>: trying to run a second time <code>make</code> or <code>make dev</code> will fail as the
  database already exists. We'll need to run respectively
  <code>php app/console doctrine:database:drop --force --env=prod</code> and
  <code>php app/console doctrine:database:drop --force --env=dev</code>, but we should really
  run those commands only once.</p>
</blockquote>

<p>It is time to commit our progress:</p>

<pre><code>git add -A
git commit -m 'Created Profile entity'
</code></pre>

<h2 id="linking-with-the-database">Linking with the database</h2>

<p>The only thing missing in our application is the actual creation of the profile.
Before doing anything with the code, we'll need to update our functional test:
we don't want the data to be actually persisted, as it would make the test fail
on a second run:</p>

<pre><code>&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends \PHPUnit_Framework_TestCase
{
    private $app;
    private $em;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', true);
        $this-&gt;app-&gt;boot();

        $this-&gt;em = $this-&gt;app-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');
        $this-&gt;em-&gt;beginTransaction();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    protected function tearDown()
    {
        $this-&gt;em-&gt;rollback();
        $this-&gt;em-&gt;close();
    }
}
</code></pre>

<p>Let's update the controller:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use AppBundle\Entity\Profile;
use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $em = $this-&gt;get('doctrine.orm.entity_manager');

        $createdProfile = new Profile($request-&gt;request-&gt;get('name'));
        $em-&gt;persist($createdProfile);
        $em-&gt;flush();

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<p>Time to run the tests:</p>

<pre><code>make test
</code></pre>

<p>All green! We can commit:</p>

<pre><code>git add -A
git commit -m 'Saved created profile in database'
</code></pre>

<h2 id="managing-errors">Managing errors</h2>

<p>Our endpoint should return an error if the "name" parameter is missing. Let's add
a functional test for this:</p>

<pre><code>&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;
    private $em;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', true);
        $this-&gt;app-&gt;boot();

        $this-&gt;em = $this-&gt;app-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');
        $this-&gt;em-&gt;beginTransaction();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    public function testItFailsIfNameIsMissing()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('no-name' =&gt; ''));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    protected function tearDown()
    {
        $this-&gt;em-&gt;rollback();
        $this-&gt;em-&gt;close();
    }
}
</code></pre>

<p>It should make our tests fail:</p>

<pre><code>make test
</code></pre>

<p>We can make this test pass by adding a simple check:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $em = $this-&gt;get('doctrine.orm.entity_manager');

        $name = $request-&gt;request-&gt;get('name');
        if (null === $name) {
            return new JsonResponse(array('error' =&gt; 'The "name" parameter is missing from the request\'s body'), 422);
        }
        $createdProfile = new Profile($name);
        $em-&gt;persist($createdProfile);
        $em-&gt;flush();

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<p>Let's see:</p>

<pre><code>php app/console doctrine:database:drop --force --env=test
make test
</code></pre>

<blockquote>
  <p><strong>Note</strong>: Because our last test failed, the database hasn't been removed, so we
  need to do it manually.</p>
</blockquote>

<p>Looks nice! Our endpoint should also fail when a profile with the same name
already exist:</p>

<pre><code>&lt;?php
// File: tests/Controller/ProfileCreationControllerTest.php

namespace AppBundle\Tests\Controller;

use Symfony\Component\HttpFoundation\Request;

class ProfileCreationControllerTest extends PHPUnit_Framework_TestCase
{
    private $app;
    private $em;

    protected function setUp()
    {
        $this-&gt;app = new \AppKernel('test', true);
        $this-&gt;app-&gt;boot();

        $this-&gt;em = $this-&gt;app-&gt;getContainer()-&gt;get('doctrine.orm.entity_manager');
        $this-&gt;em-&gt;beginTransaction();
    }

    public function testItCreatesProfiles()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Fawlty Towers'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(201, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    public function testItFailsIfNameIsMissing()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('no-name' =&gt; ''));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    public function testItFailsIfNameAlreadyExists()
    {
        $headers = array(
            'CONTENT_TYPE' =&gt; 'application/json',
            'PHP_AUTH_USER' =&gt; 'spanish_inquisition',
            'PHP_AUTH_PW' =&gt; 'NobodyExpectsIt!',
        );
        $body = json_encode(array('name' =&gt; 'Provençal le Gaulois'));
        $request = Request::create('/api/v1/profiles', 'POST', array(), array(), array(), $headers, $body);

        $this-&gt;app-&gt;handle($request);
        $response = $this-&gt;app-&gt;handle($request);

        $this-&gt;assertSame(422, $response-&gt;getStatusCode(), $response-&gt;getContent());
    }

    protected function tearDown()
    {
        $this-&gt;em-&gt;rollback();
        $this-&gt;em-&gt;close();
    }
}
</code></pre>

<p>Our tests should be broken again:</p>

<pre><code>make test
</code></pre>

<p>Another check can fix this awful situation:</p>

<pre><code class="php">&lt;?php
// File: src/AppBundle/Controller/ProfileCreationController.php;

namespace AppBundle\Controller;

use Symfony\Bundle\FrameworkBundle\Controller\Controller;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Method;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\Route;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;

class ProfileCreationController extends Controller
{
    /**
     * @Route("/api/v1/profiles")
     * @Method({"POST"})
     */
    public function createProfileAction(Request $request)
    {
        $em = $this-&gt;get('doctrine.orm.entity_manager');

        $name = $request-&gt;request-&gt;get('name');
        if (null === $name) {
            return new JsonResponse(array('error' =&gt; 'The "name" parameter is missing from the request\'s body'), 422);
        }
        if (null !== $em-&gt;getRepository('AppBundle:Profile')-&gt;findOneByName($name)) {
            return new JsonResponse(array('error' =&gt; 'The name "'.$name.'" is already taken'), 422);
        }
        $createdProfile = new Profile($name);
        $em-&gt;persist($createdProfile);
        $em-&gt;flush();

        return new JsonResponse($createdProfile-&gt;toArray(), 201);
    }
}
</code></pre>

<p>Are we there yet?</p>

<pre><code>php app/console doctrine:database:drop --force --env=test
make test
</code></pre>

<p>Yes we are. Here's our last commit for this time:</p>

<pre><code>git add -A
git commit -m 'Added error checks'
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>Creating an endpoint with Symfony is pretty straighfoward: it all comes down to
HTTP knowledge.</p>

<p>Our codebase is very small due to the simplicity of our examples, but in a real
life application we'll need to add more complexity as new requirements appear.</p>

<p>The pragmatic approach is good for now, but at some point we'll need to refactor
our code by creating some services, each with their specific responsibilities,
to prevent our application from becoming a <a href="https://speakerdeck.com/richardmiller/atm">big ball of mud</a>
where everything is hard to read, impossible to test and expensive to change.</p>

<p>This will the subject of <a href="/2015/03/04/sf-ws-part-2-3-creation-refactoring.html">the next article</a>.</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the phpspec reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[phpspec: a quick tour]]></title>
            <link href="https://gnugat.github.io/2014/03/11/phpspec-quick-tour.html"/>
            <updated>2014-03-11T00:00:00+00:00</updated>
            <id>https://gnugat.github.io/2014/03/11/phpspec-quick-tour.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>This article is part of a series on Tests in general and on how to practice
them:</p>

<ol>
<li><a href="/2014/02/05/tests-introduction.html">Introduction</a></li>
<li><a href="/2014/02/12/tests-tools-overview.html">Tools overview</a></li>
<li><a href="/2014/02/19/test-driven-development.html">Test Driven Development</a></li>
<li><a href="/2014/02/26/tdd-just-do-it.html">TDD: just do it!</a></li>
<li><a href="/2014/03/05/spec-bdd.html">spec BDD</a></li>
<li><a href="/2014/03/11/phpspec-quick-tour.html">phpspec: a quick tour</a></li>
<li><a href="/2014/03/19/behavior-driven-development-story-bdd.html">Behavior Driven Development: story BDD</a></li>
<li><a href="/2014/03/26/behat-quick-tour.html">Behat: a quick tour</a></li>
<li><a href="/2014/04/02/tests-cheat-sheet.html">Conclusion</a></li>
</ol>

<p>The <a href="/2014/03/05/spec-bdd.md">last article</a> might have seemed
too abstract. Fortunately, this one will be much more concrete! We'll present
<a href="http://www.phpspec.net/">phpspec</a>, a spec BDD tool for PHP.</p>

<h2 id="introduction">Introduction</h2>

<p>phpspec automates the Test Driven Development (TDD) and spec BDD process by:</p>

<ul>
<li>allowing you to generate the specification</li>
<li>then allowing you to generate the code from it</li>
</ul>

<p>It also forces you to follow good practices:</p>

<ul>
<li>you can only test non-static public methods</li>
<li>you cannot generate a code coverage report</li>
</ul>

<p>It also tries to be less verbose, as you'll see in the next sections.</p>

<h2 id="installation">Installation</h2>

<p>Simply install phpspec using <a href="https://getcomposer.org/">Composer</a>:</p>

<pre><code>composer require --dev 'phpspec/phpspec:~2.0@RC'
</code></pre>

<p>At the time I write this article, phpspec is in Release Candidate, but don't
worry: I've been using it since the beta version and I've never had any trouble.</p>

<h2 id="process">Process</h2>

<p>First, bootstrap and complete the specification:</p>

<pre><code>phpspec describe 'Fully\Qualified\Classname'
$EDITOR spec/Fully/Qualified/ClassnameSpec.php
</code></pre>

<p>Then bootstrap and complete the code to make the tests pass:</p>

<pre><code>phpspec run
$EDITOR src/Fully/Qualified/Classname.php
phpspec run
</code></pre>

<p>Finally refactor, but keep the tests passing:</p>

<pre><code>$EDITOR src/Fully/Qualified/Classname.php
phpspec run
</code></pre>

<p>I've found that Marcello Duarte, the creator of phpspec, talks really well about
it in his presentation <a href="http://www.slideshare.net/marcello.duarte/test-transform-refactor">Test, transform, refactor</a>.</p>

<p>I advise you to have a look at his slides, as they explain everything you should
now about the red, green, refactor cycle.</p>

<h2 id="a-tour-of-the-documentation">A tour of the documentation</h2>

<p>Surprisingly, the documentation is complete and small:</p>

<ul>
<li><a href="http://www.phpspec.net/cookbook/matchers.html">here's the complete list of assertions</a></li>
<li><a href="http://www.phpspec.net/cookbook/templates.html">here's how to customize the specification and code tempaltes</a></li>
<li><a href="http://www.phpspec.net/cookbook/configuration.html">here's how to configure phpspec</a></li>
</ul>

<p>There's nothing missing in these docs!</p>

<h2 id="prophecy%2C-the-test-double-framework">Prophecy, the test double framework</h2>

<p>Unlike PHPUnit, phpspec uses an external library for its test doubles:
<a href="https://github.com/phpspec/prophecy">prophecy</a> (but you can still find how to
use it in the <a href="http://www.phpspec.net/cookbook/configuration.html">documentation</a>).</p>

<h2 id="conclusion">Conclusion</h2>

<p>phpspec generates specification and code boilerplates for you. It forces you to
concentrate on the class behavior rather than on the implementation and it
provides a non verbose API. Even its documentations is complete and small!</p>

<p>I hope you enjoyed this article, be sure to
<a href="https://twitter.com/epiloic">tweet me what you think about it</a> ;) .</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the reference article</a></p>
</blockquote>
]]></content>
        </entry>
    </feed>