<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2025-08-20T13:45:04+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Tests cheat sheet]]></title>
            <link href="/2014/04/02/tests-cheat-sheet.html"/>
            <updated>2014-04-02T00:00:00+01:00</updated>
            <id>/2014/04/02/tests-cheat-sheet.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>This article concludes the series on Tests:</p>

<ol>
<li><a href="/2014/02/05/tests-introduction.html">Introduction</a></li>
<li><a href="/2014/02/12/tests-tools-overview.html">Tools overview</a></li>
<li><a href="/2014/02/19/test-driven-development.html">Test Driven Development</a></li>
<li><a href="/2014/02/26/tdd-just-do-it.html">TDD: just do it!</a></li>
<li><a href="/2014/03/05/spec-bdd.html">spec BDD</a></li>
<li><a href="/2014/03/11/phpspec-quick-tour.html">phpspec: a quick tour</a></li>
<li><a href="/2014/03/19/behavior-driven-development-story-bdd.html">Behavior Driven Development: story BDD</a></li>
<li><a href="/2014/03/26/behat-quick-tour.html">Behat: a quick tour</a></li>
<li><a href="/2014/04/02/tests-cheat-sheet.html">Conclusion</a></li>
</ol>

<p>I've tried to put as much general information and references to blogs which
could help you to go further, in each article. In this final post, I'll regroup
those references and the conclusions.</p>

<ul>
<li><a href="#definitions">Definitions</a></li>
<li><a href="#tools-overview">Tools overview</a></li>
<li><a href="#test-driven-development-tdd">TDD</a></li>
<li><a href="#behavior-driven-development-bdd">BDD</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="definitions">Definitions</h2>

<p>A test is a way to check if something behaves correctly. This something is
called a System Under Test (SUT) and can be:</p>

<ul>
<li>the User Interface (HTML, console output, etc): integration tests</li>
<li>classes, functions: unit tests</li>
<li>interractions between those classes and functions: functional tests</li>
<li>the business value: acceptance tests</li>
</ul>

<p>Generally, you proceed as follow:</p>

<ol>
<li>have a set of input (parameters, fixtures, etc)</li>
<li>put it in the SUT</li>
<li>check the output</li>
</ol>

<p>When doing unit tests, you'll need to isolate your SUT from its collaborators
(the dependencies, the other classes used by it). To do so, you'll need test
doubles and Dependency Injection.</p>

<h3 id="references">References</h3>

<ul>
<li><a href="http://martinfowler.com/articles/mocksArentStubs.html">Tests doubles explained by Martin Fowler</a></li>
<li><a href="/2014/01/22/ioc-di-and-service-locator.html">Dependency Injection explained</a></li>
<li><a href="http://codemanship.co.uk/parlezuml/blog/?postid=1202">Test coverage can be deceptive, by Jason Gorman</a></li>
</ul>

<h2 id="tools-overview">Tools overview</h2>

<p>Frameworks can help you to automate your tests. You'll generally find these
tools:</p>

<ul>
<li>integration tests:

<ul>
<li><a href="https://github.com/alexandresalome/php-webdriver">Alexandre Salome's webdriver</a> (PHP)</li>
<li><a href="https://github.com/facebook/php-webdriver">Facebook's webdriver</a> (PHP)</li>
<li><a href="https://github.com/fabpot/goutte">Goutte</a> (PHP)</li>
<li><a href="http://phantomjs.org/">PhantomJS</a></li>
</ul></li>
<li>xUnit frameworks:

<ul>
<li><a href="http://phpunit.de/">PHPUnit</a> (PHP)</li>
<li><a href="https://github.com/atoum/">Atoum</a> (PHP)</li>
<li><a href="http://codeception.com/">Codeception</a> (PHP)</li>
<li><a href="http://visionmedia.github.io/mocha/">Mocha</a> (js)</li>
<li><a href="http://casperjs.org/">CasperJs</a> (js)</li>
</ul></li>
<li>tests double libraries:

<ul>
<li><a href="https://github.com/phpspec/prophecy">Prophecy</a> (PHP)</li>
<li><a href="https://github.com/padraic/mockery">Mockery</a> (PHP)</li>
<li><a href="http://sinonjs.org/">Sinon.js</a> (js)</li>
</ul></li>
<li>assertion libraries:

<ul>
<li><a href="http://chaijs.com/">Chai</a> (js)</li>
</ul></li>
<li>behavior frameworks:

<ul>
<li><a href="http://www.phpspec.net/">phpspec</a> (PHP)</li>
<li><a href="http://behat.org/">Behat</a> (PHP)</li>
<li><a href="http://jasmine.github.io/2.0/introduction.html">jasmine</a> (js)</li>
</ul></li>
</ul>

<p><em>Note</em>: xUnit frameworks allows many kinds of tests (they're not limited to unit
tests).</p>

<p><em>Note</em>: WebDriver is an API for <a href="http://docs.seleniumhq.org/">Selenium</a>, a java
server which allows you to interract with a browser.</p>

<h3 id="references">References</h3>

<ul>
<li><a href="http://www.xprogramming.com/testfram.htm">xUnit conventions</a></li>
<li><a href="http://verraes.net/2013/09/extract-till-you-drop/">Mathias Verraes writing tests to allow him to improve the code</a></li>
</ul>

<h2 id="test-driven-development-tdd">Test driven development (TDD)</h2>

<p>A process in which:</p>

<ol>
<li>you write the test first</li>
<li>then you write the code to make the test pass as quickly as possible (commit any sins)</li>
<li>refactor the code, clean your sins</li>
</ol>

<p>This allows you to naturally have a 100% test coverage, and it has the side
effect of making your code more decoupled (you need your code to be decoupled in
order to test it).</p>

<h3 id="references%3A">References:</h3>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Test-Driven_Development_by_Example">Kent Beck's book: Test Driven Development by Example</a></li>
<li><a href="http://vimeo.com/68375232">Ian Cooper coming back to the sources of TDD</a></li>
<li><a href="http://codemanship.co.uk/parlezuml/blog/?postid=1170">False arguments against TDD</a></li>
<li><a href="http://www.daedtech.com/what-tdd-is-and-is-not">What TDD is and is not</a></li>
<li><a href="http://blog.8thlight.com/uncle-bob/2014/03/11/when-to-think.html">Where is the design phase in TDD</a></li>
</ul>

<p>About writing the code as quickly as possible, commiting any sins:</p>

<ul>
<li><a href="http://www.joelonsoftware.com/items/2009/09/23.html">Duct tape programming</a></li>
<li><a href="http://redotheweb.com/2013/06/04/you-should-write-ugly-code.html">You should write ugly code</a></li>
<li><a href="http://verraes.net/2013/07/managed-technical-debt/">Managed technical debt</a></li>
</ul>

<h2 id="behavior-driven-development-bdd">Behavior Driven Development (BDD)</h2>

<p>BDD is divided in two sections: spec and story. It comes from the lack of
direction in TDD and introduces the concept of business value.</p>

<ul>
<li>spec BDD: test methods should be sentences</li>
<li>story BDD: acceptance criteria (from user stories) should be executable</li>
</ul>

<p><a href="http://behat.org/">Behat</a> and <a href="http://www.phpspec.net/">phpspec</a> allows you to
automate the process by allowing you to:</p>

<ol>
<li>bootstrap the test</li>
<li>then you have to manually implement the test</li>
<li>bootstrap the code from the written tests</li>
<li>then you have to manually implement the code</li>
</ol>

<h3 id="references%3A">References:</h3>

<ul>
<li><a href="http://dannorth.net/introducing-bdd/">Introductiong BDD</a></li>
<li><a href="http://dannorth.net/2011/01/31/whose-domain-is-it-anyway/">Whose domain is it anyway?</a></li>
<li><a href="http://www.slideshare.net/lunivore/behavior-driven-development-11754474">Slides by Liz Keogh</a></li>
<li><a href="http://www.wekeroad.com/2013/08/28/how-behavioral-is-your-bdd/">Are you really doing BDD?</a></li>
<li><a href="http://ht.ly/pfNW5">Acceptance Test fail!</a></li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Automated tests allow you to make sure your system isn't full of bug, and help
to detect any regressions.</p>

<p>Theres many kinds out there: you can test what the user sees, what the computer
sees and what the product owner expects.</p>

<p>I'd be really glad if this cheat sheet was of some use to you. If you have any
comments, you can contact me on <a href="https://twitter.com/epiloic">Twitter</a> :) .</p>

<h3 id="note-about-bdd%2C-behat-and-selenium">Note about BDD, behat and selenium</h3>

<p>I had <a href="https://twitter.com/epiloic/status/449280860236570625">great feedbacks</a>
about the <a href="/2014/03/26/behat-quick-tour.html">Behat article</a>:
which were triggered by the following statement: "if you're using Mink
or Selenium, then you're doing it wrong". Let me re-phrase that.</p>

<p>If you're using Selenium or Mink, then you're doing integration tests, not
behavior ones. Those tools are fine: the UI is what the user sees and interacts
with, so it's important to make sure it isn't broken.</p>

<p>What isn't fine is to use Behat with these tools and then to say that you're
doing BDD. Use the right tools for the job:
<a href="http://phpunit.de/manual/3.7/en/selenium.html">PHPUnit can perfectly be used with selenium</a>,
and libraries like <a href="https://github.com/alexandresalome/php-webdriver">webdriver</a>
allow you to work with selenium without using Behat.</p>

<p>One of the question raised was: "If I can't interract with the UI, how do I test
the behavior of my application?"" Well there's many ways and the answer deserves
a whole article or even a whole series! I'll just give you the douchebag (it's
the actual application name, I mean no offense!) example:</p>

<ul>
<li><a href="https://speakerdeck.com/igorw/silex-an-implementation-detail">the slides explaining the application</a></li>
<li><a href="https://github.com/igorw/doucheswag/">the sources</a></li>
</ul>

<p>Inner conclusion: make a distinction between integration (HTML, UI, etc) and
Behavior (business value, acceptance criteria from user stories) tests.
If you can't do both, then the choice is yours: which one is the most important
to you?</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Behat: a quick tour]]></title>
            <link href="/2014/03/26/behat-quick-tour.html"/>
            <updated>2014-03-26T00:00:00+00:00</updated>
            <id>/2014/03/26/behat-quick-tour.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>This article is part of a series on Tests in general and on how to practice
them:</p>

<ol>
<li><a href="/2014/02/05/tests-introduction.html">Introduction</a></li>
<li><a href="/2014/02/12/tests-tools-overview.html">Tools overview</a></li>
<li><a href="/2014/02/19/test-driven-development.html">Test Driven Development</a></li>
<li><a href="/2014/02/26/tdd-just-do-it.html">TDD: just do it!</a></li>
<li><a href="/2014/03/05/spec-bdd.html">spec BDD</a></li>
<li><a href="/2014/03/11/phpspec-quick-tour.html">phpspec: a quick tour</a></li>
<li><a href="/2014/03/19/behavior-driven-development-story-bdd.html">Behavior Driven Development: story BDD</a></li>
<li><a href="/2014/03/26/behat-quick-tour.html">Behat: a quick tour</a></li>
<li><a href="/2014/04/02/tests-cheat-sheet.html">Conclusion</a></li>
</ol>

<p><a href="/2014/03/19/behavior-driven-development-story-bdd">Story Behavior Driven Development</a> (BDD)
is all about making user story's acceptance criteria executable.
In this article we'll oversee <a href="http://behat.org/">Behat</a> a PHP framework which
enables you to do so.</p>

<h2 id="introduction">Introduction</h2>

<p>In a nutshel Behat reads your user stories and links each steps in acceptance
criteria to a function. The execution of those functions will then ascertain if
the acceptance criteria succeeded.</p>

<p>To be able to read the user story, Behat needs you to write it in a specific
format.</p>

<h2 id="user-story">User story</h2>

<p>By default, your user stories are located as follow: <code>/features/*.feature</code>.
They're written using the <a href="http://docs.behat.org/guides/1.gherkin.html">Gherkin language</a>,
which looks like this:</p>

<pre><code>Feature: &lt;user story title&gt;
    In order to &lt;business value to attain&gt;
    As a/an &lt;actor&gt;
    I need to &lt;requirements to meet&gt;

    Scenario: &lt;acceptance criteria title&gt;
        Given &lt;precondition&gt;
        When &lt;event&gt;
        Then &lt;outcome&gt;
</code></pre>

<p>The first lines will be printed while executing the acceptance criteria. The
<code>Scenario</code> keyword starts a new criteria. The <code>Given</code>, <code>When</code> and <code>Then</code>
keywords will trigger a search for a related test method. Those are called
steps.</p>

<p>Your criteria will most likely have more than three lines. You can use <code>And</code> and
<code>But</code> keywords to link the steps:</p>

<pre><code>Feature: &lt;user story title&gt;
    In order to &lt;business value to attain&gt;
    As a/an &lt;actor&gt;
    I need to &lt;requirements to meet&gt;

    Scenario: &lt;acceptance criteria title&gt;
        Given &lt;precondition&gt;
        And &lt;another precondition&gt;
        When &lt;event&gt;
        But &lt;another event&gt;
        Then &lt;outcome&gt;
        And &lt;another outcom&gt;
        But &lt;yet another outcome&gt;
</code></pre>

<p><em>Note</em>: to be fair, <code>Given</code>, <code>When</code>, <code>Then</code>, <code>But</code> and <code>And</code> keywords aren't
different to Behat: the choice is there for you, in order to make your
acceptance criteria more readable.</p>

<h2 id="context">Context</h2>

<p>The test methods should be placed in a context: <code>/features/bootstrap/FeatureContext.php</code>.
It looks like this:</p>

<pre><code>&lt;?php

use Behat\Behat\Context\BehatContext;

class FeatureContext extends BehatContext
{
    /**
     * @Given /^a sentence from an acceptance criteria$/
     */
    public function aTestMethod()
    {
        // Your test code.
    }
}
</code></pre>

<p>When Behat reads your user stories, for each step it will look in your context
and check the test method's annotations (comments starting by <code>@Given</code>, <code>@When</code>
or <code>@Then</code>) to see if it matches.</p>

<p><em>Note</em>: again, <code>@Given</code>, <code>@When</code> and <code>@Then</code> don't really matter. If you write
<code>Given I am an imp</code> in your user story, and then write a test method with the
annotation <code>@When /^I am an imp$/</code>, it will match!</p>

<p>As you can see, a regexp is used for the matching, but since the version 3.0
(still in release candidate at the time I write this article) you can use plain
text with placeholders:</p>

<pre><code>/**
 * @Given I am an/a :type
 */
public function setType($type)
{
    // Your test code.
}
</code></pre>

<p>This has been borrowed from <a href="https://github.com/jnicklas/turnip">Turnip</a>.</p>

<p><em>Note</em>: your test method name can be anything, it doesn't have to match the step
sentence.</p>

<h2 id="the-definition-of-success">The definition of success</h2>

<p>When a test method is executed, it can have the following state:</p>

<ul>
<li>not found: you need to create it</li>
<li>pending: the test method exists, but isn't implemented</li>
<li>failing: the method throws an exception or raises an error</li>
<li>succeeds: the default</li>
</ul>

<p>To set the pending state, write the following in your method:</p>

<pre><code>throw new \Behat\Behat\Tester\Exception\Pending();
</code></pre>

<p>As you can see, if you write the test method, but put nothing in it, then the
test will succeeds. The responsibility to make the success state match business
expectations is yours.</p>

<p>Behat eats its own dog food: its tests are written with itself! Which means you
can have a look at them to inspire yourself. You'll see something that isn't
written in the documentation: you can use
<a href="http://phpunit.de/manual/current/en/writing-tests-for-phpunit.html#writing-tests-for-phpunit.assertions">PHPUnit's assertion methods</a>
to make your test pass or fail.</p>

<h2 id="an-automated-flow">An automated flow</h2>

<p>Remember how <a href="/2014/03/11/phpspec-quick-tour">phpspec</a>
generates your code based on your specifications? Well it's the same thing with
Behat.</p>

<p>First Bootstrap your context:</p>

<pre><code>behat --init
</code></pre>

<p>Write a <code>/features/&lt;user-story&gt;.feature</code> file.</p>

<p>Next run the tests. For the pending steps, behat will propose you a template
code which can be copy/pasted in your test methods:</p>

<pre><code>behat
</code></pre>

<p>Then complete your test methods.</p>

<p>And finally run your tests:</p>

<pre><code>behat
</code></pre>

<p>The tests should all fail. Which means now you can start writting the code to
make it pass: it's Behavior <strong>Driven</strong> Development, remember? ;)</p>

<h2 id="misconceptions">Misconceptions</h2>

<p>A lot of people hate Behat because it's slow and it needs <a href="http://docs.seleniumhq.org/">Selenium</a>
to work, which isn't easy to install (if a novice can't install it, then it's
not easy).
Oh, and they hate it because the tests written with it aren't maintenable.</p>

<p>Guess what? They're wrong. They're probably using the
<a href="http://mink.behat.org/">mink extension</a>, which enables you to write things like:</p>

<pre><code>Feature: User registration
    In order to gain access to the website
    As a user
    I need to register

    Scenario: Giving account details
        Given I fill the field "#username" with "John"
        And  I fill the field "#password" with "Doe"
        When I submit the form "ul.form-block &gt; li:last &gt; #submit"
        And I wait until the page is fully loaded
        Then I should see "You've registered successfully"
</code></pre>

<p>The thing is, you're not describing the business value in this acceptance
criteria. You're describing User Interface (UI) interractions. And it's
completly different!</p>

<p>So here's my rule of thumb: don't use mink nor selenium.
In <a href="https://speakerdeck.com/igorw/silex-an-implementation-detail">Silex, an implementation detail</a>,
the advice given is: imagine you need to add a CLI which shares the same
functionnalities than the web interface. It would be a shame to have to re-write
all your acceptance tests, wouldn't it?</p>

<h2 id="conclusion">Conclusion</h2>

<p>Behat enables you to make your acceptance criteria executable, and automates the
process. Awsome!</p>

<p>If you're using Selenium, or the mink extension, then you're doing it wrong:
don't test the UI, test the business value.</p>

<p>Here's my workflow advice:</p>

<ol>
<li>write only one criteria</li>
<li>implement only one step</li>
<li>write the specification of one class used in the step implementation (using <a href="/2014/03/11/phpspec-quick-tour">phpspec</a>)</li>
<li>write the code matching the specification</li>
<li>go back to 3. until any code from the step implementation is written</li>
<li>go back to 2. until any step is written</li>
<li>go back to 1. until the user story is completely written</li>
</ol>

<p>I hope you enjoyed this article, be sure to
<a href="https://twitter.com/epiloic">tweet me what you think about it</a> ;) .</p>

<p>Story BDD and Behat have a steep learning curve, which makes them hard to
practice in the beginning (but totally worth it). To help you get your own way,
here's a list of references:</p>

<ul>
<li><a href="http://docs.behat.org/">Behat documentation</a></li>
<li><a href="https://github.com/Behat/Behat">Behat sources</a></li>
<li><a href="http://www.slideshare.net/everzet/behat-30-meetup-march">Behat version 3.0 announcement (slides)</a></li>
<li><a href="https://www.youtube.com/watch?v=xOgyKTmgYI8">Behat version 3.0 announcement (video)</a></li>
</ul>

<p>And of course have a look at the references <a href="/2014/03/19/behavior-driven-development-story-bdd">from my BDD article</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Behavior Driven Development: story BDD]]></title>
            <link href="/2014/03/19/behavior-driven-development-story-bdd.html"/>
            <updated>2014-03-19T00:00:00+00:00</updated>
            <id>/2014/03/19/behavior-driven-development-story-bdd.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>This article is part of a series on Tests in general and on how to practice
them:</p>

<ol>
<li><a href="/2014/02/05/tests-introduction.html">Introduction</a></li>
<li><a href="/2014/02/12/tests-tools-overview.html">Tools overview</a></li>
<li><a href="/2014/02/19/test-driven-development.html">Test Driven Development</a></li>
<li><a href="/2014/02/26/tdd-just-do-it.html">TDD: just do it!</a></li>
<li><a href="/2014/03/05/spec-bdd.html">spec BDD</a></li>
<li><a href="/2014/03/11/phpspec-quick-tour.html">phpspec: a quick tour</a></li>
<li><a href="/2014/03/19/behavior-driven-development-story-bdd.html">Behavior Driven Development: story BDD</a></li>
<li><a href="/2014/03/26/behat-quick-tour.html">Behat: a quick tour</a></li>
<li><a href="/2014/04/02/tests-cheat-sheet.html">Conclusion</a></li>
</ol>

<p>In this article, we'll talk about Behavior Driven Development (BDD), again.
There's no special skills required to read on, although some notions on
<a href="/2014/02/05/tests-introduction">tests</a> and
<a href="/2014/02/19/test-driven-development">Test Driven Development</a>
(TDD) would be a plus.</p>

<h2 id="from-spec-bdd-to-story-bdd">From spec BDD to story BDD</h2>

<p>So TDD has 3 simple rules:</p>

<ol>
<li>write the test first</li>
<li>then write as quickly as possible the code to make it pass</li>
<li>finally refactor, without changing the tests (and still making them pass)</li>
</ol>

<p>Like many TDD oficionados, <a href="http://dannorth.net/about/">Dan North</a> felt that it
was missing some guidelines. To fix this, he created spec BDD, which adds the
following rules to TDD:</p>

<ul>
<li>test methods should be sentences (prefix them with <code>it_should</code> instead of <code>test</code>)</li>
<li>tests should specify the behavior of the System Under Test (SUT)</li>
</ul>

<p>One of his colleagues, Chris Matts, suggested to take BDD a step further: why
not making sure the business value was met? And that's how story BDD was
created.</p>

<h2 id="acceptance-tests">Acceptance tests</h2>

<p>If you're working with agile methodologies, you should be familiar with user
stories. Those are simple cards which describe what to do in 3 lines:</p>

<pre><code>In order to attain a business value
As an actor
I need to meet some requirements
</code></pre>

<p>They've also some acceptance criteria, which follow approximately this template:</p>

<pre><code>Given a context
When an event happens
Then an outcome should occur
</code></pre>

<p>If the system fulfills the acceptance test, then it behaves correctly. By making
them executable, you can test the business behavior of your system! That's what
story BDD is all about.</p>

<p>Technically, this means parsing the acceptance tests and match each line with
a chunk of code. But don't worry about implementation details, we'll see them
in the next article.</p>

<h2 id="misconceptions">Misconceptions</h2>

<p>Somehow, a surprising number of people started to think that BDD was all about
integration tests. For example in a web application, they would write:</p>

<pre><code>Given I am on "/home"
When I click on "form#name_form input[name=submit]"
And I wait until the page is fully loaded
Then the "form#name_form input[name=first_name]" form field should contain "value"
</code></pre>

<p>What's wrong with it? Well:</p>

<ul>
<li>it's not human friendly (usage of xpath)</li>
<li>it's completely coupled to your routing (usage of URL)</li>
<li>it's entirely coupled to the web implementation (usage of web vocabulary)</li>
<li>it's thoroughly coupled to the HTML integration (again, usage of xpath)</li>
<li>it's fully coupled to the test tool (the waiting line is a hack)</li>
<li>and mostly: it doesn't describe your business need</li>
</ul>

<p>Here's a better approach:</p>

<pre><code>Given the opportunity to introduce myself
When I give my name
Then I should be greeted
</code></pre>

<p>Yep, that's the story BDD example of "Hello World", in case you didn't recognize
it ;) .</p>

<h2 id="conclusion">Conclusion</h2>

<p>If you make a user story's acceptance tests executable, then you're doing story
BDD. It helps you to make sure that your application meets your business needs.</p>

<p>Hopefully this article helped you a little. If you have any questions, rants or
praises, feel free to send them to me on <a href="https://twitter.com/epiloic">Twitter</a>.</p>

<p>Tests are hard. TDD is harder. BDD even more! Here's some good references to
help you on story BDD:</p>

<ul>
<li><a href="http://dannorth.net/introducing-bdd/">Introducing BDD, by Dan North</a></li>
<li><a href="http://dannorth.net/2011/01/31/whose-domain-is-it-anyway/">Whose domain is it anyway? By Dan North</a></li>
<li><a href="http://slideshare.net/lunivore/behavior-driven-development-11754474">BDD slides by Liz Keogh</a></li>
<li><a href="http://www.wekeroad.com/2013/08/28/how-behavioral-is-your-bdd/">Are you really doing BDD? By Rob Conery</a></li>
<li><a href="http://ht.ly/pfNW5">A.T. Fail! By Robert C. Martin</a></li>
</ul>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[phpspec: a quick tour]]></title>
            <link href="/2014/03/11/phpspec-quick-tour.html"/>
            <updated>2014-03-11T00:00:00+00:00</updated>
            <id>/2014/03/11/phpspec-quick-tour.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>This article is part of a series on Tests in general and on how to practice
them:</p>

<ol>
<li><a href="/2014/02/05/tests-introduction.html">Introduction</a></li>
<li><a href="/2014/02/12/tests-tools-overview.html">Tools overview</a></li>
<li><a href="/2014/02/19/test-driven-development.html">Test Driven Development</a></li>
<li><a href="/2014/02/26/tdd-just-do-it.html">TDD: just do it!</a></li>
<li><a href="/2014/03/05/spec-bdd.html">spec BDD</a></li>
<li><a href="/2014/03/11/phpspec-quick-tour.html">phpspec: a quick tour</a></li>
<li><a href="/2014/03/19/behavior-driven-development-story-bdd.html">Behavior Driven Development: story BDD</a></li>
<li><a href="/2014/03/26/behat-quick-tour.html">Behat: a quick tour</a></li>
<li><a href="/2014/04/02/tests-cheat-sheet.html">Conclusion</a></li>
</ol>

<p>The <a href="/2014/03/05/spec-bdd.md">last article</a> might have seemed
too abstract. Fortunately, this one will be much more concrete! We'll present
<a href="http://www.phpspec.net/">phpspec</a>, a spec BDD tool for PHP.</p>

<h2 id="introduction">Introduction</h2>

<p>phpspec automates the Test Driven Development (TDD) and spec BDD process by:</p>

<ul>
<li>allowing you to generate the specification</li>
<li>then allowing you to generate the code from it</li>
</ul>

<p>It also forces you to follow good practices:</p>

<ul>
<li>you can only test non-static public methods</li>
<li>you cannot generate a code coverage report</li>
</ul>

<p>It also tries to be less verbose, as you'll see in the next sections.</p>

<h2 id="installation">Installation</h2>

<p>Simply install phpspec using <a href="https://getcomposer.org/">Composer</a>:</p>

<pre><code>composer require --dev 'phpspec/phpspec:~2.0@RC'
</code></pre>

<p>At the time I write this article, phpspec is in Release Candidate, but don't
worry: I've been using it since the beta version and I've never had any trouble.</p>

<h2 id="process">Process</h2>

<p>First, bootstrap and complete the specification:</p>

<pre><code>phpspec describe 'Fully\Qualified\Classname'
$EDITOR spec/Fully/Qualified/ClassnameSpec.php
</code></pre>

<p>Then bootstrap and complete the code to make the tests pass:</p>

<pre><code>phpspec run
$EDITOR src/Fully/Qualified/Classname.php
phpspec run
</code></pre>

<p>Finally refactor, but keep the tests passing:</p>

<pre><code>$EDITOR src/Fully/Qualified/Classname.php
phpspec run
</code></pre>

<p>I've found that Marcello Duarte, the creator of phpspec, talks really well about
it in his presentation <a href="http://www.slideshare.net/marcello.duarte/test-transform-refactor">Test, transform, refactor</a>.</p>

<p>I advise you to have a look at his slides, as they explain everything you should
now about the red, green, refactor cycle.</p>

<h2 id="a-tour-of-the-documentation">A tour of the documentation</h2>

<p>Surprisingly, the documentation is complete and small:</p>

<ul>
<li><a href="http://www.phpspec.net/cookbook/matchers.html">here's the complete list of assertions</a></li>
<li><a href="http://www.phpspec.net/cookbook/templates.html">here's how to customize the specification and code tempaltes</a></li>
<li><a href="http://www.phpspec.net/cookbook/configuration.html">here's how to configure phpspec</a></li>
</ul>

<p>There's nothing missing in these docs!</p>

<h2 id="prophecy%2C-the-test-double-framework">Prophecy, the test double framework</h2>

<p>Unlike PHPUnit, phpspec uses an external library for its test doubles:
<a href="https://github.com/phpspec/prophecy">prophecy</a> (but you can still find how to
use it in the <a href="http://www.phpspec.net/cookbook/configuration.html">documentation</a>).</p>

<h2 id="conclusion">Conclusion</h2>

<p>phpspec generates specification and code boilerplates for you. It forces you to
concentrate on the class behavior rather than on the implementation and it
provides a non verbose API. Even its documentations is complete and small!</p>

<p>I hope you enjoyed this article, be sure to
<a href="https://twitter.com/epiloic">tweet me what you think about it</a> ;) .</p>

<blockquote>
  <p><strong>Reference</strong>: <a class="button button-reference" href="/2015/08/03/phpspec.html">see the reference article</a></p>
</blockquote>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[spec BDD]]></title>
            <link href="/2014/03/05/spec-bdd.html"/>
            <updated>2014-03-05T00:00:00+00:00</updated>
            <id>/2014/03/05/spec-bdd.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>This article is part of a series on Tests in general and on how to practice
them:</p>

<ol>
<li><a href="/2014/02/05/tests-introduction.html">Introduction</a></li>
<li><a href="/2014/02/12/tests-tools-overview.html">Tools overview</a></li>
<li><a href="/2014/02/19/test-driven-development.html">Test Driven Development</a></li>
<li><a href="/2014/02/26/tdd-just-do-it.html">TDD: just do it!</a></li>
<li><a href="/2014/03/05/spec-bdd.html">spec BDD</a></li>
<li><a href="/2014/03/11/phpspec-quick-tour.html">phpspec: a quick tour</a></li>
<li><a href="/2014/03/19/behavior-driven-development-story-bdd.html">Behavior Driven Development: story BDD</a></li>
<li><a href="/2014/03/26/behat-quick-tour.html">Behat: a quick tour</a></li>
<li><a href="/2014/04/02/tests-cheat-sheet.html">Conclusion</a></li>
</ol>

<p>In this article, we'll talk about Behavior Driven Development (BDD). There's no
special skills required to read on, although some notions on although some
notions on <a href="/2014/02/05/tests-introduction">tests</a> and
<a href="/2014/02/19/test-driven-development">Test Driven Development</a>
(TDD) would be a plus.</p>

<h2 id="from-tdd-to-bdd">From TDD to BDD</h2>

<p><a href="http://dannorth.net/about/">Dan North</a>, a fervent TDDist, felt that there was
something missing about this practice:</p>

<ul>
<li>you don't know where to start (which test should be written first?)</li>
<li>you don't know when to stop (should I test getters/setters?)</li>
<li>you don't know what defines a failure (compilation error? typo?)</li>
</ul>

<p>While being an adapt of the concept, he felt that there was missing some
important guidelines, and that his tests didn't answered the right questions.</p>

<p>Around 2006, he wrote an article called
<a href="http://dannorth.net/about/">introducing BDD</a>, in which he explained his unease
and how to fix it: instead of writing tests from a technical point of view he
decided to write them from a business point of view.</p>

<h2 id="from-unit-tests-to-specification">From unit tests to specification</h2>

<p>The first step to test the behavior of a class is to write a specification.
Because xUnit frameworks were in vogue, developers had the habit of making a
parallel between their Systems Under Test (SUT) and their Test Suites:</p>

<ul>
<li>suffix the SUT's name with <code>Test</code> to name the Test Suite</li>
<li>prefix the SUT's method names with <code>test</code> to name the Test Suite's methods</li>
</ul>

<p>In the Software world, a lot of problems can be solved by giving descriptive
names. And this is what Dan North did: Test Suites became Specification. Why?
Because it forces you to say "this method should do this" instead of writting
"test method".</p>

<p>To be more precise, Dan Nort stated that "test method names should be
sentences". Which means that test method names should be
<a href="http://en.wikipedia.org/wiki/Snake_case">snake_cased</a>, as underscores give more
spaces to words (they're basically spaces).</p>

<p>And that's pretty much it!</p>

<h2 id="is-that-all%3F">Is that all?</h2>

<p>Yes! Well, no. I mean... This is only the first part of BDD: it's called specBDD
(guess why ;) ). I'll write about the second part
(<a href="/2014/03/19/behavior-driven-development-story-bdd">story BDD</a>)
in a future article.</p>

<h2 id="conclusion">Conclusion</h2>

<p>BDD is just TDD, but tests become specifications and test methods are sentences
which start with "it_should".</p>

<p>I hope you enjoyed this article. If you want to make any comment, you're welcome
to do so on <a href="https://twitter.com/epiloic">Twitter</a>.</p>

<p>To keep good habits, in the <a href="/2014/03/11/phpspec-quick-tour">next article</a>
we'll switch to the technical mode and see some <a href="http://www.phpspec.net/">phpspec</a>!</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[TDD: just do it!]]></title>
            <link href="/2014/02/26/tdd-just-do-it.html"/>
            <updated>2014-02-26T00:00:00+00:00</updated>
            <id>/2014/02/26/tdd-just-do-it.html</id>
            <content type="html"><![CDATA[<p>This article is part of a series on Tests in general and on how to practice
them:</p>

<ol>
<li><a href="/2014/02/05/tests-introduction.html">Introduction</a></li>
<li><a href="/2014/02/12/tests-tools-overview.html">Tools overview</a></li>
<li><a href="/2014/02/19/test-driven-development.html">Test Driven Development</a></li>
<li><a href="/2014/02/26/tdd-just-do-it.html">TDD: just do it!</a></li>
<li><a href="/2014/03/05/spec-bdd.html">spec BDD</a></li>
<li><a href="/2014/03/11/phpspec-quick-tour.html">phpspec: a quick tour</a></li>
<li><a href="/2014/03/19/behavior-driven-development-story-bdd.html">Behavior Driven Development: story BDD</a></li>
<li><a href="/2014/03/26/behat-quick-tour.html">Behat: a quick tour</a></li>
<li><a href="/2014/04/02/tests-cheat-sheet.html">Conclusion</a></li>
</ol>

<p>The first two articles didn't require special skills whereas the last one needed
you to be a little bit used to tests. Well the next ones will require you to be
a little bit used to Test Driven Develoment (TDD), so this article is here to
make you practice them!</p>

<p>I really mean it: reading articles on TDD might feel good, but the only thing to
do to fully grasp them is to:</p>

<ol>
<li>start writting tests before any production code</li>
<li>then write the code to quickly make them pass (write ugly code if needed)</li>
<li>finally refactor the mess, without touching the tests</li>
</ol>

<p>In other word: just do it! The learning curve is steep, so dive into it as soon
as possible.</p>

<p>One of the best way to learn is to pair with someone who's used to it. If you
don't have someone to pair with, you can always read this
<a href="http://www.objectmentor.com/resources/articles/xpepisode.htm">Extreme Programming Episode by Robert C. Martin and Robert S. Koss</a>.</p>

<p>The next article will be about the next level:
<a href="/2014/03/05/spec-bdd.html">Behavior Driven Development</a> (BDD).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Test Driven Development]]></title>
            <link href="/2014/02/19/test-driven-development.html"/>
            <updated>2014-02-19T00:00:00+00:00</updated>
            <id>/2014/02/19/test-driven-development.html</id>
            <content type="html"><![CDATA[<p>This article is part of a series on Tests in general and on how to practice
them:</p>

<ol>
<li><a href="/2014/02/05/tests-introduction.html">Introduction</a></li>
<li><a href="/2014/02/12/tests-tools-overview.html">Tools overview</a></li>
<li><a href="/2014/02/19/test-driven-development.html">Test Driven Development</a></li>
<li><a href="/2014/02/26/tdd-just-do-it.html">TDD: just do it!</a></li>
<li><a href="/2014/03/05/spec-bdd.html">spec BDD</a></li>
<li><a href="/2014/03/11/phpspec-quick-tour.html">phpspec: a quick tour</a></li>
<li><a href="/2014/03/19/behavior-driven-development-story-bdd.html">Behavior Driven Development: story BDD</a></li>
<li><a href="/2014/03/26/behat-quick-tour.html">Behat: a quick tour</a></li>
<li><a href="/2014/04/02/tests-cheat-sheet.html">Conclusion</a></li>
</ol>

<p>Unlike the two previous articles, this one requires some experience in testing.
While Test Driven Development (TDD) oficionados would tell you that on the
contrary this is the way to learn tests, I'd rather advise you to practice them
a little bit before hand, so you can fully grasp the interest of this principle.</p>

<p>In this article, we'll cover:</p>

<ol>
<li><a href="#introduction">an introduction to TDD</a></li>
<li><a href="#writing-the-test-first">why we should write tests first</a></li>
<li><a href="#writing-the-code-afterward">how to write the code afterward</a></li>
<li><a href="#refactoring-in-the-end">the importance of refactoring in the end</a></li>
</ol>

<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<h2 id="introduction">Introduction</h2>

<p>Test Driven Development (TDD) is a simple principle stating that we should:</p>

<ol>
<li>write the test first</li>
<li>then write the code to make it pass</li>
<li>then refactor to clean the mess</li>
</ol>

<p>It is also described as <code>red, green, refactor</code> to reflect the state of the tests
after being run in the end of each step. Well the last step should still be
green, but it wouldn't be self explicit if we said <code>red, green, green</code> wouldn't
it?</p>

<p>Kent Beck is considered to be the father of TDD, even though this practice must
have been used before, especially because he wrote the
<a href="http://en.wikipedia.org/wiki/Test-Driven_Development_by_Example">'bible' Test Driven Development by Example</a>
and also because he created the <a href="http://en.wikipedia.org/wiki/Extreme_Programming">eXtreme Programming methodology</a>
(which integrates TDD into its practices).</p>

<p>TDD mostly applies to <strong>unit</strong> tests, but it could be used for any kind of test.</p>

<p>Each step has a purpose, which we'll discover.</p>

<h2 id="writing-the-test-first">Writing the test first</h2>

<p>So, why would we write the test before the code? The idea behind this is to
write a piece of software which will describe how to use the future code: when
writing the test, you're not bothered with implementation details and will
naturally create the API (the public methods).</p>

<p>The first consequence to this step is having a meaningful code coverage: no need
for tools to inspect which lines of code are executed when running the test in
order to make sure the code is properly tested
(<a href="http://codemanship.co.uk/parlezuml/blog/?postid=1202">those tools aren't effective anyway</a>).</p>

<p>The second one is better design: to write tests you need the code to be
decoupled. Writing tests firts forces you to make those decoupling decision
early. Decoupled code should be easier to re-use, read and maintain.</p>

<h2 id="writing-the-code-afterward">Writing the code afterward</h2>

<p><a href="http://vimeo.com/68375232">As depicted by Ian Cooper</a>, this step is the
<a href="http://www.joelonsoftware.com/items/2009/09/23.html">duct tape progammer</a>'s
one: in order to make the freshly written test pass, every sin should be
commited. Every design, clean code and best practice concerns should be put
aside so the test passes as quickly as possible.</p>

<p>Why so much fuss about all
<a href="http://redotheweb.com/2013/06/04/you-should-write-ugly-code.html">this ugly code</a>?
The main reason is speed, to answer all criticism about how long tests take to
be written.</p>

<p>With this, the school of pragmatic programmers and scholar ones can finally be
reunited: as a matter of fact, while this step is all about the first "clan",
the refactoring step is all about the second one.</p>

<p>To illustrate the fact that sometimes the clean solution comes to mind once the
dirty has been written, here's a quote from <a href="http://eloquentjavascript.net/chapter6.html">the Eloquent Javascript book</a>:</p>

<blockquote>
  <p>A student had been sitting motionless behind his computer for hours,
  frowning darkly. He was trying to write a beautiful solution to a
  difficult problem, but could not find the right approach. Fu-Tzu hit
  him on the back of his head and shouted '<em>Type something!</em>' The student
  started writing an ugly solution. After he had finished, he suddenly
  understood the beautiful solution.</p>
</blockquote>

<h2 id="refactoring-in-the-end">Refactoring in the end</h2>

<p>Now that we have sin, we have created a technical debt. The third and last step
of TDD, refactoring, is all about managing this debt.</p>

<p>The rules here is to step back a little bit, consider how we can improve the
structure of the code to make it simpler, more readable and if there's anything
which can be extracted to be reused.</p>

<p>Once this consideration is done, then we can start moving the code at the only
condition that we don't break the tests. It also means that the tests shouldn't
be modified.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Writing first the test allows a complete and meaningful code coverage, a more
decoupled code and a more natural API (public methods).</p>

<p>Then allowing every sins to write as quickly as possible the code to make the
test pass allows to speed up development through pragmatic decisions.</p>

<p>Finally refactoring without touching the tests allows to get rid of the
technical debt created in the previous step, depending on the estimated time
left for the task.</p>

<p>Unfortunately TDD comes with a quite steep learning curve, but hey! You don't
get something for nothing!</p>

<p>I hope you enjoyed this article, if you'd like to make any comments about it
(either good or bad), please feel free to do so <a href="https://twitter.com/epiloic">on Twitter</a>.</p>

<p>There's been many criticism about TDD, and most of those are simply
misconceptions. If you're part of the sceptics,
<a href="http://codemanship.co.uk/parlezuml/blog/?postid=1170">check if your argument is listed in Jason Gorman's article</a>.</p>

<p>The next article is about <a href="/2014/02/26/tdd-just-do-it.html">actually doing TDD</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Tests: Tools overview]]></title>
            <link href="/2014/02/12/tests-tools-overview.html"/>
            <updated>2014-02-12T00:00:00+00:00</updated>
            <id>/2014/02/12/tests-tools-overview.html</id>
            <content type="html"><![CDATA[<p>This article is part of a series on Tests in general and on how to practice
them:</p>

<ol>
<li><a href="/2014/02/05/tests-introduction.html">Introduction</a></li>
<li><a href="/2014/02/12/tests-tools-overview.html">Tools overview</a></li>
<li><a href="/2014/02/19/test-driven-development.html">Test Driven Development</a></li>
<li><a href="/2014/02/26/tdd-just-do-it.html">TDD: just do it!</a></li>
<li><a href="/2014/03/05/spec-bdd.html">spec BDD</a></li>
<li><a href="/2014/03/11/phpspec-quick-tour.html">phpspec: a quick tour</a></li>
<li><a href="/2014/03/19/behavior-driven-development-story-bdd.html">Behavior Driven Development: story BDD</a></li>
<li><a href="/2014/03/26/behat-quick-tour.html">Behat: a quick tour</a></li>
<li><a href="/2014/04/02/tests-cheat-sheet.html">Conclusion</a></li>
</ol>

<p>This article can be read by any regular developer (no special level required),
we'll put some code on the principles we've previously seen and we'll have a
quick look on existing tools. Here's what we'll cover:</p>

<ol>
<li><a href="#test-frameworks">test frameworks</a></li>
<li><a href="#phpunit">PHPUnit</a></li>
<li><a href="#unit-tests">unit tests</a> with test doubles (mocks and stubs)</li>
<li><a href="#functional-tests">functional tests</a></li>
<li><a href="#user-interface-tests">user interface tests</a></li>
</ol>

<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<h2 id="test-frameworks">Test frameworks</h2>

<p>In order to automate your tests (whether they're unitary, functionnal or anything
else), you'll need to use some tools. These would be libraries helping you
doing assertions, or libraries helping you creating test doubles without writing
any new classes, or even frameworks which group those libraries together.</p>

<p>Most of the test frameworks follow the
<a href="http://www.xprogramming.com/testfram.htm"><strong>xUnit</strong> convention, which have been (accidently?) created by Kent Beck</a>.
Those are composed of:</p>

<ul>
<li>a test runner which gather the <strong>test suites</strong>, execute their tests and then
prints the result using a <strong>test result formatter</strong></li>
<li>a test case, a class which you extend to write your tests</li>
<li>test fixtures to provide data as context for the tests</li>
<li>test suites, a bunch of tests which share commonalities (in practice this would
be the class which extends the test case and where you'll write your tests)</li>
<li>test execution: you can execute a bunch of code before every test with a
<strong>setUp</strong> method, and afterward in a <strong>tearDown</strong> function</li>
<li>test result formatter taking responsibility for outputing how test failed,
or if it should be written on the output or in a XML file</li>
<li>assertions which check if the given expected value matches the given actual
value</li>
</ul>

<p>Those are, among a ton of others:</p>

<ul>
<li><a href="http://phpunit.de/">PHPUnit</a> in PHP</li>
<li><a href="https://github.com/atoum/">Atoum</a> in PHP</li>
<li><a href="http://junit.org/">jUnit</a> in Java</li>
<li><a href="http://docs.python.org/2/library/unittest.html">unittest</a> in Python</li>
</ul>

<p>You could aslo find Behavior Driven Development (BDD) style test frameworks:</p>

<ul>
<li><a href="http://codeception.com/">Codeception</a> in PHP</li>
<li><a href="http://www.phpspec.net/">phpspec</a> alongside with <a href="http://behat.org/">Behat</a>
in PHP</li>
<li><a href="http://pivotal.github.io/jasmine/">jasmine</a> in javascript</li>
<li><a href="http://rspec.info/">RSpec</a> in ruby</li>
</ul>

<p>I won't talk about these, as it will be the subject of a future article
(there's so much to say about them).</p>

<p>Full stack frameworks isn't the only thing around here to help you write tests,
there also are some libraries:</p>

<ul>
<li><a href="http://visionmedia.github.io/mocha/">Mocha</a>, a base layer for tests,
in javascript</li>
<li><a href="http://chaijs.com/">Chai</a>, an assertion library in javascript</li>
<li><a href="http://sinonjs.org/">Sinon.js</a>, a test double library in javascript</li>
<li><a href="https://github.com/padraic/mockery">Mockery</a>, a mock framework in PHP</li>
<li><a href="https://github.com/phpspec/prophecy">Prophecy</a>, another mock framework in PHP</li>
</ul>

<p>Choose your weapon wisely!</p>

<h2 id="phpunit">PHPUnit</h2>

<p>I mainly code in PHP, and in this language PHPUnit is the most popular test
framework. It's been there for so long (version 1.0.0 released in July 2006)
that almost any libraries and frameworks are tested with it. So it'll be our tool
for the next examples.</p>

<p>You can install it using <a href="https://getcomposer.org/">Composer</a>:</p>

<pre><code>curl -sS https://getcomposer.org/installer | php # Download composer
composer install "phpunit/phpunit:~3.7"
php vendor/bin/phpunit -h
</code></pre>

<p><strong>Note</strong>: if you don't know Composer, let's just say that it makes your life easier
by downloading for you the libraries you told him to (it takes care of selecting
the good versions and can update them to get bug fixes). It also autoloads your
classes so you don't have to require them.</p>

<p>Now that you have the latest stable version, you'll need to configure it:</p>

<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!-- File: phpunit.xml --&gt;
&lt;phpunit
    backupGlobals="false"
    colors="true"
    syntaxCheck="false"
    bootstrap="test/bootstrap.php"
&gt;
    &lt;testsuites&gt;
        &lt;testsuite name="Fossil Test Suite"&gt;
            &lt;directory suffix="Test.php"&gt;./test/&lt;/directory&gt;
        &lt;/testsuite&gt;
    &lt;/testsuites&gt;
&lt;/phpunit&gt;
</code></pre>

<p>This configuration tells PHPUnit to look (recursively) in the <code>test</code> directory
for files ending in <code>Test.php</code>. Those will be your test suites.</p>

<p>You'll need a bootstrap file in order to use composer's autoloader:</p>

<pre><code>&lt;?php

$loader = require __DIR__.'/../vendor/autoload.php';
$loader-&gt;add('Gnugat\\Fossil\\Test', __DIR__);
</code></pre>

<p>And voilà! You can now write your tests in <code>test</code>.</p>

<h2 id="unit-tests">Unit tests</h2>

<p>The common understanding of unit test is a symmetry between classes and tests:
when you have a class with 2 methods, you need to have a test class for it
which will test these two methods.</p>

<p>It looks like this wasn't the real meaning of the term unit, which should have
meant making tests which can be run in any order without ruinning them, and as
many times as wanted. Fortunately a new kind of test was created to fix this
misunderstanding, so let's stick with the common one.</p>

<p>Imagine you have the following class, which creates a file if it doesn't already
exist:</p>

<pre><code>&lt;?php
// File: src/MarkdownFile/DocumentationWriter.php

namespace Gnugat\Fossil\MarkdownFile;

use Symfony\Component\Filesystem\Filesystem;

class DocumentationWriter
{
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function write($absolutePathname, $content)
    {
        if (!$this-&gt;filesystem-&gt;exists($absolutePathname)) {
            $this-&gt;filesystem-&gt;dumpFile($absolutePathname, $content);
        }
    }
}
</code></pre>

<p><strong>Note</strong>: once again the code samples are taken from
<a href="https://github.com/gnugat/fossil">fossil</a>, have a look at
<a href="/2014/01/15/bootstrap-markdown-files-of-your-FOSS-project.html">this article</a>
to discover what it is.</p>

<p>In order for it to be autoloaded, you'll need to edit your <code>composer.json</code> file:</p>

<pre><code>{
    "require": {
        "phpunit/phpunit": "~3.7"
    },
    "autoload": {
        "psr-4": {
            "Gnugat\\Fossil": "src/"
        }
    }
}
</code></pre>

<p>To test it, we could run it and check if the file has been created with the
given content, but that would be testing Symfony2's <code>Filesystem</code> which
<a href="https://github.com/symfony/symfony/blob/fe86efd3f256c5bda845cf23bf8a5400ae6a295e/src/Symfony/Component/Filesystem/Tests/FilesystemTest.php">happens to be already tested</a>.</p>

<p>So what does our class adds to it? Well it calls <code>Filesystem</code> to check if the
file exists, and if not it calls again the <code>Filesystem</code> to create it. We could
check if those calls are made using stubs and mocks.</p>

<p><strong>Reminder</strong>: stubs are a substitute of an object which forces it to return
a given value. When a System Under Test (SUT, the class you're testing) has
collaborators (classes used by the SUT, also called dependencies), we can stub
them so their behavior is completly controlled.</p>

<p><strong>Reminder</strong>: mocks are a substitute of an object which checks if its methods
have been called. When a System Under Test (SUT, the class you're testing) has
collaborators (classes used by the SUT, also called dependencies), we can mock
them to monitor their use.</p>

<p>PHPUnit allows us to create stubs and mocks without having to write a class
which extends the colaborator and overwrites its methods:</p>

<pre><code>&lt;?php
// File: test/MarkdownFile/DocumentationWriterTest.php

namespace Gnugat\Fossil\Test\MarkdownFile;

use Gnugat\Fossil\MarkdownFile\DocumentationWriter;

class DocumentationWriterTest extends \PHPUnit_Framework_TestCase
{
    const FIXTURE_ABSOLUTE_PATHNAME = '/tmp/example.txt';
    const FIXTURE_CONTENT = "Hello world\n";

    public function setUp()
    {
        $this-&gt;filesystem = $this-&gt;getMock('Symfony\\Component\\Filesystem\\Filesystem');
        $this-&gt;documentationWriter = new DocumentationWriter($this-&gt;filesystem);
    }

    public function testWriteNewFile()
    {
        // Stub
        $this-&gt;filesystem-&gt;expects($this-&gt;any())
            -&gt;method('exists')
            -&gt;with(self::FIXTURE_ABSOLUTE_PATHNAME)
            -&gt;will($this-&gt;returnValue(true))
        ;

        // Mock
        $this-&gt;filesystem-&gt;expects($this-&gt;once())
            -&gt;method('dumpFile')
            -&gt;with(
                $this-&gt;equalTo(self::FIXTURE_ABSOLUTE_PATHNAME),
                $this-&gt;equalTo(self::FIXTURE_CONTENT)
            )
        ;

        // Call
        $this-&gt;documentationWriter-&gt;write(
            self::FIXTURE_ABSOLUTE_PATHNAME,
            self::FIXTURE_CONTENT
        );
    }
}
</code></pre>

<p>In the stub: for every call (<code>expects($this-&gt;any())</code>) of the method <code>exists</code>
with the parameter <code>self::FIXTURE_ABSOLUTE_PATHNAME</code>, force the colaborator to
return <code>true</code>.</p>

<p>In the mock: a unique call must be made (<code>expects($this-&gt;once())</code>) of the method
<code>dumpFile</code> with the two parameters <code>self::FIXTURE_ABSOLUTE_PATHNAME</code> and
<code>self::FIXTURE_CONTENT</code>.</p>

<p>You can run the test using <code>php vendor/bin/phpunit</code> and see that they pass. As
an exercise, write a second method in this test suite
<code>testDoesNotWriteExistingFile</code>, with a stub returning false and a mock checking
that <code>dumpFile</code> is never called (<a href="http://phpunit.de/manual/3.7/en/test-doubles.html#test-doubles.mock-objects.tables.matchers">hint</a>).</p>

<p>I advise you to watch <a href="http://verraes.net/2013/09/extract-till-you-drop/">extract till you drop</a>,
a nice refactoring session by Mathias Verraes: in order to improve his code, he
writes tests which give him enough confidence to proceed. He uses PHPUnit with
assertions, mocks and stubs, so you can really see their use.</p>

<h2 id="functional-tests">Functional tests</h2>

<p>Unit tests are used in order to make sure each unit of <code>code</code> works as expected.
But applications aren't just about code, they're also about interactions
between these units. This is what functional tests are for: they use the entry
point of the system and check the final status code.</p>

<p>To illustrate this, we'll still use PHPUnit: even though there's the word <code>unit</code>
in its name, this test framework allows us to write many types of tests.</p>

<p>The Symfony2 web framework is all about the HTTP protocol: it takes a HTTP
Request and returns a HTTP Response. It also provides a convenient client which
simulates HTTP Requests, allowing us to write easily functional tests:</p>

<pre><code>&lt;?php
// File: src/Acme/DemoBundle/Tests/Controller/DemoControllerTest.php

namespace Acme\DemoBundle\Tests\Controller;

use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\Response;

class DemoControllerTest extends WebTestCase
{
    public function testIndex()
    {
        $client = static::createClient();

        $client-&gt;request('GET', '/demo/hello/Fabien');

        $this-&gt;assertSame(
            Response::HTTP_OK,
            $client-&gt;getResponse()-&gt;getStatusCode()
        );
    }
}
</code></pre>

<p>The <code>assertSame</code> line is an assertion: it compares the expected value (first
argument) with the actual one (second one). PHPUnit provides many assertions:</p>

<ul>
<li><code>assertSame</code> is equivalent to <code>===</code> (type and value comparison)</li>
<li><code>assertEquals</code> is equivalent to <code>==</code> (loose value comparison)</li>
<li><code>assertFileExists</code> checks if the given filename corresponds to an exisitng file</li>
<li><a href="http://phpunit.de/manual/3.7/en/appendixes.assertions.html">and many more</a></li>
</ul>

<p>Different approaches exist with assertions, for example jasmine uses the
<code>expect</code> method to set the actual value, chained with a matcher like <code>toBe</code>
which takes the expected value:</p>

<pre><code>describe("A suite", function() {
  it("contains spec with an expectation", function() {
    var expectedValue = true;
    var actualValue = true;

    expect(actualValue).toBe(expectedValue);
  });
});
</code></pre>

<p>In this case, assertions are splitted into expectations and matchers.</p>

<p>Back to our sheeps. Here's an example of functional test for a Symfony2 command:</p>

<pre><code>&lt;?php
// File: src/Acme/DemoBundle/Tests/Command/GreetCommandTest.php

namespace Acme/DemoBundle/Tests/Command;

use Symfony\Component\Console\Tester\CommandTester;
use Symfony\Bundle\FrameworkBundle\Console\Application;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Acme\DemoBundle\Command\GreetCommand;

class ListCommandTest extends WebTestCase
{
    public function testExecute()
    {
        $kernel = $this-&gt;createKernel();
        $kernel-&gt;boot();

        $application = new Application($kernel);
        $application-&gt;add(new GreetCommand());

        $command = $application-&gt;find('demo:greet');
        $commandTester = new CommandTester($command);
        $commandTester-&gt;execute(
            array(
                'name' =&gt; 'Fabien',
                '--yell'  =&gt; true,
            )
        );

        $exitSuccess = 0;

        $this-&gt;assertSame($exitSuccess, $commandTester-&gt;getStatusCode());
    }
}
</code></pre>

<p>Just like with a controller where we check the HTTP Response's status code, in
a command we check the exit status code.</p>

<h2 id="user-interfact-tests">User Interfact tests</h2>

<p>Up until now, we've been testing that the code worked and that interractions
between all those units go well. But what about the thing the user actually
sees and interacts with?</p>

<p>The User Interface (UI) turns out to be tricky to test, but not impossible. You
can click on buttons, or load pages, or run CLI tasks programmatically and you
can inspect the standard output or the HTTP Response's content.</p>

<p>The main problem with this is that you'll tie your tests to the UI, which
changes a lot.</p>

<p>We'll see briefly the tools available and then better explain the flaws of such
a technique.</p>

<h3 id="selenium">Selenium</h3>

<p><a href="http://docs.seleniumhq.org/">Selenium</a> allows you to open a browser and
simulates interractions with the page. Technically it means having a Selenium
server running in the background, and using a webdriver library in your test to
send messages to it. In PHP, you can find those webdrivers:</p>

<ul>
<li><a href="https://github.com/alexandresalome/php-webdriver">One by Alexandre Salomé</a></li>
<li><a href="https://github.com/facebook/php-webdriver">another one by Facebook</a></li>
</ul>

<p>You can find code samples in the respective documentation of each library, for
example here's the doc describing <a href="https://github.com/alexandresalome/php-webdriver/blob/master/doc/elements.rst#element-api">how to click on a button with Alexandre's one</a>.</p>

<p>If you're curious, <a href="http://codeception.com/11-20-2013/webdriver-tests-with-codeception.html">here's how to use Selenium with another test framework</a>:
<a href="http://codeception.com/">Codeception</a>.</p>

<h3 id="casperjs">CasperJs</h3>

<p>You don't like the idea of running a server in order to run your tests? You
don't want a browser to be openned and you <a href="http://stackoverflow.com/questions/2354590/why-is-selenium-rc-so-slow">find it too slow</a>?</p>

<p>Then you might want to try a <strong>headless website testing</strong> solution like
<a href="http://casperjs.org/">CasperJs</a>. It's headless because it won't open a
browser to make the tests.</p>

<p>Here's the <a href="http://docs.casperjs.org/en/latest/quickstart.html">get started documentation</a>,
so you can have a quick look on how to use it.</p>

<h3 id="goutte">Goutte</h3>

<p>Simulating a browser is too much for you? Making a curl request and parsing its
response would be sufficient for your needs? Then have a look at the
<a href="https://github.com/fabpot/goutte">Goutte web scrapper</a>.</p>

<p>This one also allows you to click on links.</p>

<h3 id="mink">Mink</h3>

<blockquote>
  <p>One Tool to rule them all, One Tool to find them,
  One Tool to bring them all and in the webness bind them</p>
</blockquote>

<p><a href="http://mink.behat.org/">Mink</a> can use either Goutte or Selenium as a driver to
interract with the UI. It's goal is to provide a unified API.</p>

<h3 id="what%27s-the-point%3F">What's the point?</h3>

<p>The thing in common with all these tools is that they rely on the HTML rendered
in the HTTP Response. In order to check if a message appears, you'll have to
crawl the page, find the <code>div</code> using its class or id in a CSS selector, or even
worse using its xpath.</p>

<p>When the page will change (and it will) your tests will be broken. There's some
best practices out there, mainly making your tests rely on ID's on one hand and
making your code and stylesheets rely on classes on the other hand, but in the
end it still is a risky business.</p>

<p>Well that's my opinion and this section might be more a rant than an objective
description. To counter balance this, here's a nice article on
<a href="http://blog.mozilla.org/webqa/2013/09/26/writing-reliable-locators-for-selenium-and-webdriver-tests/">writing reliable locators for Selenium and WebDriver tests</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In PHP, <a href="http://phpunit.de/">PHPUnit</a> is the most popular test framework and it
allows you to write unit, functional and every other kinds of tests.</p>

<p>Unit tests allow you to make sure each functions return the expected output when
given a set of fixtures, and functional tests are used to check the status code
(think HTTP response, or a command's exit status).</p>

<p>Stubs are used to force a colaborator's method to return a wanted value, and
mocks are used to check if a colaborator's method have been called.</p>

<p><a href="http://docs.seleniumhq.org/">Selenium</a> is the most popular tool to test the
User Interface, which is done by interracting with the HTML rendered in the
HTML's reponse.</p>

<p>I hope this article helped you to see how each kinds of tests are written. The
next one will be on Test Driven Development, a practice where tests are written
before the code: <a href="/2014/02/19/test-driven-development.html">TDD</a>.</p>

<p>If there's something bothering you in this post, or if you have a question, or
if you want to give me your opinion, be sure to do so on
<a href="https://twitter.com/epiloic">Twitter</a> ;) .</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Tests: Introduction]]></title>
            <link href="/2014/02/05/tests-introduction.html"/>
            <updated>2014-02-05T00:00:00+00:00</updated>
            <id>/2014/02/05/tests-introduction.html</id>
            <content type="html"><![CDATA[<p>This article is part of a series on Tests in general and on how to practice
them:</p>

<ol>
<li><a href="/2014/02/05/tests-introduction.html">Introduction</a></li>
<li><a href="/2014/02/12/tests-tools-overview.html">Tools overview</a></li>
<li><a href="/2014/02/19/test-driven-development.html">Test Driven Development</a></li>
<li><a href="/2014/02/26/tdd-just-do-it.html">TDD: just do it!</a></li>
<li><a href="/2014/03/05/spec-bdd.html">spec BDD</a></li>
<li><a href="/2014/03/11/phpspec-quick-tour.html">phpspec: a quick tour</a></li>
<li><a href="/2014/03/19/behavior-driven-development-story-bdd.html">Behavior Driven Development: story BDD</a></li>
<li><a href="/2014/03/26/behat-quick-tour.html">Behat: a quick tour</a></li>
<li><a href="/2014/04/02/tests-cheat-sheet.html">Conclusion</a></li>
</ol>

<p>This introduction can be read by anyone (no special level required) and it
targets those who've never heard about tests, or those you've never really
practice them. Here's what we'll cover:</p>

<ol>
<li><a href="#what-is-a-test">what is a test</a></li>
<li><a href="#what-are-the-different-kinds-of-tests">which kinds of tests are around there</a></li>
<li><a href="#how-to-do-an-isolated-test">how to do an isolated test</a></li>
</ol>

<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<h2 id="what-is-a-test%3F">What is a test?</h2>

<p>A test is a way to check if part of the system is working. Let's say you just
wrote the <code>strlen</code> function: it takes a string as argument and returns its
length. To make sure it works correctly, you might have created a script file
which looked like this:</p>

<pre><code>&lt;?php

echo strlen('We'); // Should print 2
echo strlen('are'); // Sould print 3
echo strlen('the knights'); // Should print 11
echo strlen('who say "Ni"!'); // Should print 13
</code></pre>

<p>This script (which you might have thrown away once satisfied with the printed
result) is a test. It makes sure your function works correctly by providing it
with different inputs and comparing its output with the expected one.</p>

<p>This test is not really efficient, but it does the work. Let's see how to
improve it in the following sections.</p>

<h2 id="what-are-the-different-kinds-of-tests">What are the different kinds of tests</h2>

<p>Tests can be grouped under 3 categories:</p>

<ol>
<li>random manual tests</li>
<li>scenarized manual tests</li>
<li>automated tests</li>
</ol>

<h3 id="random-manual-tests">Random manual tests</h3>

<p>The first one is when you use your software to see if it works correctly. This
is the worst kind of test because systems can be so complex that some part will
enventually be forgoten, and therefore not checked.</p>

<p>Incidentally, this is what happens everyday when users use your product, except
you're not sure if they'll report the bugs they see (and for each bug discovery
you can potentially lose them).</p>

<p>Why do I mention it, if it's so bad? Because it's still usefull to discover bugs
on parts which haven't been correctly covered by the other kinds of tests.
Actually this is the kind of tests which are done during beta-tests: you get a
restricted set of (volunteer) users to use your product and see if everything
is fine.</p>

<h3 id="scenarized-manual-tests">Scenarized manual tests</h3>

<p>Let's take a scientific approach to the first kind of tests by writing test
plans which describe use cases with their expected outcome.</p>

<p>Everytime someone tests the system, they follow the scenario given to them.
This is an improvement of the previous approach as there's less risk of
forgoting a step which is written.</p>

<p>Those tests are generally followed (more or less rigorously) during
<strong>acceptance testing</strong> at the end of developments by the customer or product
owner or even better by Quality Assurance (QA).</p>

<h3 id="automated-tests">Automated tests</h3>

<p>The problem with the two previous categories is that they require humans, and
<em>to err is human</em>. The software industry was partly created to automate
repititive tasks, so how about we automate those tests?</p>

<p>The simplest way of automating test is to use assertions:</p>

<pre><code>&lt;?php

$input = 'We are no longer the knights who say "Ni"!';
$expectedOutput = 42;

$output = strlen($input);

echo ($expectedOutput === $output ? 'Test pass' : 'Test fails');
</code></pre>

<p>If you keep this script, you can run it regurarly, which means the risk of
forgoting a step is almost near zero! I say almost because the test doesn't
magically cover every use case: human still have to write them, which lets a
small room for errors to happen, but this is the best we can do.</p>

<p>As you can see, automated tests are constructed very simply:</p>

<ol>
<li>define the input and the expected output</li>
<li>execute the part of the system which needs to be tested</li>
<li>compare its output with the expected one</li>
</ol>

<h2 id="further-kinds-of-tests">Further kinds of tests</h2>

<p>We've seen the 3 big categories of tests. But that's not quite it: whether it's
automated or not, your tests can target many levels/layers in your application:</p>

<ul>
<li>View layer:

<ul>
<li>User Interface (UI) tests: HTML and DOM</li>
</ul></li>
<li>Application layer:

<ul>
<li>functional tests: controllers, HTTP status code, command exit status</li>
</ul></li>
<li>Domain layer (the code which solves business needs):

<ul>
<li>behavior tests: interaction between classes</li>
<li>unit tests: services, interfaces, functions</li>
</ul></li>
</ul>

<p><strong>Note</strong>: this classification has been taken from
<a href="https://speakerdeck.com/halleck/symfony2-un-framework-oriente-domain-driven-design?slide=20">Jean François Lépine's slides</a></p>

<p>Each of those tests can be executed manually, or can be automated.</p>

<p>There's so many types of tests out there, and so little of us to write them!
Depending on your team, competences, project and planning, you won't be able to
write every possible tests.</p>

<p>I'm afraid you'll have somehow to chose which kind of test is more suitable for
you project. As a matter of fact, testing everything isn't wise:</p>

<pre><code>&lt;?php

class User
{
    private $name;

    public function __construct($name)
    {
        $this-&gt;name = $name;
    }

    public function getName()
    {
        return $this-&gt;name;
    }
}

// Is this test really usefull? I think not!
$input = 'Johann Gambolputty de von Ausfern -schplenden -schlitter -crasscrenbon -fried -digger -dangle -dungle -burstein -von -knacker -thrasher -apple -banger -horowitz -ticolensic -grander -knotty -spelltinkle -grandlich -grumblemeyer -spelterwasser -kürstlich -himbleeisen -bahnwagen -gutenabend -bitte -eine -nürnburger -bratwustle -gerspurten -mit -zweimache -luber -hundsfut -gumberaber -shönendanker -kalbsfleisch -mittler -raucher von Hautkopft of Ulm.';
$expectedOutput = $input;

$user = new User($input);
$output = $user-&gt;getName();

echo ($expectedOutput === $output ? 'Test pass' : 'Test fails');
</code></pre>

<p>In the upper code sample, we're testing if the getter returns a value which
haven't been modified. Sure you could introduce a typo while sketching the
class, but once you've manually tested it a first time there's no need to check
regularly if it still works in the future.</p>

<p>You may not be able to write every possible tests, but still writing some tests
will save you time in the future as it will prevent regression: the software
industry is an industry of changing requirements, which means your code will
eventually be changed, adapted and sometime completly re-written.</p>

<p>Tests will allow you to change the code lighthearted, because if your change
breaks something, you'll know it simply by running your tests.</p>

<h2 id="how-to-do-an-isolated-test%3F">How to do an isolated test?</h2>

<p>Chances are your system is composed of parts which interact with each other:
your functions call other functions, your classes depend on other classes and
use external functions, etc.</p>

<p>What if the part of the system you want to test interracts with a database, the
filesystem and also use a randomizer? Yep that's right, a randomizer: how can
you even write the expected output if it's supposed to be unpredictable?</p>

<p>The solution is quite simple: you should isolate the part you want to test.
In order to do so, you should use <strong>test doubles</strong> which is the practice of
replacing the dependencies of this part with objects which will behave the way
you tell them to.</p>

<p>There's many kinds of test doubles, fortunately <a href="http://martinfowler.com/articles/mocksArentStubs.html">Martin Fowler has summed it up
for you</a> as follow:</p>

<blockquote>
  <ul>
  <li><p>Dummy objects are passed around but never actually used.
  Usually they are just used to fill parameter lists.</p></li>
  <li><p>Fake objects actually have working implementations, but usually take some
  shortcut which makes them not suitable for production (an in memory
  database is a good example).</p></li>
  <li><p>Stubs provide canned answers to calls made during the test, usually not
  responding at all to anything outside what's programmed in for the test.
  Stubs may also record information about calls, such as an email gateway
  stub that remembers the messages it 'sent', or maybe only how many messages
  it 'sent'.</p></li>
  <li><p>Mocks are what we are talking about here: objects pre-programmed with
  expectations which form a specification of the calls they are expected to
  receive.</p></li>
  </ul>
</blockquote>

<p>In practice you'll use stubs to specify the return value of the dependency, and
you'll use mocks to check if the dependency's method has been called. The best
way to create stubs and mocks is to write a class which inherits the targeted
dependency, and overwrites its public methods.</p>

<p><strong>Note</strong>: the part you want to test is called the System Under Test (SUT), and
its dependencies are called collaborators.</p>

<h3 id="dependency-injection%27s-back%21">Dependency Injection's back!</h3>

<p>Did you notice I've used the word dependency in this section? That's because in
order to make a class <em>testable</em>, you need it to be as decoupled as possible
from its dependencies.</p>

<p>You won't be able to easily replace dependencies which are created by the part
you want to test. The simplest way is to inject them (pass them as arguments)
to your class, allowing you to decide what should be injected: the real
dependency, or one of its stub (or mock).</p>

<p>This is why Dependency Injection is a big deal. If you don't clearly know what
is this design pattern about, I advise you to
<a href="/2014/01/22/ioc-di-and-service-locator.html">read this article</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Tests allow you to make sure parts of your system work as expected, and they can
be automated so you can run them regurarly in order to detect any regressions.</p>

<p>There's a lot of layers which can be tested and you might have to choose what is
best for you (the wrong answer being "no tests for me, thank you very much").</p>

<p>Dependency Injection is the right way to go, as it will allow you to use test
doubles to isolate the part you want to check.</p>

<p>This article had much theory in it, so the next one will be more practical with
code samples, case studies and tools which will allow you to test your
applications: <a href="/2014/02/12/tests-tools-overview.htm">Tools overview</a>.</p>

<h3 id="a-word-about-test-coverage">A word about test coverage</h3>

<p>I might not have stressed this out enough: <strong>tests won't magically prevent your
system from failing</strong>. This is all because your test will only cover the part
you targeted, for the use case you could think of at the time.</p>

<p>So, how to make sure your tests are enough? At first glance, test coverage might
be a solution: it's a tool which will mark any line of code executed while the
test is run and which will produce a report telling you which parts haven't been
visited.</p>

<p>The biggest flaw of such a tool is that just because you called a line doesn't
mean you tested it. The other important weakness is that not every code needs
to be tested (for example getters of values which are not altered): the report
will tell you a percentage of code covered, but it won't be able to tell you
if the covered part is the essential one.</p>

<p>In order to know if your tests cover the critical parts, mutation testing have
been invented: a tool will alter random parts of your code and run the tests. If
your tests fail, then they play well their role of guarding your application
against regressions.</p>

<p>However this is not very precise, they're slow and they can't know what are the
critical parts of your system...</p>

<p>I guess the best you can do is TDD, which we'll see in a future article ;) .</p>

<p>If you're interested in this subject, I advise you to read
<a href="http://codemanship.co.uk/parlezuml/blog/?postid=1202">Jason Gorman's article on code coverage</a>.</p>
]]></content>
        </entry>
    </feed>