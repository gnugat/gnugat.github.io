<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title><![CDATA[Loïc Faugeron]]></title>
    <link href="/feed/atom.xml" rel="self"/>
    <link href="/"/>
    <updated>2025-09-03T07:18:36+01:00</updated>
    <id>http://gnugat.github.com</id>
            <author>
            <name><![CDATA[Loïc Faugeron]]></name>            <email><![CDATA[faugeron.loic@gmail.com]]></email>        </author>
        <generator uri="http://sculpin.io/">Sculpin</generator>
            <entry>
            <title type="html"><![CDATA[Strategy Pattern, Symfony and autowiring]]></title>
            <link href="/2024/08/16/strategy-pattern-symfony-autowiring.html"/>
            <updated>2024-08-16T00:00:00+01:00</updated>
            <id>/2024/08/16/strategy-pattern-symfony-autowiring.html</id>
            <content type="html"><![CDATA[<blockquote>
  <p><strong>TL;DR</strong>: Since Symfony 5.3</p>
  
  <p>Tag the "Strategy" Interface with the attribute <code>[#AutoconfigureTag]</code>:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\Attribute\AutoconfigureTag;

#[AutoconfigureTag]
interface Strategy
{
    // Add your Strategy methods below, for example
    // (please use a more descriptive name than "algorithm"...):
    public function algorithm();

    // *IF* your Strategies need to be executed in a specific order,
    // then add a method that returns the priority (highest priority first, lowest priority last)
    // Note: it MUST be static
    public static function getDefaultPriority(): int;

    // *IF* your Strategies are executed conditionally,
    // then add a "predicate" method (eg named `supports()`):
    public function predicate($input): bool
}
</code></pre>
  
  <p>Inject the <code>iterable</code> that contains all tagged "Strategy" implementations
  in the "Context"'s constructor with the attribute <code>#[TaggedIterator(&lt;tag&gt;)]</code>:</p>

<pre><code class="php">&lt;?php

class Context
{
    public function __construct(
        // *IF* your Strategies need to be executed in a specific order,
        // then use the `defaultPriorityMethod` parameter and set it with the Strategy's static method name
        #[TaggedIterator(Strategy::class, defaultPriorityMethod: 'getDefaultPriority')]
        private iterable $strategies,
    ) {
    }

    public function operation($input)
    {
        foreach ($this-&gt;strategies() as $strategy) {
            // *IF* your Strategies need to be executed conditionally,
            // then add a if statement that verifies the Strategy's predicate method
            if ($strategy-&gt;predicate($input)) {
                $strategy-&gt;algorithm();

                // *IF* you only want the first matching Strategy to be executed,
                // then break the loop here
                break;
            }
        }
    }
}
</code></pre>
  
  <p>Set <code>autowire</code> and <code>autoconfigure</code> parameters to be <code>true</code> in the DIC configuration:</p>

<pre><code class="yaml">services:
    _defaults:
        autowire: true
        autoconfigure: true
</code></pre>
</blockquote>

<p>The Strategy Pattern can be really useful when you want to avoid multiple
conditionals, and/or when you want to add new repetitive chunks of logic
in a maintainable way.</p>

<p>Let's see how to use it in a Symfony application, and how autowiring can help
us configure it.</p>

<p>Note that the code snippets below will NOT be truncated, they'll always contain
the full code (so no things like <code>// rest of the class below</code> comments).</p>

<h2 id="use-case-example">Use Case Example</h2>

<p>Some classes are just bound to contain repeated chunks of similar logic:</p>

<pre><code class="php">&lt;?php

class EmailDailyReports
{
    public function __construct(
        private BuildSpreadsheet $buildSpreadsheet,
        private Mailer $mailer,
        private WriteSpreadsheet $writeSpreadsheet,
        private RetrieveDataForReportOne $retrieveDataForReportOne,
        private RetrieveDataForReportTwo $retrieveDataForReportTwo,
    ) {
    }

    public function send(\DateTime $startDate, \DateTime $endDate): void
    {
        $reportOneData = $this-&gt;retrieveDataForReportOne-&gt;fromDatabase($startDate, $endDate);
        $reportOneName = 'Report One';
        $reportOneSpreadsheet = $this-&gt;buildSpreadsheet-&gt;using($reportOneData, $reportOneName);
        $reportOneFilename = $this-&gt;writeSpreadsheet-&gt;save($reportOneSpreadsheet);

        $reportTwoData = $this-&gt;retrieveDataForReportTwo-&gt;fromDatabase($startDate, $endDate);
        $reportTwoName = 'Report Two';
        $reportTwoSpreadsheet = $this-&gt;buildSpreadsheet-&gt;using($reportTwoData, $reportTwoName);
        $reportTwoFilename = $this-&gt;writeSpreadsheet-&gt;save($reportTwoSpreadsheet);

        $email = (new Email())
            -&gt;from('sender@example.com')
            -&gt;to('recipient@example.com')
            -&gt;attachFromPath($reportOneFilename, $reportOneName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
            -&gt;attachFromPath($reportTwoFilename, $reportTwoName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
            -&gt;subject('Daily Reports')
            -&gt;text('Find reports in attached files');
        $this-&gt;mailer-&gt;send($email);
    }
}
</code></pre>

<p>This <code>EmailDailyReports</code> class builds spreadsheets and sends emails for reports.</p>

<p>The retrieval of the data for each report is delegated to a dedicated service.</p>

<p>This is fine as is, with currently only 2 reports to manage...
But what if we need to add 1 more report? 2 more reports? 30 more reports?</p>

<h2 id="strategy-pattern">Strategy Pattern</h2>

<p>This use case is the perfect candidate for the Strategy Pattern.</p>

<p><code>EmailDailyReports</code> would be considered the "Context" class,
and the services that retrieve the report data would be the "Strategies".</p>

<p>Let's refactor <code>EmailDailyReports</code> to implement this design pattern.</p>

<p>First we create a Strategy interface:</p>

<pre><code class="php">&lt;?php

interface RetrieveDataForReport
{
    public function fromDatabase(\DateTime $startDate, \DateTime $endDate): array;
    public function getName(): string;
}
</code></pre>

<p>Then we make sure the Strategy implementations both implement it
(<code>RetrieveDataForReportOne</code> and <code>RetrieveDataForReportTwo</code>).</p>

<p>Finally we refactor the Context class to be injected with a collection of
Strategies, and iterate through them:</p>

<pre><code class="php">&lt;?php

class EmailDailyReports
{
    public function __construct(
        private BuildSpreadsheet $buildSpreadsheet,
        private Mailer $mailer,
        private WriteSpreadsheet $writeSpreadsheet,
    ) {
    }

    public function send(\DateTime $startDate, \DateTime $endDate): void
    {
        $email = (new Email())
            -&gt;from('sender@example.com')
            -&gt;to('recipient@example.com')
            -&gt;subject('Daily Reports')
            -&gt;text('Find reports in attached files');

        foreach ($this-&gt;retrieveDataForReports as $retrieveDataForReport) {
            $reportData = $retrieveDataForReport-&gt;fromDatabase($startDate, $endDate);
            $reportName = $retrieveDataForReport-&gt;getReportName();
            $reportSpreadsheet = $this-&gt;buildSpreadsheet-&gt;using($reportData, $reportName);
            $reportFilename = $this-&gt;writeSpreadsheet-&gt;save($reportSpreadsheet);

            $email-&gt;attachFromPath($reportFilename, $reportName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        }

        $this-&gt;mailer-&gt;send($email);
    }

    private array $retrieveDataForReports = [];

    public function register(RetrieveDataForReport $retrieveDataForReport): void
    {
        $this-&gt;retrieveDataForReports[] = $retrieveDataForReport;
    }
}
</code></pre>

<p>If the order in which the reports are built is important,
then we need to add a bit of extra logic:</p>

<pre><code class="php">&lt;?php

class EmailDailyReports
{
    public function __construct(
        private BuildSpreadsheet $buildSpreadsheet,
        private Mailer $mailer,
        private WriteSpreadsheet $writeSpreadsheet,
    ) {
    }

    public function send(\DateTime $startDate, \DateTime $endDate): void
    {
        $email = (new Email())
            -&gt;from('sender@example.com')
            -&gt;to('recipient@example.com')
            -&gt;subject('Daily Reports')
            -&gt;text('Find reports in attached files');

        foreach ($this-&gt;getSortedRetrieveDataForReports() as $retrieveDataForReport) {
            $reportData = $retrieveDataForReport-&gt;fromDatabase($startDate, $endDate);
            $reportName = $retrieveDataForReport-&gt;getReportName();
            $reportSpreadsheet = $this-&gt;buildSpreadsheet-&gt;using($reportData, $reportName);
            $reportFilename = $this-&gt;writeSpreadsheet-&gt;save($reportSpreadsheet);

            $email-&gt;attachFromPath($reportFilename, $reportName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        }

        $this-&gt;mailer-&gt;send($email);
    }

    private const int DEFAULT_PRIORITY = 100;
    private const array NOT_SORTED = [];

    private array $unsortedRetrieveDataForReports = [];
    private array $sortedRetrieveDataForReports = self::NOT_SORTED;

    public function register(
        RetrieveDataForReport $retrieveDataForReport,
        int $priority = self::DEFAULT_PRIORITY,
    ): void {
        $this-&gt;unsortedRetrieveDataForReports[$priority][] = $retrieveDataForReport;
        $this-&gt;sortedRetrieveDataForReports = self::NOT_SORTED;
    }

    private function getSortedRetrieveDataForReports(): void
    {
        if (self::NOT_SORTED === $this-&gt;sortedRetrieveDataForReports)) {
            // Strategies with higher priority need to be executed before the ones with lower priority
            krsort($this-&gt;unsortedRetrieveDataForReports);

            // Flattens strategies by removing the "priority" dimension from the array
            $this-&gt;sortedRetrieveDataForReports = array_merge(...$this-&gt;unsortedRetrieveDataForReports);
        }

        return $this-&gt;sortedRetrieveDataForReports;
    }
}
</code></pre>

<p>Have you heard of the Symfony component EventDispatcher?
While it is a well known implementation of the Observer design pattern,
the way the EventListeners (strategies) are registered and executed in the
EventDispatcher (context) is very similar to this.</p>

<h2 id="configuring-di-in-symfony---yaml">Configuring DI in Symfony - YAML</h2>

<p>Speaking of Symfony, how would we configure the Dependency Injection Container
for this service? First, let's write the YAML configuration:</p>

<pre><code class="yaml">services:
    'EmailDailyReports':
        arguments:
            - '@BuildSpreadsheet'
            - '@Mailer'
            - '@WriteSpreadsheet'
        calls:
            - register:
                - '@RetrieveDataForReportOne'
                - 200
            - register:
                - '@RetrieveDataForReportTwo'
                - 100

    'BuildSpreadsheet': ~
    'Mailer': ~
    'WriteSpreadsheet': ~
    'RetrieveDataForReportOne': ~
    'RetrieveDataForReportTwo': ~
</code></pre>

<p>Note that we need to write the priorities here in the <code>EmailDailyReports</code>
service definition. The <code>calls</code> section is fine for now, as we only have two
Strategies.</p>

<p>But what if we need to add 1 more report? 2 more reports? 30 more reports?</p>

<h2 id="configuring-di-in-symfony---compiler-passes">Configuring DI in Symfony - Compiler Passes</h2>

<p>The entire <code>calls</code> section can be removed from the configuration,
by creating a CompilerPass:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\Compiler\CompilerPassInterface;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\DependencyInjection\Reference;

class RegisterRetrieveDataForReportsCompilerPass implements CompilerPassInterface
{ 
    public function process(ContainerBuilder $container): void
    {
        // Get Context service definition
        $emailDailyReports = $container-&gt;findDefinition(EmailDailyReports::class);

        // Get iterable of all the Strategy service definitions (they'll be tagged with the Strategy interface FQCN)
        $retrieveDataForReports = $container-&gt;findTaggedServiceIds(RetrieveDataForReport::class);

        foreach ($retrieveDataForReports as $id =&gt; $tags) {
            // In theory you can tag a service many times with the same tag,
            // but in our case here, there'll only be one tag
            foreach ($tags as $retrieveDataForReport) {
                // call the Setter Injection on the Context service definition
                $emailDailyReports-&gt;addMethodCall('register', [
                    new Reference($id),             
                    $retrieveDataForReport['priority'] ?? EmailDailyReports::DEFAULT_PRIORITY,
                ]);            
            }
        }
    }
}
</code></pre>

<p>Also, make sure to register the CompilerPass in the Bundle:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\HttpKernel\Bundle\Bundle;

class MyBundle extends Bundle
{ 
    public function build(ContainerBuilder $container): void
    {
        parent::build($container);      

        $container-&gt;addCompilerPass(new RegisterRetrieveDataForReportsCompilerPass());
    }
}
</code></pre>

<p>Note that now the priorities need to be defined in the tags of the
RetrieveDataForReport service definitions:</p>

<pre><code class="yaml">services:
    'EmailDailyReports':
        arguments:
            - '@BuildSpreadsheet'
            - '@Mailer'
            - '@WriteSpreadsheet'

    'BuildSpreadsheet': ~
    'Mailer': ~
    'WriteSpreadsheet': ~
    'RetrieveDataForReportOne':
        tags:
            - { name: 'RetrieveDataForReport', priority: 200 }
    'RetrieveDataForReportTwo':
        tags:
            - { name: 'RetrieveDataForReport', priority: 100 }
</code></pre>

<p>Defining manually the service definition for every classes in our project is
all fun and games, and having to set tags is fine for now, as we only have two
Strategies.</p>

<p>But what if we need to add 1 more report? 2 more reports? 30 more reports?</p>

<h2 id="configuring-di-in-symfony-5.3---taggediterator">Configuring DI in Symfony (5.3) - TaggedIterator</h2>

<p>Since <a href="https://github.com/symfony/symfony/pull/22295">Symfony 3.3</a>,
the Dependency Injection's autowiring will inject dependencies named after the
type of the service arguments.</p>

<p>This works great for the constructor of <code>EmailDailyReports</code> (note the
conspicuously missing <code>EmailDailyReports</code>, <code>BuildSpreadsheet</code>, <code>Mailer</code> and
<code>WriteSpreadsheet</code>):</p>

<pre><code class="yaml">services:
    _defaults:
        autowire: true

    'RetrieveDataForReportOne':
        tags:
            - { name: 'RetrieveDataForReport', priority: 200 }
    'RetrieveDataForReportTwo':
        tags:
            - { name: 'RetrieveDataForReport', priority: 100 }
</code></pre>

<p>By adding <code>_defaults.autowire: true</code>, we were able to remove 8 lines of configuration!</p>

<p>Then, since <a href="https://github.com/symfony/symfony/pull/39804">Symfony 5.3</a>,
it is possible to automatically tag all the implementations,
by using the <code>#[AutoconfigureTag]</code> attribute on the interface:</p>

<pre><code class="php">&lt;?php

use Symfony\Component\DependencyInjection\Attribute\AutoconfigureTag;

#[AutoconfigureTag]
interface RetrieveDataForReport
{
    public function fromDatabase(\DateTime $startDate, \DateTime $endDate): array;
    public function getName(): string;
    public static function getDefaultPriority(): int;
}
</code></pre>

<p>This only works if <code>_defaults.autoconfigure</code> is set to <code>true</code> in the config
(note the conspicuously missing <code>RetrieveDataForReportOne</code> and <code>RetrieveDataForReportTwo</code>):</p>

<pre><code class="yaml">services:
    _defaults:
        autowire: true
        autoconfigure: true
</code></pre>

<p>You might have noticed that we've added a <code>public static function getDefaultPriority(): int</code>
method to our interface. Since the priorities configuration is gone from YAML,
the have to be returned by the implementations:</p>

<ul>
<li><code>RetrieveDataForReportOne::getDefaultPriority()</code> needs to return <code>200</code></li>
<li><code>RetrieveDataForReportTwo::getDefaultPriority()</code> needs to return <code>100</code></li>
</ul>

<p>Finally, since <a href="https://github.com/symfony/symfony/pull/40406">Symfony 5.3</a>,
it is also possible to inject an <code>iterator</code> containing all services that have a specific tag,
by using the <code>#[TaggedIterator]</code> attribute. Let's use it in the "Context" class:</p>

<pre><code class="php">&lt;?php

class EmailDailyReports
{
    public function __construct(
        private BuildSpreadsheet $buildSpreadsheet,
        private Mailer $mailer,
        private WriteSpreadsheet $writeSpreadsheet,
        #[TaggedIterator(RetrieveDataForReport::class, defaultPriorityMethod: 'getDefaultPriority')]
        private iterable $retrieveDataForReports,
    ) {
    }

    public function send(\DateTime $startDate, \DateTime $endDate): void
    {
        $email = (new Email())
            -&gt;from('sender@example.com')
            -&gt;to('recipient@example.com')
            -&gt;subject('Daily Reports')
            -&gt;text('Find reports in attached files');

        foreach ($this-&gt;retrieveDataForReports as $retrieveDataForReport) {
            $reportData = $retrieveDataForReport-&gt;fromDatabase($startDate, $endDate);
            $reportName = $retrieveDataForReport-&gt;getReportName();
            $reportSpreadsheet = $this-&gt;buildSpreadsheet-&gt;using($reportData, $reportName);
            $reportFilename = $this-&gt;writeSpreadsheet-&gt;save($reportSpreadsheet);

            $email-&gt;attachFromPath($reportFilename, $reportName, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        }

        $this-&gt;mailer-&gt;send($email);
    }
}
</code></pre>

<p>This means we can remove the <code>CompilerPass</code> (and unregister it from the Bundle).</p>

<p>You'll also note that we've removed from <code>EmailDailyReports</code> the following methods:</p>

<ul>
<li><code>register()</code>: the "Strategies" are no longer injected one by one</li>
<li><code>getSortedRetrieveDataForReports()</code>: TaggedIterator supports sorting by priorities,
but it requires the "Strategies" to have a <strong>static</strong> method that returns the priority</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>To sum up:</p>

<ul>
<li>Tag the "Strategy" Interface with the attribute <code>[#AutoconfigureTag]</code></li>
<li>Inject the <code>iterable</code> that contains all tagged "Strategy" implementations
in the "Context"'s constructor with the attribute <code>#[TaggedIterator(&lt;tag&gt;)]</code></li>
<li>Set <code>autowire</code> and <code>autoconfigure</code> parameters to be <code>true</code> in the DIC configuration</li>
</ul>

<p>The use case doesn't demonstrate how to avoid multiple use statements,
but this can be done by adding a "predicate" method to the "Strategy":
this will allow the "Context" to only execute a sub set of the strategies.</p>

<p>It's even possible to only execute the first strategy,
by adding a <code>break</code> in the loop.</p>

<p>I've tried to synthesize as much information as possible at the top of this article,
in the ironically (yet aptly) named "TL;DR" section.</p>

<p>I hope this'll prove useful to you (it'll definitely be for me!).</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Facade design pattern, by example]]></title>
            <link href="/2014/05/21/facade-design-pattern-by-example.html"/>
            <updated>2014-05-21T00:00:00+01:00</updated>
            <id>/2014/05/21/facade-design-pattern-by-example.html</id>
            <content type="html"><![CDATA[<p><a href="#conclusion">TL;DR: jump to the conclusion</a>.</p>

<p>Sometimes, you just want to hide low level complexity behind a unique interface
which communicates a high level policy. The Facade design pattern is all about
this.</p>

<p>In this article, we'll see a real world example with
<a href="https://github.com/gnugat/redaktilo">Redaktilo</a>.</p>

<h2 id="low-level-file-manipulation">Low level file manipulation</h2>

<p><strong>Redaktilo</strong> provides an object oriented way to manipulate files. For example
you can open existing ones, or create new ones:</p>

<pre><code class="php">&lt;?php
require_once __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\DependencyInjection\StaticContainer;

$filesystem = StaticContainer::makeFilesystem();

$filename = '/tmp/monthy.py';
if ($filesystem-&gt;exists($filename)) {
    $file = $filesystem-&gt;open('/tmp/existing.txt');
} else {
    $file = $filesystem-&gt;create('/tmp/new.txt');
}

// ...
</code></pre>

<p>The main interest in this library lies in manipulations you can do, for example
jumping to a line and adding a new one under it:</p>

<pre><code class="php">&lt;?php
// ...

$lineSearchStrategy = StaticContainer::makeLineSearchStrategy();
$lineReplaceStrategy = StaticContainer::makeLineReplaceStrategy();

$lineNumber = $lineSearchStrategy-&gt;findNext('if Knight.saysNi():');
$lineReplaceStrategy-&gt;insertAt($file, $lineNumber, '    print "Ni!"');

// ...
</code></pre>

<p>Finally, you need to actually save the changes (they were only done in memory
until now) :</p>

<pre><code class="php">// ...

$filesystem-&gt;write($file);
</code></pre>

<h2 id="a-higher-level-api%3F">A higher level API?</h2>

<p>The Filesystem and Search/Replace strategies are low level APIs and require a
lot of boilerplate code to do every day tasks.</p>

<p>What if we provided a unique interface in front of those services? One that
would be in a higher level, say a text editor metaphor for instance?</p>

<pre><code class="php">&lt;?php
require_once __DIR__.'/vendor/autoload.php';

use Gnugat\Redaktilo\DependencyInjection\StaticContainer;

$editor = StaticContainer::makeEditor();

$filename = '/tmp/monthy.py';
$file = $editor-&gt;open($filename, true); // Force file creation.

$editor-&gt;jumpDownTo($file, 'if Knight.saysNi():');
$editor-&gt;addAfter($file, '    print "Ni!"');

$editor-&gt;save($file);
</code></pre>

<p>You don't need to take care of every service creation, and now you only have to
learn a small set of methods. The text editor metaphor also provides you with a
neat way to easily remember these methods!</p>

<h2 id="conclusion">Conclusion</h2>

<p>Facades hide low level implementation by providing a unique high level API.</p>

<p>Here's another blog post about this pattern, by
<a href="http://mikeebert.tumblr.com/post/25342991856/design-pattern-facade-pattern">Mike Ebert</a>.</p>

<p>I hope you found this article interesting, if you have any questions or
feedback please feel free to do so on <a href="https://twitter.com/epiloic">Twitter</a>.</p>
]]></content>
        </entry>
            <entry>
            <title type="html"><![CDATA[Inversion of Control, Dependency Injection, Dependency Injection Container and Service Locator]]></title>
            <link href="/2014/01/22/ioc-di-and-service-locator.html"/>
            <updated>2014-01-22T00:00:00+00:00</updated>
            <id>/2014/01/22/ioc-di-and-service-locator.html</id>
            <content type="html"><![CDATA[<p>If you don't want to read this article, just jump to the <a href="#conclusion">conclusion</a>
which sums it up in 44 words.</p>

<p>If you've never heard of those (or one of those), this article will teach you
what they are.</p>

<p>If you know what are those, but don't know what's the difference between them,
this article will teach you what it is.</p>

<p>If you know what are those and what's the difference between them... Well read
this article and tell me what you think about it on
<a href="https://twitter.com/epiloic">Twitter</a> ;) .</p>

<p>Those big names actually refer to simple design patterns and principles which
might help you in your projects. Maybe you've been using them without knowing it!</p>

<h2 id="inversion-of-control">Inversion of Control</h2>

<p>This principle is very abstract, as it is based on the way you use objects
rather than specifying how to write them.</p>

<p>To keep things short: IoC (Inversion of Control) is all about relationship
between higher level classes and detail classes. Higher level classes shouldn't
depend on detail classes, but rather the contrary.</p>

<p>In order to ensure this, higher level classes should depend on abstractions
(like interfaces) instead of depending on concrete classes. Also, you should
make sure that higher level classes own detail classes.</p>

<p>While I understand this principle, I cannot make a better explanation than this
which is really a shame. But I know a good article which can:
<a href="http://lostechies.com/derickbailey/2011/09/22/dependency-injection-is-not-the-same-as-the-dependency-inversion-principle/">Dependency Injection is NOT the same as the Dependency Inversion Principle, by Derick Bailey</a>.</p>

<p>I really encourage you to read it as it explains very well the problem IoC tries
to solve, with some good (and graphical) examples.</p>

<h2 id="dependency-injection">Dependency Injection</h2>

<p>Let's explain each words:</p>

<ul>
<li>a dependency is an object used by your class</li>
<li>an injection is the fact of passing an argument to a function</li>
</ul>

<p>Some people instanciate those dependencies inside the class which use them, for
example:</p>

<pre><code>&lt;?php

namespace Gnugat\Fossil\MarkdownFile;

use Symfony\Component\Filesystem\Filesystem;

class DocumentationWriter
{
    public function write($absolutePathname, $content)
    {
        $filesystem = new Filesystem();
        if (!$filesystem-&gt;exists($absolutePathname)) {
            $filesystem-&gt;dumpFile($absolutePathname, $content);
        }
    }
}

$documentationWriter = new DocumentationWriter();
$documentationWriter-&gt;write('/tmp/example.txt', 'Hello world');
</code></pre>

<p>There's nothing wrong with this code, but it could be improved.</p>

<p>First of all, it happens that <code>Filesystem</code> is "stateless": you can call every
methods it has, in the order you want, it won't change the way it behaves. Which
means you could create a single instance for your whole application: it would
save some precious memory.</p>

<p>Second of all, this class cannot be tested: if anything, you would be testing
<code>Filesystem</code> itself by checking if the file was written with the same name and
content.</p>

<p>DI (Dependency Injection) is used to solve these two problems: you should first
create the instance of <code>Filesystem</code> and then pass it to (inject it into)
<code>DocumentationWriter</code>:</p>

<pre><code>&lt;?php

namespace Gnugat\Fossil\MarkdownFile;

use Symfony\Component\Filesystem\Filesystem;

class DocumentationWriter
{
    public function write(Filesystem $filesystem, $absolutePathname, $content)
    {
        if (!$filesystem-&gt;exists($absolutePathname)) {
            $filesystem-&gt;dumpFile($absolutePathname, $content);
        }
    }
}

$filesystem = new Filesystem();

$documentationWriter = new DocumentationWriter();
$documentationWriter-&gt;write($filesystem, '/tmp/example.txt', 'Hello world');
</code></pre>

<p>The dependency can now be shared throughout your application, and you can pass
a mock of it which will be able to tell you which method was called.</p>

<p>Injection is usually done via the constructor:</p>

<pre><code>&lt;?php

namespace Gnugat\Fossil\MarkdownFile;

use Symfony\Component\Filesystem\Filesystem;

class DocumentationWriter
{
    private $filesystem;

    public function __construct(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function write($absolutePathname, $content)
    {
        if (!$this-&gt;filesystem-&gt;exists($absolutePathname)) {
            $this-&gt;filesystem-&gt;dumpFile($absolutePathname, $content);
        }
    }
}

$filesystem = new Filesystem();

$documentationWriter = new DocumentationWriter($filesystem);
$documentationWriter-&gt;write('/tmp/example.txt', 'Hello world');
</code></pre>

<p>Time to time, injection will be done via setters:</p>

<pre><code>&lt;?php

namespace Gnugat\Fossil\MarkdownFile;

use Symfony\Component\Filesystem\Filesystem;

class DocumentationWriter
{
    private $filesystem;

    public function setFilesystem(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function write($absolutePathname, $content)
    {
        if (!$this-&gt;filesystem-&gt;exists($absolutePathname)) {
            $this-&gt;filesystem-&gt;dumpFile($absolutePathname, $content);
        }
    }
}

$filesystem = new Filesystem();

$documentationWriter = new DocumentationWriter();
$documentationWriter-&gt;setFilesystem($filesystem);
$documentationWriter-&gt;write('/tmp/example.txt', 'Hello world');
</code></pre>

<p>Setter injection is used when you have no control on the object construction,
and can be dangerous: if the setter isn't called, a runtime error will occur.</p>

<p>To help debug this kind of error, you can do this:</p>

<pre><code>&lt;?php

namespace Gnugat\Fossil\MarkdownFile;

use Symfony\Component\Filesystem\Filesystem;

class DocumentationWriter
{
    private $filesystem;

    public function setFilesystem(Filesystem $filesystem)
    {
        $this-&gt;filesystem = $filesystem;
    }

    public function write($absolutePathname, $content)
    {
        if (!$this-&gt;getFilesystem()-&gt;exists($absolutePathname)) {
            $this-&gt;getFilesystem()-&gt;dumpFile($absolutePathname, $content);
        }
    }

    private function getFilesystem()
    {
        if (!($this-&gt;filesystem instanceof Filesystem)) {
            $msg = 'The Filesystem dependency is missing.';
            $msg .= ' Did you forgot to call setFilesystem?';
            throw new \LogicException($msg);
        }

        return $this-&gt;filesystem;
    }
}

$documentationWriter = new DocumentationWriter();
// Will throw an exception with a helpful message.
$documentationWriter-&gt;write('/tmp/example.txt', 'Hello world');
</code></pre>

<p>You shouldn't need to use setter injection in your own class, but rather on
classes which extend third party library.</p>

<p>For example Doctrine's repositories can only be retrieved using its
<code>EntityManager</code>, which mean you don't have the control on its construction. If
you need to pass dependencies to it, you'll have to use setter injection.</p>

<h3 id="dependency-injection-and-inversion-of-control">Dependency Injection and Inversion of Control</h3>

<p>The subject of <a href="http://lostechies.com/derickbailey/2011/09/22/dependency-injection-is-not-the-same-as-the-dependency-inversion-principle/">the article previously quoted</a>
is the relation between DI and IoC: some people confuse them and think they're
the same by simply deducing that IoC is injecting interfaces instead of concrete
classes.</p>

<p>While combining them is possible, you should remember that IoC is first a matter
of higher level classes owning their detail classes. The principle (IoC) and the
design pattern (DI) are really different things.</p>

<h2 id="dependency-injection-container">Dependency Injection Container</h2>

<p>The flaw of DI is the manual construction of all those objects: some classes
might have dependencies which themselves have dependencies. And even without
deep dependencies, manually creating a large number of classes is never
pleasant.</p>

<p>The biggest risk is to scatter object construction in the whole application and
losing track of it: if you don't know that an object has already been
constructing you might accidently construct it again.</p>

<p>Let's add a dependency on <a href="https://github.com/Seldaek/monolog">Monolog</a> to our
<code>DocumentationWriter</code> (plus some custom configuration to spice it up):</p>

<pre><code>&lt;?php

use Gnugat\Fossil\ApplicationLayer\OutputFormatter;
use Gnugat\Fossil\MarkdownFile\DocumentationWriter;
use Monolog\Logger;
use Symfony\Bridge\Monolog\Handler\ConsoleHandler;
use Symfony\Component\Console\Output\ConsoleOutput;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;

$verbosityLevelMap = array(
    'OutputInterface::VERBOSITY_NORMAL' =&gt; Logger::NOTICE,
    'OutputInterface::VERBOSITY_VERBOSE' =&gt; Logger::INFO,
    'OutputInterface::VERBOSITY_VERY_VERBOSE' =&gt; Logger::DEBUG,
    'OutputInterface::VERBOSITY_DEBUG' =&gt; Logger::DEBUG,
);

$consoleOutput = new ConsoleOutput();
$outputFormatter = new OutputFormatter();
$consoleHandler = new ConsoleHandler(
    $consoleOutput,
    true,
    $verbosityLevelMap
);
$consoleHandler-&gt;setFormatter($outputFormatter);

$logger = new Logger('default.logger');
$logger-&gt;pushHandler($consoleHandler);

$filesystem = new Filesystem();

$documentationWritter = new DocumentationWriter(
    $filesystem,
    $logger
);
$documentationWriter-&gt;write('/tmp/example.txt', 'Hello world');
</code></pre>

<p>It's quite a burden isn't it?</p>

<p>The DIC (Dependency Injection Container) solves this problem by taking the
responsibility of creating them for you. technically, you still write all of
these lines, but instead of putting them mixed with business logic code you put
it in a separate file.</p>

<p>DIC can be found in many languages:</p>

<ul>
<li>java, for example with <a href="http://docs.spring.io/spring/docs/2.5.6/reference/beans.html">Spring</a></li>
<li>PHP, for example with <a href="http://framework.zend.com/manual/2.0/en/modules/zend.di.introduction.html">Zend\Di</a></li>
<li>js, for example in <a href="http://angularjs.org/">AngularJs</a></li>
</ul>

<p>To better understand what is a DIC, we'll take a look at <a href="pimple.sensiolabs.org">Pimple</a>,
a small DIC for PHP using a javascript-like syntax.</p>

<p>Pimple can be considered as an array in which you can put parameters and
"factories": an anonymous function which creates an instance of the class.</p>

<p>Here's the code sample:</p>

<pre><code>&lt;?php

// File: dic.php

use Gnugat\Fossil\ApplicationLayer\OutputFormatter;
use Gnugat\Fossil\MarkdownFile\DocumentationWriter;
use Monolog\Logger;
use Symfony\Bridge\Monolog\Handler\ConsoleHandler;
use Symfony\Component\Console\Output\ConsoleOutput;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Filesystem\Filesystem;

$dic = new Pimple();

// This is a parameter definition
$dic['verbosity_level_map'] = array(
    'OutputInterface::VERBOSITY_NORMAL' =&gt; Logger::NOTICE,
    'OutputInterface::VERBOSITY_VERBOSE' =&gt; Logger::INFO,
    'OutputInterface::VERBOSITY_VERY_VERBOSE' =&gt; Logger::DEBUG,
    'OutputInterface::VERBOSITY_DEBUG' =&gt; Logger::DEBUG,
);

// Thess are a factory definition
$dic['console_output'] = $dic-&gt;share(function($dic) {
    return new ConsoleOutput();
});
$dic['output_formatter'] = $dic-&gt;share(function($dic) {
    return new OutputFormatter();
});

// You can inject dependencies which have been declared previously
$dic['console_handler'] = $dic-&gt;share(function($dic) {
    $consoleHandler = new ConsoleHandler(
        $dic['console_output'],
        true,
        $dic['verbosity_level_map']
    );
    $consoleHandler-&gt;setFormatter($dic['output_formatter']);

    return $consoleHandler
});

$dic['logger'] = $dic-&gt;share(function($dic) {
    $logger = new Logger('default.logger');
    $logger-&gt;pushHandler($dic['console_handler']);

    return $logger
});

$dic['filesystem'] = $dic-&gt;share(function($dic) {
    return new Filesystem();
});

$dic['documentation_writer'] = $dic-&gt;share(function($dic) {
    return new DocumentationWriter(
        $dic['filesystem'],
        $dic['logger']
    );
});
</code></pre>

<p>So, what's the big difference between this and the previous code sample? Well
now you centralized all your instances into a single container, the definition
of your object is done in a central place (you can move it into a file
<code>dic.php</code> for example) and the best of all: classes will be instanciated lazily,
which means as long as you don't aks for them they won't be created, and once
you created them they won't be created a second time.</p>

<p>In your application, you just need to pass the DIC and use it:</p>

<pre><code>&lt;?php

// File: front_controller.php

require_once __DIR__.'/dic.php';

// Now you can retrieve instances from the DIC
$documentationWriter = $dic['documentation_writer'];

$documentationWriter-&gt;write('/tmp/example.txt', 'Hello world');
</code></pre>

<p>I must stress on the fact that object creation is now centralized: the code
from the first example (the one without DIC) could be scattered into different
places of your application.</p>

<h3 id="dependency-injection-container-and-ioc">Dependency Injection Container and IoC</h3>

<p>Again, people often mixep up those two for the same reason they mix up DI and
IoC. There's a lot of <a href="https://github.com/rande/python-simple-ioc">DIC libraries which have been falsely called ioc</a>.</p>

<p>Please, don't make the same mistake.</p>

<h3 id="dependency-injection-container-and-singleton">Dependency Injection Container and Singleton</h3>

<p>Singleton is a design pattern saying that a given object should only be
instanciated once and that it should be guarded from being instanciated a second
time.</p>

<p>Here's an implementation example of a singleton:</p>

<pre><code>&lt;?php

// Code from https://github.com/domnikl/DesignPatternsPHP/blob/master/Singleton/Singleton.php

class Singleton
{
    protected static $instance;

    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static;
        }

        return static::$instance;
    }

    private function __construct()
    {
        // is not allowed to call from outside: private!
    }
}
</code></pre>

<p>While in our example the DIC makes sure our objects are constructed only once,
we can't call them singletons as nobody prevents you from creating them a second
time manually.</p>

<p>Keep in mind that DIC aren't always making sure of this: in our example we've
used <a href="https://github.com/fabpot/Pimple/blob/1.1/lib/Pimple.php#L116">the special share method</a>
of Pimple to ensure it, but you can also retrieve a new instance on every call:</p>

<pre><code>&lt;?php

use Symfony\Component\Finder\Finder;

$dic['finder'] = function($dic) {
    return new Finder();
});

$firstFinder = $dic['finder'];
$secondFinder = $dic['finder'];
</code></pre>

<p>To recap: DI and DIC have nothing to do with Singleton.</p>

<h2 id="service-locator">Service Locator</h2>

<p>The classes you put into the DIC can be called <code>Services</code>: they will execute
a task for you when you call them.</p>

<p>A Service Locator isn't just a container of services which gets them when you
ask it to: what we described is simply a DIC. To be a Service Locator, a DIC
must be injected as a dependency.</p>

<p>This might happen with classes which have many dependencies: instead of
injecting them one by one you can inject directly the DIC and let the class
retrieve the services it needs.</p>

<p>You should be warned that this is generally a bad idea: a class which requires
too many dependencies should be splitted into several smaller classes.</p>

<p>There is however some cases when Service Locator are usefull, for example
controllers are good candidates as their only responsibility is to pass input
to services and to return output.</p>

<p>To be more precise, Service Locator shouldn't be used in your business logic,
but rather in objects which serve as intermediate between two layers.</p>

<p>Here's a <a href="http://ralphschindler.com/2012/10/10/di-dic-service-locator-redux">good article about when to use Service Locators by Ralph Schindler</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Here's the TL;DR:</p>

<ul>
<li>IoC: higher level classes own detail classes (which are abstractions)</li>
<li>DI: pass as argument objects to the class which will use them</li>
<li>DIC: creates the dependencies and then injects them into the asked class</li>
<li>Service Locator: depending on the DIC instead of many dependencies</li>
</ul>

<p>If this article didn't teach you anything and made you angry, please
<a href="https://twitter.com/epiloic">tweet it to me</a>. If you learned some things, or
if this article made your day, feel free to do the same ;) .</p>

<h3 id="more-resources">More resources</h3>

<p>If you want to read more about DI and DIC, here's good series by
Fabien Potencier's series on <a href="http://fabien.potencier.org/article/11/what-is-dependency-injection">what is Dependency Injection</a>.</p>

<p>There's also William Durand's slides on <a href="http://edu.williamdurand.fr/php-slides/index.html#slide152">Writing Better Code</a>
(actually the slides are about PHP and contain good resources. I encourage you to read it entirely!).</p>
]]></content>
        </entry>
    </feed>